<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="G-FD56VNK157">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"chars.tech","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.14.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="持久存储是一种非易失性存储，在重启设备时也不会丢失数据。Cocoa框架提供了几种数据持久化机制： 1）属性列表； 2）对象归档； 3）iOS的嵌入式关系数据库SQLite3； 4）Core Data。 在iOS开发中，持久化数据的方法也并不限于属性列表、对象归档、SQLite3和Core Data。它们只是四种最常用且简单的方法。其实也可以使用传统C语言I&#x2F;O调用（比如，fopen()）">
<meta property="og:type" content="article">
<meta property="og:title" content="拆拆 iOS 数据持久化">
<meta property="og:url" content="https://chars.tech/2016-01-19-ios-data-persistence/index.html">
<meta property="og:site_name" content="Chars&#39;s Blog">
<meta property="og:description" content="持久存储是一种非易失性存储，在重启设备时也不会丢失数据。Cocoa框架提供了几种数据持久化机制： 1）属性列表； 2）对象归档； 3）iOS的嵌入式关系数据库SQLite3； 4）Core Data。 在iOS开发中，持久化数据的方法也并不限于属性列表、对象归档、SQLite3和Core Data。它们只是四种最常用且简单的方法。其实也可以使用传统C语言I&#x2F;O调用（比如，fopen()）">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://chars.tech/assets/images/tech/ios-data-persistence-1.png">
<meta property="og:image" content="https://chars.tech/assets/images/tech/ios-data-persistence-2.png">
<meta property="og:image" content="https://chars.tech/assets/images/tech/ios-data-persistence-3.png">
<meta property="og:image" content="https://chars.tech/assets/images/tech/ios-data-persistence-4.png">
<meta property="og:image" content="https://chars.tech/assets/images/tech/ios-data-persistence-5.png">
<meta property="og:image" content="https://chars.tech/assets/images/tech/ios-data-persistence-6.png">
<meta property="article:published_time" content="2016-01-19T06:50:24.000Z">
<meta property="article:modified_time" content="2018-12-08T03:20:37.000Z">
<meta property="article:author" content="Chars">
<meta property="article:tag" content="ios">
<meta property="article:tag" content="存储">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chars.tech/assets/images/tech/ios-data-persistence-1.png">


<link rel="canonical" href="https://chars.tech/2016-01-19-ios-data-persistence/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://chars.tech/2016-01-19-ios-data-persistence/","path":"2016-01-19-ios-data-persistence/","title":"拆拆 iOS 数据持久化"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>拆拆 iOS 数据持久化 | Chars's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FD56VNK157"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-FD56VNK157","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Chars's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Chars's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Never stop living and learning</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%BA%94%E7%94%A8%E7%9A%84%E6%B2%99%E7%9B%92"><span class="nav-number">1.</span> <span class="nav-text">一、应用的沙盒</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96Documents%E7%9B%AE%E5%BD%95"><span class="nav-number">1.1.</span> <span class="nav-text">获取Documents目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96Library%E7%9B%AE%E5%BD%95"><span class="nav-number">1.2.</span> <span class="nav-text">获取Library目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96tmp%E7%9B%AE%E5%BD%95"><span class="nav-number">1.3.</span> <span class="nav-text">获取tmp目录</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98%E6%96%B9%E6%A1%88"><span class="nav-number">2.</span> <span class="nav-text">二、文件保存方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E6%96%87%E4%BB%B6%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">2.1.</span> <span class="nav-text">单文件持久化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">2.2.</span> <span class="nav-text">多文件持久化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">三、属性列表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">3.1.</span> <span class="nav-text">属性列表序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSData"><span class="nav-number">3.2.</span> <span class="nav-text">NSData</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90plist"><span class="nav-number">3.3.</span> <span class="nav-text">解析plist</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99plist"><span class="nav-number">3.4.</span> <span class="nav-text">读写plist</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="nav-number">3.5.</span> <span class="nav-text">创建工程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%BD%92%E6%A1%A3"><span class="nav-number">4.</span> <span class="nav-text">四、归档</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%B5%E5%BE%AANSCoding%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.1.</span> <span class="nav-text">遵循NSCoding协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0NSCopying%E5%8D%8F%E8%AE%AE"><span class="nav-number">4.2.</span> <span class="nav-text">实现NSCopying协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B-1"><span class="nav-number">4.3.</span> <span class="nav-text">创建工程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81SQLite3"><span class="nav-number">5.</span> <span class="nav-text">五、SQLite3</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%8F%98%E9%87%8F"><span class="nav-number">5.1.</span> <span class="nav-text">绑定变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B-2"><span class="nav-number">5.2.</span> <span class="nav-text">创建工程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81Core-Data"><span class="nav-number">6.</span> <span class="nav-text">六、Core Data</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AF%E8%AF%AD"><span class="nav-number">6.1.</span> <span class="nav-text">术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B-3"><span class="nav-number">6.2.</span> <span class="nav-text">创建工程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-number">7.</span> <span class="nav-text">七、总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chars"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Chars</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">113</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/charsdavy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;charsdavy" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/3875245858" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;3875245858" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/chars.davy" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;chars.davy" rel="noopener" target="_blank"><i class="fab fa-instagram fa-fw"></i>Instagram</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://chars.tech/2016-01-19-ios-data-persistence/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Chars">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chars's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="拆拆 iOS 数据持久化 | Chars's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          拆拆 iOS 数据持久化
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2016-01-19 14:50:24" itemprop="dateCreated datePublished" datetime="2016-01-19T14:50:24+08:00">2016-01-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/pieces/" itemprop="url" rel="index"><span itemprop="name">pieces</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>持久存储是一种非易失性存储，在重启设备时也不会丢失数据。Cocoa框架提供了几种数据持久化机制：</p>
<p>1）属性列表；</p>
<p>2）对象归档；</p>
<p>3）iOS的嵌入式关系数据库SQLite3；</p>
<p>4）Core Data。</p>
<p>在iOS开发中，持久化数据的方法也并不限于属性列表、对象归档、SQLite3和Core Data。它们只是四种最常用且简单的方法。其实也可以使用传统C语言I&#x2F;O调用（比如，fopen()）读写数据，也可以使用Cocoa的底层文件管理工具。只不过这两种方法都需要写很多代码，并且没有必要这么做。</p>
<span id="more"></span>

<h1 id="一、应用的沙盒"><a href="#一、应用的沙盒" class="headerlink" title="一、应用的沙盒"></a>一、应用的沙盒</h1><p>Cocoa提供的四种数据持久化机制都涉及一个共同因素，即应用的&#x2F;Documents文件夹。每个应用都有自己的&#x2F;Documents文件夹，且能读写各自的&#x2F;Documents目录中的内容。</p>
<p>为了便于理解，我们先来看一下iPhone模拟器使用的文件夹布局，从而了解iOS中应用是如何组织的。打开Finder窗口，找到主目录，找到Library（资源库）目录，找到Developer&#x2F;CoreSimulator&#x2F;Devices&#x2F;，在该目录中可以看到一些子目录，分别对应Xcode中的模拟器。子目录的名称是Xcode自动生成的GUID（Globally Unique Identifier，全局唯一标识符），因此无法确定每个目录对应哪一个模拟器。解决这个问题的方法是找到模拟器目录中名为device.plist的文件，并打开它，就可以看见一个对应模拟器设备名称的键。</p>
<p>虽然这是模拟器的目录，但实际设备上的文件结构与此相似。如果想看到设备上应用程序的沙盒，就将它连接到Mac上并打开Xcode的Devices窗口，在窗口边侧栏可以看到该设备，选中它然后在Installed Apps表中选择一个应用程序。在表的下方有一个看起来像齿轮的图表。点击它并在弹出菜单中选择Show Container选项就可以看到应用程序沙盒的内容。</p>
<p>每个应用程序沙盒都包含以下三个目录：</p>
<p>1）Documents：应用程序可以将数据存储在Documents目录中。如果这个应用程序启用了iTunes文件分享功能，用户就可以在iTunes中看到目录的内容（以及应用程序创建的所有子目录），还可以对其更新文件。</p>
<p>如果要为应用程序启用文件分享功能，需要打开它的Info.plist文件并添加键为Application supports iTunes file sharing值为YES的条目。</p>
<p>2）Library：应用程序也可以在这里存储数据。它用来存放不想共享给用户的文件。需要时可以创建自己的子目录。系统创建了名为Cache和Preferences的子目录。后者包含了存储应用程序偏好设置的plist文件，通过NSUserDefaults来操作。</p>
<p>3）tmp：tmp目录供应用存储临时文件。当iOS设备执行同步时，iTunes不会备份tmp中的文件。在不需要这些文件时，应用要负责删除tmp中的文件，以免占用文件系统空间。</p>
<h2 id="获取Documents目录"><a href="#获取Documents目录" class="headerlink" title="获取Documents目录"></a>获取Documents目录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSString *documentsDirectory = paths[0];</span><br></pre></td></tr></table></figure>

<p>常量<code>NSDocumentDirectory</code>表明我们正在查找Documents目录的路径。第二个常量<code>NSUserDomainMask</code>表明我们希望将搜索限制在应用的沙盒内，在OS X中表明我们希望该函数查看用户的主目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *filename = [documentsDirectory stringByAppendingPathComponent:@”theFile.txt”];</span><br></pre></td></tr></table></figure>
<p>完成此调用之后，filename就包含了指向应用Documents目录中theFile.txt文件的完整路径。</p>
<h2 id="获取Library目录"><a href="#获取Library目录" class="headerlink" title="获取Library目录"></a>获取Library目录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSString *libraryDirectory = paths[0];</span><br></pre></td></tr></table></figure>

<p>常量<code>NSLibraryDirectory</code>表明我们正在查找Library目录的路径。第二个常量<code>NSUserDomainMask</code>表明我们希望将搜索限制在应用的沙盒内，在OS X中表明我们希望该函数查看用户的主目录。</p>
<h2 id="获取tmp目录"><a href="#获取tmp目录" class="headerlink" title="获取tmp目录"></a>获取tmp目录</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *tempPath = NSTemporaryDirectory();</span><br><span class="line">NSString *filename = [tempPath stringByAppendingPathComponent:@”theFile.txt”];</span><br></pre></td></tr></table></figure>

<h1 id="二、文件保存方案"><a href="#二、文件保存方案" class="headerlink" title="二、文件保存方案"></a>二、文件保存方案</h1><p>Cocoa提供的四种实现数据持久化的方法，都使用iOS的文件系统。使用SQLite3将创建一个SQLite3数据库文件，并让SQLite3去存储和检索数据。Core Data则以其最简单的形式帮助开发者完成所有的文件系统的管理工作。使用属性列表则需要考虑将数据存储在一个文件中，还是存储在多个文件中。</p>
<h2 id="单文件持久化"><a href="#单文件持久化" class="headerlink" title="单文件持久化"></a>单文件持久化</h2><p>把数据保存在一个文件中是最简单的方法，而且对于许多应用，这也是完全可以接受的方法。首先，创建一个根对象，通常是数组或字典（使用归档容器的情况下根对象可以给予这个自定义类）。接下来，使用所有需要保存的程序数据填充根对象。真正保存时，代码会将该根对象的全部内容重新写入单个文件。应用在启动时会将该文件的全部内容读入内存，并在退出时注销。</p>
<p>使用单文件的缺点：必须将全部数据加载到内存中，并且不管有多小的更改也必须将所有数据全部重新写入文件系统。</p>
<h2 id="多文件持久化"><a href="#多文件持久化" class="headerlink" title="多文件持久化"></a>多文件持久化</h2><p>使用多文件持久化是另一种实现持久化的方法。例如，电子邮件应用可能会将每封邮件都单独存储在一个文件中。</p>
<p>这种方法的优点，例如应用可以只加载用户请求的数据（另一种形式的延迟加载），当用户进行更改时只保存更改的文件。此方法允许开发者在收到内存不足通知时释放内存。用户当前未查看的任何数据都可以从内存中删除，下次需要时再从文件系统重新加载即可。</p>
<p>使用多文件持久化的缺点：它大大增加了应用的复杂性。</p>
<h1 id="三、属性列表"><a href="#三、属性列表" class="headerlink" title="三、属性列表"></a>三、属性列表</h1><p>属性列表使用起来非常方便，可以使用Xcode或Property List Editor应用手动编辑它们。而且只要字典或数组包含特定可序列化对象，就可以将NSDictionary和NSArray实例写入属性列表或者从属性列表创建它们。</p>
<h2 id="属性列表序列化"><a href="#属性列表序列化" class="headerlink" title="属性列表序列化"></a>属性列表序列化</h2><p>序列化对象，是指可以被转换为字节流以便于存储到文件中或通过网络进行传输的对象。虽然任何对象都可以被序列化，但是只有某些对象才能放置到某个集合类中（如NSDictionary或NSArray中），然后才使用该集合类的writeToFile:atomically:或writeToURL:atomically:方法将它们存储到属性列表中。可以按照该方法序列化下面的类：</p>
<p>1）NSArray、NSMutableArray</p>
<p>2）NSDictionary、NSMutableDictionary</p>
<p>3）NSData、NSMutableData</p>
<p>4）NSString、NSMutableString</p>
<p>5）NSNumber</p>
<p>6）NSDate</p>
<p>如果只使用这些对象构建数据模型，就可以使用属性列表来方便地保护和加载数据。如果打算使用属性列表持久保存应用数据，则可以使用数组或字典。假设放到字典或数组中的所有对象都是前面列出的可序列化对象，则可以通过对字典或数组的实例调用writeToFile:atomically:方法来写入属性列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myArray writeToFile:@”/some/file/location/output.plist” atomically:YES];</span><br></pre></td></tr></table></figure>

<p>说明：这里的atomically参数让该方法将数据写入辅助文件，而不是写入指定位置。成功写入该文件之后，辅助文件将被复制到第一个参数指定的位置。这是更安全的写入文件的方法，因为如果应用在保存期间崩溃，则现有文件（如果有）不会被破坏。尽管增加一点开销，但是多数情况下还是值得的。</p>
<p>属性列表方法的一个问题就是，无法将自定义对象序列化到属性列表中，另外也不能使用没有在可序列化对象类型列表中指定的Cocoa Touch的其他类。这意味着无法使用NSURL、UIImage和UIColor等类。</p>
<p>且不说序列化问题，将这些模型对象保存到属性列表中还意味着无法轻松创建派生的或需要计算的属性（例如，等于两个属性之后的属性），并且必须将实际上应该包含在模型中的某些代码移动到控制器类。这些限制也适用于简单数据模型和简单应用。但在多数情况下，如果创建了专用的模型类，则应用更容易维护。</p>
<p>在复杂的应用中，简单属性列表仍然非常有用。它们是将静态数据包含在应用中的最佳方法。例如，当应用包含一个选取器时，创建一个属性列表文件并将其放在项目的Resources文件夹中，就是将项目列表包含到选取器中的最佳方法，这样能把项目列表编译到应用中。</p>
<h2 id="NSData"><a href="#NSData" class="headerlink" title="NSData"></a>NSData</h2><p>NSData主要是提供一块原始数据的封装，方便数据的封装与流动，比较常见的是NSString&#x2F;NSImage数据的封装与传递。在应用中，最常用于访问存储在文件中或者网络资源中的数据。</p>
<p>这个类提供的封装&#x2F;解封方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+(id)dataWithBytes:(const void *)bytes length:(NSUInteger)length;</span><br><span class="line">-(NSUInteger)length;</span><br><span class="line">-(const void *)bytes NS_RETURNS_INNER_POINTER;</span><br></pre></td></tr></table></figure>

<p>从这几个方法可以看出，NSData根本不管传递的内容到底是什么，仅仅是传递一块内存——仅需内存的起始地址和长度。</p>
<h2 id="解析plist"><a href="#解析plist" class="headerlink" title="解析plist"></a>解析plist</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idresult = [NSPropertyListSerialization propertyListWithData:data options:0format:NULL error:NULL];</span><br></pre></td></tr></table></figure>

<h2 id="读写plist"><a href="#读写plist" class="headerlink" title="读写plist"></a>读写plist</h2><p>1）写入文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSArray*phrase;</span><br><span class="line">phrase =[NSArray arrayWithObjects:@&quot;I&quot;, @&quot;seem&quot;, @&quot;to&quot;,@&quot;be&quot; ,@&quot;a&quot;, @&quot;verb&quot;, nil];</span><br><span class="line">[phrasewriteToFile:@&quot;/tmp/verbiage.txt&quot; atomically:YES];</span><br></pre></td></tr></table></figure>

<p>现在看一下文件&#x2F;tmp&#x2F;verbiage.txt，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xmlversion=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPEplist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot;</span><br><span class="line"> &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plistversion=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">  &lt;string&gt;I&lt;/string&gt;</span><br><span class="line">  &lt;string&gt;seem&lt;/string&gt;</span><br><span class="line">  &lt;string&gt;to&lt;/string&gt;</span><br><span class="line">  &lt;string&gt;be&lt;/string&gt;</span><br><span class="line">  &lt;string&gt;a&lt;/string&gt;</span><br><span class="line">  &lt;string&gt;verb&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>

<p>这些属性列表文件可以为任意复杂的形式，可以是包含字符串、数字和日期数组的字典数组。Xcode还包含一个属性列表编辑器，所以可以查看plist文件并进行编辑。</p>
<p><strong>说明：</strong>有些属性列表文件（特别是首选项文件）是以压缩的二进制格式存储的。通过使用plutil命令：<code>plutil -convert xml1 filename.plist</code>，可以将这些文件转换为人们可读的形式。</p>
<p>2）读取</p>
<p>之前已经将verbiage.txt文件存放在磁盘上，可以使用<code>+arrayWithContentsOfFile:</code>方法读取该文件。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray*pharse = [NSArray arrayWithContentsOfFile:@&quot;/tmp/ verbiage.txt &quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,phrase);</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>注意到<code>writeToFile:</code>方法中的单词<code>atomically</code>了吗？这种调用有什么负面作用吗？没有。<code>atomically:</code>参数的值为BOOL类型，用于通知Cocoa是否应该首先将文件内容保存在临时文件中，当文件成功保存后，再将该临时文件和原始文件交换。这是一种安全机制：如果在保存过程中出现意外，不会破坏原始文件。但这种安全机制需要付出一定的代价：在保存过程中，由于原始文件仍然保存在磁盘中，所以需要使用双倍的磁盘空间。除非保存的文件非常大，将会占用用户硬盘空间，否则应该自动保存文件。</p>
<p>如果能将数据精简为属性列表类型，则可以使用这些非常便捷的调用来将内容保存到磁盘中，供以后读取。如果你正在从事一项新创意或设计一个新项目，可以使用这些便捷方法来快速编写和运行程序。即使只想把数据块保存到磁盘中，并且根本不需要使用对象，也可以使用NSData来简化工作。只需要将数据包装在一个NSData对象中，然后再NSData对象上调用<code>writeToFile: atomically:</code>方法。</p>
<p>这些函数的一个缺点就是，它们不会返回任何错误信息。如果不能加载文件，只能从方法中得到nil指针，而不能确定出现了何种错误。</p>
<h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>在Xcode中，使用Single View Application模板创建一个项目，命名Persistence，点击Main.storyboard，布局如下图</p>
<p><img src="/assets/images/tech/ios-data-persistence-1.png" alt="布局"></p>
<p>连线，添加处理函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface PlistViewController ()</span><br><span class="line">- (IBAction)saveClicked:(id)sender;</span><br><span class="line">@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">    </span><br><span class="line">    NSString *filePath = [self dataFilePath];</span><br><span class="line">    if ([[NSFileManager defaultManager] fileExistsAtPath:filePath]) &#123;</span><br><span class="line">        NSArray *array = [[NSArray alloc] initWithContentsOfFile:filePath];</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            UITextField *theField = self.lineFields[i];</span><br><span class="line">            theField.text = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSString *)dataFilePath&#123;</span><br><span class="line">    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">    NSString *documentsDirectory = [paths objectAtIndex:0];</span><br><span class="line">    return [documentsDirectory stringByAppendingPathComponent:@&quot;data.plist&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)saveClicked:(id)sender &#123;</span><br><span class="line">    NSString *filePath = [self dataFilePath];</span><br><span class="line">    NSArray *array = [self.lineFields valueForKey:@&quot;text&quot;];</span><br><span class="line">    [array writeToFile:filePath atomically:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、归档"><a href="#四、归档" class="headerlink" title="四、归档"></a>四、归档</h1><p>在Cocoa世界中，归档是指另一中形式的序列化，但它是任何对象都可以实现的更常规的类型。专门编写用于保存数据的任何模型对象都应该支持归档。使用对模型对象进行归档的技术可以轻松将复杂的对象写入文件，然后再从中读取它们。</p>
<p>只要在类中实现的每个属性都是标量（如整型或浮点型）或都是遵循NSCoding协议的某个类的实例，就可以对整个对象进行完全的归档。由于大多数支持存储数据的Foundation和Cocoa Touch类都遵循NSCoding协议（不过，有一些例外，如UIImage），对于大多数类来说，归档相对而言比较容易实现。</p>
<p>尽管对归档的使用没有严格要求，但还有一个协议应该与NSCoding一起实现，即NSCopying协议。后者允许复制对象，这使开发者在使用数据模型对象时具备了较大的灵活性。</p>
<h2 id="遵循NSCoding协议"><a href="#遵循NSCoding协议" class="headerlink" title="遵循NSCoding协议"></a>遵循NSCoding协议</h2><p>NSCoding协议声明了两个必须实现的方法，一个方法将对象编码到归档中，另一个方法对归档解码来创建一个新对象。这两个方法都传递一个NSCoder实例，使用方式与NSUserDefaults非常相似。也可以使用KVC对对象和原生数据类型进行编码和解码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@protocolNSCoding</span><br><span class="line">-(void)encodeWithCoder:(NSCoder*)aCoder;</span><br><span class="line">-(id)initWithCoder:(NSCoder*)aDecoder;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>当对象需要保存自身时，<code>encodeWithCoder:</code>方法将被调用；当对象需要加载自身时，<code>initWithCoder:</code>方法将被调用。</p>
<p>那么，这个编码器是什么呢？NSCoder是一个抽象类，定义一些有用的方法来在对象与NSData之间来回转换。完全不需要创建新NSCoder，因为它实际上并无多大作用。但是，我们实际上要使用NSCoder的一些具体的子类来编码和解码对象。我们将使用其中两个子类NSKeyedArchiver和NSKeyedUnarchiver。</p>
<p><code>initWithCoder:</code>和其他任何init方法一样，在对对象执行操作之前，需要使用超类对它们进行初始化。为此，可以采用两种方式，具体取决于父类。如果父类采用NSCoding协议，则应该调用<code>[super initWithCoder:decoder]</code>；否则，只需要调用<code>[super init]</code>即可。NSObject不采用NSCoding协议，因此我们使用简单的init方法。</p>
<p><code>+ archivedDataWithRootObject:</code>类方法编码thing对象。首先，它在后台创建一个NSKeyedArchiver实例；然后，它将NSKeyedArchiver实例传递给对象thing的<code>-encodeWithCoder:</code>方法。当thing编码自身的属性时，它可能对其他对象也进行编码，例如，字符串、数组以及我们可能输入到该数组中的任何内容。整个对象集合完成键和值的编码后，具有键&#x2F;值对的归档程序将所有对象扁平化为一个NSData类并将其返回。</p>
<p>如果愿意，可以使用<code>-writeToFile:atomically:</code>方法将这个NSData类保存到磁盘中。在此，我们先处理thing对象，然后通过freezeDried表示法重新创建它，并将它输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thing =[NSKeyedUnarchiveObjectWithData: freezeDried];</span><br><span class="line">NSLog(@&quot;reconstitutedthing:%@&quot;,thing);</span><br></pre></td></tr></table></figure>

<p>如果被编码的数据中含有循环将会怎么样？例如，如果thing包含在自身的subThingies数组中会怎样？thing会对数组进行编码吗？哪个对象对thing进行编码，哪个对象对数组进行编码，哪个对象再次对thing进行编码，依此类推？幸运的是，Cocoa在归档程序和解压程序实现上非常灵活，能够保存并恢复对象周期。</p>
<h2 id="实现NSCopying协议"><a href="#实现NSCopying协议" class="headerlink" title="实现NSCopying协议"></a>实现NSCopying协议</h2><p>遵循NSCopying对于任何数据模型对象来说都是非常好的事情。NSCopying有一个copyWithZone:方法，可用来复制对象。实现NSCopying与实现initWithCoder:非常相似，只需要创建一个同一类的新实例，然后将新实例的所有属性都设置为与该对象属性相同的值即可。</p>
<p>说明：不要过于担心NSZone参数。它指向系统用于管理内存的struct。只有在极少数情况下，开发者才需要关注zone或者创建自己的zone。目前，还没有使用多个zone的说法。对某个对象调用copy的方法与使用默认zone调用copyWithZone的方法完全相同，几乎始终能满足你的需求。事实上，现在的iOS上完全可以忽略zone。NSCopying用zone在本质上是考虑向后兼容性所致。</p>
<h2 id="创建工程-1"><a href="#创建工程-1" class="headerlink" title="创建工程"></a>创建工程</h2><p>按照上文创建工程，设计界面（与上文界面相同），连线，添加响应方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ArchiverViewController.h&quot;</span><br><span class="line">#import &quot;Lines.h&quot;</span><br><span class="line"></span><br><span class="line">static NSString *const kRootKey = @&quot;kRootKey&quot;;</span><br><span class="line"></span><br><span class="line">@interface ArchiverViewController ()</span><br><span class="line">- (IBAction)saveClicked:(id)sender;</span><br><span class="line">@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">    </span><br><span class="line">    NSString *filePath = [self dataFilePath];</span><br><span class="line">    if ([[NSFileManager defaultManager] fileExistsAtPath:filePath]) &#123;</span><br><span class="line">        NSData *data = [[NSMutableData alloc] initWithContentsOfFile:filePath];</span><br><span class="line">        NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];</span><br><span class="line">        Lines *lines = [unarchiver decodeObjectForKey:kRootKey];</span><br><span class="line">        [unarchiver finishDecoding];</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            UITextField *theField = self.lineFields[i];</span><br><span class="line">            theField.text = lines.lines[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSString *)dataFilePath&#123;</span><br><span class="line">    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">    NSString *documentsDirectory = [paths objectAtIndex:0];</span><br><span class="line">    return [documentsDirectory stringByAppendingPathComponent:@&quot;data.archive&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)saveClicked:(id)sender &#123;</span><br><span class="line">    NSString *filePath = [self dataFilePath];</span><br><span class="line">    Lines *lines = [[Lines alloc] init];</span><br><span class="line">    lines.lines = [self.lineFields valueForKey:@&quot;text&quot;];</span><br><span class="line">    NSMutableData *data = [[NSMutableData alloc] init];</span><br><span class="line">    NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];</span><br><span class="line">    [archiver encodeObject:lines forKey:kRootKey];</span><br><span class="line">    [archiver finishEncoding];</span><br><span class="line">    [data writeToFile:filePath atomically:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与属性列表序列化实现多几行代码，那么是否就是使用归档比使用序列化属性列表更有优势呢？答案是否定的。如果我们拥有一个包含可归档对象的数组，则可以对数组实例本身进行归档来归档整个数组。对集合类（如数组）进行归档时，也会归档其包含的所有对象。只要放入数组或字典中的对象遵循NSCoding，就可以归档数组或字典并还原它。这样，对其进行归档时，其中所有对象都将位于已还原的数组和字典中。这一点并不适用于属性链接的持久化，它只支持一小部分的Foundation对象类型。如果没有编写额外的代码，来将这些自定义类的实例与字典通过每个对象属性的键进行互相转化，就不能对其进行持久化。</p>
<p>换句话说，NSCoding方法具有非常好的伸缩性，因为无论添加多少对象，将这些对象写入磁盘的方式都完全相同。不过使用属性列表的话，工作量会随着添加对象而增加。</p>
<h1 id="五、SQLite3"><a href="#五、SQLite3" class="headerlink" title="五、SQLite3"></a>五、SQLite3</h1><p>SQLite3在存储和检索大量数据方面非常有效。它能够对数据进行复杂的聚合，与使用对象执行这些操作相比，获得结果的速度更快。</p>
<p>SQLite3使用SQL（Structured Query Language，结构化查询语言），SQL是与关系数据库交互的标准语言。</p>
<p>这里推荐两篇SQLite3深入研究探索的参考文章：</p>
<p>An Introduction to the SQLite3 C&#x2F;C++ Interface (<a target="_blank" rel="noopener" href="http://www.sqlite.org/cintro.html">www.sqlite.org/cintro.html</a>)</p>
<p>SQL As Understood by SQLite (<a target="_blank" rel="noopener" href="http://www.sqlite.org/lang.html">www.sqlite.org/lang.html</a>)</p>
<p>关系数据库（包括SQLite3）和面向对象的编程语言使用完全不同的方法来存储和组织数据。这些方法差异很大，因而出现了在两者之间进行转换的各种技术以及很多库和工具。这些技术统称为ORM（Object-Relational-Mapping，对象关系映射）。目前有很多种ORM工具可用于Cocoa Touch。</p>
<h2 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h2><p>虽然可以通过创建SQL字符串来插入值，但常用的方法是使用绑定变量来执行数据库插入操作。正确处理字符串并确保它们没有无效字符（以及引号处理过的属性）是非常烦琐的事情。借助绑定变量，这些问题将迎刃而解。</p>
<p>要使用绑定变量插入值，只需要按正常方式创建SQL语句即可，不过要在SQL字符串中添加一个问号。每个问号都表示一个需要在语句执行之前进行绑定的变量。然后，准备好SQL语句，将值绑定到各个变量并执行命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*将整型数据绑定到第一个变量，将字符串绑定到第二个变量，然后执行并结束语句*/</span><br><span class="line">char *sql = “insert into foo values (?, ?);”;</span><br><span class="line">sqlite3_stmt *stmt;</span><br><span class="line"></span><br><span class="line">if(sqlite3_prepare_v2(database, sql, -1, &amp;stmt, nil) == SQLITE_OK)&#123;</span><br><span class="line">    sqlite3_bind_int(stmt, 1, 235);</span><br><span class="line">    sqlite3_bind_text(stmt, 2, “Bar”, -1, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(sqlite3_step(stmt) != SQLITE_DONE)&#123;</span><br><span class="line">    NSLog(@”This should be real error checking!”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sqlite3_finalize(stmt);</span><br></pre></td></tr></table></figure>

<p>根据希望使用的数据类型，可以选择不同的绑定语句。大部分绑定函数都只有3个参数。</p>
<p>1）无论针对哪种数据类型，任何绑定函数的第一个参数都指向之前在sqlite3_prepare_v2()调用中使用的sqlite3_stmt。</p>
<p>2）第二个参数是被绑定变量的索引。它是一个有序索引值，者这表示SQL语句中的第一个问号是索引1，其后面的每个问号都依次按序增加1。</p>
<p>3）第三个参数始终表示应该替换问号的值。</p>
<p>有些绑定函数（比如用于绑定文本和二进制数据的绑定函数）拥有另外两个参数。</p>
<p>1）一个参数是在上面第三个参数中传递的数据长度。对于C字符串，可以传递-1来代替字符串长度，这样函数将使用整个字符串。对于所有其他情况，需要指定所传递数据的长度。</p>
<p>2）另外一个参数是可选的函数回调，用于在语句执行后完成内存清理工作。通常，这种函数使用malloc()释放已分配的内存。</p>
<h2 id="创建工程-2"><a href="#创建工程-2" class="headerlink" title="创建工程"></a>创建工程</h2><p>创建工程，设计布局，与前文工程相同操作，连线，添加响应方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;SqliteViewController.h&quot;</span><br><span class="line">#import &lt;sqlite3.h&gt;</span><br><span class="line"></span><br><span class="line">@interface SqliteViewController ()</span><br><span class="line">- (IBAction)saveClicked:(id)sender;</span><br><span class="line">@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>导入sqlite库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">    </span><br><span class="line">    sqlite3 *database;</span><br><span class="line">    //打开数据库</span><br><span class="line">    if (sqlite3_open([[self dataFilePath] UTF8String], &amp;database) != SQLITE_OK) &#123;</span><br><span class="line">        sqlite3_close(database);</span><br><span class="line">        NSAssert(0, @&quot;Failed to open database&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     有用的C语言知识：</span><br><span class="line">     如果两个内联的字符串之间只有空白（包括换行符）而没有其他字符，</span><br><span class="line">     那么这两个字符串会被连接为一个字符串。</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">    //创建数据库SQL</span><br><span class="line">    NSString *createSQL = @&quot;create table if not exists fields (row integer primary key, field_data text);&quot;;</span><br><span class="line">    char *errorMsg;</span><br><span class="line">    //执行SQL语句</span><br><span class="line">    if (sqlite3_exec(database, [createSQL UTF8String], NULL, NULL, &amp;errorMsg) != SQLITE_OK) &#123;</span><br><span class="line">        sqlite3_close(database);</span><br><span class="line">        NSAssert(0, @&quot;Error creating table: %s&quot;, errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //查询数据库</span><br><span class="line">    NSString *query = @&quot;select row, field_data from fields order by row;&quot;;</span><br><span class="line">    sqlite3_stmt *statement;</span><br><span class="line">    if (sqlite3_prepare_v2(database, [query UTF8String], -1, &amp;statement, nil) == SQLITE_OK) &#123;</span><br><span class="line">        //遍历返回的每行</span><br><span class="line">        while (sqlite3_step(statement) == SQLITE_ROW) &#123;</span><br><span class="line">            int row = sqlite3_column_int(statement, 0);</span><br><span class="line">            char *rowData = (char *)sqlite3_column_text(statement, 1);</span><br><span class="line">            NSString *fieldValue = [[NSString alloc] initWithUTF8String:rowData];</span><br><span class="line">            UITextField *field = self.lineFields[row];</span><br><span class="line">            field.text = fieldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        sqlite3_finalize(statement);</span><br><span class="line">    &#125;</span><br><span class="line">    //关闭数据库</span><br><span class="line">    sqlite3_close(database);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSString *)dataFilePath&#123;</span><br><span class="line">    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">    NSString *documentsDirectory = [paths objectAtIndex:0];</span><br><span class="line">    return [documentsDirectory stringByAppendingPathComponent:@&quot;data.sqlite&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)saveClicked:(id)sender &#123;</span><br><span class="line">    sqlite3 *database;</span><br><span class="line">    if (sqlite3_open([[self dataFilePath] UTF8String], &amp;database) != SQLITE_OK) &#123;</span><br><span class="line">        sqlite3_close(database);</span><br><span class="line">        NSAssert(0, @&quot;Failed to open database&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        UITextField *field = self.lineFields[i];</span><br><span class="line">        //内联字符串的连接，又一次派上用场</span><br><span class="line">        char *update = &quot;insert or replace into fields (row, field_data) values (?, ?);&quot;;</span><br><span class="line">        char *errorMsg = NULL;</span><br><span class="line">        sqlite3_stmt *stmt;</span><br><span class="line">        //绑定变量</span><br><span class="line">        if (sqlite3_prepare_v2(database, update, -1, &amp;stmt, nil) == SQLITE_OK) &#123;</span><br><span class="line">            sqlite3_bind_int(stmt, 1, i);</span><br><span class="line">            sqlite3_bind_text(stmt, 2, [field.text UTF8String], -1, NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        //判断执行更新是否成功</span><br><span class="line">        if (sqlite3_step(stmt) != SQLITE_DONE) &#123;</span><br><span class="line">            NSAssert(0, @&quot;Error updating table: %s&quot;, errorMsg);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlite3_finalize(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlite3_close(database);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，以上者三种方式没有什么差异，只不过是三种不同的持久化机制而已。</p>
<h1 id="六、Core-Data"><a href="#六、Core-Data" class="headerlink" title="六、Core Data"></a>六、Core Data</h1><p>Core Data是一款稳定、功能全面的持久化工具。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>实体：表示对对象的描述。</p>
<p>托管对象：表示在运行时创建该实体的具体实例。</p>
<p>注意，在数据模型编辑器中，你将创建实体；而在代码中，你将创建并检索托管对象。实体和托管对象之间的差异类似于类与类的实例。 </p>
<p>实体由属性组成，属性分为3种类型：</p>
<p>1）特性（attribute）：特性在Core Data实体中的作用与实例变量在Objective-C类中的作用完全相同，它们都用于保存数据。</p>
<p>2）关系（relationship）：关系用于定义实体之间的关系。举例来说，假设要定义一个Person实体，你可能首先会定义一些特性，比如height和weight，还可以定义地址特性，比如state和zipCode，或者将它们嵌入到单独的HomeAddr实体中。使用后面这种方法，你可能希望在Person与HomeAddr之间创建一个关系。关系可以是一对一或一对多。从Person到HomeAddr的关系可以是“一对一”，因为大多数人都只有一个家庭地址。从HomeAddr到Person的关系则可以是“一对多”，因为可能多个人住在同一个家庭地址。</p>
<p>3）提取属性（fetched property）：提取属性是关系的备选方法。用提取属性可以创建一个能在提取时被评估的查询，从而确定哪些对象属于这个关系。沿用刚才的例子，一个Person对象可以拥有一个名为Neighbors的提取属性，该属性查找数据存储中与这个Person的HomeAddr拥有相同zipCode的所有HomeAddr对象。由于提取属性的结构和使用方式，它们通常都是一对一关系。提取属性也是唯一一种能够让你跨越多个数据存储的关系。</p>
<h2 id="创建工程-3"><a href="#创建工程-3" class="headerlink" title="创建工程"></a>创建工程</h2><p>依旧如前文方式创建工程，添加响应参数，不过在这里要注意的是，Core Data的创建方法步骤：</p>
<p>1）创建Model文件</p>
<p><img src="/assets/images/tech/ios-data-persistence-2.png" alt="创建Model文件"></p>
<p>2）编辑Model文件，点击“Add Entity”添加实体，点击“Add Attribute”添加特性</p>
<p><img src="/assets/images/tech/ios-data-persistence-3.png" alt="编辑Model文件"></p>
<p>3）创建NSManagedObject文件，关联数据模型</p>
<p><img src="/assets/images/tech/ios-data-persistence-4.png" alt="创建NSManagedObject文件-1"></p>
<p><img src="/assets/images/tech/ios-data-persistence-5.png" alt="创建NSManagedObject文件-2"></p>
<p><img src="/assets/images/tech/ios-data-persistence-6.png" alt="创建NSManagedObject文件-3"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;CoreDataViewController.h&quot;</span><br><span class="line">#import &lt;CoreData/CoreData.h&gt;</span><br><span class="line"></span><br><span class="line">static NSString *const kLineEntityName = @&quot;Line&quot;;</span><br><span class="line">static NSString *const kLineNumberKey = @&quot;lineNumber&quot;;</span><br><span class="line">static NSString *const kLineTextKey = @&quot;lineText&quot;;</span><br><span class="line"></span><br><span class="line">@interface CoreDataViewController ()</span><br><span class="line">- (IBAction)saveClicked:(id)sender;</span><br><span class="line">@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">    </span><br><span class="line">    NSManagedObjectContext *context = [self myContext];</span><br><span class="line"></span><br><span class="line">    NSFetchRequest *request = [[NSFetchRequest alloc] initWithEntityName:kLineEntityName];</span><br><span class="line">    NSError *error;</span><br><span class="line">    NSArray *objects = [context executeFetchRequest:request error:&amp;error];</span><br><span class="line">    if (objects == nil) &#123;</span><br><span class="line">        NSLog(@&quot;There was an error!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (NSManagedObject *oneObject in objects) &#123;</span><br><span class="line">        int lineNum = [[oneObject valueForKey:kLineNumberKey] intValue];</span><br><span class="line">        NSString *lineText = [oneObject valueForKey:kLineTextKey];</span><br><span class="line"></span><br><span class="line">        UITextField *theField = self.lineFields[lineNum];</span><br><span class="line">        theField.text = lineText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSManagedObjectContext *)myContext&#123;</span><br><span class="line">    //上下文 关联Company.xcdatamodeld模型文件</span><br><span class="line">    NSManagedObjectContext *context = [[NSManagedObjectContext alloc] init];</span><br><span class="line">    //模型文件</span><br><span class="line">    NSManagedObjectModel *model = [NSManagedObjectModel mergedModelFromBundles:nil];</span><br><span class="line">    //持久化存储调度器</span><br><span class="line">    NSPersistentStoreCoordinator *store = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:model];</span><br><span class="line">    NSString *doc = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">    NSString *sqlitePath = [doc stringByAppendingPathComponent:@&quot;line.sqlite&quot;];</span><br><span class="line">    //数据存储的类型 数据库存储路径</span><br><span class="line">    [store addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:[NSURL fileURLWithPath:sqlitePath] options:nil error:nil];</span><br><span class="line">    context.persistentStoreCoordinator = store;</span><br><span class="line">    </span><br><span class="line">    return context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (IBAction)saveClicked:(id)sender &#123;</span><br><span class="line">    </span><br><span class="line">    NSManagedObjectContext *context = [self myContext];</span><br><span class="line">    </span><br><span class="line">    NSError *error;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        UITextField *theField = self.lineFields[i];</span><br><span class="line">        NSFetchRequest *request = [[NSFetchRequest alloc] initWithEntityName:kLineEntityName];</span><br><span class="line">        NSPredicate *pred = [NSPredicate predicateWithFormat:@&quot;(%K = %d)&quot;, kLineNumberKey, i];</span><br><span class="line">        [request setPredicate:pred];</span><br><span class="line"></span><br><span class="line">        NSArray *objects = [context executeFetchRequest:request error:&amp;error];</span><br><span class="line">        if (objects == nil) &#123;</span><br><span class="line">            NSLog(@&quot;There was an error!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        NSManagedObject *theLine = nil;</span><br><span class="line">        if ([objects count] &gt; 0) &#123;</span><br><span class="line">            theLine = [objects objectAtIndex:0];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            theLine = [NSEntityDescription insertNewObjectForEntityForName:kLineEntityName inManagedObjectContext:context];</span><br><span class="line">        &#125;</span><br><span class="line">        [theLine setValue:[NSNumber numberWithInt:i] forKey:kLineNumberKey];</span><br><span class="line">        [theLine setValue:theField.text forKey:kLineTextKey];</span><br><span class="line">    &#125;</span><br><span class="line">    [context save:nil];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Core Data版本与之前的版本功能完全相同。Core Data需要的工作量很大。对于这种简单的应用，它并没有提供明显的优势。但是在比较复杂的应用中，Core Data可以显著减少设计和编写数据模型所需的时间。</p>
<h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><p>四种数据持久化机制，各有优势，根据使用情况选择对应机制进行数据持久化。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ios/" rel="tag"># ios</a>
              <a href="/tags/%E5%AD%98%E5%82%A8/" rel="tag"># 存储</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2016-02-10-memory-alignment/" rel="prev" title="内存对齐详解">
                  <i class="fa fa-chevron-left"></i> 内存对齐详解
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2016-01-15-ios-preference-setting/" rel="next" title="iOS App 偏好设置">
                  iOS App 偏好设置 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC8zMzY4My8xMDIzOA=="></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chars</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




<script src="/js/third-party/comments/livere.js"></script>

</body>
</html>
