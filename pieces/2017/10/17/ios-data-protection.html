<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <!-- JQuery (used for bootstrap and jekyll search) -->
    <script src="/assets/js/jquery-3.2.1.min.js" ></script>
    
    <!-- Main JS (navbar.js and katex_init.js)-->
    <script defer=true src="/assets/js/main.min.js"></script>
    
    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css">

    <!--Favicon-->
    <link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

    <!-- Canonical -->
    <link rel="canonical" href="http://chars.tech/pieces/2017/10/17/ios-data-protection.html">

    <!-- RSS -->
    <link rel="alternate" type="application/atom+xml" title="Chars" href="http://chars.tech///feed.xml"/>

    <!-- Font Awesome -->
    <!-- <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"> -->
    <link rel="stylesheet" type="text/css" href="/assets/css/font-awesome.min.css">

    <!-- Google Fonts -->
    
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css"> 
    

    <!-- KaTeX 0.8.3 -->
    
    <!--<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js"></script> -->
    <link rel="stylesheet" type="text/css" href="/assets/css/katex.min.css">
    <script src="/assets/js/katex.min.js">
    </script>
    

    <!-- Google Analytics -->
    
    <script>
        (function(i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r;
            i[r] = i[r] || function() {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o),
                m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m)
        })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

        ga('create', 'UA-80507808-1', 'auto');
        ga('send', 'pageview');

    </script>
    
    
    <!-- seo tags -->
    <!-- Begin Jekyll SEO tag v2.4.0 -->
<title>聊聊 iOS 数据保护</title>
<meta name="generator" content="Jekyll v3.7.2" />
<meta property="og:title" content="聊聊 iOS 数据保护" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="文件系统中的文件、keychain中的项，都是加密存储的。当用户解锁设备后，系统通过UDID密钥和用户设定的密码生成一个用于解密的密码密钥，存放在内存中，直到设备再次被锁，开发者可以通过Data Protection API 来设定文件系统中的文件、keychain中的项应该何时被解密。这个就是数据保护的内容。" />
<meta property="og:description" content="文件系统中的文件、keychain中的项，都是加密存储的。当用户解锁设备后，系统通过UDID密钥和用户设定的密码生成一个用于解密的密码密钥，存放在内存中，直到设备再次被锁，开发者可以通过Data Protection API 来设定文件系统中的文件、keychain中的项应该何时被解密。这个就是数据保护的内容。" />
<link rel="canonical" href="http://chars.tech/pieces/2017/10/17/ios-data-protection.html" />
<meta property="og:url" content="http://chars.tech/pieces/2017/10/17/ios-data-protection.html" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-10-17T23:18:19+08:00" />
<script type="application/ld+json">
{"description":"文件系统中的文件、keychain中的项，都是加密存储的。当用户解锁设备后，系统通过UDID密钥和用户设定的密码生成一个用于解密的密码密钥，存放在内存中，直到设备再次被锁，开发者可以通过Data Protection API 来设定文件系统中的文件、keychain中的项应该何时被解密。这个就是数据保护的内容。","@type":"BlogPosting","url":"http://chars.tech/pieces/2017/10/17/ios-data-protection.html","headline":"聊聊 iOS 数据保护","dateModified":"2017-10-17T23:18:19+08:00","datePublished":"2017-10-17T23:18:19+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://chars.tech/pieces/2017/10/17/ios-data-protection.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <!-- Manual seo tags -->
    <!--
    <title>聊聊 iOS 数据保护 | Chars</title>
    <meta name="description" content="文件系统中的文件、keychain中的项，都是加密存储的。当用户解锁设备后，系统通过UDID密钥和用户设定的密码生成一个用于解密的密码密钥，存放在内存中，直到设备再次被锁，开发者可以通过Data Protection API 来设定文件系统中的文件、keychain中的项应该何时被解密。这个就是数据保护的内容。">
    -->
</head>

  <body>
    <header class="site-header">
    
    <!-- Logo and title -->
	<div class="branding">
		<a href="/">
			<img class="avatar" src="/assets/img/avatar.png" alt=""/>
		</a>

		<h1 class="site-title">
			<a href="/">Chars</a>
		</h1>
	</div>
    
    <!-- Toggle menu -->
    <nav class="clear">
    <a id="pull" class="toggle" href="#">
    <i class="fa fa-bars fa-lg"></i>
    </a>
    
    <!-- Menu -->
    <ul>
        
        
        
        
        <li>
            <a class="clear" href="/about/">
                About
            </a>
        </li>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
         
        
        
        <li>
            <a class="clear" href="http://chars.tech/hobby">
                Hobby
            </a>
        </li>
        
        
        <li>
            <a class="clear" href="http://chars.tech/search">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
        </li>
        
        
        <li>
            <a class="clear" href="http://chars.tech/tags">
                <i class="fa fa-tags" aria-hidden="true"></i>
            </a>
        </li>
        
        
    </ul>
        
	</nav>
</header>

    <div class="content">
      <article >
  <header id="main" style="background-image: url('/')">
    <h1 id="%E8%81%8A%E8%81%8A+iOS+%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8A%A4" class="title">聊聊 iOS 数据保护</h1>
    <p class="meta">
    October 17, 2017
    
    </p>
  </header>
  <section class="post-content"><p>文件系统中的文件、keychain中的项，都是加密存储的。当用户解锁设备后，系统通过UDID密钥和用户设定的密码生成一个用于解密的密码密钥，存放在内存中，直到设备再次被锁，开发者可以通过Data Protection API 来设定文件系统中的文件、keychain中的项应该何时被解密。这个就是数据保护的内容。</p>

<h2 id="钥匙串keychain">钥匙串（keychain）</h2>

<p>keychain服务提供了一种安全的保存私密信息（密码，序列号，私钥，证书等）的方式，每个iOS程序都有一个独立的keychain存储。相对于NSUserDefaults、文件保存等一般方式，keychain保存更为安全，而且keychain里保存的信息不会因APP被删除而丢失。</p>

<p>基于钥匙串的特点，我们在使用时对于新增的数据项目，要注意数据删除的时机。还有一点需要注意的就是，保护属性的指定。如果没有指定保护属性，这将被视为严重的安全漏洞。</p>

<h3 id="作用">作用</h3>

<h4 id="备份">备份</h4>

<p>当我们备份设备数据时，系统会将用户数据保存在相应的钥匙串中，并依照相应的安全策略保存。主要分成两类：<strong>加密</strong>和<strong>不加密</strong>。</p>

<p>两者的主要区别在于恢复数据时的范围不同。加密备份的数据可以恢复到任何设备上（ThisDeviceOnly指定的项目除外），而不加密的备份则只能恢复至同一台设备。</p>

<h4 id="共享">共享</h4>

<p>keychain支持在多个应用之间共享数据。但现实开发中<code class="highlighter-rouge">UIPasteboardNameFind</code>的使用代替了keychain。不过好在Apple在iOS11中已经废弃它。看来Apple想规范开发者对于用户敏感数据的共享使用，同时提醒大家使用更加安全的方式存储用户敏感数据。</p>

<h3 id="使用范例">使用范例</h3>

<h4 id="secitemadd">SecItemAdd</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSMutableDictionary *dict = [NSMutableDictionary dictionary];
NSData *passwordData = [@"myPassword" dataUsingEncoding:NSUTF8StringEncoding];

[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];
[dict setObject:@"Conglomco" forKey:(__bridge id)kSecAttrLabel];
[dict setObject:@"This is your password for the Conglomco service." forKey:(__bridge id)kSecAttrDescription];
[dict setObject:@"chars" forKey:(__bridge id)kSecAttrAccount];
[dict setObject:@"cn.zaker.keychain.sample" forKey:(__bridge id)kSecAttrService];
[dict setObject:passwordData forKey:(__bridge id)kSecValueData];
[dict setObject:(__bridge id)kSecAttrAccessibleWhenUnlocked forKey:(__bridge id)kSecAttrAccessible];

OSStatus error = SecItemAdd((__bridge CFDictionaryRef)dict, NULL);
if (error == errSecSuccess) {
    NSLog(@"Yay");
}
</code></pre></div></div>

<h4 id="secitemdelete">SecItemDelete</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSMutableDictionary *dict = [NSMutableDictionary dictionary];

[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];
[dict setObject:@"chars" forKey:(__bridge id)kSecAttrAccount];
[dict setObject:@"cn.zaker.keychain.sample" forKey:(__bridge id)kSecAttrService];

OSStatus error = SecItemDelete((__bridge CFDictionaryRef)dict);
if (error == errSecSuccess) {
	NSLog(@"Yay");
}
</code></pre></div></div>

<h4 id="secitemupdate">SecItemUpdate</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSMutableDictionary *dict = [NSMutableDictionary dictionary];
NSData *newPasswordData = [@"newMyPassword" dataUsingEncoding:NSUTF8StringEncoding];

[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];
[dict setObject:@"chars" forKey:(__bridge id)kSecAttrAccount];
[dict setObject:@"cn.zaker.keychain.sample" forKey:(__bridge id)kSecAttrService];

NSDictionary *updatedAttribute = [NSDictionary dictionaryWithObject:newPasswordData forKey:(__bridge id)kSecValueData];

OSStatus error = SecItemUpdate((__bridge CFDictionaryRef)dict, (__bridge CFDictionaryRef)updatedAttribute);
if (error == errSecSuccess) {
	NSLog(@"Yay");
}
</code></pre></div></div>

<h4 id="secitemcopymatching">SecItemCopyMatching</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSMutableDictionary *dict = [NSMutableDictionary dictionary];

[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];
[dict setObject:@"chars" forKey:(__bridge id)kSecAttrAccount];
[dict setObject:@"cn.zaker.keychain.sample" forKey:(__bridge id)kSecAttrService];
[dict setObject:(id)kCFBooleanTrue forKey:(__bridge id)kSecReturnAttributes];

NSDictionary *result = nil;
OSStatus error = SecItemCopyMatching((__bridge CFDictionaryRef)dict, (void *)&amp;result);
if (error == errSecSuccess) {
	NSLog(@"Yay %@", result);
}
</code></pre></div></div>

<h3 id="常用方法">常用方法</h3>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SecItemAdd</td>
      <td>添加数据</td>
    </tr>
    <tr>
      <td>SecItemDelete</td>
      <td>删除数据</td>
    </tr>
    <tr>
      <td>SecItemUpdate</td>
      <td>修改数据</td>
    </tr>
    <tr>
      <td>SecItemCopyMatching</td>
      <td>查找数据</td>
    </tr>
  </tbody>
</table>

<h3 id="保护属性">保护属性</h3>

<table>
  <thead>
    <tr>
      <th>钥匙串保护属性</th>
      <th>含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>kSecAttrAccessibleAfterFirstUnlock</td>
      <td>开机之后密钥不可用，直到用户首次输入密码</td>
    </tr>
    <tr>
      <td>kSecAttrAccessibleAlways</td>
      <td>密钥在设备开机后依旧可用。在iOS9中已经废弃</td>
    </tr>
    <tr>
      <td>kSecAttrAccessibleAlwaysThisDeviceOnly</td>
      <td>密钥始终可用，但无法迁移到其他设备</td>
    </tr>
    <tr>
      <td>kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly</td>
      <td>作用同上</td>
    </tr>
    <tr>
      <td>kSecAttrAccessibleWhenUnlocked</td>
      <td>只要解锁过设备，则密钥保持可用状态</td>
    </tr>
    <tr>
      <td>kSecAttrAccessibleWhenUnlockedThisDeviceOnly</td>
      <td>作用同上</td>
    </tr>
    <tr>
      <td>kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly</td>
      <td>作用同上，只有用户设置密码密钥才可用</td>
    </tr>
  </tbody>
</table>

<p><code class="highlighter-rouge">kSecAttrAccessibleAlways</code> 将会引入一个很明显的安全问题，因为此种保护属性，只要有人窃取了你的设备，他们就能读取钥匙串的内容。</p>

<p><code class="highlighter-rouge">kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly</code> 这个属性可以完美的解决上述的安全问题。因为越狱时通常需要重启设备。</p>

<p><code class="highlighter-rouge">kSecAttrAccessibleWhenUnlocked</code> 这个属性要求攻击者必须知道用户密码才能提取隐私数据。它很适合做默认属性值。</p>

<p><code class="highlighter-rouge">kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly</code> 是iOS8新增的保护属性。这个属性要求在使用时用户设定了密码，否则使用就失败。</p>

<h3 id="基本用法">基本用法</h3>

<table>
  <thead>
    <tr>
      <th>项目类</th>
      <th>描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>kSecClassGenericPassword</td>
      <td>普通密码</td>
    </tr>
    <tr>
      <td>kSecClassInternetPassword</td>
      <td>专门用于互联网服务的密码</td>
    </tr>
    <tr>
      <td>kSecClassCertificate</td>
      <td>加密证书</td>
    </tr>
    <tr>
      <td>kSecClassKey</td>
      <td>加密密钥</td>
    </tr>
    <tr>
      <td>kSecClassIdentity</td>
      <td>一个密钥对（包括公共证书和私钥）</td>
    </tr>
  </tbody>
</table>

<h3 id="icloud同步">iCloud同步</h3>

<p>这是iOS7引入的一种新机制，可以把钥匙串项目同步到iCloud，允许用户在多个设备之间共享钥匙串项目。</p>

<p>默认情况下，应用程序创建的钥匙串项目会禁用这个机制，但可以把<code class="highlighter-rouge">kSecAttrSynchronizable</code>设置为<code class="highlighter-rouge">true</code>来启用。</p>

<p>另外请注意，使用此选项时无法指定不兼容的kSecAttrAccessible属性。例如，指定kSecAttrAccessibleWhenUnlockedThisDeviceOnly不起作用，因为ThisDeviceOnly指定的项目不会备份，也不能同步到iCloud、笔记本电脑、台式机或其他同步位置。</p>

<h2 id="数据保护">数据保护</h2>

<p>Apple 推出了数据保护API作为额外的保护层，它允许开发者指定文件解密密钥的生命周期。可以使用这个API控制文件的访问权限，与钥匙串项目中的kSecAttrAccessible 属性类似。</p>

<p>数据保护API使用用户密码和层级密钥来加密保护文件的密钥，而当这些文件不能被访问时，会从内存中删除这个层级密钥。</p>

<h3 id="文件保护过程">文件保护过程</h3>

<p><img src="http://o88e8any8.bkt.clouddn.com/ios_data_protection_2.png" alt="文件保护过程" /></p>

<p>1.文件生成一个<code class="highlighter-rouge">文件密钥</code>来加密文件的内容。</p>

<p>2.生成一个额外的密钥对，用于生成<code class="highlighter-rouge">文件公钥</code>和<code class="highlighter-rouge">文件私钥</code>。</p>

<p>3.用<code class="highlighter-rouge">文件私钥</code>和<code class="highlighter-rouge">Protected Unless Open等级公钥</code>计算出一个<code class="highlighter-rouge">共享密码</code>。</p>

<p>4.用<code class="highlighter-rouge">共享密码</code> SHA-1散列值加密文件密钥。</p>

<p>5.加密过的<code class="highlighter-rouge">文件密钥</code>会存储在文件的元数据中，元数据中还有文件的公钥。</p>

<p>6.系统丢弃<code class="highlighter-rouge">文件私钥</code>。</p>

<p>7.关闭文件时从内存中删除未加密的文件密钥。</p>

<p>8.需要再次打开文件时，用<code class="highlighter-rouge">Protected Unless Open等级私钥</code>和<code class="highlighter-rouge">文件公钥</code>计算<code class="highlighter-rouge">共享密码</code>。</p>

<p>9.计算<code class="highlighter-rouge">共享密码</code>的SHA-1散列值，把它当作解密文件的密钥。</p>

<h3 id="dataprotectionclass-权限">DataProtectionClass 权限</h3>

<p>如果你的应用在设备进入后台或锁定时不需要写入或读取文件，那你就可以在工程中配置一个<code class="highlighter-rouge">NSFileProtectionComplete</code>值来添加权限。这将确保所有受保护的文件数据只能在设备解锁时访问，相当于为所有的应用文件都设置<code class="highlighter-rouge">kSecAttrAccessibleWhenUnlocked</code>选项。</p>

<p>从Xcode5开始，新工程会默认启用数据保护权限，但是一些旧工程并不会自动开启。</p>

<p>开启方式如下图：</p>

<p><img src="http://o88e8any8.bkt.clouddn.com/ios_data_protection_1.png?imageView2/2/w/800" alt="开启DataProtectionClass权限" /></p>

<h3 id="使用范例-1">使用范例</h3>

<h4 id="nsdatawritingfileprotectioncomplete">NSDataWritingFileProtectionComplete</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSData *data = [self generateData];
NSError *error = nil;
NSString *path = [NSString stringWithFormat:@"%@_demo.pdf", NSTemporaryDirectory()];
[data writeToFile:path options:NSDataWritingFileProtectionComplete error:&amp;error];
if (error) {
	NSLog(@"%@", error);
}
</code></pre></div></div>

<h4 id="nsfileprotectioncomplete">NSFileProtectionComplete</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@"demo.txt"];
NSError *error = nil;
NSDictionary *attr = [NSDictionary dictionaryWithObject:NSFileProtectionComplete forKey:NSFileProtectionKey];
[[NSFileManager defaultManager] setAttributes:attr ofItemAtPath:path error:&amp;error];
if (error) {
	NSLog(@"%@", error);
}
</code></pre></div></div>

<h4 id="sqlite_open_fileprotection_completeunlessopen">SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@"demo.sqlite"];
sqlite3 *handle = NULL;
sqlite3_open_v2([path UTF8String],
                &amp;handle,
                SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE | SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN,
                NULL);
</code></pre></div></div>

<h3 id="保护等级">保护等级</h3>

<h4 id="completeuntilfirstuserauthentication">CompleteUntilFirstUserAuthentication</h4>

<p>这个保护等级是iOS5开始使用的默认值。主要用来防御一些需要重启的攻击。</p>

<h4 id="complete">Complete</h4>

<p>官方称这是目前最安全的文件保护等级。在这种情况下，锁屏之后系统就会删除内存中的层级密钥，并把文件改为不可读。</p>

<p>具体使用的范例前文可见。</p>

<p>使用Complete保护之前，考虑是否合适。如果你的应用进程需要持续写/读一个文件，那这种保护模式就不合适了。</p>

<h4 id="completeunlessopen">CompleteUnlessOpen</h4>

<p>如果一个文件当前被一个应用打开，那会暂时禁用该文件的保护。它会确保打开的文件在设备被锁定时依然能够写入，并且允许新建文件到磁盘。不过这个等级保护的文件在锁屏时无法打开，除非锁屏时就已经提前打开。</p>

<h2 id="commoncrypto加密">CommonCrypto加密</h2>

<p>CommonCrypto是Apple官方提供的一套加密框架。在使用这套方案时，主要注意以下几个问题即可。</p>

<h3 id="避免弱算法">避免弱算法</h3>

<p>众所周知，DES就是一种很典型的弱算法。如果你使用弱算法，那应用就很容易遭受密码攻击和暴力破解。</p>

<p>我们在实际使用时，可以考虑使用AES算法、MD5算法或MD5加盐算法等。</p>

<h3 id="破碎的熵">破碎的熵</h3>

<p>我们通常会使用<code class="highlighter-rouge">rand</code>方法来产生随机数，但是系统的这个随机函数并不是真正的随机。它产生的随机数符合正态分布，我们可以使用官方提供的方法<code class="highlighter-rouge">SecRandomCopyBytes</code>获得。也可以自己使用算法产生随机数。</p>

<p>这里分享一个笔者以前自己实现的随机数案例。<a href="/2016/04/30/uniform-random/">《均匀分布随机函数的实现》</a></p>

<h3 id="弱密钥">弱密钥</h3>

<p>开发者经常将用户的密码当作加密密钥，尤其在移动设备上，这将导致一个非常脆弱、低熵加密的密钥。</p>

<p>那么正确的姿势是使用<code class="highlighter-rouge">CCKeyDerivationPBKDF</code>方法来生成。</p>

<h2 id="touch-id">Touch ID</h2>

<h3 id="使用范例-2">使用范例</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#import &lt;LocalAuthentication/LocalAuthentication.h&gt;

LAContext *context = [[LAContext alloc] init];
NSError *error = nil;
NSString *reason = @"We use this to verify your identify";
if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;error]) {
	[context evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:reason reply:^(BOOL success, NSError * _Nullable error) {
		if (success) {
			NSLog(@"Hello, that's your finger!");
		} else {
			NSLog(@"Couldn't read your fingerprint. Falling back to PIN or somthing.");
		}
	}];
} else {
	NSLog(@"Error : %@ %@", error, [error userInfo]);
}
</code></pre></div></div>

<h3 id="touch-id-与普通密码相比的安全性">Touch ID 与普通密码相比的安全性</h3>

<p>一个人的指纹是世界上最好的密码之一。它独一无二，高度特异，并且无需记忆。它会伴随人终生，所以你可以一直使用同一个指纹密码。</p>

<p>比起简单的4位数字锁屏密码一万分之一的破解可能性，能找到同样单个指纹的人的概率为五万分之一，这是非常安全的，比起前者我可以不断尝试，Touch ID 指纹的硬性破解几率几乎没有，因为不可能有五万多个人排队来一一解锁你的设备，况且 Touch ID 会拒绝第五次以后的尝试而要求输入密码。所以我们可以添加更加复杂的密码而不是简单的数字密码来进一步提高安全性。</p>

<h3 id="touch-id-指纹识别的原理">Touch ID 指纹识别的原理</h3>

<p>在如此快速的识别过程中，Home 按钮上的一圈金属环起到了感应手指的功能，通知 Touch ID 来读取指纹。Touch ID 置于该按钮中，传感器的厚度只有 170 微米，拥有 500 ppi 高分辨率，可读取极小的指纹细节。传感器可从皮肤皮下层指纹的一些小部分拍摄高分辨率图像，然后会分析该信息，根据三种基本指纹类型（弧形纹、箕形纹或斗形纹）将指纹分类，它会绘制比人眼不可见的纹路细节，确保指纹读取准确无误。</p>

<p><img src="http://o88e8any8.bkt.clouddn.com/ios_data_protection_3.png" alt="touch id sensor" /></p>

<p>Touch ID 可从 360 度方向读取指纹，随后创建指纹的某种数学表达式，并将其与已注册的数据进行比较，以确定是否匹配。如果匹配，便可替代密码来解锁设备或通过某个令牌。</p>

<p>此外，根据苹果官方的描述，Touch ID 会向以注册的指纹数据里持续的添加新的特征数据，随着时间的推移，这能不断提高匹配准确度，也能进一步的提高安全性。</p>

<p><img src="http://o88e8any8.bkt.clouddn.com/ios_data_protection_4.png" alt="touch id ontouch" /></p>

<p>除了上述的内容，苹果还加入可以一些有效的手段来进一步确保安全，例如设备再重新启动或者保持锁定 48 小时后，就只能通过密码而不是指纹来解锁设备。</p>

<h3 id="secure-enclave">Secure Enclave</h3>

<p>Apple声明指纹的图案不会被保存，存储于设备中的是指纹特征的数学表达式，而且从这些表达式不可能直接反推出指纹图像。</p>

<p><img src="http://o88e8any8.bkt.clouddn.com/ios_data_protection_5.png" alt="touch-id-structure" /></p>

<p>指纹的验证运算独立于主要处理器芯片（例如 A7、A8），芯片内有称为 “Secure Enclave” 的高级安全架构，专用于密码指纹数据，并使用 Secure Enclave 的专用密钥加密，以及每次启动以随机的 UID 进行管理。指纹数据仅能被 Secure Enclave 处理和使用，正因为此架构独立于其它设备部件，仅有 Touch ID 使用它，且不能将它用于匹配其他指纹数据库，所以存储的指纹数据不会由 iOS 或其他应用访问，也不会被存储到 Apple 服务器或备份到 iCloud 等地方。</p>

<p><img src="http://o88e8any8.bkt.clouddn.com/ios_data_protection_6.png" alt="A7-Secure-Enclave" /></p>

<p>从硬件上来看指纹特征数据尚不能被 “Secure Enclave” 和 Touch ID 以外的部件访问到，并且两者芯片互相隔离开来，所有软件都没有权利获得指纹数据，仅能得到指纹是否错误的回馈。因为架构的核心秘密仅仅只有苹果公司知道，所以目前几乎没有第三方软件可以访问到这部分敏感信息。</p>

<p>到此，关于 iOS 数据保护的问题暂时告一段落。欢迎大家评论指正。</p>
</section>
   
   <!-- Tag list -->
  
  


    <footer>
        <div class="tag-list">
        
          <div class="meta">Tags</div>
        
            
        
          <a class="button" href="/tags#ios">
            <p><i class="fa fa-tag fa-fw"></i> ios</p>
          </a>
        
          <a class="button" href="/tags#存储">
            <p><i class="fa fa-tag fa-fw"></i> 存储</p>
          </a>
        
          <a class="button" href="/tags#安全">
            <p><i class="fa fa-tag fa-fw"></i> 安全</p>
          </a>
        
        </div>
    </footer>
  

    
</article>

<!-- comment -->

<div class="comments">
  <!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid=MTAyMC8zMzY4My8xMDIzOA==>
<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
</script>
<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
</div>


<!-- Post navigation -->

  <div id="post-nav">
  
  <div id="previous-post" class="post-nav-post">
      <p>Previous</p>
      <a href="/ml/2017/09/26/tensorflow-pycharm-mac.html">
        MacOS 搭建 Tensorflow PyCharm 环境
      </a>
  </div>
  
  
  <div id="next-post" class="post-nav-post">
      <p>Next</p>
      <a href="/ml/2017/11/30/tensorflow-wide-and-deep.html">
        （译）TensorFlow 广度和深度学习的教程
      </a>
  </div>
  
</div>

    </div>
    
<footer class="site-footer">
    <p class="text"></p>
    <p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a>. Theme by <a href="https://github.com/charsdavy/Type-on-Strap">Type-on-Strap</a>. &copy; 2016 - 2018 </p>
            <div class="footer-icons">
                <ul>
                <!-- Social icons from Font Awesome, if enabled -->
                
<li>
	<a href="http://chars.tech////feed.xml" title="Follow RSS feed">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>



<li>
	<a href="mailto:chars.davy@gmail.com" title="Email">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>









<li>
	<a href="https://www.facebook.com/wei.deng.1460" title="Follow on Facebook">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>





<li>
	<a href="https://github.com/charsdavy" title="Follow on GitHub">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-github fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>

























<li>
	<a href="https://twitter.com/charsdavy" title="Follow on Twitter" class="type">
        <span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>



<li>
    <a href="https://weibo.com/u/3875245858" title="Follow on Weibo" class="type">
        <span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
        </span>
    </a>
</li>








                </ul>
            </div>
</footer>




  </body>
</html>
