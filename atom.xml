<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chars&#39;s Tech Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://charsdavy.github.io/"/>
  <updated>2016-06-20T05:04:00.000Z</updated>
  <id>http://charsdavy.github.io/</id>
  
  <author>
    <name>Chars Davy</name>
    <email>chars_d@126.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS开发 - 成熟的夜间模式解决方案</title>
    <link href="http://charsdavy.github.io/2016/06/20/ios-night-mode/"/>
    <id>http://charsdavy.github.io/2016/06/20/ios-night-mode/</id>
    <published>2016-06-20T05:03:03.000Z</published>
    <updated>2016-06-20T05:04:00.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：iOS夜间模式是我们在APP开发中经常会要提供的一个功能。然后，是否可以使用一些已经成熟的第三方框架呢，文章分享一个适用于夜间模式的框架 - DKNightVersion 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/DKNightVersion.gif?imageView/2/w/360&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;方法调剂的版本&quot;&gt;&lt;a href=&quot;#方法调剂的版本&quot; class=&quot;headerlink&quot; title=&quot;方法调剂的版本&quot;&gt;&lt;/a&gt;方法调剂的版本&lt;/h1&gt;&lt;p&gt;如何在不改变原有的架构，甚至不改变原有的代码的基础上，为应用优雅地添加夜间模式成为很多开发者不得不面对的问题。这也是 1.0 时代的 DKNightVersion 想要实现的目标。&lt;/p&gt;
&lt;p&gt;其核心思路就是使用方法调剂修改 backgroundColor 的存取方法。&lt;/p&gt;
&lt;h1 id=&quot;使用-nightBackgroundColor&quot;&gt;&lt;a href=&quot;#使用-nightBackgroundColor&quot; class=&quot;headerlink&quot; title=&quot;使用 nightBackgroundColor&quot;&gt;&lt;/a&gt;使用 nightBackgroundColor&lt;/h1&gt;&lt;p&gt;在思考之后，我想到，想要在不改动原有代码的基础上实现夜间模式只能通过在分类中添加 nightBackgroundColor 属性，并且使用方法调剂改变 backgroundColor 的 setter 方法。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)hook_setBackgroundColor:(UIColor*)backgroundColor &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ([DKNightVersionManager currentThemeVersion] == DKThemeVersionNormal) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self setNormalBackgroundColor:backgroundColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self hook_setBackgroundColor:backgroundColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在当前主题为 DKThemeVersionNormal 时，将颜色保存至 normalBackgroundColor 中，然后再调用原 backgroundColor 的 setter 方法，更新视图的颜色。&lt;/p&gt;
&lt;h1 id=&quot;DKNightVersionManager&quot;&gt;&lt;a href=&quot;#DKNightVersionManager&quot; class=&quot;headerlink&quot; title=&quot;DKNightVersionManager&quot;&gt;&lt;/a&gt;DKNightVersionManager&lt;/h1&gt;&lt;p&gt;这里只解决了颜色设置的问题，下面会说明，如果在主题改变时，实时更新颜色，而不用重新进入当前页面。&lt;/p&gt;
&lt;p&gt;整个 DKNightVersion 都是由一个 DKNightVersionManager 的单例来管理的，而它的主要工作就是负责改变应用的主题、并在主题改变时通知其它视图更新颜色：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)changeColor:(id &amp;lt;DKNightVersionChangeColorProtocol&amp;gt;)object &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ([object respondsToSelector:@selector(changeColor)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [object changeColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ([object respondsToSelector:@selector(subviews)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (![object subviews]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // Basic case, do nothing.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            for (id subview in [object subviews]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // recursive darken all the subviews of current view.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                [self changeColor:subview];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if ([subview respondsToSelector:@selector(changeColor)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    [subview changeColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果主题更新，那么就会递归地调用 changeColor 方法，刷新全部的视图颜色，而这个方法的实现比较简单：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)changeColor &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ([DKNightVersionManager currentThemeVersion] == DKThemeVersionNormal) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.backgroundColor = self.normalBackgroundColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.backgroundColor = self.nightBackgroundColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面就是整个框架在 1.0 版本时的实现思路。不过这个版本的 DKNightVersion 在实际应用中会有比较多的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在高速滚动的 scrollView 上面来回切换夜间模式，会出现颜色错乱的问题&lt;/li&gt;
&lt;li&gt;由于对 backgroundColor 属性进行不合适的方法调剂，其行为无法预测，比如：在设置颜色后，再取出，不一定与设置时传入的颜色相同&lt;/li&gt;
&lt;li&gt;无法适配第三方 UI 控件&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;使用色表的版本&quot;&gt;&lt;a href=&quot;#使用色表的版本&quot; class=&quot;headerlink&quot; title=&quot;使用色表的版本&quot;&gt;&lt;/a&gt;使用色表的版本&lt;/h1&gt;&lt;p&gt;为了解决 1.0 中的各种问题，我决定在 2.0 版本中放弃对 nightBackgroundColor 的使用，并且重新设计底层的实现，转而使用更为稳定、安全的方法实现夜间模式，先看一下效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/DKNightVersion.gif?imageView/2/w/360&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
&lt;p&gt;新的实现支持夜间模式，且支持多主题&lt;/p&gt;
&lt;h1 id=&quot;DKColorPicker&quot;&gt;&lt;a href=&quot;#DKColorPicker&quot; class=&quot;headerlink&quot; title=&quot;DKColorPicker&quot;&gt;&lt;/a&gt;DKColorPicker&lt;/h1&gt;&lt;p&gt;与上一个版本实现上的不同，在 2.0 中删除了全部的 nightBackgroundColor，使用一个名为 dk_backgroundColorPicker 的属性取代它。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, copy) DKColorPicker dk_backgroundColorPicker;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个属性其实就是一个 block，它接收参数 DKThemeVersion &lt;em&gt;themeVersion，但是会返回一个 UIColor &lt;/em&gt;：&lt;/p&gt;
&lt;p&gt;在第一次传入 picker 或者每次主题改变时，都会将当前主题 DKThemeVersion 传入 picker 并执行，然后，将得到的 UIColor 赋值给对应的属性 backgroundColor 更新视图颜色。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef UIColor *(^DKColorPicker)(DKThemeVersion *themeVersion);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;比如下面使用 DKColorPickerWithRGB 创建一个临时的 DKColorPicker：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 DKThemeVersionNormal 时返回 0xffffff&lt;/li&gt;
&lt;li&gt;在 DKThemeVersionNight 时返回 0x343434&lt;/li&gt;
&lt;li&gt;在自定义的主题下返回 0xfafafa （这里的顺序与色表中主题的顺序有关）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cell.dk_backgroundColorPicker = DKColorPickerWithRGB(0xffffff, 0x343434, 0xfafafa);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同时，每一个对象还持有一个 pickers 数组，来存储自己的全部 DKColorPicker：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface NSObject ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, strong) NSMutableDictionary&amp;lt;NSString *, DKColorPicker&amp;gt; *pickers;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在第一次使用这个属性时，当前对象注册为 DKNightVersionThemeChangingNotificaiton 通知的观察者。&lt;/p&gt;
&lt;p&gt;在每次收到通知时，都会调用 night_update 方法，将当前主题传入 DKColorPicker，并再次执行，并将结果传入对应的属性 [self performSelector:sel withObject:result]。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)night_updateColor &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.pickers enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull selector, DKColorPicker  _Nonnull picker, BOOL * _Nonnull stop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SEL sel = NSSelectorFromString(selector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        id result = picker(self.dk_manager.themeVersion);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [UIView animateWithDuration:DKNightVersionAnimationDuration  animations:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma clang diagnostic push&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma clang diagnostic ignored &amp;quot;-Warc-performSelector-leaks&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [self performSelector:sel withObject:result];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma clang diagnostic pop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也就是说，在每次改变主题的时候，都会发出通知。&lt;/p&gt;
&lt;h1 id=&quot;DKColorTable&quot;&gt;&lt;a href=&quot;#DKColorTable&quot; class=&quot;headerlink&quot; title=&quot;DKColorTable&quot;&gt;&lt;/a&gt;DKColorTable&lt;/h1&gt;&lt;p&gt;虽然我们在上面临时创建了一些 DKColorPicker。不过在 DKNightVersion 中，我更推荐使用色表，来减少相同的 DKColorPicker 的创建，并且能够更好地管理整个应用中的颜色：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NORMAL   NIGHT    RED  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#ffffff          #343434  #fafafa      BG&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#aaaaaa    #313131   #aaaaaa  SEP&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#0000ff      #ffffff          #fa0000   TINT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#000000    #ffffff          #000000  TEXT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#ffffff          #444444    #ffffff BAR&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面就是默认色表文件 DKColorTable.txt 中的内容，其中，第一行表示主题，NORMAL 主题必须存在，而且必须为第一列，而最右面的 BG、SEP 就是对应 DKColorPicker 的 key。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;self.tableView.dk_backgroundColorPicker =  DKColorPickerWithKey(BG);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在使用时，上面的代码就相当于返回了一个在 NORMAL 时返回 #ffffff、NIGHT 时返回 #343434 以及 RED 时返回 #fafafa 的 DKColorPicker。&lt;/p&gt;
&lt;h1 id=&quot;pickerify&quot;&gt;&lt;a href=&quot;#pickerify&quot; class=&quot;headerlink&quot; title=&quot;pickerify&quot;&gt;&lt;/a&gt;pickerify&lt;/h1&gt;&lt;p&gt;虽然说，我们使用色表以及 DKColorPicker 解决了，但是，到目前为止我们还没有解决第三方框架的问题。&lt;/p&gt;
&lt;p&gt;比如我们使用了某个第三方框架，或者自己添加了某个 color 属性，比如说：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface DKView ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, strong) UIColor *weirdColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;weirdColor 并没有对应的 DKColorPicker，但是，我们可以通过 pickerify 在想要使用 dk_weirdColorPicker 的地方生成这个对应的 picker：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@pickerify(DKView, weirdColor);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后，我们就可以使用 dk_weirdColorPicker 属性了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;view.dk_weirdColorPicker = DKColorPickerWithKey(BG);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;pickerify 其实是一个宏：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define pickerify(KLASS, PROPERTY) interface \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    KLASS (Night) \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @property (nonatomic, copy, setter = dk_set ## PROPERTY ## Picker:) DKColorPicker dk_ ## PROPERTY ## Picker; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @end \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @interface \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    KLASS () \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @property (nonatomic, strong) NSMutableDictionary&amp;lt;NSString *, DKColorPicker&amp;gt; *pickers; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @end \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @implementation \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    KLASS (Night) \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    - (DKColorPicker)dk_ ## PROPERTY ## Picker &amp;#123; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return objc_getAssociatedObject(self, @selector(dk_ ## PROPERTY ## Picker)); \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    - (void)dk_set ## PROPERTY ## Picker:(DKColorPicker)picker &amp;#123; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        objc_setAssociatedObject(self, @selector(dk_ ## PROPERTY ## Picker), picker, OBJC_ASSOCIATION_COPY_NONATOMIC); \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self setValue:picker(self.dk_manager.themeVersion) forKeyPath:@keypath(self, PROPERTY)];\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self.pickers setValue:[picker copy] forKey:_DKSetterWithPROPERTYerty(@#PROPERTY)]; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个宏根据传入的类和属性名，为我们生成了对应 picker 的存取方法，它也可以说是一种元编程的手段。&lt;/p&gt;
&lt;p&gt;这里生成的 setter 方法不是标准意义上的驼峰命名法 dk_setweirdColorPicker:，因为我不知道怎么才能让大写首字母之后的属性添加到这里（如果各位读者有解决方案，欢迎提 PR 或者 issue）。&lt;/p&gt;
&lt;h1 id=&quot;嵌入式-Ruby&quot;&gt;&lt;a href=&quot;#嵌入式-Ruby&quot; class=&quot;headerlink&quot; title=&quot;嵌入式 Ruby&quot;&gt;&lt;/a&gt;嵌入式 Ruby&lt;/h1&gt;&lt;p&gt;由于框架中很多的代码，都是重复的，所以在这里使用了嵌入式 Ruby 模板来生成对应的文件 color.m.irb：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  &amp;lt;%= klass.name %&amp;gt;+Night.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  &amp;lt;%= klass.name %&amp;gt;+Night&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Copyright (c) 2015 Draveness. All rights reserved.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  These files are generated by ruby script, if you want to modify code&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  in this file, you are supposed to update the ruby code, run it and&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  test it. And finally open a pull request.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;&amp;lt;%= klass.name %&amp;gt;+Night.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;DKNightVersionManager.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;objc/runtime.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface &amp;lt;%= klass.name %&amp;gt; ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, strong) NSMutableDictionary&amp;lt;NSString *, DKColorPicker&amp;gt; *pickers;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation &amp;lt;%= klass.name %&amp;gt; (Night)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;% klass.properties.each do |property| %&amp;gt;&amp;lt;%= &amp;quot;&amp;quot;&amp;quot;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (DKColorPicker)dk_#&amp;#123;property.name&amp;#125;Picker &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return objc_getAssociatedObject(self, @selector(dk_#&amp;#123;property.name&amp;#125;Picker));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)dk_set#&amp;#123;property.cap_name&amp;#125;Picker:(DKColorPicker)picker &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objc_setAssociatedObject(self, @selector(dk_#&amp;#123;property.name&amp;#125;Picker), picker, OBJC_ASSOCIATION_COPY_NONATOMIC);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.#&amp;#123;property.name&amp;#125; = picker(self.dk_manager.themeVersion);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.pickers setValue:[picker copy] forKey:@\&amp;quot;#&amp;#123;property.setter&amp;#125;\&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;&amp;quot;&amp;quot; %&amp;gt;&amp;lt;% end %&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这部分的实现并不在这篇文章的讨论范围之内，如果，对这部分看兴趣，可以看一下仓库中的 generator 文件夹，其中包含了代码生成器的全部代码。&lt;/p&gt;
&lt;h1 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h1&gt;&lt;p&gt;如果你对 DKNightVersion 的使用有兴趣，可以查看仓库的 README 文件，有人会说不要在项目中 ObjC runtime，我个人觉得是没有问题，AFNetworking、 BlocksKit 也使用方法调剂来改变原有方法的实现，不能因为它强大就不使用它；正相反，有时候，使用 runtime 才能优雅地解决问题。&lt;/p&gt;
&lt;p&gt;GitHub地址:&lt;a href=&quot;https://github.com/draveness/iOS-Source-Code-Analyze&quot;&gt;https://github.com/draveness/iOS-Source-Code-Analyze&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://draveness.me/night&quot;&gt;http://draveness.me/night&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：iOS夜间模式是我们在APP开发中经常会要提供的一个功能。然后，是否可以使用一些已经成熟的第三方框架呢，文章分享一个适用于夜间模式的框架 - DKNightVersion 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/DKNightVersion.gif?imageView/2/w/360&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="iOS" scheme="http://charsdavy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 源代码分析 - SDWebImage</title>
    <link href="http://charsdavy.github.io/2016/06/17/ios-sdwebimage-code-reading/"/>
    <id>http://charsdavy.github.io/2016/06/17/ios-sdwebimage-code-reading/</id>
    <published>2016-06-17T11:50:38.000Z</published>
    <updated>2016-06-20T11:51:44.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：世人都说阅读源代码对于功力的提升是十分显著的, 但是很多的著名开源框架源代码动辄上万行, 复杂度实在太高, 曾经试图读一些开源框架的源代码, 比如说 AFNetworking, SDWebImage, ReactiveCocoa 但是由于当时比较浮躁, 实在没法静下心来看, 而且有一些急功近利, 所以面对宝藏实在无力挖掘. 而最近, 由于时间比较充裕, 也终于能静下心来一段一段分析这些著名项目的源代码. 本文主要分享SDWebImage框架源代码的相关信息. &lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;简洁的接口&quot;&gt;&lt;a href=&quot;#简洁的接口&quot; class=&quot;headerlink&quot; title=&quot;简洁的接口&quot;&gt;&lt;/a&gt;简洁的接口&lt;/h1&gt;&lt;p&gt;首先来介绍一下这个 SDWebImage 这个著名开源框架, 这个开源框架的主要作用就是:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Asynchronous image downloader with cache support with an UIImageView category.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个异步下载图片并且支持缓存的 UIImageView 分类.&lt;/p&gt;
&lt;p&gt;就这么直译过来相信各位也能理解, 框架中最最常用的方法其实就是这个:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.imageView sd_setImageWithURL:[NSURL URLWithString:@&amp;quot;url&amp;quot;]  placeholderImage:[UIImage imageNamed:@&amp;quot;placeholder.png&amp;quot;]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然这个框架中还有 UIButton 的分类, 可以给 UIButton 异步加载图片, 不过这个并没有 UIImageView 分类中的这个方法常用.&lt;/p&gt;
&lt;p&gt;这个框架的设计还是极其的优雅和简洁, 主要的功能就是这么一行代码, 而其中复杂的实现细节全部隐藏在这行代码之后, 正应了那句话:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把简洁留给别人, 把复杂留给自己.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们已经看到了这个框架简洁的接口, 接下来我们看一下 SDWebImage 是用什么样的方式优雅地实现异步加载图片和缓存的功能呢?&lt;/p&gt;
&lt;h1 id=&quot;复杂的实现&quot;&gt;&lt;a href=&quot;#复杂的实现&quot; class=&quot;headerlink&quot; title=&quot;复杂的实现&quot;&gt;&lt;/a&gt;复杂的实现&lt;/h1&gt;&lt;p&gt;其实复杂只是相对于简洁而言的, 并不是说 SDWebImage 的实现就很糟糕, 相反, 它的实现还是非常 amazing 的.&lt;/p&gt;
&lt;p&gt;UIImageView+WebCache 和 UIButton+WebCache 直接为表层的 UIKit 框架提供接口, 而 SDWebImageManger 负责处理和协调 SDWebImageDownloader 和 SDWebImageCache. 并与 UIKit 层进行交互, 而底层的一些类为更高层级的抽象提供支持.&lt;/p&gt;
&lt;p&gt;在这里我们会忽略很多的实现细节, 并不会对每一行源代码逐一解读.&lt;/p&gt;
&lt;h1 id=&quot;UIImageView-WebCache&quot;&gt;&lt;a href=&quot;#UIImageView-WebCache&quot; class=&quot;headerlink&quot; title=&quot;UIImageView+WebCache&quot;&gt;&lt;/a&gt;UIImageView+WebCache&lt;/h1&gt;&lt;p&gt;接下来我们就以 UIImageView+WebCache 中的&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)sd_setImageWithURL:(NSURL *)url  placeholderImage:(UIImage *)placeholder;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这一方法为入口研究一下 SDWebImage 是怎样工作的. 我们打开上面这段方法的实现代码 UIImageView+WebCache.m&lt;/p&gt;
&lt;p&gt;当然你也可以&lt;code&gt;git clone git@github.com:rs/SDWebImage.git&lt;/code&gt;到本地来查看.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)sd_setImageWithURL:(NSURL *)url &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          placeholderImage:(UIImage *)placeholder &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self sd_setImageWithURL:url &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            placeholderImage:placeholder &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             options:0 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             progress:nil &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             completed:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段方法唯一的作用就是调用了另一个方法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self sd_setImageWithURL:placeholderImage:options:progress:completed:]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个文件中, 你会看到很多的&lt;code&gt;sd_setImageWithURL......&lt;/code&gt;方法, 它们最终都会调用上面这个方法, 只是根据需要传入不同的参数, 这在很多的开源项目中乃至我们平时写的项目中都是很常见的. 而这个方法也是 UIImageView+WebCache 中的核心方法.&lt;/p&gt;
&lt;p&gt;这里就不再复制出这个方法的全部实现了.&lt;/p&gt;
&lt;h1 id=&quot;操作的管理&quot;&gt;&lt;a href=&quot;#操作的管理&quot; class=&quot;headerlink&quot; title=&quot;操作的管理&quot;&gt;&lt;/a&gt;操作的管理&lt;/h1&gt;&lt;p&gt;这是这个方法的第一行代码:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// UIImageView+WebCache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// sd_setImageWithURL:placeholderImage:options:progress:completed: #1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self sd_cancelCurrentImageLoad];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这行看似简单的代码最开始是被我忽略的, 我后来才发现蕴藏在这行代码之后的思想, 也就是 SDWebImage 管理操作的办法.&lt;/p&gt;
&lt;p&gt;框架中的所有操作实际上都是通过一个 operationDictionary 来管理, 而这个字典实际上是动态的添加到 UIView 上的一个属性, 至于为什么添加到 UIView 上, 主要是因为这个 operationDictionary 需要在 UIButton 和 UIImageView 上重用, 所以需要添加到它们的根类上.&lt;/p&gt;
&lt;p&gt;这行代码是要保证没有当前正在进行的异步下载操作, 不会与即将进行的操作发生冲突, 它会调用:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// UIImageView+WebCache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// sd_cancelCurrentImageLoad #1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self sd_cancelImageLoadOperationWithKey:@&amp;quot;UIImageViewImageLoad&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而这个方法会使当前 UIImageView 中的所有操作都被 cancel. 不会影响之后进行的下载操作.&lt;/p&gt;
&lt;h1 id=&quot;占位图的实现&quot;&gt;&lt;a href=&quot;#占位图的实现&quot; class=&quot;headerlink&quot; title=&quot;占位图的实现&quot;&gt;&lt;/a&gt;占位图的实现&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// UIImageView+WebCache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// sd_setImageWithURL:placeholderImage:options:progress:completed: #4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (!(options &amp;amp; SDWebImageDelayPlaceholder)) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.image = placeholder;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果传入的 options 中没有 SDWebImageDelayPlaceholder(默认情况下 options == 0), 那么就会为 UIImageView 添加一个临时的 image, 也就是占位图.&lt;/p&gt;
&lt;h1 id=&quot;获取图片&quot;&gt;&lt;a href=&quot;#获取图片&quot; class=&quot;headerlink&quot; title=&quot;获取图片&quot;&gt;&lt;/a&gt;获取图片&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// UIImageView+WebCache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// sd_setImageWithURL:placeholderImage:options:progress:completed: #8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (url) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;``` &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;接下来会检测传入的 url 是否非空, 如果非空那么一个全局的 SDWebImageManager 就会调用以下的方法获取图片:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;[SDWebImageManager.sharedManager downloadImageWithURL:options:progress:completed:]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;下载完成后会调用 (SDWebImageCompletionWithFinishedBlock)completedBlock 为 UIImageView.image 赋值, 添加上最终所需要的图片.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;// UIImageView+WebCache&lt;br&gt;// sd_setImageWithURL:placeholderImage:options:progress:completed: #10&lt;br&gt;dispatch_main_sync_safe(^{&lt;br&gt;    if (!wself) return;&lt;br&gt;    if (image) {&lt;br&gt;        wself.image = image;&lt;br&gt;        [wself setNeedsLayout];&lt;br&gt;    } else {&lt;br&gt;        if ((options &amp;amp; SDWebImageDelayPlaceholder)) {&lt;br&gt;            wself.image = placeholder;&lt;br&gt;            [wself setNeedsLayout];&lt;br&gt;        }&lt;br&gt;    }&lt;br&gt;    if (completedBlock &amp;amp;&amp;amp; finished) {&lt;br&gt;        completedBlock(image, error, cacheType, url);&lt;br&gt;    }&lt;br&gt;});&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# dispatch_main_sync_safe 宏定义&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;上述代码中的 dispatch_main_sync_safe 是一个宏定义, 点进去一看发现宏是这样定义的&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;#define dispatch_main_sync_safe(block)\&lt;br&gt;    if ([NSThread isMainThread]) {\&lt;br&gt;        block();\&lt;br&gt;    } else {\&lt;br&gt;        dispatch_sync(dispatch_get_main_queue(), block);\&lt;br&gt;    }&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;相信这个宏的名字已经讲他的作用解释的很清楚了: 因为图像的绘制只能在主线程完成, 所以, dispatch_main_sync_safe 就是为了保证 block 能在主线程中执行.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;而最后, 在` [SDWebImageManager.sharedManager downloadImageWithURL:options:progress:completed:] `返回 operation 的同时, 也会向 operationDictionary 中添加一个键值对, 来表示操作的正在进行:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;// UIImageView+WebCache&lt;br&gt;// sd_setImageWithURL:placeholderImage:options:progress:completed: #28&lt;br&gt;[self sd_setImageLoadOperation:operation forKey:@”UIImageViewImageLoad”];&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;它将 opertion 存储到 operationDictionary 中方便以后的 cancel.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;到此为止我们已经对 SDWebImage 框架中的这一方法分析完了, 接下来我们将要分析 SDWebImageManager 中的方法&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;[SDWebImageManager.sharedManager downloadImageWithURL:options:progress:completed:]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# SDWebImageManager&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在 SDWebImageManager.h 中你可以看到关于 SDWebImageManager 的描述:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;The SDWebImageManager is the class behind the UIImageView+WebCache category and likes. It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache). You can use this class directly to benefit from web image downloading with caching in another context than a UIView.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这个类就是隐藏在 UIImageView+WebCache 背后, 用于处理异步下载和图片缓存的类, 当然你也可以直接使用 SDWebImageManager 的上述方法 ` downloadImageWithURL:options:progress:completed: `来直接下载图片.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可以看到, 这个类的主要作用就是为 UIImageView+WebCache 和 SDWebImageDownloader, SDImageCache 之间构建一个桥梁, 使它们能够更好的协同工作, 我们在这里分析这个核心方法的源代码, 它是如何协调异步下载和图片缓存的.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;// SDWebImageManager&lt;br&gt;// downloadImageWithURL:options:progress:completed: #6&lt;br&gt;if ([url isKindOfClass:NSString.class]) {&lt;br&gt;    url = [NSURL URLWithString:(NSString *)url];&lt;br&gt;}&lt;br&gt;if (![url isKindOfClass:NSURL.class]) {&lt;br&gt;    url = nil;&lt;br&gt;}&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这块代码的功能是确定 url 是否被正确传入, 如果传入参数的是 NSString 类型就会被转换为 NSURL. 如果转换失败, 那么 url 会被赋值为空, 这个下载的操作就会出错.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# SDWebImageCombinedOperation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当 url 被正确传入之后, 会实例一个非常奇怪的 &amp;quot;operation&amp;quot;, 它其实是一个遵循 SDWebImageOperation 协议的 NSObject 的子类. 而这个协议也非常的简单:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;@protocol SDWebImageOperation &lt;NSObject&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(void)cancel;&lt;br&gt;@end&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这里仅仅是将这个 SDWebImageOperation 类包装成一个看着像 NSOperation 其实并不是 NSOperation 的类, 而这个类唯一与 NSOperation 的相同之处就是它们都可以响应 cancel 方法. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;而调用这个类的存在实际是为了使代码更加的简洁, 因为调用这个类的 cancel 方法, 会使得它持有的两个 operation 都被 cancel.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;// SDWebImageCombinedOperation&lt;br&gt;// cancel #1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(void)cancel {&lt;br&gt;  self.cancelled = YES;&lt;br&gt;  if (self.cacheOperation) {&lt;pre&gt;&lt;code&gt;[self.cacheOperation cancel];
self.cacheOperation = nil;
&lt;/code&gt;&lt;/pre&gt;  }&lt;br&gt;  if (self.cancelBlock) {&lt;pre&gt;&lt;code&gt;self.cancelBlock();
_cancelBlock = nil;
&lt;/code&gt;&lt;/pre&gt;  }&lt;br&gt;}&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;而这个类, 应该是为了实现更简洁的 cancel 操作而设计出来的. 既然我们获取了 url, 再通过 url 获取对应的 key&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NSString *key = [self cacheKeyForURL:url];&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;下一步是使用 key 在缓存中查找以前是否下载过相同的图片.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;operation.cacheOperation = [self.imageCache&lt;br&gt;queryDiskCacheForKey:key&lt;br&gt;done:^(UIImage *image, SDImageCacheType cacheType) { … }];&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这里调用 SDImageCache 的实例方法 queryDiskCacheForKey:done: 来尝试在缓存中获取图片的数据. 而这个方法返回的就是货真价实的 NSOperation.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果我们在缓存中查找到了对应的图片, 那么我们直接调用 completedBlock 回调块结束这一次的图片下载操作.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;// SDWebImageManager&lt;br&gt;// downloadImageWithURL:options:progress:completed: #47&lt;br&gt;dispatch_main_sync_safe(^{&lt;br&gt;    completedBlock(image, nil, cacheType, YES, url);&lt;br&gt;});&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果我们没有找到图片, 那么就会调用 SDWebImageDownloader 的实例方法:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;id &lt;SDWebImageOperation&gt; subOperation =&lt;br&gt; [self.imageDownloader&lt;br&gt;    downloadImageWithURL:url&lt;br&gt;    options:downloaderOptions&lt;br&gt;    progress:progressBlock&lt;br&gt;    completed:^(UIImage &lt;em&gt;downloadedImage, NSData &lt;/em&gt;data, NSError *error, BOOL finished) { … }];&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果这个方法返回了正确的 downloadedImage, 那么我们就会在全局的缓存中存储这个图片的数据:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;[self.imageCache&lt;br&gt;    storeImage:downloadedImage&lt;br&gt;    recalculateFromImage:NO&lt;br&gt;    imageData:data&lt;br&gt;    forKey:key&lt;br&gt;    toDisk:cacheOnDisk];&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;并调用 completedBlock 对 UIImageView 或者 UIButton 添加图片, 或者进行其它的操作.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;最后, 我们将这个 subOperation 的 cancel 操作添加到 operation.cancelBlock 中. 方便操作的取消.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;operation.cancelBlock = ^{&lt;br&gt;    [subOperation cancel];&lt;br&gt;    }&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# SDWebImageCache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SDWebImageCache.h 这个类在源代码中有这样的注释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;SDImageCache maintains a memory cache and an optional disk cache.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;它维护了一个内存缓存和一个可选的磁盘缓存, 我们先来看一下在上一阶段中没有解读的两个方法, 首先是:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(NSOperation &lt;em&gt;)queryDiskCacheForKey:(NSString &lt;/em&gt;)key&lt;br&gt;  done:(SDWebImageQueryCompletedBlock)doneBlock;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这个方法的主要功能是异步的查询图片缓存. 因为图片的缓存可能在两个地方, 而该方法首先会在内存中查找是否有图片的缓存.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;// SDWebImageCache&lt;br&gt;// queryDiskCacheForKey:done: #9&lt;br&gt;UIImage *image = [self imageFromMemoryCacheForKey:key];&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这个 imageFromMemoryCacheForKey 方法会在 SDWebImageCache 维护的缓存 memCache 中查找是否有对应的数据, 而 memCache 就是一个 NSCache.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果在内存中并没有找到图片的缓存的话, 就需要在磁盘中寻找了, 这个就比较麻烦了..&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在这里会调用一个方法 diskImageForKey 这个方法的具体实现我在这里就不介绍了, 涉及到很多底层 Core Foundation 框架的知识, 不过这里文件名字的存储使用 MD5 处理过后的文件名.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;// SDImageCache&lt;br&gt;// cachedFileNameForKey: #6&lt;br&gt;CC_MD5(str, (CC_LONG)strlen(str), r);&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对于其它的实现细节也就不多说了...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果在磁盘中查找到对应的图片, 我们会将它复制到内存中, 以便下次的使用.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;// SDImageCache&lt;br&gt;// queryDiskCacheForKey:done: #24&lt;br&gt;UIImage &lt;em&gt;diskImage = [self diskImageForKey:key];&lt;br&gt;if (diskImage) {&lt;br&gt;    CGFloat cost = diskImage.size.height &lt;/em&gt; diskImage.size.width * diskImage.scale;&lt;br&gt;    [self.memCache setObject:diskImage forKey:key cost:cost];&lt;br&gt;}&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这些就是 SDImageCache 的核心内容了, 而接下来将介绍如果缓存没有命中, 图片是如何被下载的.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# SDWebImageDownloader&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;按照之前的惯例, 我们先来看一下 SDWebImageDownloader.h 中对这个类的描述.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;Asynchronous downloader dedicated and optimized for image loading.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;专用的并且优化的图片异步下载器.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这个类的核心功能就是下载图片, 而核心方法就是上面提到的:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;(id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url&lt;br&gt;  options:(SDWebImageDownloaderOptions)options&lt;br&gt;  progress:(SDWebImageDownloaderProgressBlock)progressBlock&lt;br&gt;  completed:(SDWebImageDownloaderCompletedBlock)completedBlock;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;回调&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这个方法直接调用了另一个关键的方法:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;(void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock&lt;br&gt;  andCompletedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock&lt;br&gt;  forURL:(NSURL *)url&lt;br&gt;  createCallback:(SDWebImageNoParamsBlock)createCallback&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;它为这个下载的操作添加回调的块, 在下载进行时, 或者在下载结束时执行一些操作, 先来阅读一下这个方法的源代码:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;// SDWebImageDownloader&lt;br&gt;// addProgressCallback:andCompletedBlock:forURL:createCallback: #10&lt;br&gt;BOOL first = NO;&lt;br&gt;if (!self.URLCallbacks[url]) {&lt;br&gt;    self.URLCallbacks[url] = [NSMutableArray new];&lt;br&gt;    first = YES;&lt;br&gt;}&lt;br&gt;// Handle single download of simultaneous download request for the same URL&lt;br&gt;NSMutableArray &lt;em&gt;callbacksForURL = self.URLCallbacks[url];&lt;br&gt;NSMutableDictionary &lt;/em&gt;callbacks = [NSMutableDictionary new];&lt;br&gt;if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];&lt;br&gt;if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];&lt;br&gt;[callbacksForURL addObject:callbacks];&lt;br&gt;self.URLCallbacks[url] = callbacksForURL;&lt;br&gt;if (first) {&lt;br&gt;    createCallback();&lt;br&gt;}&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;方法会先查看这个 url 是否有对应的 callback, 使用的是 downloader 持有的一个字典 URLCallbacks.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果是第一次添加回调的话, 就会执行 first = YES, 这个赋值非常的关键, 因为 first 不为 YES 那么 HTTP 请求就不会被初始化, 图片也无法被获取.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;然后, 在这个方法中会重新修正在 URLCallbacks 中存储的回调块.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;NSMutableArray &lt;em&gt;callbacksForURL = self.URLCallbacks[url];&lt;br&gt;NSMutableDictionary &lt;/em&gt;callbacks = [NSMutableDictionary new];&lt;br&gt;if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];&lt;br&gt;if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];&lt;br&gt;[callbacksForURL addObject:callbacks];&lt;br&gt;self.URLCallbacks[url] = callbacksForURL;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果是第一次添加回调块, 那么就会直接运行这个 createCallback 这个 block, 而这个 block, 就是我们在前一个方法 downloadImageWithURL:options:progress:completed: 中传入的回调块.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;// SDWebImageDownloader&lt;br&gt;// downloadImageWithURL:options:progress:completed: #4&lt;br&gt;[self addProgressCallback:progressBlock andCompletedBlock:completedBlock forURL:url createCallback:^{ … }];&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;我们下面来分析这个传入的无参数的代码. 首先这段代码初始化了一个 NSMutableURLRequest:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;// SDWebImageDownloader&lt;br&gt;// downloadImageWithURL:options:progress:completed: #11&lt;br&gt;NSMutableURLRequest *request = [[NSMutableURLRequest alloc]&lt;br&gt;    initWithURL:url&lt;br&gt;    cachePolicy:…&lt;br&gt;    timeoutInterval:timeoutInterval];&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这个 request 就用于在之后发送 HTTP 请求.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在初始化了这个 request 之后, 又初始化了一个 SDWebImageDownloaderOperation 的实例, 这个实例, 就是用于请求网络资源的操作. 它是一个 NSOperation 的子类,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;// SDWebImageDownloader&lt;br&gt;// downloadImageWithURL:options:progress:completed: #20&lt;br&gt;operation = [[SDWebImageDownloaderOperation alloc]&lt;br&gt;    initWithRequest:request&lt;br&gt;    options:options&lt;br&gt;    progress:…&lt;br&gt;    completed:…&lt;br&gt;    cancelled:…}];&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;但是在初始化之后, 这个操作并不会开始(NSOperation 实例只有在调用 start 方法或者加入 NSOperationQueue 才会执行), 我们需要将这个操作加入到一个 NSOperationQueue 中.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;// SDWebImageDownloader&lt;br&gt;// downloadImageWithURL:options:progress:completed: #59&lt;br&gt;[wself.downloadQueue addOperation:operation];&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;只有将它加入到这个下载队列中, 这个操作才会执行.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# SDWebImageDownloaderOperation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这个类就是处理 HTTP 请求, URL 连接的类, 当这个类的实例被加入队列之后, start 方法就会被调用, 而 start 方法首先就会产生一个 NSURLConnection.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;// SDWebImageDownloaderOperation&lt;br&gt;// start #1&lt;br&gt;@synchronized (self) {&lt;br&gt;    if (self.isCancelled) {&lt;br&gt;        self.finished = YES;&lt;br&gt;        [self reset];&lt;br&gt;        return;&lt;br&gt;    }&lt;br&gt;    self.executing = YES;&lt;br&gt;    self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];&lt;br&gt;    self.thread = [NSThread currentThread];&lt;br&gt;}&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;而接下来这个 connection 就会开始运行:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;// SDWebImageDownloaderOperation&lt;br&gt;// start #29&lt;br&gt;[self.connection start];&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;它会发出一个 SDWebImageDownloadStartNotification 通知&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;// SDWebImageDownloaderOperation&lt;br&gt;// start #35&lt;br&gt;[[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self];&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 代理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在 start 方法调用之后, 就是 NSURLConnectionDataDelegate 中代理方法的调用.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(void)connection:(NSURLConnection &lt;em&gt;)connection didReceiveResponse:(NSURLResponse &lt;/em&gt;)response;&lt;/li&gt;
&lt;li&gt;(void)connection:(NSURLConnection &lt;em&gt;)connection didReceiveResponse:(NSURLResponse &lt;/em&gt;)response;&lt;/li&gt;
&lt;li&gt;(void)connectionDidFinishLoading:(NSURLConnection *)aConnection;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在这三个代理方法中的前两个会不停回调 progressBlock 来提示下载的进度.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;而最后一个代理方法会在图片下载完成之后调用 completionBlock 来完成最后 UIImageView.image 的更新.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;而这里调用的 progressBlock completionBlock cancelBlock 都是在之前存储在 URLCallbacks 字典中的.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;到目前为止, 我们就基本解析了 SDWebImage 中&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;[self.imageView&lt;br&gt;    sd_setImageWithURL:[NSURL URLWithString:@”url”]&lt;br&gt;    placeholderImage:[UIImage imageNamed:@”placeholder.png”]];&lt;br&gt;```&lt;/p&gt;
&lt;p&gt;这个方法执行的全部过程了.&lt;/p&gt;
&lt;h1 id=&quot;流程图&quot;&gt;&lt;a href=&quot;#流程图&quot; class=&quot;headerlink&quot; title=&quot;流程图&quot;&gt;&lt;/a&gt;流程图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/sdwebimage-flow-chart.png?imageView/2/w/400&quot; alt=&quot;流程图&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们使用一个流程图来表示上述方法所执行的全过程.&lt;br&gt;这段流程图展示了上述方法调用中大部分重要方法的调用.&lt;/p&gt;
&lt;p&gt;SDWebImage 如何为 UIImageView 添加图片(面试回答)&lt;/p&gt;
&lt;p&gt;SDWebImage 中为 UIView 提供了一个分类叫做 WebCache, 这个分类中有一个最常用的接口, sd_setImageWithURL:placeholderImage:, 这个分类同时提供了很多类似的方法, 这些方法最终会调用一个同时具有 option progressBlock completionBlock 的方法, 而在这个类最终被调用的方法首先会检查是否传入了 placeholderImage 以及对应的参数, 并设置 placeholderImage.&lt;/p&gt;
&lt;p&gt;然后会获取 SDWebImageManager 中的单例调用一个 downloadImageWithURL:… 的方法来获取图片, 而这个 manager 获取图片的过程有大体上分为两部分, 它首先会在 SDWebImageCache 中寻找图片是否有对应的缓存, 它会以 url 作为数据的索引先在内存中寻找是否有对应的缓存, 如果缓存未命中就会在磁盘中利用 MD5 处理过的 key 来继续查询对应的数据, 如果找到了, 就会把磁盘中的缓存备份到内存中.&lt;/p&gt;
&lt;p&gt;然而, 假设我们在内存和磁盘缓存中都没有命中, 那么 manager 就会调用它持有的一个 SDWebImageDownloader 对象的方法 downloadImageWithURL:… 来下载图片, 这个方法会在执行的过程中调用另一个方法 addProgressCallback:andCompletedBlock:fotURL:createCallback: 来存储下载过程中和下载完成的回调, 当回调块是第一次添加的时候, 方法会实例化一个 NSMutableURLRequest 和 SDWebImageDownloaderOperation, 并将后者加入 downloader 持有的下载队列开始图片的异步下载.&lt;/p&gt;
&lt;p&gt;而在图片下载完成之后, 就会在主线程设置 image 属性, 完成整个图像的异步下载和配置.&lt;/p&gt;
&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;SDWebImage 的图片加载过程其实很符合我们的直觉:&lt;/p&gt;
&lt;p&gt;查看缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存命中&lt;ul&gt;
&lt;li&gt;返回图片&lt;/li&gt;
&lt;li&gt;更新 UIImageView&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缓存未命中&lt;ul&gt;
&lt;li&gt;异步下载图片&lt;/li&gt;
&lt;li&gt;加入缓存&lt;/li&gt;
&lt;li&gt;更新 UIImageView&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只要有足够的耐心, 阅读这个开源项目的源代码也是没有太多困难的.&lt;/p&gt;
&lt;p&gt;SDWebImage 的探索到目前为止差不多结束了, 对于这个框架的学习以及解析确实使我受益匪浅, 我也将在之后继续阅读其它的著名框架的源代码. 在这篇博客之中难免会有错误, 希望各位能够指正~&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://dravenes.me/ios-yuan-dai-ma-jie-xi-sdwebimage&quot;&gt;http://dravenes.me/ios-yuan-dai-ma-jie-xi-sdwebimage&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：世人都说阅读源代码对于功力的提升是十分显著的, 但是很多的著名开源框架源代码动辄上万行, 复杂度实在太高, 曾经试图读一些开源框架的源代码, 比如说 AFNetworking, SDWebImage, ReactiveCocoa 但是由于当时比较浮躁, 实在没法静下心来看, 而且有一些急功近利, 所以面对宝藏实在无力挖掘. 而最近, 由于时间比较充裕, 也终于能静下心来一段一段分析这些著名项目的源代码. 本文主要分享SDWebImage框架源代码的相关信息. &lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="开源框架" scheme="http://charsdavy.github.io/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊 iOS 中的网络加密</title>
    <link href="http://charsdavy.github.io/2016/06/15/ios-network-encrypt/"/>
    <id>http://charsdavy.github.io/2016/06/15/ios-network-encrypt/</id>
    <published>2016-06-14T23:55:50.000Z</published>
    <updated>2016-06-14T23:57:32.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：公司的接口一般会两种协议的，一种HTTP，一种HTTPS的，HTTP 只要请求，服务器就会响应，如果我们不对请求和响应做出加密处理，所有信息都是会被检测劫持到的，是很不安全的，客户端加密可以使用本文这套工具类进行处理。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;导言&quot;&gt;&lt;a href=&quot;#导言&quot; class=&quot;headerlink&quot; title=&quot;导言&quot;&gt;&lt;/a&gt;导言&lt;/h1&gt;&lt;p&gt;公司的接口一般会两种协议的，一种HTTP，一种HTTPS的，HTTP 只要请求，服务器就会响应，如果我们不对请求和响应做出加密处理，所有信息都是会被检测劫持到的，是很不安全的，客户端加密可以使用本文这套工具类进行处理。&lt;/p&gt;
&lt;p&gt;但是不论在任何时候，都应该将服务置于HTTPS上，因为它可以避免中间人攻击的问题，还自带了基于非对称密钥的加密通道。&lt;/p&gt;
&lt;h1 id=&quot;HTTPS交互原理&quot;&gt;&lt;a href=&quot;#HTTPS交互原理&quot; class=&quot;headerlink&quot; title=&quot;HTTPS交互原理&quot;&gt;&lt;/a&gt;HTTPS交互原理&lt;/h1&gt;&lt;p&gt;简答说，HTTPS 就是 HTTP协议加了一层SSL协议的加密处理，SSL 证书就是遵守 SSL协议，由受信任的数字证书颁发机构CA（如GlobalSign，wosign），在验证服务器身份后颁发，这是需要花钱滴，签发后的证书作为公钥一般放在服务器的根目录下，便于客户端请求返回给客户端，私钥在服务器的内部中心保存，用于解密公钥。&lt;/p&gt;
&lt;p&gt;HTTPS 客户端与服务器交互过程：&lt;/p&gt;
&lt;p&gt;1）客户端发送请求，服务器返回公钥给客户端；&lt;/p&gt;
&lt;p&gt;2）客户端生成对称加密秘钥，用公钥对其进行加密后，返回给服务器；&lt;/p&gt;
&lt;p&gt;3）服务器收到后，利用私钥解开得到对称加密秘钥，保存；&lt;/p&gt;
&lt;p&gt;4）之后的交互都使用对称加密后的数据进行交互。&lt;/p&gt;
&lt;h2 id=&quot;证书&quot;&gt;&lt;a href=&quot;#证书&quot; class=&quot;headerlink&quot; title=&quot;证书&quot;&gt;&lt;/a&gt;证书&lt;/h2&gt;&lt;p&gt;简单说，证书有两种，一种是正经的：&lt;/p&gt;
&lt;p&gt;CA颁发的证书&lt;/p&gt;
&lt;p&gt;一种是不正经的：&lt;/p&gt;
&lt;p&gt;自己生成签发的证书&lt;/p&gt;
&lt;h1 id=&quot;我们需要做什么&quot;&gt;&lt;a href=&quot;#我们需要做什么&quot; class=&quot;headerlink&quot; title=&quot;我们需要做什么&quot;&gt;&lt;/a&gt;我们需要做什么&lt;/h1&gt;&lt;p&gt;如果遇到正经的证书，我们直接用AFNetworking 直接请求就好了，AFNetworking 内部帮我们封装了HTTPS的请求方式，但是大部分公司接口都是不正经的证书，这时需要我们做以下几步：&lt;/p&gt;
&lt;p&gt;1）将服务器的公钥证书拖到Xcode中&lt;/p&gt;
&lt;p&gt;2）修改验证模式&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;manager.securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModePublicKey];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;简单来说，就是你本可以修改AFN这个设置来允许客户端接收服务器的任何证书，但是这么做有个问题，就是你无法验证证书是否是你的服务器后端的证书，给中间人攻击，即通过重定向路由来分析伪造你的服务器端打开了大门。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AFSecurityPolicy *securityPolicy = [AFSecurityPolicy defaultPolicy];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;securityPolicy.allowInvalidCertificates = YES;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;解决方法&quot;&gt;&lt;a href=&quot;#解决方法&quot; class=&quot;headerlink&quot; title=&quot;解决方法&quot;&gt;&lt;/a&gt;解决方法&lt;/h2&gt;&lt;p&gt;AFNetworking是允许内嵌证书的，通过内嵌证书，AFNetworking就通过比对服务器端证书、内嵌的证书、站点域名是否一致来验证连接的服务器是否正确。由于CA证书验证是通过站点域名进行验证的，如果你的服务器后端有绑定的域名，这是最方便的。将你的服务器端证书，如果是pem格式的，用下面的命令转成cer格式&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;openssl x509 -in &amp;lt;你的服务器证书&amp;gt;.pem -outform der -out server.cer&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后将生成的server.cer文件，如果有自建ca，再加上ca的cer格式证书，引入到app的bundle里，AFNetworking在&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AFSecurityPolicy *securityPolicy = [AFSecurityPolicy AFSSLPinningModeCertificate];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AFSecurityPolicy *securityPolicy = [AFSecurityPolicy AFSSLPinningModePublicKey];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;情况下，会自动扫描bundle中.cer的文件，并引入，这样就可以通过自签证书来验证服务器唯一性了。&lt;/p&gt;
&lt;h1 id=&quot;AFSecurityPolicy三种验证模式&quot;&gt;&lt;a href=&quot;#AFSecurityPolicy三种验证模式&quot; class=&quot;headerlink&quot; title=&quot;AFSecurityPolicy三种验证模式&quot;&gt;&lt;/a&gt;AFSecurityPolicy三种验证模式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;AFSSLPinningModeNone&lt;br&gt;这个模式表示不做SSL pinning，&lt;br&gt;只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书就不会通过。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AFSSLPinningModeCertificate&lt;br&gt;这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AFSSLPinningModePublicKey&lt;br&gt;这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，&lt;br&gt;只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/75d96b72bfb1&quot;&gt;http://www.jianshu.com/p/75d96b72bfb1&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：公司的接口一般会两种协议的，一种HTTP，一种HTTPS的，HTTP 只要请求，服务器就会响应，如果我们不对请求和响应做出加密处理，所有信息都是会被检测劫持到的，是很不安全的，客户端加密可以使用本文这套工具类进行处理。&lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="iOS" scheme="http://charsdavy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>State 模式</title>
    <link href="http://charsdavy.github.io/2016/06/10/state-pattern/"/>
    <id>http://charsdavy.github.io/2016/06/10/state-pattern/</id>
    <published>2016-06-10T07:51:37.000Z</published>
    <updated>2016-06-13T01:06:20.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：State模式在实际使用中比较多,适合”状态的切换”.因为我们经常会使用if else if else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式了.不只是根据状态,也有根据属性.如果某个对象的属性不同,对象的行为就不一样,这点在数据库系统中出现频率比较高,我们经常会在一个数据表的尾部,加上property属性含义的字段,用以标识记录中一些特殊性质的记录,这种属性的改变(切换)又是随时可能发生的,就有可能要使用State.文章主要分享State模式相关内容.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-charsdavy-github-io-2016-06-10-state-pattern-1.png?imageView/2/w/460&quot; alt=&quot;State模式图&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;不同的状态,不同的行为;或者说,每个状态有着相应的行为.&lt;/p&gt;
&lt;h1 id=&quot;何时使用&quot;&gt;&lt;a href=&quot;#何时使用&quot; class=&quot;headerlink&quot; title=&quot;何时使用&quot;&gt;&lt;/a&gt;何时使用&lt;/h1&gt;&lt;p&gt;State模式在实际使用中比较多,适合”状态的切换”.因为我们经常会使用 if else if else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式了.&lt;/p&gt;
&lt;p&gt;不只是根据状态,也有根据属性.如果某个对象的属性不同,对象的行为就不一样,这点在数据库系统中出现频率比较高,我们经常会在一个数据表的尾部,加上property属性含义的字段,用以标识记录中一些特殊性质的记录,这种属性的改变(切换)又是随时可能发生的,就有可能要使用State.&lt;/p&gt;
&lt;p&gt;参考网址：&lt;br&gt;&lt;a href=&quot;http://www.jdon.com/designpatterns/designpattern_State.htm&quot;&gt;http://www.jdon.com/designpatterns/designpattern_State.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;举例来说：一个人具有生气，高兴和抓狂等状态，在这些状态下做同一个事情可能会有不同的结果，一个人的心情可能在这三种状态中循环转变。使用一个moodState类表示一个人的心情，使用mad,Happy,Angry类代表不同的心情。使用UML图表示如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-charsdavy-github-io-2016-06-10-state-pattern-2.png?imageView/2/w/460&quot; alt=&quot;State模式UML图&quot;&gt;&lt;/p&gt;
&lt;p&gt;适用性：在下面的两情况下均可以使用State模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个对象的行为取决于它的状态，并且必须在运行时刻根据状态改变它的行为。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个操作中含有庞大的多分支的条件豫剧，并且这些分支依赖于该对象的状态，这个状态通常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构，State模式将每一个条件分支放入一个单独的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参与者：    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Context(环境，Person)定义客户感兴趣的类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;State(Moodstate)：定义一个接口以封装与Context的一个特定状态相关的行为&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ConcreteState Subclasses(具体状态子类，如Angry)每一个子类实现一个与Context的状态相关的行为。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他们的协作关系是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Context将于状态相关的请求委托给当前的ConcreteState对象处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Context可将自身作为一个参数传递给处理该请求的状态对象，这使得状态对象在必要的时候可访问Context。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Context是客户使用的主要接口，客户可用状态对象来配置一个Context，一旦一个Context配置完毕，他的客户不再需要直接与状态对象打交道。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Context或者ConcreteState子类都可以决定哪个状态是另外那个状态的后继者，以及是在何种条件下进行状态转换。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;相应的代码：&quot;&gt;&lt;a href=&quot;#相应的代码：&quot; class=&quot;headerlink&quot; title=&quot;相应的代码：&quot;&gt;&lt;/a&gt;相应的代码：&lt;/h1&gt;&lt;p&gt;MoodState代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public interface MoodState&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void doSomething();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void changeState();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Angry代码:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;implements MoodState&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Person p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public Angry(Person p)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.p = p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void doSomething()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.out.println(&amp;quot;I&amp;apos;m angry!&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void changeState()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		p.setState(new Happy(p));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Happy代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Happy implements MoodState&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Person p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public Happy(Person p)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.p = p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void doSomething()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.out.println(&amp;quot;I&amp;apos;m happy!&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void changeState()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		p.setState(new Mad(p));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Mad代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Mad implements MoodState&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Person p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public Mad(Person p)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.p=p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void doSomething()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.out.println(&amp;quot;I&amp;apos;m Mad&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void changeState()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		p.setState( new Angry(p));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Person代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Person&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private MoodState state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public Person()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		state = new Mad(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void setState(MoodState state)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.state = state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void doSomething()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		state.doSomething();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		state.changeState();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Client代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Client&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public static void main(String[] args)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Person p = new Person();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		for(int i=0;i&amp;lt;10;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			p.doSomething();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;状态模式将与特定状态相关的行为局部化，并且将不同状态的行为分割开来，使得状态转换显式化并且可以被共享。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：State模式在实际使用中比较多,适合”状态的切换”.因为我们经常会使用if else if else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式了.不只是根据状态,也有根据属性.如果某个对象的属性不同,对象的行为就不一样,这点在数据库系统中出现频率比较高,我们经常会在一个数据表的尾部,加上property属性含义的字段,用以标识记录中一些特殊性质的记录,这种属性的改变(切换)又是随时可能发生的,就有可能要使用State.文章主要分享State模式相关内容.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-charsdavy-github-io-2016-06-10-state-pattern-1.png?imageView/2/w/460&quot; alt=&quot;State模式图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="进阶" scheme="http://charsdavy.github.io/categories/advance/"/>
    
    
      <category term="设计模式" scheme="http://charsdavy.github.io/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 运行时编程</title>
    <link href="http://charsdavy.github.io/2016/06/09/objc-run-time/"/>
    <id>http://charsdavy.github.io/2016/06/09/objc-run-time/</id>
    <published>2016-06-09T02:21:31.000Z</published>
    <updated>2016-06-09T02:54:52.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：Objective-C语言将决定尽可能的从编译和链接时推迟到运行时。只要有可能，Objective-C总是使用动态的方式来解决问题。这意味着Objective-C语言不仅需要一个编译器，同时也需要一个运行时系统来执行编译好的代码。这里的运行时系统扮演的角色类似于Objective-C语言的操作系统，Objective-C基于该系统来工作。本文章将具体介绍NSObject类以及Objective-C程序是如何与运行时系统交互的。特别地，本文章还给出来怎样在运行时动态地加载新类和将消息转发给其它对象的范例，同时也给出了怎样在程序运行时获取对象信息的方法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;p&gt;Objective-C语言将决定尽可能的从编译和链接时推迟到运行时。只要有可能，Objective-C总是使用动态的方式来解决问题。这意味着Objective-C语言不仅需要一个编译器，同时也需要一个运行时系统来执行编译好的代码。这里的运行时系统扮演的角色类似于 Objective-C语言的操作系统，Objective-C基于该系统来工作。 &lt;/p&gt;
&lt;p&gt;本文章将具体介绍NSObject类以及Objective-C程序是如何与运行时系统交互的。特别地，本文章还给出来怎样在运行时动态地加载新类和将消息转发给其它对象的范例，同时也给出了怎样在程序运行时获取对象信息的方法。 &lt;/p&gt;
&lt;p&gt;通常，如果仅仅写一个Cocoa 程序，程序员不需要知道和理解Objective-C运行时系统的底层细节，但这篇文章仍然值得推荐阅读，以了解 Objective-C运行时系统的原理，并能更好的利用 Objective-C的优点。&lt;/p&gt;
&lt;h1 id=&quot;2-参考&quot;&gt;&lt;a href=&quot;#2-参考&quot; class=&quot;headerlink&quot; title=&quot;2 参考&quot;&gt;&lt;/a&gt;2 参考&lt;/h1&gt;&lt;p&gt;《Objective-C 2.0 运行时系统参考库》描述了Objective-C运行库的数据结构和函数接口。程序可以通过这些接口来和Objective-C运行时系统交互。例如，您可以增加一个类或者方法，或者获得所有类的定义列表等。&lt;/p&gt;
&lt;p&gt;《Objective-C 2.0 程序设计语言》介绍了Objective-C语言本身。&lt;/p&gt;
&lt;p&gt;《Objective-C 版本说明》给出了在最近版本的Mac OS X系统中关于Objective-C运行时系统的一些改动。&lt;/p&gt;
&lt;h1 id=&quot;3-运行时系统的版本和平台&quot;&gt;&lt;a href=&quot;#3-运行时系统的版本和平台&quot; class=&quot;headerlink&quot; title=&quot;3 运行时系统的版本和平台&quot;&gt;&lt;/a&gt;3 运行时系统的版本和平台&lt;/h1&gt;&lt;p&gt;在不同的平台上Objective-C运行时系统的版本也不相同。&lt;/p&gt;
&lt;h2 id=&quot;3-1-早期版本和现行版本&quot;&gt;&lt;a href=&quot;#3-1-早期版本和现行版本&quot; class=&quot;headerlink&quot; title=&quot;3.1 早期版本和现行版本&quot;&gt;&lt;/a&gt;3.1 早期版本和现行版本&lt;/h2&gt;&lt;p&gt;Objective-C运行时系统有两个已知版本：早期版本和现行版本。&lt;/p&gt;
&lt;p&gt;现行版本主要是Objective-C 2.0 及与其相关的新特性。早期版本的编程接口见《Objective-C 1运行时系统参考库》；现行版本的编程接口见《Objective-C 2.0  运行时系统参考库》。&lt;/p&gt;
&lt;p&gt;在现行版本中，最显著的新特性就是实例变量是“健壮（non-fragile ）的”：&lt;/p&gt;
&lt;p&gt;1）在早期版本中，如果您改变类中实例变量的布局，您必须重新编译该类的所有子类。&lt;/p&gt;
&lt;p&gt;2）在现行版本中，如果您改变类中实例变量的布局，您无需重新编译该类的任何子类。&lt;/p&gt;
&lt;p&gt;此外，现行版本支持声明property 的synthesis属性（参考《Objective-C 2.0 程序设计语言》的“属性”一节）。&lt;/p&gt;
&lt;h2 id=&quot;3-2-平台&quot;&gt;&lt;a href=&quot;#3-2-平台&quot; class=&quot;headerlink&quot; title=&quot;3.2 平台&quot;&gt;&lt;/a&gt;3.2 平台&lt;/h2&gt;&lt;p&gt;iPhone 程序和Mac OS X 10.5及以后的系统中的64位程序使用的都是Objective-C运行时系统的现行版本。&lt;/p&gt;
&lt;p&gt;其它情况（Mac OS X系统中的32位程序）使用的是早期版本。&lt;/p&gt;
&lt;h1 id=&quot;4-和运行时系统的交互&quot;&gt;&lt;a href=&quot;#4-和运行时系统的交互&quot; class=&quot;headerlink&quot; title=&quot;4 和运行时系统的交互&quot;&gt;&lt;/a&gt;4 和运行时系统的交互&lt;/h1&gt;&lt;p&gt;Objective-C程序有三种途径和运行时系统交互：&lt;/p&gt;
&lt;p&gt;1）通过 Objective-C源代码；&lt;/p&gt;
&lt;p&gt;2）通过 Foundation框架中类NSObject的方法；&lt;/p&gt;
&lt;p&gt;3）通过直接调用运行时系统的函数。&lt;/p&gt;
&lt;h2 id=&quot;4-1-通过Objective-C源代码&quot;&gt;&lt;a href=&quot;#4-1-通过Objective-C源代码&quot; class=&quot;headerlink&quot; title=&quot;4.1 通过Objective-C源代码&quot;&gt;&lt;/a&gt;4.1 通过Objective-C源代码&lt;/h2&gt;&lt;p&gt;大部分情况下，运行时系统在后台自动运行，您只需编写和编译Objective-C源代码。 &lt;/p&gt;
&lt;p&gt;当您编译Objective-C类和方法时，编译器为实现语言动态特性将自动创建一些数据结构和函数。&lt;/p&gt;
&lt;p&gt;这些数据结构包含类定义和协议类定义中的信息，如在《Objective-C 2.0 程序设计语言》中“定义类”和“协议类”一节所讨论的类的对象和协议类的对象，方法选标，实例变量模板，以及其它来自于源代码的信息。运行时系统的主要功能就是根据源代码中的表达式发送消息，如“消息”一节所述。&lt;/p&gt;
&lt;h2 id=&quot;4-2-通过类NSObject的方法&quot;&gt;&lt;a href=&quot;#4-2-通过类NSObject的方法&quot; class=&quot;headerlink&quot; title=&quot;4.2 通过类NSObject的方法&quot;&gt;&lt;/a&gt;4.2 通过类NSObject的方法&lt;/h2&gt;&lt;p&gt;Cocoa 程序中绝大部分类都是NSObject类的子类，所以大部分都继承了NSObject类的方法，因而继承了NSObject的行为。（NSProxy类是个例外；更多细节参考“消息转发”一节。）然而，某些情况下，NSObject类仅仅定义了完成某件事情的模板，而没有提供所有需要的代码。&lt;/p&gt;
&lt;p&gt;例如，NSObject类定义了description 方法，返回该类内容的字符串表示。这主要是用来调试程序——GDB中的print-object方法就是直接打印出该方法返回的字符串。NSObject类中该方法的实现并不知道子类中的内容，所以它只是返回类的名字和对象的地址。NSObject的子类可以重新实现该方法以提供更多的信息。例如，NSArray 类改写了该方法来返回NSArray 类包含的每个对象的内容。&lt;/p&gt;
&lt;p&gt;某些NSObject的方法只是简单地从运行时系统中获得信息，从而允许对象进行一定程度的自我检查。例如，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class 返回对象的类；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;isKindOfClass:和isMemberOfClass:检查对象是否在指定的类继承体系中；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;respondsToSelector:检查对象能否响应指定的消息；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conformsToProtocol:检查对象是否实现了指定协议类的方法；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;methodForSelector:返回指定方法实现的地址。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;4-3-通过运行时系统的函数&quot;&gt;&lt;a href=&quot;#4-3-通过运行时系统的函数&quot; class=&quot;headerlink&quot; title=&quot;4.3 通过运行时系统的函数&quot;&gt;&lt;/a&gt;4.3 通过运行时系统的函数&lt;/h2&gt;&lt;p&gt;运行时系统是一个有公开接口的动态库，由一些数据结构和函数的集合组成，这些数据结构和函数的声明头文件在/usr/include/objc 中。这些函数支持用纯 C 的函数来实现Objective-C同样的功能。还有一些函数构成了NSObject类方法的基础。这些函数使得访问运行时系统接口和提供开发工具成为可能。尽管大部分情况下它们在 Objective-C程序不是必须的，但是有时候对于 Objecitve-C程序来说某些函数是非常有用的。&lt;/p&gt;
&lt;p&gt;这些函数的文档参见《Objective-C 2.0 运行时系统参考库》。&lt;/p&gt;
&lt;h1 id=&quot;5-消息&quot;&gt;&lt;a href=&quot;#5-消息&quot; class=&quot;headerlink&quot; title=&quot;5 消息&quot;&gt;&lt;/a&gt;5 消息&lt;/h1&gt;&lt;p&gt;本章节描述了代码的消息表达式如何转换为对objc_msgSend函数的调用，如何通过名字来指定一个方法，以及如何使用objc_msgSend函数。&lt;/p&gt;
&lt;h2 id=&quot;5-1-获得方法地址&quot;&gt;&lt;a href=&quot;#5-1-获得方法地址&quot; class=&quot;headerlink&quot; title=&quot;5.1 获得方法地址&quot;&gt;&lt;/a&gt;5.1 获得方法地址&lt;/h2&gt;&lt;p&gt;避免动态绑定的唯一办法就是取得方法的地址，并且直接像函数调用一样调用它。当一个方法会被连续调用很多次，而且您希望节省每次调用方法都要发送消息的开销时，使用方法地址来调用方法就显得很有效。&lt;/p&gt;
&lt;p&gt;利用NSObject类中的methodForSelector:方法，您可以获得一个指向方法实现的指针，并可以使用该指针直接调用方法实现。methodForSelector:返回的指针和赋值的变量类型必须完全一致，包括方法的参数类型和返回值类型都在类型识别的考虑范围中。&lt;/p&gt;
&lt;p&gt;下面的例子展示了怎么使用指针来调用setFilled:的方法实现：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void (*setter)(id, SEL, BOOL); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int i; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for ( i = 0; i &amp;lt; 1000, i++ ) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setter(targetList[i], @selector(setFilled:), YES);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;方法指针的第一个参数是接收消息的对象（self），第二个参数是方法选标（_cmd）。这两个参数在方法中是隐藏参数，但使用函数的形式来调用方法时必须显示的给出。&lt;/p&gt;
&lt;p&gt;使用methodForSelector:来避免动态绑定将减少大部分消息的开销，但是这只有在指定的消息被重复发送很多次时才有意义，例如上面的for 循环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;methodForSelector:是Cocoa 运行时系统的提供的功能，而不是Objective-C语言本身的功能。&lt;/p&gt;
&lt;h2 id=&quot;5-2-objc-msgSend函数&quot;&gt;&lt;a href=&quot;#5-2-objc-msgSend函数&quot; class=&quot;headerlink&quot; title=&quot;5.2 objc_msgSend函数&quot;&gt;&lt;/a&gt;5.2 objc_msgSend函数&lt;/h2&gt;&lt;p&gt;在Objective-C中，消息是直到运行的时候才和方法实现绑定的。编译器会把一个消息表达式，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[receiver message]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;转换成一个对消息函数objc_msgSend的调用。该函数有两个主要参数：消息接收者和消息对应的方法名字——也就是方法选标：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objc_msgSend(receiver, selector)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;同时接收消息中的任意数目的参数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objc_msgSend(receiver, selector, arg1, arg2, ...)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该消息函数做了动态绑定所需要的一切：&lt;/p&gt;
&lt;p&gt;1）它首先找到选标所对应的方法实现。因为不同的类对同一方法可能会有不同的实现，所以找到的方法实现依赖于消息接收者的类型。&lt;/p&gt;
&lt;p&gt;2）然后将消息接收者对象（指向消息接收者对象的指针）以及方法中指定的参数传给找到的方法实现。&lt;/p&gt;
&lt;p&gt;3）最后，将方法实现的返回值作为该函数的返回值返回。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;编译器将自动插入调用该消息函数的代码。您无须在代码中显示调用该消息函数。&lt;/p&gt;
&lt;p&gt;消息机制的关键在于编译器为类和对象生成的结构。每个类的结构中至少包括两个基本元素：&lt;/p&gt;
&lt;p&gt;1）指向父类的指针。&lt;/p&gt;
&lt;p&gt;2）类的方法表。方法表将方法选标和该类的方法实现的地址关联起来。例如，setOrigin::的方法选标和setOrigin::的方法实现的地址关联，display  的方法选标和display 的方法实现的地址关联，等等。&lt;/p&gt;
&lt;p&gt;当新的对象被创建时，其内存同时被分配，实例变量也同时被初始化。对象的第一个实例变量是一个指向该对象的类结构的指针，叫做isa。通过该指针，对象可以访问它对应的类以及相应的父类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;尽管严格来说这并不是 Obective-C 语言的一部分，但是在Objective-C运行时系统中对象需要有isa 指针。对象和结构体struct objc_object（在objc/objc.h 中定义）必须“一致”。然而，您很少需要创建您自己的根对象，因为从 NSObject或者NSProxy 继承的对象都自动包括isa 变量。&lt;/p&gt;
&lt;p&gt;类和对象的结构如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-f237a0b62cb32d9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当对象收到消息时，消息函数首先根据该对象的 isa 指针找到该对象所对应的类的方法表，并从表中寻找该消息对应的方法选标。如果找不到，objc_msgSend将继续从父类中寻找，直到 NSObject类。一旦找到了方法选标， objc_msgSend则以消息接收者对象为参数调用，调用该选标对应的方法实现。&lt;/p&gt;
&lt;p&gt;这就是在运行时系统中选择方法实现的方式。在面向对象编程中，一般称作方法和消息动态绑定的过程。&lt;/p&gt;
&lt;p&gt;为了加快消息的处理过程，运行时系统通常会将使用过的方法选标和方法实现的地址放入缓存中。每个类都有一个独立的缓存，同时包括继承的方法和在该类中定义的方法。消息函数会首先检查消息接收者对象对应的类的缓存（理论上，如果一个方法被使用过一次，那么它很可能被再次使用）。如果在缓存中已经有需要的方法选标，则消息仅仅比函数调用慢一点点。如果程序运行了足够长的时间，几乎每个消息都能在缓存中找到方法实现。程序运行时，缓存也将随着新的消息的增加而增加。&lt;/p&gt;
&lt;h2 id=&quot;5-3-使用隐藏的参数&quot;&gt;&lt;a href=&quot;#5-3-使用隐藏的参数&quot; class=&quot;headerlink&quot; title=&quot;5.3 使用隐藏的参数&quot;&gt;&lt;/a&gt;5.3 使用隐藏的参数&lt;/h2&gt;&lt;p&gt;当objc_msgSend找到方法对应的实现时，它将直接调用该方法实现，并将消息中所有的参数都传递给方法实现，同时，它还将传递两个隐藏的参数：&lt;/p&gt;
&lt;p&gt;1）接收消息的对象&lt;/p&gt;
&lt;p&gt;2）方法选标&lt;/p&gt;
&lt;p&gt;这些参数帮助方法实现获得了消息表达式的信息。它们被认为是“隐藏”的原因是它们并没有在定义方法的源代码中声明，而是在代码编译时是插入方法的实现中的。&lt;/p&gt;
&lt;p&gt;尽管这些参数没有被显示声明，但在源代码中仍然可以引用它们（就像可以引用消息接收者对象的实例变量一样）。在方法中可以通过 self来引用消息接收者对象，通过选标_cmd来引用方法本身。&lt;/p&gt;
&lt;p&gt;在下面的例子中，_cmd指的是strange 方法，self指的收到strange 消息的对象。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- strange  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    id  target = getTheReceiver();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SEL method = getTheMethod();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ( target == self || method == _cmd )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return [target performSelector:method];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这两个参数中，self更有用一些。实际上，它是在方法实现中访问消息接收者对象的实例变量的途径。 &lt;/p&gt;
&lt;h1 id=&quot;6-动态方法解析&quot;&gt;&lt;a href=&quot;#6-动态方法解析&quot; class=&quot;headerlink&quot; title=&quot;6 动态方法解析&quot;&gt;&lt;/a&gt;6 动态方法解析&lt;/h1&gt;&lt;p&gt;本章节将描述怎样动态地提供一个方法的实现。&lt;/p&gt;
&lt;h2 id=&quot;6-1-动态方法解析&quot;&gt;&lt;a href=&quot;#6-1-动态方法解析&quot; class=&quot;headerlink&quot; title=&quot;6.1 动态方法解析&quot;&gt;&lt;/a&gt;6.1 动态方法解析&lt;/h2&gt;&lt;p&gt;有时候，程序员需要动态地提供一个方法的实现。例如，Objective-C中属性（Property ）（ 参考《Objective-C 2.0 程序设计语言》中“属性”小节）前的修饰符@dynamic&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@dynamic propertyName;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;表示编译器须动态地生成该属性对应地方法。&lt;/p&gt;
&lt;p&gt;程序员可以通过实现&lt;code&gt;resolveInstanceMethod:和resolveClassMethod:&lt;/code&gt;来动态地实现给定选标的对象方法或者类方法。&lt;/p&gt;
&lt;p&gt;Objective-C方法可以认为是至少有两个参数self和_cmd的C 函数。您可以通过class_addMethod 方法将一个函数加入到类的方法中。例如，有如下的函数：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void dynamicMethodIMP(id self, SEL _cmd) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // implementation ....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;程序员可以通过resolveInstanceMethod:将它作为类方法resolveThisMethodDynamically的实现：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@implementation MyClass&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (BOOL)resolveInstanceMethod:(SEL)aSEL  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (aSEL == @selector(resolveThisMethodDynamically)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &amp;quot;v@:&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          return YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return [super resolveInstanceMethod:aSEL];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通常消息转发（见 “消息转发”）和动态方法解析是互不相干的。在进入消息转发机制之前，respondsToSelector:和instancesRespondToSelector:  会被首先调用。您可以在这两个方法中为传进来的选标提供一个IMP 。如果您实现了resolveInstanceMethod:方法，但是仍然希望正常的消息转发机制进行，您只需要返回NO即可。 &lt;/p&gt;
&lt;h2 id=&quot;6-2-动态加载&quot;&gt;&lt;a href=&quot;#6-2-动态加载&quot; class=&quot;headerlink&quot; title=&quot;6.2 动态加载&quot;&gt;&lt;/a&gt;6.2 动态加载&lt;/h2&gt;&lt;p&gt;Objective-C程序可以在运行时链接和载入新的类和范畴类。新载入的类和在程序启动时载入的类并没有区别。 &lt;/p&gt;
&lt;p&gt;动态加载可以用在很多地方。例如，系统配置中的模块就是被动态加载的。&lt;br&gt;在Cocoa 环境中，动态加载一般被用来对应用程序进行定制。您的程序可以在运行时加载其他程序员编写的模块——和Interface Build 载入定制的调色板以及系统配置程序载入定制的模块的类似。这些模块通过您许可的方式扩展您的程序，而您无需自己来定义或者实现。您提供了框架，而其它的程序员提供了实现。 &lt;/p&gt;
&lt;p&gt;尽管已经有一个运行时系统的函数来动态加载Mach-O文件中的Objective-C模块（objc_loadModules，在objc/objc-load.h中定义），Cocoa 的NSBundle类为动态加载提供了一个更方便的接口——一个面向对象的，已经和相关服务集成的接口。关于NSBundle类的更多相关信息请参考Foundation 框架中关于NSBundle类的文档。关于Mach-O文件的有关信息请参考《Mac OS X ABI Mach-O  文件格式参考库》。&lt;/p&gt;
&lt;h1 id=&quot;7-消息转发&quot;&gt;&lt;a href=&quot;#7-消息转发&quot; class=&quot;headerlink&quot; title=&quot;7 消息转发&quot;&gt;&lt;/a&gt;7 消息转发&lt;/h1&gt;&lt;p&gt;通常，给一个对象发送它不能处理的消息会得到出错提示，然而，Objective-C运行时系统在抛出错误之前，会给消息接收对象发送一条特别的消息来通知该对象。&lt;/p&gt;
&lt;h2 id=&quot;7-1-消息转发&quot;&gt;&lt;a href=&quot;#7-1-消息转发&quot; class=&quot;headerlink&quot; title=&quot;7.1 消息转发&quot;&gt;&lt;/a&gt;7.1 消息转发&lt;/h2&gt;&lt;p&gt;如果一个对象收到一条无法处理的消息，运行时系统会在抛出错误前，给该对象发送一条forwardInvocation:消息，该消息的唯一参数是个NSInvocation类型的对象——该对象封装了原始的消息和消息的参数。&lt;/p&gt;
&lt;p&gt;程序员可以实现forwardInvocation:方法来对不能处理的消息做一些默认的处理，也可以以其它的某种方式来避免错误被抛出。如forwardInvocation:的名字所示，它通常用来将消息转发给其它的对象。 &lt;/p&gt;
&lt;p&gt;关于消息转发的作用，您可以考虑如下情景：假设，需要设计一个能够响应negotiate 消息的对象，并且能够包括其它类型的对象对消息的响应。通过在negotiate 方法的实现中将negotiate 消息转发给其它的对象这种方式可以很容易的达到这一目的。&lt;/p&gt;
&lt;p&gt;更进一步，假设您希望您的对象和另外一个类的对象对 negotiate 的消息的响应完全一致。一种可能的方式就是让您的类继承其它类的方法实现。然而，有时候这种方式不可行，因为您的类和其它类可能需要在不同的继承体系中响应negotiate 消息。&lt;/p&gt;
&lt;p&gt;虽然您的类无法继承其它类的negotiate 方法，您仍然可以提供一个方法实现，这个方法实现只是简单的将negotiate 消息转发给其他类的对象，就好像从其它类那里“借”来的实现一样。如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- negotiate &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ( [someOtherObject respondsTo:@selector(negotiate)] )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return [someOtherObject negotiate];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种方式显得有欠灵活，特别是有很多消息您都希望传递给其它对象时，您必须为每一种消息提供方法实现。此外，这种方式不能处理未知的消息。当您写下代码时，所有您需要转发的消息的集合也必须确定。然而，实际上，这个集合会随着运行时事件的发生，新方法或者新类的定义而变化。&lt;/p&gt;
&lt;p&gt;forwardInvocation:消息给这个问题提供了一个更特别的，动态的解决方案：当一个对象由于没有相应的方法实现而无法响应某消息时，运行时系统将通过 forwardInvocation:消息通知该对象。每个对象都从NSObject类中继承了forwardInvocation:方法。然而，NSObject中的方法实现只是简单地调用了doesNotRecognizeSelector:。通过实现您自己的forwardInvocation:方法，您可以在该方法实现中将消息转发给其它对象。&lt;/p&gt;
&lt;p&gt;要转发消息给其它对象，forwardInvocation:方法所必须做的有：&lt;/p&gt;
&lt;p&gt;1）决定将消息转发给谁，并且 &lt;/p&gt;
&lt;p&gt;2）将消息和原来的参数一块转发出去 &lt;/p&gt;
&lt;p&gt;消息可以通过invokeWithTarget:方法来转发：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)forwardInvocation:(NSInvocation *)anInvocation &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ([someOtherObject respondsToSelector: [anInvocation selector]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [anInvocation invokeWithTarget:someOtherObject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [super forwardInvocation:anInvocation];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;转发消息后的返回值将返回给原来的消息发送者。返回值可以是任何类型的，包括：id，结构体，浮点数等。&lt;/p&gt;
&lt;p&gt;forwardInvocation:方法就像一个不能识别的消息的分发中心，将这些消息转发给不同接收对象。或者它也可以像一个运输站将所有的消息都发送给同一个接收对象。它可以将一个消息翻译成另外一个消息，或者简单的“吃掉”某些消息，因此没有响应也没有错误。forwardInvocation:方法也可以对不同的消息提供同样的响应，这一切都取决于方法的具体实现。该方法所提供的是将不同的对象链接到消息链的能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;forwardInvocation: 方法只有在消息接收对象中无法正常响应消息时才会被调用。所以，如果您希望您的对象将negotiate 消息转发给其它对象，您的对象不能有negotiate 方法。否则，forwardInvocation:将不可能会被调用。&lt;/p&gt;
&lt;p&gt;更多消息转发的信息，参考Foundation框架参考库中NSInvocation类的文档。&lt;/p&gt;
&lt;h2 id=&quot;7-2-消息转发和多重继承&quot;&gt;&lt;a href=&quot;#7-2-消息转发和多重继承&quot; class=&quot;headerlink&quot; title=&quot;7.2 消息转发和多重继承&quot;&gt;&lt;/a&gt;7.2 消息转发和多重继承&lt;/h2&gt;&lt;p&gt;消息转发很像继承，并且可以用来在Objective-C程序中模拟多重继承。如下图所示，  一个对象通过转发来响应消息，看起来就像该对象从别的类那借来了或者“继承”了方法实现一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-f060df75ab9be460.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上图中，Warrior类的一个对象实例将negotiate 消息转发给Diplomat 类的一个实例。看起来，Warrior类似乎和Diplomat 类一样，响应negotiate消息，并且行为和Diplomat 一样（尽管实际上是Diplomat类响应了该消息）。&lt;/p&gt;
&lt;p&gt;转发消息的对象看起来有两个继承体系分支——自己的和响应消息的对象的。在上面的例子中，Warrior看起来同时继承自Diplomat 和自己的父类。&lt;/p&gt;
&lt;p&gt;消息转发提供了多重继承的很多特性。然而，两者有很大的不同：多重继承是将不同的行为封装到单个的对象中，有可能导致庞大的，复杂的对象。而消息转发是将问题分解到更小的对象中，但是又以一种对消息发送对象来说完全透明的方式将这些对象联系起来。&lt;/p&gt;
&lt;h2 id=&quot;7-3-消息代理对象&quot;&gt;&lt;a href=&quot;#7-3-消息代理对象&quot; class=&quot;headerlink&quot; title=&quot;7.3 消息代理对象&quot;&gt;&lt;/a&gt;7.3 消息代理对象&lt;/h2&gt;&lt;p&gt;消息转发不仅和继承很像，它也使得以一个轻量级的对象（消息代理对象）代表更多的对象进行消息处理成为可能。&lt;/p&gt;
&lt;p&gt;《Objective-C 2.0 程序设计语言》中“远程消息”一节中的代理类就是这样一个代理对象。代理类负责将消息转发给远程消息接收对象的管理细节，保证消息参数的传输等等。但是消息类没有进一步的复制远程对象的功能，它只是将远程对象映射到一个本地地址上，从而能够接收其它应用程序的消息。 &lt;/p&gt;
&lt;p&gt;同时也存在着其它类型的消息代理对象。例如，假设您有个对象需要操作大量的数据——它可能需要创建一个复杂的图片或者需要从磁盘上读一个文件的内容。创建一个这样的对象是很费时的，您可能希望能推迟它的创建时间——直到它真正需要时，或者系统资源空闲时。同时，您又希望至少有一个预留的对象和程序中其它对象交互。&lt;/p&gt;
&lt;p&gt;在这种情况下，您可以为该对象创建一个轻量的代理对象。该代理对象可以有一些自己的功能，例如响应数据查询消息，但是它主要的功能是代表某个对象，当时间到来时，将消息转发给被代表的对象。当代理对象的forwardInvocation:方法收到需要转发给被代表的对象的消息时，代理对象会保证所代表的对象已经存在，否则就创建它。所有发到被代表的对象的消息都要经过代理对象，对程序来说，代理对象和被代表的对象是一样的。&lt;/p&gt;
&lt;h2 id=&quot;7-4-消息转发和类继承&quot;&gt;&lt;a href=&quot;#7-4-消息转发和类继承&quot; class=&quot;headerlink&quot; title=&quot;7.4 消息转发和类继承&quot;&gt;&lt;/a&gt;7.4 消息转发和类继承&lt;/h2&gt;&lt;p&gt;尽管消息转发很“像”继承，但它不是继承。例如在NSObject类中，方法respondsToSelector:和isKindOfClass:只会出现在继承链中，而不是消息转发链中。例如，如果向一个 Warrior类的对象询问它能否响应negotiate 消息，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if ( [aWarrior respondsToSelector:@selector(negotiate)] )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回值是NO，尽管该对象能够接收和响应negotiate。&lt;/p&gt;
&lt;p&gt;大部分情况下，NO是正确的响应。但不是所有时候都是的。例如，如果您使用消息转发来创建一个代理对象以扩展某个类的能力，这里的消息转发必须和继承一样，尽可能的对用户透明。如果您希望您的代理对象看起来就像是继承自它代表的对象一样，您需要重新实现respondsToSelector:和isKindOfClass:方法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)respondsToSelector:(SEL)aSelector &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ( [super respondsToSelector:aSelector] )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        /* Here, test whether the aSelector message can     *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         * be forwarded to another object and whether that  *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         * object can respond to it. Return YES if it can.  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;除了respondsToSelector:和isKindOfClass:方法外，instancesRespondToSelector:方法也必须重新实现。如果您使用的是协议类，需要重新实现的还有conformsToProtocol:方法。类似地，如果对象需要转发远程消息，则 methodSignatureForSelector:方法必须能够返回实际响应消息的方法的描述。例如，如果对象需要将消息转发给它所代表的对象，您可能需要如下的methodSignatureForSelector:实现：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMethodSignature* signature = [super methodSignatureForSelector:selector];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (!signature) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       signature = [surrogate methodSignatureForSelector:selector];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return signature;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;您也可以将消息转发的部分放在一段私有的代码里，然后从forwardInvocation:调用它。&lt;br&gt;注意：消息转发是一个比较高级的技术，仅适用于没有其它更好的解决办法的情况。它并不是用来代替继承的。如果您必须使用该技术，请确定您已经完全理解了转发消息的类和接收转发消息的类的行为。&lt;/p&gt;
&lt;p&gt;本节中涉及的方法在Foundation框架参考库中的NSObject类的文档中都有描述。关于invokeWithTarget:的具体信息，请参考Foundation框架参考库中NSInvocation类的文档。&lt;/p&gt;
&lt;h1 id=&quot;8-属性声明&quot;&gt;&lt;a href=&quot;#8-属性声明&quot; class=&quot;headerlink&quot; title=&quot;8 属性声明&quot;&gt;&lt;/a&gt;8 属性声明&lt;/h1&gt;&lt;p&gt;当编译器遇到一个属性（Property ）声明时（参考《Objective-C 2.0 程序设计语言》中的“属性”小节），编译器将产生一些描述性的元数据与属性所在的类或者协议类关联。您可以通过函数访问元数据，这些函数支持在类或者协议类中通过名字来查找，通过@encode获得属性的类型编码，将属性的特征（Attribute ）作为C字符串的数组返回等。每个类或者协议类都维护了一个声明了的属性列表。&lt;/p&gt;
&lt;h2 id=&quot;8-1-属性类型和相关函数&quot;&gt;&lt;a href=&quot;#8-1-属性类型和相关函数&quot; class=&quot;headerlink&quot; title=&quot;8.1 属性类型和相关函数&quot;&gt;&lt;/a&gt;8.1 属性类型和相关函数&lt;/h2&gt;&lt;p&gt;属性（Property ）类型定义了对描述属性的结构体objc_property 的不透明的句柄。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef struct objc_property *Property;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;您可以使用函数class_copyPropertyList和protocol_copyPropertyList 来获得类（包括范畴类）或者协议类中的属性列表：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;例如，有如下的类声明：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface Lender : NSObject &amp;#123; float alone;&amp;#125;@property float alone;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以像这样获得它的属性：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;id LenderClass = objc_getClass(&amp;quot;Lender&amp;quot;);unsigned int outCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;amp;outCount);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;还可以通过property_getName函数获得属性的名字：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const char *property_getName(objc_property_t property)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;函数class_getProperty 和protocol_getProperty则在类或者协议类中返回具有给定名字的属性的引用：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objc_property_t class_getProperty(Class cls, const char *name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_property_t protocol_getProperty(Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过property_getAttributes函数可以获得属性的名字和@encode编码。关于类型编码的更多细节，参考“类型编码”一节；关于属性的类型编码，见“属性类型编码”及“属性特征的描述范例”。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const char *property_getAttributes(objc_property_t property)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;综合起来，您可以通过下面的代码得到一个类中所有的属性。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;id LenderClass = objc_getClass(&amp;quot;Lender&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unsigned int outCount, i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;amp;outCount);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for (i = 0; i &amp;lt; outCount; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objc_property_t property = properties[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fprintf(stdout,  &amp;quot;%s  %s\n&amp;quot;,  property_getName(property), property_getAttributes(property));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;8-2-属性类型编码&quot;&gt;&lt;a href=&quot;#8-2-属性类型编码&quot; class=&quot;headerlink&quot; title=&quot;8.2 属性类型编码&quot;&gt;&lt;/a&gt;8.2 属性类型编码&lt;/h2&gt;&lt;p&gt;property_getAttributes函数将返回属性（Property）的名字，@encode 编码，以及其它特征（Attribute ）。&lt;/p&gt;
&lt;p&gt;1）property_getAttributes返回的字符串以字母T 开始，接着是@encode 编码和逗号。&lt;/p&gt;
&lt;p&gt;2）如果属性有readonly修饰，则字符串中含有R 和逗号。 &lt;/p&gt;
&lt;p&gt;3）如果属性有copy或者retain修饰，则字符串分别含有C 或者&amp;amp;，然后是逗号。 &lt;/p&gt;
&lt;p&gt;4）如果属性定义有定制的getter 和setter 方法，则字符串中有G 或者S 跟着相应的方法名以及逗号（例如，GcustomGetter，ScustomSetter:，，）。&lt;/p&gt;
&lt;p&gt;如果属性是只读的，且有定制的get 访问方法，则描述到此为止。&lt;/p&gt;
&lt;p&gt;5）字符串以V 然后是属性的名字结束。&lt;/p&gt;
&lt;p&gt;范例请参考 “属性特征的描述范例” 一节。&lt;/p&gt;
&lt;h2 id=&quot;8-3-属性特征的描述范例&quot;&gt;&lt;a href=&quot;#8-3-属性特征的描述范例&quot; class=&quot;headerlink&quot; title=&quot;8.3 属性特征的描述范例&quot;&gt;&lt;/a&gt;8.3 属性特征的描述范例&lt;/h2&gt;&lt;p&gt;给定如下定义：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;enum FooManChu &amp;#123; FOO, MAN, CHU &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct YorkshireTeaStruct &amp;#123; int pot; char lady; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef struct YorkshireTeaStruct YorkshireTeaStructType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;union MoneyUnion &amp;#123; float alone; double down; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下表给出了属性（Property ）声明以及property_getAttributes返回的相应的字符串：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性声明&lt;/th&gt;
&lt;th&gt;属性描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;@property char charDefault;&lt;/td&gt;
&lt;td&gt;Tc,VcharDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property double doubleDefault;&lt;/td&gt;
&lt;td&gt;Td,VdoubleDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property enum FooManChuenumDefault;&lt;/td&gt;
&lt;td&gt;Ti,VenumDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property float floatDefault;&lt;/td&gt;
&lt;td&gt;Tf,VfloatDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property int intDefault;&lt;/td&gt;
&lt;td&gt;Ti,VintDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property long longDefault;&lt;/td&gt;
&lt;td&gt;Tl,VlongDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property short shortDefault;&lt;/td&gt;
&lt;td&gt;Ts,VshortDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property singed singedDefault;&lt;/td&gt;
&lt;td&gt;Ti,VsingedDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property struct YorkshireTeaStruct structDefault;&lt;/td&gt;
&lt;td&gt;T{ YorkshireTeaStruct =”pot”i”lady”c},VstructDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property YorkshireTeaStructType typedefDefault;&lt;/td&gt;
&lt;td&gt;T{ YorkshireTeaStruct =”pot”i”lady”c},VtypedefDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property union MoneyUnion unionDefault;&lt;/td&gt;
&lt;td&gt;T(MoneyUnion=”alone”f”down”d),VunionDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property unsigned unsignedDefault;&lt;/td&gt;
&lt;td&gt;TI,VunsignedDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property int (&lt;em&gt;functionPointerDefault)(char &lt;/em&gt;);&lt;/td&gt;
&lt;td&gt;T^?,VfunctionPointerDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property void *voidPointerDefault;&lt;/td&gt;
&lt;td&gt;T^v,VvoidPointerDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property id idDefault;&lt;/td&gt;
&lt;td&gt;T@,VidDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property int *intPointer;&lt;/td&gt;
&lt;td&gt;T^i,VintPointer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property int intSynthEquals;In the implementation block: @synthesize intSynthEquals = _intSynthEquals;&lt;/td&gt;
&lt;td&gt;Ti,V_intSynthEquals&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (getter=intGetFoo, setter=intSetFoo:) int intSetterGetter;&lt;/td&gt;
&lt;td&gt;Ti,GintGetFoo,SintSetFoo:,VintSetterGetter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (readonly)  int intReadonly;&lt;/td&gt;
&lt;td&gt;Ti,R,VintReadonly&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (getter=isIntReadOnlyGetter,  readonly)  int intReadonlyGetter;&lt;/td&gt;
&lt;td&gt;Ti,R,GisIntReadOnlyGetter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (readwrite)  int intReadwrite;&lt;/td&gt;
&lt;td&gt;Ti,VintReadwrite&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (assign)  int intAssign;&lt;/td&gt;
&lt;td&gt;Ti,VintAssign&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (retain)  id idRetain;&lt;/td&gt;
&lt;td&gt;T@,&amp;amp;,VidRetain&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (copy) id idCopy;&lt;/td&gt;
&lt;td&gt;T@,C,VidCopy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (nonatomic)  int intNonatomic;&lt;/td&gt;
&lt;td&gt;Ti,VintNonatomic&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property(nonatomic, readonly,  copy)  id idReadonlyCopyNonatomic;&lt;/td&gt;
&lt;td&gt;T@,R,C,VidReadonlyCopyNonatomic&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property(nonatomic, readonly,  retain)  id idReadonlyRetainNonatomic;&lt;/td&gt;
&lt;td&gt;T@,R,&amp;amp;,VidReadonlyRetainNonatomic&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;9-类型编码&quot;&gt;&lt;a href=&quot;#9-类型编码&quot; class=&quot;headerlink&quot; title=&quot;9 类型编码&quot;&gt;&lt;/a&gt;9 类型编码&lt;/h1&gt;&lt;p&gt;为了和运行时系统协作，编译器将方法的返回类型和参数类型都编码成一个字符串，并且和方法选标关联在一起。这些编码在别的上下文环境中同样有用，所以您可以直接使@encode()编译指令来得到具体的编码。给定一个类型， @encode()将返回该类型的编码字符串。类型可以是基本类型例如整形，指针，结构体或者联合体，也可以是一个类，就和 C 语言中的sizeof()操作符的参数一样，可以是任何类型。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;char *buf1 = @encode(int **);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;char *buf2 = @encode(struct key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;char *buf3 = @encode(Rectangle);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下表列出了这些类型编码。注意，它们可能很多和您使用的对象编码有一些重合。然而，这里列出来的有些编码是您写编码器的时候不会使用的，也有一些不是@encode()产生的，但是在您写编码器的时候是会使用的。（关于对象编码的更多信息，请参考Foundation框架参考库中的NSCoder类文档。）&lt;/p&gt;
&lt;p&gt;Objective-C类型编码&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;编码&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l&lt;/td&gt;
&lt;td&gt;long，在64位程序中，l为32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;q&lt;/td&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;unsigned char&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;unsigned int&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;unsigned short&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;unsigned long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Q&lt;/td&gt;
&lt;td&gt;unsigned long long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;f&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;C++标准的bool或者C99标准的_Bool&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;字符串（char *）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@&lt;/td&gt;
&lt;td&gt;对象（无论是静态指定的还是通过id引用的）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;#&lt;/td&gt;
&lt;td&gt;类（Class）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:&lt;/td&gt;
&lt;td&gt;方法选标（SEL）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[array type]&lt;/td&gt;
&lt;td&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{name=type…}&lt;/td&gt;
&lt;td&gt;结构体&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(name=type…)&lt;/td&gt;
&lt;td&gt;联合体&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bnum&lt;/td&gt;
&lt;td&gt;num个bit的位域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;^type&lt;/td&gt;
&lt;td&gt;type类型的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;未知类型（其他时候，一般用来指函数指针）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;重要：&lt;/strong&gt; Objective-C 不支持long double 类型。@encode(long double)和double 一样，返回的字符串都是d。&lt;/p&gt;
&lt;p&gt;数组的类型编码以方括号来表示，紧接着左方括号的是数组元素的数量，然后是数据元素的类型。例如，一个12个浮点数（floats）指针的数组可以表示如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[12^f]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;结构体和联合体分别用大括号和小括号表示。括号中首先是结构体标签，然后是一个“=”符号，接着是结构体中各个成员的编码。例如，结构体&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef struct example &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    id   anObject;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char *aString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int  anInt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; Example;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;的编码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;example=@*i&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;定义的类型名（Example）和结构体标签（example）有同样的编码结果。指向结构体类型的指针的编码同样也包含了结构体内部数据成员的编码信息，如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;^&amp;#123;example=@*i&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而，更高层次的间接关联就没有了内部数据成员的编码信息：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;^^&amp;#123;example&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对象的编码类似结构体。例如， @encode()对NSObject编码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;NSObject=#&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;NSObject类仅声明了一个Class 类型的实例变量，isa。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;尽管有一些编码无法从 @encode()的结果中直接得到，但是运行时系统会使用它们来表示协议类中方法的修饰符，这些编码如表所示。&lt;/p&gt;
&lt;p&gt;Objective-C方法编码&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;编码&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;const&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;in&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;inout&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;out&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;bycopy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;byref&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;td&gt;oneway&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;10-附言&quot;&gt;&lt;a href=&quot;#10-附言&quot; class=&quot;headerlink&quot; title=&quot;10 附言&quot;&gt;&lt;/a&gt;10 附言&lt;/h1&gt;&lt;p&gt;在此，运行时机制相关问题已经全部阐述。消息发送和转发是Runtime的强大之处，通过它，您可以为程序增加很多动态的行为，虽然在实际开发中很少直接使用这些机制（如直接调用objc_msgSend），但了解它们有助于您更多地去了解底层的实现。其实在实际的编码过程中，您也可以灵活地使用这些机制，去实现一些特殊的功能，如hook操作等。&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://www.apple.com.cn/developer/Documentation/index.html&quot;&gt;http://www.apple.com.cn/developer/Documentation/index.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：Objective-C语言将决定尽可能的从编译和链接时推迟到运行时。只要有可能，Objective-C总是使用动态的方式来解决问题。这意味着Objective-C语言不仅需要一个编译器，同时也需要一个运行时系统来执行编译好的代码。这里的运行时系统扮演的角色类似于Objective-C语言的操作系统，Objective-C基于该系统来工作。本文章将具体介绍NSObject类以及Objective-C程序是如何与运行时系统交互的。特别地，本文章还给出来怎样在运行时动态地加载新类和将消息转发给其它对象的范例，同时也给出了怎样在程序运行时获取对象信息的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="iOS" scheme="http://charsdavy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Git 使用 - 远程操作</title>
    <link href="http://charsdavy.github.io/2016/06/05/git-using-remote/"/>
    <id>http://charsdavy.github.io/2016/06/05/git-using-remote/</id>
    <published>2016-06-05T03:03:55.000Z</published>
    <updated>2016-06-13T11:45:41.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git的读音为/gɪt/。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Git&quot;&gt;Git&lt;/a&gt;是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。&lt;/p&gt;
&lt;p&gt;Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper，后者之前一直是Linux 内核开发人员在全球使用的主要源代码工具。开放源码社区中的有些人觉得 BitKeeper 的许可证并不适合开放源码社区的工作，因此 Torvalds 决定着手研究许可证更为灵活的版本控制系统。尽管最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是我们已经发现在很多其他自由软件项目中也使用了 Git。例如 最近就迁移到 Git 上来了，很多 Freedesktop 的项目也迁移到了 Git 上。&lt;/p&gt;
&lt;p&gt;Git有很多优势，其中之一就是远程操作非常简单。但是，Git也是一把双刃剑，使用得当，将会尽享Git的便利与强大。本文将主要介绍几个常用的Git远程操作命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:06:05:git-using-remote:1.jpg?imageView/2/w/560&quot; alt=&quot;introduction&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;git-clone&quot;&gt;&lt;a href=&quot;#git-clone&quot; class=&quot;headerlink&quot; title=&quot;git clone&quot;&gt;&lt;/a&gt;git clone&lt;/h1&gt;&lt;p&gt;远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到&lt;code&gt;git clone&lt;/code&gt;命令。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git clone &amp;lt;版本库的网址&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;比如，克隆Weibo的版本库。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git clone https://github.com/charsdavy/iWeibo.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为&lt;code&gt;git clone&lt;/code&gt;命令的第二个参数。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git clone &amp;lt;版本库的网址&amp;gt; &amp;lt;本地目录名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;git clone&lt;/code&gt;支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git clone http[s]://example.com/path/to/repo.git/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git clone ssh://example.com/path/to/repo.git/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git clone git://example.com/path/to/repo.git/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git clone /opt/git/project.git &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git clone file:///opt/git/project.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git clone ftp[s]://example.com/path/to/repo.git/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git clone rsync://example.com/path/to/repo.git/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;SSH协议还有另一种写法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git clone [user@]example.com:path/to/repo.git/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考&lt;a href=&quot;http://git-scm.com/book/en/Git-on-the-Server-The-Protocols&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;git-remote&quot;&gt;&lt;a href=&quot;#git-remote&quot; class=&quot;headerlink&quot; title=&quot;git remote&quot;&gt;&lt;/a&gt;git remote&lt;/h1&gt;&lt;p&gt;为了便于管理，Git要求每个远程主机都必须指定一个主机名。&lt;code&gt;git remote&lt;/code&gt;命令就用于管理主机名。&lt;/p&gt;
&lt;p&gt;不带选项的时候，&lt;code&gt;git remote&lt;/code&gt;命令列出所有远程主机。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git remote&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用-v选项，可以参看远程主机的网址。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git remote -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;origin  git@github.com:charsdavy/iWeibo.git (fetch)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;origin  git@github.com:charsdavy/iWeibo.git (push)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。&lt;/p&gt;
&lt;p&gt;克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用&lt;code&gt;git clone&lt;/code&gt;命令的-o选项指定。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git clone -o Weibo https://github.com/charsdavy/iWeibo.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git remote&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Weibo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，克隆的时候，指定远程主机叫做Weibo。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;git remote show命令加上主机名，可以查看该主机的详细信息。&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;$ git remote show &amp;lt;主机名&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git remote add命令用于添加远程主机。&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;$ git remote add &amp;lt;主机名&amp;gt; &amp;lt;网址&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git remote rm命令用于删除远程主机。&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;$ git remote rm &amp;lt;主机名&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git remote rename命令用于远程主机的改名。&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;$ git remote rename &amp;lt;原主机名&amp;gt; &amp;lt;新主机名&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;git-fetch&quot;&gt;&lt;a href=&quot;#git-fetch&quot; class=&quot;headerlink&quot; title=&quot;git fetch&quot;&gt;&lt;/a&gt;git fetch&lt;/h1&gt;&lt;p&gt;一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到&lt;code&gt;git fetch&lt;/code&gt;命令。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch &amp;lt;远程主机名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令将某个远程主机的更新，全部取回本地。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git fetch&lt;/code&gt;命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;git fetch&lt;/code&gt;取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch &amp;lt;远程主机名&amp;gt; &amp;lt;分支名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;比如，取回origin主机的master分支。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch origin master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git branch&lt;/code&gt;命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git branch -r&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;origin/master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git branch -a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  remotes/origin/master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，本地主机的当前分支是master，远程分支是origin/master。&lt;/p&gt;
&lt;p&gt;取回远程主机的更新以后，可以在它的基础上，使用&lt;code&gt;git checkout&lt;/code&gt;命令创建一个新的分支。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -b newBrach origin/master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，在origin/master的基础上，创建一个新分支。&lt;/p&gt;
&lt;p&gt;此外，也可以使用&lt;code&gt;git merge&lt;/code&gt;命令或者&lt;code&gt;git rebase&lt;/code&gt;命令，在本地分支上合并远程分支。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git merge origin/master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 或者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git rebase origin/master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示在当前分支上，合并origin/master。&lt;/p&gt;
&lt;h1 id=&quot;git-pull&quot;&gt;&lt;a href=&quot;#git-pull&quot; class=&quot;headerlink&quot; title=&quot;git pull&quot;&gt;&lt;/a&gt;git pull&lt;/h1&gt;&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt;命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git pull origin next:master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果远程分支是与当前分支合并，则冒号后面的部分可以省略。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git pull origin next&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做&lt;code&gt;git fetch&lt;/code&gt;，再做&lt;code&gt;git merge&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch origin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git merge origin/next&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在&lt;code&gt;git clone&lt;/code&gt;的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。&lt;/p&gt;
&lt;p&gt;Git也允许手动建立追踪关系。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git branch --set-upstream master origin/next&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令指定master分支追踪origin/next分支。&lt;/p&gt;
&lt;p&gt;如果当前分支与远程分支存在追踪关系，&lt;code&gt;git pull&lt;/code&gt;就可以省略远程分支名。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git pull origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。&lt;/p&gt;
&lt;p&gt;如果当前分支只有一个追踪分支，连远程主机名都可以省略。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git pull&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，当前分支自动与唯一一个追踪分支进行合并。&lt;/p&gt;
&lt;p&gt;如果合并需要采用rebase模式，可以使用–rebase选项。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git pull --rebase &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果远程主机删除了某个分支，默认情况下，&lt;code&gt;git pull&lt;/code&gt; 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止由于其他人操作了远程主机，导致&lt;code&gt;git pull&lt;/code&gt;不知不觉删除了本地分支。&lt;/p&gt;
&lt;p&gt;但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git pull -p&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 等同于下面的命令&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch --prune origin &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch -p&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;git-push&quot;&gt;&lt;a href=&quot;#git-push&quot; class=&quot;headerlink&quot; title=&quot;git push&quot;&gt;&lt;/a&gt;git push&lt;/h1&gt;&lt;p&gt;&lt;code&gt;git push&lt;/code&gt;命令用于将本地分支的更新，推送到远程主机。它的格式与&lt;code&gt;git pull&lt;/code&gt;命令相仿。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt;:&amp;lt;远程分支名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;分支推送顺序的写法是&amp;lt;来源地&amp;gt;:&amp;lt;目的地&amp;gt;，所以&lt;code&gt;git pull&lt;/code&gt;是&amp;lt;远程分支&amp;gt;:&amp;lt;本地分支&amp;gt;，而&lt;code&gt;git push&lt;/code&gt;是&amp;lt;本地分支&amp;gt;:&amp;lt;远程分支&amp;gt;。&lt;/p&gt;
&lt;p&gt;如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。&lt;/p&gt;
&lt;p&gt;如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin :master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 等同于&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin --delete master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示删除origin主机的master分支。&lt;/p&gt;
&lt;p&gt;如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，将当前分支推送到origin主机的对应分支。&lt;/p&gt;
&lt;p&gt;如果当前分支只有一个追踪分支，那么主机名都可以省略。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用&lt;code&gt;git push&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push -u origin master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用&lt;code&gt;git push&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;不带任何参数的&lt;code&gt;git push&lt;/code&gt;，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用&lt;code&gt;git config&lt;/code&gt;命令。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global push.default matching&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 或者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global push.default simple&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push --all origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，将所有本地分支都推送到origin主机。&lt;/p&gt;
&lt;p&gt;如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做&lt;code&gt;git pull&lt;/code&gt;合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push --force origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令使用–force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用–force选项。&lt;/p&gt;
&lt;p&gt;最后，&lt;code&gt;git push&lt;/code&gt;不会推送标签（tag），除非使用–tags选项。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin --tags&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;git-fetch-1&quot;&gt;&lt;a href=&quot;#git-fetch-1&quot; class=&quot;headerlink&quot; title=&quot;git fetch&quot;&gt;&lt;/a&gt;git fetch&lt;/h1&gt;&lt;p&gt;最近工作上有点忙，不免回家之后还需要办公，可是工作用公司的设备。回家之后只能使用自己的MAC。不过，如何在两台设备同步代码就成了问题。需要能够在一个文件夹不断的同步新的分支，而不会产生新的文件夹。这里，分享博主的解决办法。&lt;/p&gt;
&lt;p&gt;1）从远端获取分支&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2）基于远端分支创建本地分支&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -b local_branch_name origin/remote_branch_name&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，就会在本地创建一个基于远端分支的分支。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git的读音为/gɪt/。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Git&quot;&gt;Git&lt;/a&gt;是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。&lt;/p&gt;
&lt;p&gt;Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper，后者之前一直是Linux 内核开发人员在全球使用的主要源代码工具。开放源码社区中的有些人觉得 BitKeeper 的许可证并不适合开放源码社区的工作，因此 Torvalds 决定着手研究许可证更为灵活的版本控制系统。尽管最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是我们已经发现在很多其他自由软件项目中也使用了 Git。例如 最近就迁移到 Git 上来了，很多 Freedesktop 的项目也迁移到了 Git 上。&lt;/p&gt;
&lt;p&gt;Git有很多优势，其中之一就是远程操作非常简单。但是，Git也是一把双刃剑，使用得当，将会尽享Git的便利与强大。本文将主要介绍几个常用的Git远程操作命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:06:05:git-using-remote:1.jpg?imageView/2/w/560&quot; alt=&quot;introduction&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://charsdavy.github.io/categories/tool/"/>
    
    
      <category term="Git" scheme="http://charsdavy.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>七牛云存储应用</title>
    <link href="http://charsdavy.github.io/2016/06/02/qiniu-using/"/>
    <id>http://charsdavy.github.io/2016/06/02/qiniu-using/</id>
    <published>2016-06-02T00:17:42.000Z</published>
    <updated>2016-06-04T02:09:36.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：七牛云存储，是专为移动时代开发者打造的数据管理平台，为互联网网站和移动App提供数据的在线托管、传输加速以及图片、音视频等富媒体的云处理服务。本文讲述如何使用七牛云存储来作为自己APP的数据云存储空间。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;七牛云存储，是专为移动时代开发者打造的数据管理平台，为互联网网站和移动App提供数据的在线托管、传输加速以及图片、音视频等富媒体的云处理服务。&lt;br&gt;七牛云官网&lt;a href=&quot;http://www.qiniu.com/&quot;&gt;http://www.qiniu.com/&lt;/a&gt; ，进入开发者平台，浏览了所有的开发指南，可是却是没有具体清晰的操作步骤。今天自己试着通过网络，实现了使用七牛云存储文件。现在，将操作步骤记录如下。&lt;/p&gt;
&lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h1&gt;&lt;p&gt;1.注册七牛云账号。&lt;/p&gt;
&lt;p&gt;2.创建空间。&lt;/p&gt;
&lt;p&gt;3.获取Access Key。&lt;/p&gt;
&lt;p&gt;4.获取Secret Key。&lt;/p&gt;
&lt;p&gt;5.获取官方SDK（&lt;a href=&quot;https://github.com/qiniu/objc-sdk&quot;&gt;https://github.com/qiniu/objc-sdk&lt;/a&gt; ）。&lt;/p&gt;
&lt;h1 id=&quot;导入工程&quot;&gt;&lt;a href=&quot;#导入工程&quot; class=&quot;headerlink&quot; title=&quot;导入工程&quot;&gt;&lt;/a&gt;导入工程&lt;/h1&gt;&lt;p&gt;1.打开Xcode创建Project。&lt;/p&gt;
&lt;p&gt;2.从获取的官方SDK导入库，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:06:02:qiniu-using:1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;3.获取token&lt;/p&gt;
&lt;p&gt;这一步，网上大家都说得很简单，在这一步卡壳许久。现在说说自己使用的方法：&lt;/p&gt;
&lt;p&gt;1）获取服务器代码，编译工程，以备生成token。&lt;/p&gt;
&lt;p&gt;服务器代码地址：&lt;a href=&quot;https://github.com/CharsDavy/QiNiuGenertorToken&quot;&gt;https://github.com/CharsDavy/QiNiuGenertorToken&lt;/a&gt;&lt;br&gt;2）使用Eclipse导入上述服务器代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:06:02:qiniu-using:2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Test.java文件中，修改自己的空间名称，Access Key和Secret Key。运行程序，即可获得token。&lt;/p&gt;
&lt;p&gt;这种方式生成的token的有效期是可以自己设定的，如果你想，设定1000年过期也是可以的。&lt;/p&gt;
&lt;p&gt;4.使用代码上传文件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;QiniuSDK.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString token = @&amp;quot;从服务端SDK获取&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QNUploadManager *upManager = [[QNUploadManager alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSData *data = [@&amp;quot;Hello, World!&amp;quot; dataUsingEncoding : NSUTF8StringEncoding];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [upManager putData:data key:@&amp;quot;hello&amp;quot; token:token&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        complete: ^(QNResponseInfo *info, NSString *key, NSDictionary *resp) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;%@&amp;quot;, info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;%@&amp;quot;, resp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; option:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;调试&quot;&gt;&lt;a href=&quot;#调试&quot; class=&quot;headerlink&quot; title=&quot;调试&quot;&gt;&lt;/a&gt;调试&lt;/h1&gt;&lt;p&gt;工程导入之后，可能会出现以下几种可能的错误。&lt;/p&gt;
&lt;p&gt;1.若报 &lt;code&gt;Undefined symbols for architecture x86_64: &amp;quot;_crc32&amp;quot;, referenced from:&lt;/code&gt;，项目中需导入 libz.dylib。(Build Phases—Link Binary With Libraries)&lt;/p&gt;
&lt;p&gt;2.若报&lt;code&gt;&amp;quot;_res_9_ninit&amp;quot;, referenced from: _setup_dns_server in QNResolver.o&lt;/code&gt;等，&lt;/p&gt;
&lt;p&gt;1）项目中需导入 libresolv.dylib或libresolv.9.dylib。(Build Phases— Link Binary With Libraries)；&lt;/p&gt;
&lt;p&gt;2）或 (Build Settings— Linking— Other Linker Flags) 添加 -lresolv选项。&lt;/p&gt;
&lt;p&gt;3.若报 Thread 1: EXC_BAD_ACCESS(code=1,address=0x180f4beb8)类似错误，将 QN打头的都设置 arc (Build Phases — Compile Sources)&lt;/p&gt;
&lt;p&gt;4.可能需要修改部分内容，如 &lt;code&gt;#import &amp;lt;AFNetworking/AFNetworking.h&amp;gt;&lt;/code&gt;改为 &lt;code&gt;#import &amp;quot;AFNetworking.h&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h1&gt;&lt;p&gt;以上就是本人在工程中使用七牛云进行文件云存储的过程，本文中使用的仅仅是上传文件，更多其他操作功能请参照官方文档。&lt;/p&gt;
&lt;p&gt;最后，附上一个使用七牛云存储的软件，源码地址：&lt;a href=&quot;https://github.com/CharsDavy/MyNotes&quot;&gt;https://github.com/CharsDavy/MyNotes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实，对于获取token来完成上载操作，也可以参考官方文档，地址&lt;br&gt;&lt;a href=&quot;http://developer.qiniu.com/docs/v6/api/reference/security/put-policy.html&quot;&gt;http://developer.qiniu.com/docs/v6/api/reference/security/put-policy.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：七牛云存储，是专为移动时代开发者打造的数据管理平台，为互联网网站和移动App提供数据的在线托管、传输加速以及图片、音视频等富媒体的云处理服务。本文讲述如何使用七牛云存储来作为自己APP的数据云存储空间。&lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="iOS" scheme="http://charsdavy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>你和日本的距离只差5mm</title>
    <link href="http://charsdavy.github.io/2016/06/01/chopsticks-using/"/>
    <id>http://charsdavy.github.io/2016/06/01/chopsticks-using/</id>
    <published>2016-06-01T12:38:19.000Z</published>
    <updated>2016-06-04T02:09:36.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：世界上使用筷子的国家并不是很多，很多人都认为能够使用筷子是件很神奇的事情。那么，不同的国家地区使用筷子的讲究也有所不同。这里主要说说日本使用筷子的禁忌，有些也很符合天朝国情的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;日本在使用筷子的时候，也有很大的「箸（はし）」学问，有什么禁忌是千万不要犯的呢？！&lt;/p&gt;
&lt;p&gt;✖握り箸（にぎりばし）——握筷子，这是初级错误，一般来说只有初学使用筷子的孩子和外国人会犯。&lt;/p&gt;
&lt;p&gt;✖クロス箸——两根筷子交叉，很不雅观。 &lt;/p&gt;
&lt;p&gt;✖迷い箸（まよいばし）——拿起筷子犹豫不决，前后左右晃动，似乎在挑拣食物。&lt;/p&gt;
&lt;p&gt;✖移り箸（うつりばし）——前面食物的味道还残留在口中，就取另外的食物。&lt;/p&gt;
&lt;p&gt;✖こじ箸——在碗底翻腾取食物。&lt;/p&gt;
&lt;p&gt;✖寄せ箸（よせばし）——用筷子拨动、移动盘子。&lt;/p&gt;
&lt;p&gt;✖刺し箸（さしばし）——用筷子扎取食物（对于不会用筷子的人来说，吃丸子的时候不这样会很难~）。&lt;/p&gt;
&lt;p&gt;✖涙箸——“泪筷子”，这个名称很形象，筷子夹起食物滴滴答答的流汤。&lt;/p&gt;
&lt;p&gt;✖かき箸——把碗放在嘴边，用筷子把食品拨拉到嘴里。&lt;/p&gt;
&lt;p&gt;✖込み箸（こみばし）——筷子进嘴塞食。&lt;/p&gt;
&lt;p&gt;✖持ち箸（もちばし）——把筷子拿在手里，端起碗吸食，日本农民 。&lt;/p&gt;
&lt;p&gt;✖ねぶり箸——把筷子放在嘴里吸允。&lt;/p&gt;
&lt;p&gt;✖渡し箸（わたしばし）——把筷子架在碗上。&lt;/p&gt;
&lt;p&gt;✖叩き箸（はたきばし）——用筷子敲碗催促他人（这样真的很招人烦）。&lt;/p&gt;
&lt;p&gt;✖指さし箸（ゆびさしばし）——用筷子指人（用手指人也是很不好的）。&lt;/p&gt;
&lt;p&gt;✖直箸（じかばし）——有公筷不用，直接使用自己的筷子在盘内取食。&lt;/p&gt;
&lt;p&gt;✖立箸——把筷子插在米饭碗里。&lt;/p&gt;
&lt;p&gt;✖そろえ箸——用舌头、嘴唇或者其他平面整理、理顺两根筷子（为什么不用手，这样多累啊）。 &lt;/p&gt;
&lt;p&gt;✖探り箸（さぐりばし）——用筷子在盘子里搅拌、寻找食物（瞄准一个直接吃得了，在那ba la啥）。&lt;/p&gt;
&lt;p&gt;✖せせり箸——把筷子当牙签使（小花儿表示：她的牙缝没这么大）。&lt;/p&gt;
&lt;p&gt;✖かみ箸——用牙齿咬筷子。&lt;/p&gt;
&lt;p&gt;✖振り箸（ふりばし）——甩手抖落筷子上的汤汁（轻微洁癖真的有点接受不了）。&lt;/p&gt;
&lt;p&gt;✖洗い箸（あらい）——在碗盘汤中涮洗筷子。&lt;/p&gt;
&lt;p&gt;✖箸渡し（はしわたし）——用筷子向他人的筷子递送食品。&lt;br&gt;✖そら箸——筷子靠近了盘子，却又不取食品。&lt;/p&gt;
&lt;p&gt;以上是25条使用筷子的禁忌。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：世界上使用筷子的国家并不是很多，很多人都认为能够使用筷子是件很神奇的事情。那么，不同的国家地区使用筷子的讲究也有所不同。这里主要说说日本使用筷子的禁忌，有些也很符合天朝国情的。&lt;/p&gt;
    
    </summary>
    
      <category term="爱好" scheme="http://charsdavy.github.io/categories/hobby/"/>
    
    
      <category term="日语" scheme="http://charsdavy.github.io/tags/Japanese/"/>
    
  </entry>
  
  <entry>
    <title>手把手教 GitHub + Hexo 搭建博客</title>
    <link href="http://charsdavy.github.io/2016/05/31/build-blog-by-hexo/"/>
    <id>http://charsdavy.github.io/2016/05/31/build-blog-by-hexo/</id>
    <published>2016-05-31T14:07:27.000Z</published>
    <updated>2016-06-04T02:09:36.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：本文章主要介绍使用hexo框架搭建博客，使用GitHub免费托管自己的博客代码，并使用GitHub Pages提供的免费服务。换句话说，就是使用免费资源搭建属于自己的博客网站。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在很久以前，博主就想着要有自主的博客专栏或者网站。经历了博客园这个需要所谓的编辑审核，一直比较困惑，这些编辑是什么出身，怎么知道技术博客的价值性。&lt;/p&gt;
&lt;p&gt;接下来找到了开源中国，这个可以自由发言的地方。不过，不知道是不是受众面不广，访问量都不是很理想。&lt;/p&gt;
&lt;p&gt;再然后就来自己动手开始搭建博客。从手写html发布文章，到使用jekyll，最后到了hexo阵营。&lt;/p&gt;
&lt;p&gt;终于，有种找到家的赶脚。hexo不仅搭建方便，而且在后续的功能扩展以及文章发布都是非常方便的。不仅如此，还可以本地调试，预览效果。最方便的是支持markdown编写文档。&lt;/p&gt;
&lt;p&gt;本文就是介绍如何安装使用hexo搭建属于自己的博客。从此不再担心投稿被莫名拒绝。可以在自己的一亩三分地讲述着自己的故事。&lt;/p&gt;
&lt;h1 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h1&gt;&lt;h2 id=&quot;安装Git&quot;&gt;&lt;a href=&quot;#安装Git&quot; class=&quot;headerlink&quot; title=&quot;安装Git&quot;&gt;&lt;/a&gt;安装Git&lt;/h2&gt;&lt;p&gt;MAC OS X 是自带Git命令行工具。&lt;/p&gt;
&lt;p&gt;Windows 可以安装Git Bash。&lt;/p&gt;
&lt;h2 id=&quot;安装Node-js&quot;&gt;&lt;a href=&quot;#安装Node-js&quot; class=&quot;headerlink&quot; title=&quot;安装Node.js&quot;&gt;&lt;/a&gt;安装Node.js&lt;/h2&gt;&lt;p&gt;前往&lt;a href=&quot;https://nodejs.org/en/&quot;&gt;官网地址&lt;/a&gt;，根据教程安装即可。&lt;/p&gt;
&lt;h2 id=&quot;安装hexo&quot;&gt;&lt;a href=&quot;#安装hexo&quot; class=&quot;headerlink&quot; title=&quot;安装hexo&quot;&gt;&lt;/a&gt;安装hexo&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo npm install hexo-cli -g&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;使用hexo&quot;&gt;&lt;a href=&quot;#使用hexo&quot; class=&quot;headerlink&quot; title=&quot;使用hexo&quot;&gt;&lt;/a&gt;使用hexo&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 创建hexo文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ mkdir hexo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 进入hexo文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd hexo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 初始化hexo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ hexo init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 安装依赖包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ npm install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 本地查看&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 先运行下面的命令，再在浏览器输入localhost:4000即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 问题：执行hexo server提示找不到该指令&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 解决办法：在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ npm install hexo -server --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;生成静态网站&quot;&gt;&lt;a href=&quot;#生成静态网站&quot; class=&quot;headerlink&quot; title=&quot;生成静态网站&quot;&gt;&lt;/a&gt;生成静态网站&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── .deploy #需要部署的文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── node_modules #Hexo插件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── public #生成的静态网页文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── scaffolds #模板&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| ├── _drafts #草稿&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| └── _posts #文章&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── themes #主题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── _config.yml #全局配置文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;└── package.json&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;全局配置-config-yml&quot;&gt;&lt;a href=&quot;#全局配置-config-yml&quot; class=&quot;headerlink&quot; title=&quot;全局配置 _config.yml&quot;&gt;&lt;/a&gt;全局配置 _config.yml&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# Hexo Configuration&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## Docs: http://hexo.io/docs/configuration.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## Source: https://github.com/hexojs/hexo/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Site #站点信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;title:  #标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;subtitle:  #副标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;description:  #站点描述，给搜索引擎看的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;author:  #作者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;email:  #电子邮箱&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;language: zh-CN #语言&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# URL #链接格式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;url:  #网址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root: / #根目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;permalink: :year/:month/:day/:title/ #文章的链接格式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tag_dir: tags #标签目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;archive_dir: archives #存档目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;category_dir: categories #分类目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;code_dir: downloads/code&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;permalink_defaults:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Directory #目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;source_dir: source #源文件目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public_dir: public #生成的网页文件目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Writing #写作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new_post_name: :title.md #新文章标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;titlecase: false #标题转换成大写&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;external_link: true #在新选项卡中打开连接&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;filename_case: 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;render_drafts: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;post_asset_folder: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;relative_link: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;highlight: #语法高亮&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  enable: true #是否启用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  line_number: true #显示行号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  tab_replace:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Category &amp;amp; Tag #分类和标签&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;default_category: uncategorized #默认分类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;category_map:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tag_map:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Archives&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2: 开启分页&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1: 禁用分页&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0: 全部禁用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;archive: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;category: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tag: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Server #本地服务器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;port: 4000 #端口号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;server_ip: localhost #IP 地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;logger: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;logger_format: dev&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Date / Time format #日期时间格式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;time_format: H:mm:ss&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Pagination #分页&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;per_page: 10 #每页文章数，设置成 0 禁用分页&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pagination_dir: page&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Disqus #Disqus评论，替换为多说&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;disqus_shortname:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Extensions #拓展插件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;theme: landscape-plus #主题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exclude_generator:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plugins: #插件，例如生成 RSS 和站点地图的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- hexo-generator-feed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- hexo-generator-sitemap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Deployment #部署，将 lmintlcx 改成用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;deploy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type: git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  repo: github创库地址.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  branch: master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置文件的冒号“:”后面有一个空格&lt;/li&gt;
&lt;li&gt;repo: github创库地址.git&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;hexo命令行使用&quot;&gt;&lt;a href=&quot;#hexo命令行使用&quot; class=&quot;headerlink&quot; title=&quot;hexo命令行使用&quot;&gt;&lt;/a&gt;hexo命令行使用&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;常用命令：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo help #查看帮助&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo init #初始化一个目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo new &amp;quot;postName&amp;quot; #新建文章&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo new page &amp;quot;pageName&amp;quot; #新建页面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo generate #生成网页，可以在 public 目录查看整个网站的文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo server #本地预览，&amp;apos;Ctrl+C&amp;apos;关闭&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo deploy #部署.deploy目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo clean #清除缓存，强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;简写：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo n == hexo new&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo g == hexo generate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo s == hexo server&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo d == hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;使用GitHub&quot;&gt;&lt;a href=&quot;#使用GitHub&quot; class=&quot;headerlink&quot; title=&quot;使用GitHub&quot;&gt;&lt;/a&gt;使用GitHub&lt;/h1&gt;&lt;h2 id=&quot;注册账号&quot;&gt;&lt;a href=&quot;#注册账号&quot; class=&quot;headerlink&quot; title=&quot;注册账号&quot;&gt;&lt;/a&gt;注册账号&lt;/h2&gt;&lt;p&gt;前往GitHub官网注册账号，按照网站提示注册。&lt;/p&gt;
&lt;h2 id=&quot;创建代码仓库&quot;&gt;&lt;a href=&quot;#创建代码仓库&quot; class=&quot;headerlink&quot; title=&quot;创建代码仓库&quot;&gt;&lt;/a&gt;创建代码仓库&lt;/h2&gt;&lt;p&gt;这个仓库的名字需要和你的账号对应。格式: yourname.github.io&lt;/p&gt;
&lt;p&gt;具体使用GitHub可以参考：&lt;a href=&quot;http://charsdavy.github.io/2016/05/20/github-using/&quot;&gt;《GitHub 使用》&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;编辑文章&quot;&gt;&lt;a href=&quot;#编辑文章&quot; class=&quot;headerlink&quot; title=&quot;编辑文章&quot;&gt;&lt;/a&gt;编辑文章&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 新建文章&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &amp;quot;标题&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 _posts 目录下会生成文件标题.md&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;title: Hello World&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;date: 2015-07-30 07:56:29 #发表日期，一般不改动&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;categories: hexo #文章文类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tags: [hexo,github] #文章标签，多于一项时用这种格式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;正文，使用Markdown语法书写&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;编辑完后保存, 预览&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;hexo部署&quot;&gt;&lt;a href=&quot;#hexo部署&quot; class=&quot;headerlink&quot; title=&quot;hexo部署&quot;&gt;&lt;/a&gt;hexo部署&lt;/h1&gt;&lt;p&gt;执行下列指令完成部署&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo generate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以下提示说明部署成功&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[info] Deploy done: git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;hexo插件使用&quot;&gt;&lt;a href=&quot;#hexo插件使用&quot; class=&quot;headerlink&quot; title=&quot;hexo插件使用&quot;&gt;&lt;/a&gt;hexo插件使用&lt;/h1&gt;&lt;h2 id=&quot;添加rss订阅功能&quot;&gt;&lt;a href=&quot;#添加rss订阅功能&quot; class=&quot;headerlink&quot; title=&quot;添加rss订阅功能&quot;&gt;&lt;/a&gt;添加rss订阅功能&lt;/h2&gt;&lt;p&gt;安装hexo-generator-feed插件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm install hexo-generator-feed --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;安装完后，会在node_modules目录下生成hexo-generator-feed目录。然后将其配置到根目录的_config.yml&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# Extensions&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## Plugins: http://hexo.io/plugins/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#RSS订阅&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plugin:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- hexo-generator-feed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#Feed Atom&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;feed: #可选项，可以不填&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;type: atom&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;path: atom.xml&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;limit: 20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后，在你当前主题下的_config.yml下，添加RSS订阅链接即可，这里博主用的是Yilia主题，subnav下添加rss：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# SubNav&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;subnav:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rss: &amp;quot;/atom.xml&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;至此，博客搭建完成，基本使用介绍完毕。希望对大家有所帮助。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：本文章主要介绍使用hexo框架搭建博客，使用GitHub免费托管自己的博客代码，并使用GitHub Pages提供的免费服务。换句话说，就是使用免费资源搭建属于自己的博客网站。&lt;/p&gt;
    
    </summary>
    
      <category term="应用实战" scheme="http://charsdavy.github.io/categories/apply/"/>
    
    
      <category term="hexo" scheme="http://charsdavy.github.io/tags/script/"/>
    
  </entry>
  
  <entry>
    <title>YYModel源代码阅读 - 基础知识</title>
    <link href="http://charsdavy.github.io/2016/05/27/YYModel-reading/"/>
    <id>http://charsdavy.github.io/2016/05/27/YYModel-reading/</id>
    <published>2016-05-27T12:51:21.000Z</published>
    <updated>2016-06-04T02:09:36.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：YYModel堪称神级大作，虽然不免一些小bug，但是完全不影响膝盖碎一地。文章主要分享在阅读YYModel源代码时，所引发的知识点的补充与思考。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这段时间因为工作需要，阅读了YYModel这个开源框架，至于它能做什么，最直白的讲述就是JSON与Model之间的相互转化。&lt;/p&gt;
&lt;p&gt;源代码在&lt;a href=&quot;https://github.com/ibireme/YYModel&quot;&gt;Github&lt;/a&gt;，大家可以自行&lt;code&gt;git clone&lt;/code&gt;或者download。&lt;/p&gt;
&lt;p&gt;接下来，笔者主要分析阅读源代码而引出的各种问题与知识点，不足之处请大家指正。&lt;/p&gt;
&lt;h1 id=&quot;NS-ASSUME-NONNULL-BEGIN-amp-NS-ASSUME-NONNULL-END&quot;&gt;&lt;a href=&quot;#NS-ASSUME-NONNULL-BEGIN-amp-NS-ASSUME-NONNULL-END&quot; class=&quot;headerlink&quot; title=&quot;NS_ASSUME_NONNULL_BEGIN &amp;amp; NS_ASSUME_NONNULL_END&quot;&gt;&lt;/a&gt;NS_ASSUME_NONNULL_BEGIN &amp;amp; NS_ASSUME_NONNULL_END&lt;/h1&gt;&lt;p&gt;这组宏是成对使用的，不得不说我们自己写代码的时候使用的很少，以至于遗漏这个知识点，现在我们就来看看这两个宏会引出什么问题。&lt;/p&gt;
&lt;p&gt;这组宏会引出几个关于Objective-C新特性的知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Nullability Annotations&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Lightweight Generics&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;__kindof&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Nullability-Annotations&quot;&gt;&lt;a href=&quot;#Nullability-Annotations&quot; class=&quot;headerlink&quot; title=&quot;Nullability Annotations&quot;&gt;&lt;/a&gt;Nullability Annotations&lt;/h2&gt;&lt;p&gt;我们都知道在swift中，可以使用!和?来表示一个对象是optional的还是non-optional，如view?和view!。而在 Objective-C中则没有这一区分，view既可表示这个对象是optional，也可表示是non-optioanl。这样就会造成一个问题：在 Swift与Objective-C混编时，Swift编译器并不知道一个Objective-C对象到底是optional还是non-optional，因此这种情况下编译器会隐式地将Objective-C的对象当成是non-optional。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，苹果在Xcode 6.3引入了一个Objective-C的新特性：&lt;strong&gt;nullability annotations&lt;/strong&gt;。这一新特性的核心是两个新的类型注释：&lt;strong&gt; __nullable&lt;/strong&gt; 和 &lt;strong&gt;__nonnull&lt;/strong&gt; 。从字面上我们可以猜到，&lt;code&gt;__nullable&lt;/code&gt;表示对象可以是NULL或nil，而&lt;code&gt;__nonnull&lt;/code&gt;表示对象不应该为空。当我们不遵循这一规则时，编译器就会给出警告。&lt;/p&gt;
&lt;p&gt;我们来看看以下的实例，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface TestNullabilityClass ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, copy) NSArray * items;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)itemWithName:(NSString * __nonnull)name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation TestNullabilityClass&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)testNullability &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self itemWithName:nil];    // 编译器警告：Null passed to a callee that requires a non-null argument&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)itemWithName:(NSString * __nonnull)name &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不过这只是一个警告，程序还是能编译通过并运行。&lt;/p&gt;
&lt;p&gt;事实上，在任何可以使用const关键字的地方都可以使用&lt;code&gt;__nullable&lt;/code&gt;和&lt;code&gt;__nonnull&lt;/code&gt;，不过这两个关键字仅限于使用在指针类型上。而在方法的声明中，我们还可以使用不带下划线的&lt;code&gt;nullable&lt;/code&gt;和&lt;code&gt;nonnull&lt;/code&gt;，如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (nullable id)itemWithName:(NSString * nonnull)name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在属性声明中，也增加了两个相应的特性，因此上例中的items属性可以如下声明：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, copy, nonnull) NSArray * items;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当然也可以用以下这种方式：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, copy) NSArray * __nonnull items;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;推荐使用nonnull这种方式，这样可以让属性声明看起来更清晰。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Nonnull区域设置-Audited-Regions&quot;&gt;&lt;a href=&quot;#Nonnull区域设置-Audited-Regions&quot; class=&quot;headerlink&quot; title=&quot;Nonnull区域设置(Audited Regions)&quot;&gt;&lt;/a&gt;Nonnull区域设置(Audited Regions)&lt;/h3&gt;&lt;p&gt;如果需要每个属性或每个方法都去指定&lt;code&gt;nonnull&lt;/code&gt;和&lt;code&gt;nullable&lt;/code&gt;，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：&lt;strong&gt;NS_ASSUME_NONNULL_BEGIN&lt;/strong&gt;和&lt;strong&gt;NS_ASSUME_NONNULL_END&lt;/strong&gt;。在这两个宏之间的代码，所有简单指针对象都被假定为 &lt;code&gt;nonnull&lt;/code&gt;，因此我们只需要去指定那些&lt;code&gt;nullable&lt;/code&gt;的指针。如下代码所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NS_ASSUME_NONNULL_BEGIN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface TestNullabilityClass ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, copy) NSArray * items;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)itemWithName:(nullable NSString *)name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NS_ASSUME_NONNULL_END&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在上面的代码中，items属性默认是nonnull的，itemWithName:方法的返回值也是nonnull，而参数是指定为nullable的。&lt;/p&gt;
&lt;p&gt;不过，为了安全起见，苹果还制定了几条规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;typedef定义的类型的nullability特性通常依赖于上下文，即使是在Audited Regions中，也不能假定它为nonnull。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;复杂的指针类型(如id &lt;em&gt;)必须显示去指定是nonnull还是nullable。例如，指定一个指向nullable对象的nonnull指针，可以使用”__nullable id &lt;/em&gt; __nonnull”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们经常使用的NSError **通常是被假定为一个指向nullable NSError对象的nullable指针。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;兼容性&quot;&gt;&lt;a href=&quot;#兼容性&quot; class=&quot;headerlink&quot; title=&quot;兼容性&quot;&gt;&lt;/a&gt;兼容性&lt;/h3&gt;&lt;p&gt;因为Nullability Annotations是Xcode 6.3新加入的，所以我们需要考虑之前的老代码。实际上，苹果已以帮我们处理好了这种兼容问题，我们可以安全地使用它们：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;老代码仍然能正常工作，即使对nonnull对象使用了nil也没有问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;老代码在需要和swift混编时，在新的swift编译器下会给出一个警告。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;nonnull不会影响性能。事实上，我们仍然可以在运行时去判断我们的对象是否为nil。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事实上，我们可以将nonnull/nullable与我们的断言和异常一起看待，其需要处理的问题都是同一个：违反约定是一个程序员的错误。特别是，返回值是我们可控的东西，如果返回值是nonnull的，则我们不应该返回nil，除非是为了向后兼容。&lt;/p&gt;
&lt;h2 id=&quot;Lightweight-Generics&quot;&gt;&lt;a href=&quot;#Lightweight-Generics&quot; class=&quot;headerlink&quot; title=&quot;Lightweight Generics&quot;&gt;&lt;/a&gt;Lightweight Generics&lt;/h2&gt;&lt;p&gt;Lightweight Generics 轻量级泛型，轻量是因为这是个纯编译器的语法支持（LLVM 7.0），和 Nullability 一样，没有借助任何 objc runtime 的升级，也就是说，这个新语法在 Xcode 7 上可以使用且完全向下兼容（更低的 iOS 版本）&lt;/p&gt;
&lt;h3 id=&quot;带泛型的容器&quot;&gt;&lt;a href=&quot;#带泛型的容器&quot; class=&quot;headerlink&quot; title=&quot;带泛型的容器&quot;&gt;&lt;/a&gt;带泛型的容器&lt;/h3&gt;&lt;p&gt;这无疑是本次最重大的改进，有了泛型后终于可以指定容器类中对象的类型了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSArray&amp;lt;NSString *&amp;gt; *strings = @[@&amp;quot;sun&amp;quot;, @&amp;quot;yuan&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDictionary&amp;lt;NSString *, NSNumber *&amp;gt; *mapping = @&amp;#123;@&amp;quot;a&amp;quot;: @1, @&amp;quot;b&amp;quot;: @2&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回值的 id 被替换成具体的类型后，令人感动的代码提示也出来了。&lt;/p&gt;
&lt;p&gt;假如向泛型容器中加入错误的对象，编译器会不开心的。&lt;/p&gt;
&lt;p&gt;系统中常用的一系列容器类型都增加了泛型支持，甚至连 &lt;code&gt;NSEnumerator&lt;/code&gt; 都支持了，这是非常 Nice 的改进。和 &lt;code&gt;Nullability&lt;/code&gt; 一样，我认为最大的意义还是丰富了接口描述信息，对比下面两种写法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (readonly) NSArray *imageURLs;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (readonly) NSArray&amp;lt;NSURL *&amp;gt; *imageURLs;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不用多想就清楚下面的数组中存的是什么，避免了 &lt;code&gt;NSString&lt;/code&gt; 和 &lt;code&gt;NSURL&lt;/code&gt; 的混乱。&lt;/p&gt;
&lt;h3 id=&quot;自定义泛型类&quot;&gt;&lt;a href=&quot;#自定义泛型类&quot; class=&quot;headerlink&quot; title=&quot;自定义泛型类&quot;&gt;&lt;/a&gt;自定义泛型类&lt;/h3&gt;&lt;p&gt;比起使用系统的泛型容器，更好玩的是自定义一个泛型类，目前这里还没什么文档，但拦不住我们写测试代码，假设我们要自定义一个 Stack 容器类：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface Stack&amp;lt;ObjectType&amp;gt; : NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)pushObject:(ObjectType)object;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (ObjectType)popObject;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, readonly) NSArray&amp;lt;ObjectType&amp;gt; *allObjects;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个 &lt;code&gt;ObjectType&lt;/code&gt; 是传入类型的 &lt;code&gt;placeholder&lt;/code&gt;，它只能在 &lt;code&gt;@interface&lt;/code&gt; 上定义（类声明、类扩展、Category），如果你喜欢用 T 表示也 OK，这个类型在 &lt;code&gt;@interface&lt;/code&gt; 和 &lt;code&gt;@end&lt;/code&gt; 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型，应该说一切都是符合预期的。我们还可以给 ObjectType 增加类型限制，比如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 只接受 NSNumber * 的泛型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface Stack&amp;lt;ObjectType: NSNumber *&amp;gt; : NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 只接受满足 NSCopying 协议的泛型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface Stack&amp;lt;ObjectType: id&amp;lt;NSCopying&amp;gt;&amp;gt; : NSObject&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;若什么都不加，表示接受任意类型 ( id )；当类型不满足时编译器将产生 error。&lt;br&gt;实例化一个 Stack，一切工作正常：&lt;/p&gt;
&lt;p&gt;对于多参数的泛型，用逗号隔开，其他都一样，可以参考 NSDictionary 的头文件。&lt;/p&gt;
&lt;h3 id=&quot;协变性和逆变性&quot;&gt;&lt;a href=&quot;#协变性和逆变性&quot; class=&quot;headerlink&quot; title=&quot;协变性和逆变性&quot;&gt;&lt;/a&gt;协变性和逆变性&lt;/h3&gt;&lt;p&gt;当类支持泛型后，它们的 Type 发生了变化，比如下面三个对象看上去都是 Stack，但实际上属于三个 Type：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Stack *stack; // Stack *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack&amp;lt;NSString *&amp;gt; *stringStack; // Stack&amp;lt;NSString *&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack&amp;lt;NSMutableString *&amp;gt; *mutableStringStack; // Stack&amp;lt;NSMutableString *&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当其中两种类型做类型转化时，编译器需要知道哪些转化是允许的，哪些是禁止的，比如，默认情况下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Stack *stack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack&amp;lt;NSString *&amp;gt; *stringStack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack&amp;lt;NSMutableString *&amp;gt; *mutableStringStack; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stack = stringStack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stack = mutableStringStack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stringStack = stack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stringStack = mutableStringStack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mutableStringStack = stack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mutableStringStack = stringStack&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在Xcode中我们可以看到，不指定泛型类型的 Stack 可以和任意泛型类型转化，但指定了泛型类型后，两个不同类型间是不可以强转的，假如你希望主动控制转化关系，就需要使用泛型的协变性和逆变性修饰符了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__covariant - 协变性，子类型可以强转到父类型（里氏替换原则）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__contravariant - 逆变性，父类型可以强转到子类型（WTF）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;协变&quot;&gt;&lt;a href=&quot;#协变&quot; class=&quot;headerlink&quot; title=&quot;协变&quot;&gt;&lt;/a&gt;协变&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface Stack&amp;lt;__covariant ObjectType&amp;gt; : NSObject&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;逆变&quot;&gt;&lt;a href=&quot;#逆变&quot; class=&quot;headerlink&quot; title=&quot;逆变&quot;&gt;&lt;/a&gt;逆变&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface Stack&amp;lt;__contravariant ObjectType&amp;gt; : NSObject&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;协变是非常好理解的，像 &lt;code&gt;NSArray&lt;/code&gt; 的泛型就用了协变的修饰符。&lt;/p&gt;
&lt;h2 id=&quot;kindof&quot;&gt;&lt;a href=&quot;#kindof&quot; class=&quot;headerlink&quot; title=&quot;__kindof&quot;&gt;&lt;/a&gt;__kindof&lt;/h2&gt;&lt;p&gt;&lt;code&gt;__kindof&lt;/code&gt; 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 &lt;code&gt;UITableView&lt;/code&gt; 的这个方法来说：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用时前面基本会使用 &lt;code&gt;UITableViewCell&lt;/code&gt; 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 &lt;code&gt;UITableViewCell&lt;/code&gt; 或 &lt;code&gt;UITableViewCell&lt;/code&gt; 子类的实例，于是新的 &lt;code&gt;__kindof&lt;/code&gt; 关键字解决了这个问题：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView 的 subviews 属性被修改成了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, readonly, copy) NSArray&amp;lt;__kindof UIView *&amp;gt; *subviews;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，写下面的代码时就没有任何警告了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIButton *button = view.subviews.lastObject;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;NS-ENUM-amp-NS-OPTIONS&quot;&gt;&lt;a href=&quot;#NS-ENUM-amp-NS-OPTIONS&quot; class=&quot;headerlink&quot; title=&quot;NS_ENUM &amp;amp; NS_OPTIONS&quot;&gt;&lt;/a&gt;NS_ENUM &amp;amp; NS_OPTIONS&lt;/h1&gt;&lt;p&gt;枚举是指将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。&lt;/p&gt;
&lt;p&gt;枚举本质上是一个整数，枚举的作用是把值限定在指定的范围内，并且增加代码的可读性。 枚举的成员如果没有显示指定值，那么第一个成员的值总是0，后面成员的值依次递增。枚举可以直接用于比较。&lt;/p&gt;
&lt;p&gt;一般我们声明枚举：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 声明枚举类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;enum Direction &amp;#123;up, down, left = 10, right&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main(int argc, const char * argv[])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其中up = 0, down = 1, left = 10, right = 11。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们会发现枚举中一些不可自定义的部分，例如，枚举名。&lt;/p&gt;
&lt;p&gt;NS_ENUM 和 NS_OPTIONS 都不算太古老的宏，在iOS 6 / OS X Mountain Lion才开始有，它们都是代替 enum 的更好的办法。&lt;/p&gt;
&lt;h2 id=&quot;NS-ENUM&quot;&gt;&lt;a href=&quot;#NS-ENUM&quot; class=&quot;headerlink&quot; title=&quot;NS_ENUM&quot;&gt;&lt;/a&gt;NS_ENUM&lt;/h2&gt;&lt;p&gt;如果要在早期的iOS或OS X系统中使用这两个宏，简单定义一下就好&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#ifndef NS_ENUM&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在OS X 10.4 中的原始定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define NS_ENUM(_type, _name) CF_ENUM(_type, _name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define NS_OPTIONS(_type, _name) CF_OPTIONS(_type, _name)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在之前枚举可以这么定义：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef enum &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellStyleDefault,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellStyleValue1,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellStyleValue2,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellStyleSubtitle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef NSInteger UITableViewCellStyle;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在，有了统一的风格&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef NS_ENUM(NSInteger, UITableViewCellSelectionStyle) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellSelectionStyleNone,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellSelectionStyleBlue,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellSelectionStyleGray,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellSelectionStyleDefault&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;NS_ENUM&lt;/code&gt; 的第一个参数是用于存储的新类型的类型。在64位环境下，&lt;code&gt;UITableViewCellStyle&lt;/code&gt; 和 &lt;code&gt;NSInteger&lt;/code&gt; 一样有8 bytes长。你要保证你给出的所有值能被该类型容纳，否则就会产生错误。第二个参数是新类型的名字。大括号里面和以前一样，是你要定义的各种值。&lt;/p&gt;
&lt;h2 id=&quot;NS-OPTIONS&quot;&gt;&lt;a href=&quot;#NS-OPTIONS&quot; class=&quot;headerlink&quot; title=&quot;NS_OPTIONS&quot;&gt;&lt;/a&gt;NS_OPTIONS&lt;/h2&gt;&lt;p&gt;语法和 &lt;code&gt;NS_ENUM&lt;/code&gt; 完全相同，但这个宏提示编译器值是如何通过位掩码 | 组合在一起的。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef NS_OPTIONS(NSUInteger, AMGResizing) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AMGResizingNone            = 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AMGResizingFlexibleWidth   = 1 &amp;lt;&amp;lt; 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AMGResizingFlexibleHeight  = 1 &amp;lt;&amp;lt; 1,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AMGResizingFlexibleUnicorn = 1 &amp;lt;&amp;lt; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;attribute-always-inline&quot;&gt;&lt;a href=&quot;#attribute-always-inline&quot; class=&quot;headerlink&quot; title=&quot;attribute((always_inline))&quot;&gt;&lt;/a&gt;&lt;strong&gt;attribute&lt;/strong&gt;((always_inline))&lt;/h1&gt;&lt;p&gt;我们知道一般的函数调用都会通过call的方式来调用，这样让攻击很容易对一个函数做手脚，如果是以&lt;code&gt;inline&lt;/code&gt;的方式编译的会，会把该函数的code拷贝到每次调用该函数的地方。而&lt;code&gt;static&lt;/code&gt;会让生成的二进制文件中没有清晰的符号表，让逆向的人很难弄清楚逻辑。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__attribute__((always_inline))&lt;/code&gt; 的意思是强制内联，所有加了&lt;code&gt;__attribute__((always_inline))&lt;/code&gt; 的函数再被调用时不会被编译成函数调用而是直接扩展到调用函数体内，比如定义了函数&lt;br&gt;&lt;code&gt;__attribute__((always_inline)) void a()&lt;/code&gt;&lt;br&gt;和&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void b()｛  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;｝&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;b 调用 a 函数的汇编代码不会是跳转到a执行，而是 a 函数的代码直接在 b 内成为 b 的一部分。&lt;br&gt;&lt;code&gt;#define __inline __attribute__((always_inline))&lt;/code&gt; 的意思就是用&lt;br&gt;&lt;code&gt;__inline&lt;/code&gt; 代替&lt;code&gt;__attribute__((always_inline))&lt;/code&gt;&lt;br&gt;内声明a的时候可以直接写成&lt;code&gt;__inline void a()&lt;/code&gt; 这样比较方便因为&lt;code&gt;__attribute__((always_inline))&lt;/code&gt; 字多。&lt;/p&gt;
&lt;h1 id=&quot;undef&quot;&gt;&lt;a href=&quot;#undef&quot; class=&quot;headerlink&quot; title=&quot;undef&quot;&gt;&lt;/a&gt;undef&lt;/h1&gt;&lt;p&gt;这是预编译指令，和&lt;code&gt;#define&lt;/code&gt;搭配使用，意思是取消之前的宏定义。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define PROC_ADD &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void main(void) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#ifdef PROC_ADD &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Do this code here then undefined it to run the code in the else &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// processing work &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#undef PROC_ADD &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#else &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// now that PROC_ADD has been undefined run this code &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// processing work &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;unsafe-unretained&quot;&gt;&lt;a href=&quot;#unsafe-unretained&quot; class=&quot;headerlink&quot; title=&quot;__unsafe_unretained&quot;&gt;&lt;/a&gt;__unsafe_unretained&lt;/h1&gt;&lt;p&gt;&lt;code&gt;__unsafe_unretained&lt;/code&gt;是对对象的非zeroing的weak reference，意思是当对象所指向的内存被销毁了，对象还存在，称为“野指针”。&lt;/p&gt;
&lt;p&gt;在iOS引入了Automatic Reference Count（ARC）之后，编译器可以在编译时对obj-c对象进行内存管理。大致规则如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;alloc的要release;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;retain/copy的要release;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSAutoreleasePool在ARC中被禁止使用,替换成@autoreleasepool 函数体;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;使用@ autoreleasepool,在函数入口的时候,autorelease pool入栈,正常退出时,autorelease pool出栈,从而释放变量.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;注意:@ autoreleasepool在非ARC模式下,也能使用,并据说使用@autoreleasepool比使用NSAutoreleasePool速度能快6倍, 明显提升程序性能.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;package&quot;&gt;&lt;a href=&quot;#package&quot; class=&quot;headerlink&quot; title=&quot;@package&quot;&gt;&lt;/a&gt;@package&lt;/h1&gt;&lt;p&gt;为了强制一个对象隐藏其数据，编译器限制实例变量范围以限制其在程序中的可见性，但是为了提供灵活性，苹果也让开发者显式设置范围。&lt;/p&gt;
&lt;p&gt;以下是这些关键字的使用范围：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@private&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The instance variable is accessible only within the class that declares it.&lt;/p&gt;
&lt;p&gt;实例变量只能被声明它的类访问.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@protected&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The instance variable is accessible within the class that declares it and within classes that inherit it. All instance variables without an explicit scope directive have @protected scope.&lt;/p&gt;
&lt;p&gt;实例变量能被声明它的类和子类访问，所有没有显式制定范围的实例变量都是.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@public&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The instance variable is accessible everywhere.&lt;/p&gt;
&lt;p&gt;实例变量可以被在任何地方访问.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@package&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Using the modern runtime, an &lt;code&gt;@package&lt;/code&gt; instance variable has &lt;code&gt;@public&lt;/code&gt; scope inside the executable image that implements the class, but acts like &lt;code&gt;@private&lt;/code&gt; outside.使用modern运行时，一个&lt;code&gt;@package&lt;/code&gt;实例变量在实现这个类的可执行文件镜像中实际上是&lt;code&gt;@public&lt;/code&gt;的，但是在外面就是&lt;code&gt;@private&lt;/code&gt;【runtime需要再看一下苹果文档Runtime Programming Guide】&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;@package&lt;/code&gt; scope for Objective-C instance variables is analogous to private_extern for C variables and functions. Any code outside the class implementation’s image that tries to use the instance variable gets a link error.&lt;/p&gt;
&lt;p&gt;Objective-C中的&lt;code&gt;@package&lt;/code&gt;与C语言中变量和函数的private_extern类似。任何在实现类的镜像之外的代码想使用这个实例变量都会引发link error&lt;/p&gt;
&lt;p&gt;This scope is most useful for instance variables in framework classes, where &lt;code&gt;@private&lt;/code&gt; may be too restrictive but &lt;code&gt;@protected&lt;/code&gt; or &lt;code&gt;@public&lt;/code&gt; too permissive.&lt;/p&gt;
&lt;p&gt;这个类型最常用于框架类的实例变量，使用&lt;code&gt;@private&lt;/code&gt;太限制，使用&lt;code&gt;@protected&lt;/code&gt;或者&lt;code&gt;@public&lt;/code&gt;又太开放. |&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：YYModel堪称神级大作，虽然不免一些小bug，但是完全不影响膝盖碎一地。文章主要分享在阅读YYModel源代码时，所引发的知识点的补充与思考。&lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="开源框架" scheme="http://charsdavy.github.io/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>iOS 并发概念浅析</title>
    <link href="http://charsdavy.github.io/2016/05/26/ios-simultaneously/"/>
    <id>http://charsdavy.github.io/2016/05/26/ios-simultaneously/</id>
    <published>2016-05-26T00:32:15.000Z</published>
    <updated>2016-06-04T02:09:36.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：并发（concurrency）是一个常用且较好的解决APP的流畅度方法，但并发涉及串行、并发、并行、同步、异步、多线程、GCD、NSOperation和NSOperationQueue等诸多容易混淆的概念。本文主要分享对一些易混淆概念的理解。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在进行iOS开发过程中，我们常会遇到网络请求、复杂计算、数据存取等比较耗时的操作，如果处理不合理，将对APP的流畅度产生较大影响。除了优化APP架构，并发（concurrency）是一个常用且较好的解决方法，但并发涉及串行、并发、并行、同步、异步、多线程、GCD、NSOperation和NSOperationQueue等诸多容易混淆的概念。接下来，主要分享对一些易混淆概念的理解。&lt;/p&gt;
&lt;h1 id=&quot;一、线程和任务&quot;&gt;&lt;a href=&quot;#一、线程和任务&quot; class=&quot;headerlink&quot; title=&quot;一、线程和任务&quot;&gt;&lt;/a&gt;一、线程和任务&lt;/h1&gt;&lt;p&gt;线程（thread） 和任务（task）是其他并发概念的基础，因此也是首要需理清的概念，以下是其要点，详细可参考&lt;a href=&quot;https://en.wikipedia.org/wiki/Thread_%28computing%29&quot;&gt;Thread (computing)&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Task_%28computing&quot;&gt;Task (computing)&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;1）任务（task）&quot;&gt;&lt;a href=&quot;#1）任务（task）&quot; class=&quot;headerlink&quot; title=&quot;1）任务（task）&quot;&gt;&lt;/a&gt;1）任务（task）&lt;/h2&gt;&lt;p&gt;a）任务（task）是从程序中划分出来，可以独立执行的代码片段；&lt;/p&gt;
&lt;p&gt;b）任务间可以添加依赖关系，如B任务依赖A任务，taskB.addDependency(taskA)，这意味着B任务的执行以A任务完成为前提。&lt;/p&gt;
&lt;p&gt;需要注意的是一个任务是否可以添加依赖，完全取决于任务封装类和其相关管理类的具体实现，GCD不支持任务依赖，NSOperationQueue就支持任务依赖。&lt;/p&gt;
&lt;p&gt;下面的代码是对一个任务的简单封装，并支持任务间的依赖。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//Task是一个任务的简单封装类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Task &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let taskBlock: () -&amp;gt; ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var dependencies = [Task]() &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    init(block: () -&amp;gt; ()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        taskBlock = block&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func addDependency(task: Task) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dependencies.append(task)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//初始化两个自定义任务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var taskA = Task()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //自定义任务A，自定义需要执行的代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var taskB = Task()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //自定义任务B，自定义需要执行的代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//添加依赖关系&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;taskB.addDependency(taskA)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;2）线程（thread）&quot;&gt;&lt;a href=&quot;#2）线程（thread）&quot; class=&quot;headerlink&quot; title=&quot;2）线程（thread）&quot;&gt;&lt;/a&gt;2）线程（thread）&lt;/h2&gt;&lt;p&gt;a）线程（thread）是代码执行的独立路径，一条线程只能同时执行一行代码（一行代码，其实就是一条处理器命令）。&lt;/p&gt;
&lt;p&gt;b）线程中代码管理是以任务（task）为单位，一条线程逐行执行一个任务中的代码（任务可以取消），完成后再逐行执行下一个任务中的代码。&lt;/p&gt;
&lt;p&gt;c）一条线程跳出一个任务的执行，即意味着这个任务的完成。因此，一条线程不能执行taskA一段时间后，还未完成就开始执行taskB，然后又返回执行taskA（这其实是单线程内的并发，与单核处理器的并发概念相同，具体实践中不存在线程内并发）。&lt;/p&gt;
&lt;h1 id=&quot;二、概念释疑&quot;&gt;&lt;a href=&quot;#二、概念释疑&quot; class=&quot;headerlink&quot; title=&quot;二、概念释疑&quot;&gt;&lt;/a&gt;二、概念释疑&lt;/h1&gt;&lt;h2 id=&quot;1）并行（parallelism）和并发（concurrency）&quot;&gt;&lt;a href=&quot;#1）并行（parallelism）和并发（concurrency）&quot; class=&quot;headerlink&quot; title=&quot;1）并行（parallelism）和并发（concurrency）&quot;&gt;&lt;/a&gt;1）并行（parallelism）和并发（concurrency）&lt;/h2&gt;&lt;p&gt;并发和并行都是指多个任务可以同时执行，都属于多线程编程概念，因此二者必然十分相近，容易混淆。二者区别只有一点，即是否多任务执行于严格的同一时刻。并发不是，而并行是。&lt;/p&gt;
&lt;p&gt;单核处理器时代（一个处理器同一时刻只能执行一条命令），为了实现多任务的同时执行，系统利用时间分片（time-slicing）技术，将处理器的执行时间切分为多个小片段，一会执行threadA，一会执行threadB，一会再执行threadA，即在多个线程（任务是在线程上执行的）之间来回跳动执行。虽不是真的多线程多任务同时执行，但由于处理器的处理速度非常快，在用户看来，仍然是同时执行的。这种伪多线程就是并发。&lt;/p&gt;
&lt;p&gt;多核处理器时代（不同处理器相互独立，可以同时执行各自的命令），多条线程完全可以严格同一时刻执行，这种真多线程就是并行。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//三个线程的并发&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread1 -&amp;gt; |---A---|             -&amp;gt;|---A---|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread2 ------&amp;gt;    -&amp;gt;|------B----|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread3 ------------------------------------&amp;gt; |------C------|&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述代码是三个线程的并发执行，可以看出thread1、thread2和thread3不可能严格同一时刻执行，但也都获得了处理器的一小段执行时间。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//三个线程的并行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread1 -&amp;gt; |-----A-----|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread2 -&amp;gt;       |------B----|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread3 -&amp;gt;     |------C------|&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述代码是三个线程的并行执行，可以看出thread1、thread2和thread3有一段时间同时执行。&lt;/p&gt;
&lt;p&gt;现在的终端设备无论是手机还是PC的处理器，大多都已是多核处理器，可以实现并行计算，但为了最大化的利用处理器的性能，现代处理器还是融合了time-slicing技术和多核技术，因此实际运行中，有时并发，有时并行。但相对来说，并发是个更广泛的概念，因此Apple的多线程编程叫做concurrency programming并发编程。汉语中，并发和并行的区别其实没那么清晰，可以互用，而且有时用并行更加明确，如串并行比串行、并发针对性更强。（为概念清晰起见，下文中有时会用并行，其实即是并发。）&lt;/p&gt;
&lt;h2 id=&quot;2）串并行与线程&quot;&gt;&lt;a href=&quot;#2）串并行与线程&quot; class=&quot;headerlink&quot; title=&quot;2）串并行与线程&quot;&gt;&lt;/a&gt;2）串并行与线程&lt;/h2&gt;&lt;h3 id=&quot;串行（serial）和并行&quot;&gt;&lt;a href=&quot;#串行（serial）和并行&quot; class=&quot;headerlink&quot; title=&quot;串行（serial）和并行&quot;&gt;&lt;/a&gt;串行（serial）和并行&lt;/h3&gt;&lt;p&gt;串行和并行主要区别在于一个任务的执行是否以上一个任务的完成为前提。串行中，一个任务的执行必须以上一个任务执行结束为前提；并行中，一个任务的执行与上一个任务的执行状态无关。以排队买票为例，串行像单个买票队伍，单个卖票窗口，必须一个一个来；串行像单个买票队伍，多个卖票窗口，多个人可以同时买票。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//三个串行任务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|-----A-----||------B--------||----C--|&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上文为三个串行任务，任务A完成后，才执行任务B，B结束后，才最后执行任务C。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//三个并发任务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|-----A-----|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      |------B----|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   |--C---|&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上文为三个并行任务，任务A早于任务C开始，却晚于任务C结束。&lt;/p&gt;
&lt;h3 id=&quot;串并行与线程&quot;&gt;&lt;a href=&quot;#串并行与线程&quot; class=&quot;headerlink&quot; title=&quot;串并行与线程&quot;&gt;&lt;/a&gt;串并行与线程&lt;/h3&gt;&lt;p&gt;串并行主要关注多个任务之间的相互依赖关系，与线程无关。但实际中，任务是在线程中执行的，是否串行一定在单线程上执行，并行一定在多个线程中执行呢？并非如此。&lt;/p&gt;
&lt;p&gt;单线程既可以实现串行，也可以实现并行。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//单线程串行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 thread -&amp;gt;   |----A-----||-----B-----------||-------C------|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//单线程并行（理论上，实际中不可行）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         A-Start ---------------------------------------- A-End  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           | B-Start ----------------------------------------|--- B-End  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           |   |     C-Start -------------------- C-End      |     |  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           V   V       V                           V         V     V      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 thread-&amp;gt; |-A-|---B---|-C-|-A-|-C-|--A--|-B-|--C--|---A-----|--B--|&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要指出的是单线程内的并行已经类似单核处理器，并不是本文提及的常规线程，现实中也不常见。&lt;/p&gt;
&lt;p&gt;多线程既可以实现串行，也可以实现并行，实际上，多线程串行和并行都很常见。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//多线程串行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread1 -&amp;gt; |----A-----|  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       \  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread2 ---------------&amp;gt;|-----B-----------|  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                           \  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread3 -----------------------------------&amp;gt;|-------C------|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//多线程并发&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread1 -&amp;gt;     |----A-----|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread2 -----&amp;gt;     |-----B-----------|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread3 ---------&amp;gt;     |-------C----------|&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;3）同步（synchronize）、异步（asynchronous）与线程&quot;&gt;&lt;a href=&quot;#3）同步（synchronize）、异步（asynchronous）与线程&quot; class=&quot;headerlink&quot; title=&quot;3）同步（synchronize）、异步（asynchronous）与线程&quot;&gt;&lt;/a&gt;3）同步（synchronize）、异步（asynchronous）与线程&lt;/h2&gt;&lt;p&gt;同步和异步是站在当前线程的角度，考察添加任务到新线程后，何时返回到当前线程执行下面的代码的问题，也即新添加的线程阻不阻塞当前线程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;override viewDidLoad() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_sync(queue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //block1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&amp;quot;-----1-----&amp;quot;) //1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&amp;quot;-----2-----&amp;quot;) //2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;block1是添加到系统全局队列中的新任务，由于是同步的，因此block1执行返回后，才会回到当前主线程，执行//2及以后的代码。输出结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-----1-----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-----2-----&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//viewDidLoad()在主线程中执行，因此当前线程为主线程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;override viewDidLoad() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //block1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&amp;quot;-----1-----&amp;quot;) //1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&amp;quot;-----2-----&amp;quot;) //2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;block1是添加到系统全局队列中的新任务，由于是异步的，因此block1添加全局队列后（会在另外一个线程上执行），不等到执行完成，就会返回到当前主线程，执行//2及以后的代码，所以输出结果可能为 21 12。但由于block1和主线程中的任务都是不耗时的简单任务，而创建新的线程是要消耗一定时间的（主线程一直存在，不用新创建），因此很可能的输出结果是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-----2-----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-----1-----&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;同异步结合的情形&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果同异步结合:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//viewDidLoad()在主线程中执行，因此当前线程为主线程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;override viewDidLoad() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //block1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&amp;quot;-----A-----&amp;quot;) //1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dispatch_async(dispatch_get_main_queue()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //block2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            print(&amp;quot;-----B-----&amp;quot;) //2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&amp;quot;-----C-----&amp;quot;) //3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&amp;quot;-----D-----&amp;quot;) //4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(true) &amp;#123; &amp;#125; //5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&amp;quot;-----E-----&amp;quot;) //6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;block1是添加到系统全局队列中的新任务，由于是异步的，因此block1添加全局队列后（会在另外一个线程上执行），不等到执行完成，就返回到当前主线程，执行//4及以后的代码，结果是block1所在的线程与主线程同时执行，因此理论上，D和A谁先输出不一定。但由于block1和主线程中的任务都是不耗时的简单任务，而创建新的线程是要消耗一定时间的（主线程一直存在，不用新创建），因此一般输出结果为DA。&lt;/p&gt;
&lt;p&gt;block1所在线程输出完A后，将block2添加到主调度队列中，由于是异步的，因此block2添加主调度队列后（会在主线程上执行），不等到执行完成，就返回到block2所在的线程，继续执行，因此A和C一定会输出，且C一定在A之后输出。但block2却不一定能执行，因为block1在执行时，主线程也在执行（主线程是串行单线程，任务按顺序一个一个执行），如果此时主线程执行到//5对应的死循环，则block2一定不能被执行，B一定不能被输出，如果此时主线程尚未执行到//5对应的死循环，block2已经添加到主线程中，则block2会被执行，B能被输出。但由于主线程无需另外创建，block1（所对应的线程需另外创建）执行到添加block2到主调度队列时，主线程很可能已经执行到//5对应的死循环，因此block2很可能不被执行。&lt;/p&gt;
&lt;p&gt;//6前有个死循环，因此E一定不会被输出。&lt;/p&gt;
&lt;p&gt;因此可能的输出结果是；DAC ADC ADCB DACB ACDB ACBD ABDC ABCD&lt;/p&gt;
&lt;p&gt;但很可能的输出结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-----D-----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-----A-----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-----C-----&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;4）同异步与串并行&quot;&gt;&lt;a href=&quot;#4）同异步与串并行&quot; class=&quot;headerlink&quot; title=&quot;4）同异步与串并行&quot;&gt;&lt;/a&gt;4）同异步与串并行&lt;/h2&gt;&lt;p&gt;串行和同步，并行和异步似是完全不同的概念，一个关注任务的独立关系，一个看中的是返回的时机。但事实上，串行和同步近似，并发和异步相同，他们指代的事情几乎完全相同。&lt;br&gt;就同步和串行而言，需要任务执行结束后才能返回，其实就是一个任务执行完成后，才能执行其他的任务，反应的就是串行依赖关系。&lt;/p&gt;
&lt;p&gt;而异步和并行就更相同了，不等任务执行完成，就直接返回，反应的就是并发任务之间的独立性。&lt;/p&gt;
&lt;p&gt;当然，同异步所暗含的串行和并行是当前线程的任务与新线程的任务之间的相互关系。&lt;/p&gt;
&lt;h1 id=&quot;三、GCD与NSOperationQueue&quot;&gt;&lt;a href=&quot;#三、GCD与NSOperationQueue&quot; class=&quot;headerlink&quot; title=&quot;三、GCD与NSOperationQueue&quot;&gt;&lt;/a&gt;三、GCD与NSOperationQueue&lt;/h1&gt;&lt;p&gt;GCD(grand central dispatch)和NSOperationQueue二者均是系统级的多线程封装，在使用时，我们只需创建任务队列即可，其他的如线程创立、任务分配等，均由系统自动处理。不得不说，这让多线程编程变得更高效，更简单，当然并不是没有坑。&lt;br&gt;需要强调的是，GCD和NSOperationQueue的使用核心是任务（task）和任务队列（task queue），暂时可以忘了线程（thread）这烦人的概念。&lt;/p&gt;
&lt;p&gt;关于GCD和NSOperationQueue网上已经有不少高质量的文章对其详细介绍，推荐&lt;a href=&quot;http://www.cocoachina.com/ios/20160201/15179.html&quot;&gt;《iOS并行开发：从NSOperation和调度队列开始》&lt;/a&gt;，其对基本概念、使用方法等的介绍非常清晰详尽，这里就不再赘述，只写一些个人认为容易忽略却影响认知深度的小知识点。当然如果你英语过硬，去直接看官方文档&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html&quot;&gt;《ConcurrencyProgrammingGuide》&lt;/a&gt;是最好的。&lt;/p&gt;
&lt;h2 id=&quot;1）GCD&quot;&gt;&lt;a href=&quot;#1）GCD&quot; class=&quot;headerlink&quot; title=&quot;1）GCD&quot;&gt;&lt;/a&gt;1）GCD&lt;/h2&gt;&lt;p&gt;GCD是基于C的API，因此比较底层。&lt;/p&gt;
&lt;p&gt;GCD所管理的调度队列（dispatch queue）主要有三类：串行队列（private dispatch queue）、并发队列 （global dispatch queue，又称全局调度队列）和主队列（main dispatch queue）。&lt;/p&gt;
&lt;p&gt;我们常用的 dispatch_get_global&lt;em&gt;queue(&lt;/em&gt;: _:)所获得的dispatch queue就是全局调度队列(global dispatch queue)，并发，而且全局调度队列是全局共用的，每一个优先级的全局调度队列只有一个实体。四种不同优先级的全局调度队列对应的四种优先级的线程，同一个优先级的全局调度队列可以同时拥有多条相应优先级的线程。&lt;/p&gt;
&lt;p&gt;dispatch_get_main_queue()所获得的dispatch queue是主调度队列，主调度队列是串行队列。&lt;/p&gt;
&lt;h2 id=&quot;2）NSOperationQueue&quot;&gt;&lt;a href=&quot;#2）NSOperationQueue&quot; class=&quot;headerlink&quot; title=&quot;2）NSOperationQueue&quot;&gt;&lt;/a&gt;2）NSOperationQueue&lt;/h2&gt;&lt;p&gt;NSOperationQueue是对GCD的Objective-C封装，相对于GCD具有更多先进的特性，如可以添加NSOperation依赖，取消NSOperation等。&lt;/p&gt;
&lt;p&gt;NSOperationQueue是并发队列，且不遵循先进先出（FIFO）排序原则。&lt;/p&gt;
&lt;h1 id=&quot;四、总结与感悟&quot;&gt;&lt;a href=&quot;#四、总结与感悟&quot; class=&quot;headerlink&quot; title=&quot;四、总结与感悟&quot;&gt;&lt;/a&gt;四、总结与感悟&lt;/h1&gt;&lt;p&gt;1）串并行、同异步与线程无关，单线程、多线程都可以实现串并行和同异步。&lt;/p&gt;
&lt;p&gt;2）串行和同步相同，异步和并行相同，他们只是看待同一件事物的角度不同。&lt;/p&gt;
&lt;p&gt;3）GCD和NSOperationQueue的使用核心是任务（task）和任务队列（task queue）。&lt;/p&gt;
&lt;p&gt;4）全局调度队列(global dispatch queue)是全局共用的，系统有时也会向这些调度队列添加系统任务。&lt;/p&gt;
&lt;p&gt;5) App的主调度队列是串行单线程队列。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：并发（concurrency）是一个常用且较好的解决APP的流畅度方法，但并发涉及串行、并发、并行、同步、异步、多线程、GCD、NSOperation和NSOperationQueue等诸多容易混淆的概念。本文主要分享对一些易混淆概念的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="iOS" scheme="http://charsdavy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>GitHub 使用</title>
    <link href="http://charsdavy.github.io/2016/05/20/github-using/"/>
    <id>http://charsdavy.github.io/2016/05/20/github-using/</id>
    <published>2016-05-20T14:17:11.000Z</published>
    <updated>2016-06-04T02:09:36.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：GitHub就是程序员的facebook，在这个开源、大神云集的地方，小菜是可以学到，找到很多很棒的资源的。那么，如何进入这个圈子呢？我们从使用开始。这篇文章主要讲解如何使用GitHub托管自己的代码，注意，托管是公开的喔，私有的要付费的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;下载github客户端软件&quot;&gt;&lt;a href=&quot;#下载github客户端软件&quot; class=&quot;headerlink&quot; title=&quot;下载github客户端软件&quot;&gt;&lt;/a&gt;下载github客户端软件&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;官网&lt;a href=&quot;https://help.github.com/&quot;&gt;下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Google搜索，一般用于windows7以前的系统&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;安装github软件&quot;&gt;&lt;a href=&quot;#安装github软件&quot; class=&quot;headerlink&quot; title=&quot;安装github软件&quot;&gt;&lt;/a&gt;安装github软件&lt;/h1&gt;&lt;p&gt;根据软件安装指导，按步骤安装即可。&lt;/p&gt;
&lt;h1 id=&quot;使用git命令提交&quot;&gt;&lt;a href=&quot;#使用git命令提交&quot; class=&quot;headerlink&quot; title=&quot;使用git命令提交&quot;&gt;&lt;/a&gt;使用git命令提交&lt;/h1&gt;&lt;h2 id=&quot;git-config&quot;&gt;&lt;a href=&quot;#git-config&quot; class=&quot;headerlink&quot; title=&quot;git config&quot;&gt;&lt;/a&gt;git config&lt;/h2&gt;&lt;p&gt;安装Git后首先要做的事情是设置用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.name &amp;quot;Chars Davy&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.email chars_d@example.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;重申一遍，只需要做一次这个设置。如果传递了 &lt;code&gt;--global&lt;/code&gt; 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要&lt;code&gt;--global&lt;/code&gt;选项。&lt;/p&gt;
&lt;h2 id=&quot;git-clone&quot;&gt;&lt;a href=&quot;#git-clone&quot; class=&quot;headerlink&quot; title=&quot;git clone&quot;&gt;&lt;/a&gt;git clone&lt;/h2&gt;&lt;p&gt;这是一种较为简单的初始化方式，当你已经有一个远程的Git版本库，只需要在本地克隆一份:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git  clone  git://github.com/someone/some_project.git   some_project&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的命令就是将&lt;code&gt;git://github.com/someone/some_project.git&lt;/code&gt;这个URL地址的远程版本库，完全克隆到本地some_project目录下。&lt;/p&gt;
&lt;h2 id=&quot;git-init-和-git-remote&quot;&gt;&lt;a href=&quot;#git-init-和-git-remote&quot; class=&quot;headerlink&quot; title=&quot;git init 和 git remote&quot;&gt;&lt;/a&gt;git init 和 git remote&lt;/h2&gt;&lt;p&gt;这种方式稍微复杂一些，当你本地创建了一个工作目录，你可以进入这个目录，使用&lt;code&gt;git init&lt;/code&gt;命令进行初始化；Git以后就会对该目录下的文件进行版本控制，这时候如果你需要将它放到远程服务器上，可以在远程服务器上创建一个目录，并把可访问的URL记录下来，此时你就可以利用&lt;code&gt;git remote add&lt;/code&gt;命令来增加一个远程服务器端，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git  remote  add  origin  git://github.com/someone/another_project.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的命令就会增加URL地址为&lt;code&gt;git: //github.com/someone/another_project.git&lt;/code&gt;，名称为origin的远程服务器，以后提交代码的时候只需要使用 origin别名即可。&lt;/p&gt;
&lt;h2 id=&quot;git-add&quot;&gt;&lt;a href=&quot;#git-add&quot; class=&quot;headerlink&quot; title=&quot;git add&quot;&gt;&lt;/a&gt;git add&lt;/h2&gt;&lt;p&gt;将当前更改或者新增的文件加入到Git的索引中，加入到Git的索引中就表示记入了版本历史中，这也是提交之前所需要执行的一步，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git add app/model/user.rb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就会增加&lt;code&gt;app/model/user.rb&lt;/code&gt;文件到Git的索引中，该功能类似于SVN的add，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git add .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的命令会将所有改动过的文件及文件夹迭代全部添加进本地代码仓库。&lt;/p&gt;
&lt;h2 id=&quot;git-commit&quot;&gt;&lt;a href=&quot;#git-commit&quot; class=&quot;headerlink&quot; title=&quot;git commit&quot;&gt;&lt;/a&gt;git commit&lt;/h2&gt;&lt;p&gt;提交当前工作空间的修改内容，类似于SVN的commit命令，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git commit -m story #3, add user model&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;提交的时候必须用-m来输入一条提交信息，该功能类似于SVN的commit，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git commit –m beta&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的命令会将beta作为log显示在代码提交记录中。&lt;/p&gt;
&lt;h2 id=&quot;git-push&quot;&gt;&lt;a href=&quot;#git-push&quot; class=&quot;headerlink&quot; title=&quot;git push&quot;&gt;&lt;/a&gt;git push&lt;/h2&gt;&lt;p&gt;将本地commit的代码更新到远程版本库中，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git push origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的命令就会将本地的代码更新到名为orgin的远程版本库中。&lt;/p&gt;
&lt;h1 id=&quot;git代码提交中可能遇到的问题&quot;&gt;&lt;a href=&quot;#git代码提交中可能遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;git代码提交中可能遇到的问题&quot;&gt;&lt;/a&gt;git代码提交中可能遇到的问题&lt;/h1&gt;&lt;p&gt;问题1：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;You can&amp;apos;t push to git://github.com/example/example_pro.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Use https://github.com/ example/example_pro.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote remove origin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git remote add origin git@github.com:user_name/user_repo.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;p&gt;如果在&lt;code&gt;git clone&lt;/code&gt;的时候用的是&lt;code&gt;git://github.com:xx/xxx.git&lt;/code&gt; 的形式, 那么就会出现这个问题，因为这个protocol是不支持push的，而使用&lt;code&gt;git clone git@github.com:lujinjianst/myNCCL.git&lt;/code&gt;就可以用git push。&lt;/p&gt;
&lt;p&gt;问题2：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Permission denied(publickey).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fatal:Could not read from remote repository.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;p&gt;在终端输入:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh-keygen -t rsa -C &amp;quot;chars&amp;quot;//注意,chars为用户名&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果执行成功。返回:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Generating public/private rsa key pair. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Enter file in which to save the key (/home/forwhat.cn/.ssh/id_rsa):&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这里就是设置存储地址了.反正我是直接按的回车,然后还会返回:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Enter passphrase (empty for no passphrase):&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再次直接回车。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Enter same passphrase again:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再次回车。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Your identification has been saved in /home/forwhat.cn/.ssh/id_rsa. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Your public key has been saved in /home/forwhat.cn/.ssh/id_rsa.pub. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The key fingerprint is:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;The key&amp;apos;s randomart image is: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+--[ RSA 2048]----+ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                 | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                 | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                 | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|    o            | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|   + .  S        | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  . = .  o       | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|   o + +o.o      | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|E o . o.=+.      | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|.+   ==+ooo.     | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+-----------------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样SSH key就生成了。直接cat一下就好了。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;:~/a$ cat /home/forwhat.cn/.ssh/id_rsa.pub&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;把显示出来的直接添加到github账户设置里边的SSH keys。&lt;br&gt;回来再git pull就开始远程拷贝代码了。&lt;/p&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;p&gt;没有在github账号添加SSH key。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：GitHub就是程序员的facebook，在这个开源、大神云集的地方，小菜是可以学到，找到很多很棒的资源的。那么，如何进入这个圈子呢？我们从使用开始。这篇文章主要讲解如何使用GitHub托管自己的代码，注意，托管是公开的喔，私有的要付费的。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://charsdavy.github.io/categories/tool/"/>
    
    
      <category term="Git" scheme="http://charsdavy.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>flappy bird 游戏实现</title>
    <link href="http://charsdavy.github.io/2016/05/05/flappy-bird-game/"/>
    <id>http://charsdavy.github.io/2016/05/05/flappy-bird-game/</id>
    <published>2016-05-05T13:40:44.000Z</published>
    <updated>2016-06-13T11:29:48.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：在博主还是学生的时候，flappyBird这款游戏非常火爆，最后等到Android版的出来之后，也是很痴迷的玩了一把。可是，博主游戏天赋一直平平，几度玩得想摔手机。本文主要介绍如何开发iOS平台的flappyBird，游戏中使用了原本软件的图片资源，仅作学习交流使用。博主实现的flappyBird游戏包含游戏等级设定，排行榜，音效等功能。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;技术点&quot;&gt;&lt;a href=&quot;#技术点&quot; class=&quot;headerlink&quot; title=&quot;技术点&quot;&gt;&lt;/a&gt;技术点&lt;/h1&gt;&lt;p&gt;flappyBird是单机游戏，主要涉及界面逻辑、图片资源、游戏动画、得分排行。&lt;/p&gt;
&lt;p&gt;为了实现这几个功能，需要使用以下几个技术框架：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AVFoundation&lt;/li&gt;
&lt;li&gt;归档&lt;/li&gt;
&lt;li&gt;模态视图&lt;/li&gt;
&lt;li&gt;NSTimer&lt;/li&gt;
&lt;li&gt;视图控件，包括UIImageView、UILabel、UITableView等&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;实现过程&quot;&gt;&lt;a href=&quot;#实现过程&quot; class=&quot;headerlink&quot; title=&quot;实现过程&quot;&gt;&lt;/a&gt;实现过程&lt;/h1&gt;&lt;p&gt;1、创建工程&lt;/p&gt;
&lt;p&gt;1）打开Xcode，点击新建工程，选择Single View Application模板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:05:05:flappy-bird-game:1.png?imageView/2/w/540&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt; 2）填写工程信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:05:05:flappy-bird-game:2.png?imageView/2/w/540&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、移除Main.storyboard文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:05:05:flappy-bird-game:3.png?imageView/2/w/300&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图是flappyBird的文件目录，因为Xcode6使用模板创建工程时会自动生成Main.storyboard文件，而工程中本人使用代码布局，所以可以移除Main.storyboard文件。具体操作方法可以参看本人另一篇文章：&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/chars/p/5150155.html&quot;&gt;《iOS学习之移除Main.storyboard》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、游戏界面布局&lt;br&gt;整体效果图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:05:05:flappy-bird-game:4.gif?imageView/2/w/300&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;需要说明的是，Game Over这个界面，首先需要隐藏或者等到游戏结束才创建。本人是选择在游戏判定结束时才创建并显示。&lt;/p&gt;
&lt;p&gt;4、游戏运行&lt;br&gt;这款游戏的两个关键点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用定时器驱动游戏界面运行，即游戏界面中的柱子高低变化与柱子的消失与产生。&lt;/li&gt;
&lt;li&gt;游戏结束的判定，这里涉及两个问题，一是碰撞检测，二是计分统计。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;具体实现部分代码&quot;&gt;&lt;a href=&quot;#具体实现部分代码&quot; class=&quot;headerlink&quot; title=&quot;具体实现部分代码&quot;&gt;&lt;/a&gt;具体实现部分代码&lt;/h1&gt;&lt;p&gt;1、计分统计&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(void)columnLabelClick &amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (topPipeFrame.origin.x == (100 + 30 - 70)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        columnNumber++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        columnLabel.text = [NSString stringWithFormat:@&amp;quot;%zi&amp;quot;,columnNumber];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2、绘制柱子&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(void)pipe &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //通道高度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSInteger tunnelHeight = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //根据游戏难度设定通道高度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if([[DataTool stringForKey:kRateKey] isEqualToString:@&amp;quot;ordinary&amp;quot;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tunnelHeight = 100;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;else if([[DataTool stringForKey:kRateKey] isEqualToString:@&amp;quot;general&amp;quot;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tunnelHeight = 90;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;else if([[DataTool stringForKey:kRateKey] isEqualToString:@&amp;quot;difficult&amp;quot;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tunnelHeight = 80;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;else if([[DataTool stringForKey:kRateKey] isEqualToString:@&amp;quot;hard&amp;quot;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tunnelHeight = 75;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else if([[DataTool stringForKey:kRateKey] isEqualToString:@&amp;quot;crazy&amp;quot;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tunnelHeight = 70;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //柱子图像&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSInteger tall = arc4random() % 200 + 40;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    topPipe = [[UIImageView alloc]initWithFrame:CGRectMake(320, -20, 70, tall)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    topPipe.image = [UIImage imageNamed:@&amp;quot;pipe&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:topPipe];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bottomPipe = [[UIImageView alloc]initWithFrame:CGRectMake(320, tall + tunnelHeight, 70, 400)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bottomPipe.image = [UIImage imageNamed:@&amp;quot;pipe&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:bottomPipe];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //把底部图片视图放在柱子视图上面    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view insertSubview:roadView aboveSubview:bottomPipe];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3、使用定时器，驱动游戏界面运行，并进行碰撞检测&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//添加定时器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;timer = [NSTimer scheduledTimerWithTimeInterval:0.01 target:self selector:@selector(onTimer) userInfo:nil repeats:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//定时器操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)onTimer &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //底部动画移动&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CGRect frame = roadView.frame;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (frame.origin.x == -15) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        frame.origin.x = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    frame.origin.x--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    roadView.frame = frame;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //上升&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (isTap == NO) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CGRect frame = birdsView.frame;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        frame.origin.y -= 3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        number += 3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        birdsView.frame = frame;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (number &amp;gt;= 60) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            isTap = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //下降&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(isTap == YES &amp;amp;&amp;amp; birdsView.frame.origin.y &amp;lt; 370)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CGRect frame = birdsView.frame;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        frame.origin.y++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        number -= 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        birdsView.frame = frame;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        number = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //柱子移动&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    topPipeFrame = topPipe.frame;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CGRect bottomPipeFrame = bottomPipe.frame;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    topPipeFrame.origin.x--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bottomPipeFrame.origin.x--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    topPipe.frame = topPipeFrame;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bottomPipe.frame = bottomPipeFrame;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (topPipeFrame.origin.x &amp;lt; -70) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self pipe];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //碰撞检测（交集）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bool topRet = CGRectIntersectsRect(birdsView.frame, topPipe.frame);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bool bottomRet = CGRectIntersectsRect(birdsView.frame, bottomPipe.frame);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (topRet == true || bottomRet == true) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self.soundTool playSoundByFileName:@&amp;quot;punch&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self onStop];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (topPipeFrame.origin.x == (100 + 30 - 70)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self.soundTool playSoundByFileName:@&amp;quot;pipe&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self columnLabelClick];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;4、更新分数，更新最佳分数与排行榜分数，并使用归档将数据持久化&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(void)updateScore &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //更新最佳成绩&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (columnNumber &amp;gt; [DataTool integerForKey:kBestScoreKey]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [DataTool setInteger:columnNumber forKey:kBestScoreKey];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //更新本局分数    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [DataTool setInteger:columnNumber forKey:kCurrentScoreKey];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //更新排行榜&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSArray *ranks = (NSArray *)[DataTool objectForKey:kRankKey];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableArray *newRanksM = [NSMutableArray array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSInteger count = ranks.count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BOOL isUpdate = NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (NSInteger i = 0; i &amp;lt; count; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSString *scoreStr = ranks[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSInteger score = [scoreStr integerValue];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (score &amp;lt; columnNumber &amp;amp;&amp;amp; isUpdate == NO) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            scoreStr = [NSString stringWithFormat:@&amp;quot;%zi&amp;quot;, columnNumber];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [newRanksM addObject:scoreStr];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            isUpdate = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            i--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            scoreStr = [NSString stringWithFormat:@&amp;quot;%zi&amp;quot;, score];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [newRanksM addObject:scoreStr];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (newRanksM.count &amp;gt; count) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [newRanksM removeLastObject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [DataTool setObject:newRanksM forKey:kRankKey];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;5、绘制GameOver提示显示&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(void)pullGameOver &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //游戏结束操作界面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    gameOver = [[GameOverView alloc] initWithFrame:CGRectMake(20, 160, 280, 300)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    gameOver.delegate = self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:gameOver];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;6、游戏停止操作&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(void)onStop &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //更新分数    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self updateScore];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //停止定时器    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [timer setFireDate:[NSDate distantFuture]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //弹出游戏结束操作界面    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self pullGameOver];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h1&gt;&lt;p&gt;这款游戏的实现还是很简单的，主要使用UIImageView自带的动画实现方式，即可实现bird的动画效果。使用NSTimer即可实现游戏场景的柱子移动，至于柱子的高度，则可以使用随机数方式在一定范围内实现高低变化。最后可以使用CGRectIntersectsRect来实现边界碰撞检测来判定游戏是否结束。&lt;/p&gt;
&lt;p&gt;以上是博主开发iOS版flappyBird的简要过程介绍，其中只包含了关键点的代码实现，具体完整游戏源代码地址：&lt;a href=&quot;https://github.com/CharsDavy/flappyBird&quot;&gt;https://github.com/CharsDavy/flappyBird&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：在博主还是学生的时候，flappyBird这款游戏非常火爆，最后等到Android版的出来之后，也是很痴迷的玩了一把。可是，博主游戏天赋一直平平，几度玩得想摔手机。本文主要介绍如何开发iOS平台的flappyBird，游戏中使用了原本软件的图片资源，仅作学习交流使用。博主实现的flappyBird游戏包含游戏等级设定，排行榜，音效等功能。&lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="iOS" scheme="http://charsdavy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>均匀分布随机函数的实现</title>
    <link href="http://charsdavy.github.io/2016/04/30/uniform-random/"/>
    <id>http://charsdavy.github.io/2016/04/30/uniform-random/</id>
    <published>2016-04-30T01:37:10.000Z</published>
    <updated>2016-06-04T02:09:36.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：随机函数可以说是用途很广。可是，系统提供的random函数，一般符合正态分布，所以说，这是伪随机函数。甚至在一些场合是非随机函数。为了满足项目需要，必须实现均匀分布。在此，分享博主实现均匀随机函数的实现过程与方法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;随机函数就是产生数的函数，C语言里使用rand(),srand()等随机函数实现随机数生成。&lt;/p&gt;
&lt;h1 id=&quot;函数简介&quot;&gt;&lt;a href=&quot;#函数简介&quot; class=&quot;headerlink&quot; title=&quot;函数简介&quot;&gt;&lt;/a&gt;函数简介&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int rand( void );&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回的是一个界于0～32767（0x7FFF）之间的伪随机数，包括0和32767。&lt;br&gt;C预先生成一组随机数，每次调用随机函数时从指针所指向的位置开始取值，因此使用rand()重复运行程序产生的随机数都是相同的，可以通过srand()函数来改变指针位置。&lt;br&gt;srand()会设置供rand()使用的随机数种子。如果在第一次使用rand()之前没有调用srand()，那么系统会自动调用srand()。而使用同种子相同的数调用 rand()会导致相同的随机数序列被生成。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void srand( unsigned int seed );&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;改变随机数表的指针位置（用seed变量控制）。&lt;br&gt;使用系统定时/计数器的值作为随机种子。每个种子对应一组根据算法预先生成的随机数，所以，在相同的平台环境下，不同时间产生的随机数会是不同的，相应的，若将srand（unsigned）time(NULL)改为srand(TP)（TP为任一常量），则无论何时运行、运行多少次得到的“随机数”都会是一组固定的序列，因此srand生成的随机数是伪随机数。&lt;br&gt;一般配合time(NULL)使用，因为时间每时每刻都在改变，产生的seed值都不同。&lt;/p&gt;
&lt;h1 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h1&gt;&lt;p&gt;使用rand函数生成的随机数严格满足正态分布。而在很多时候，我们希望随机数的生成不要满足正态分布，特别是在处理网络通信报文的时候。&lt;br&gt;例如，我们需要在交换机处理到海量报文时，能够使远端的从设备尽可能的分段同时向局端回应报文，以减轻局部报文处理压力。&lt;/p&gt;
&lt;h1 id=&quot;均匀分布随机函数实现&quot;&gt;&lt;a href=&quot;#均匀分布随机函数实现&quot; class=&quot;headerlink&quot; title=&quot;均匀分布随机函数实现&quot;&gt;&lt;/a&gt;均匀分布随机函数实现&lt;/h1&gt;&lt;h2 id=&quot;开发环境&quot;&gt;&lt;a href=&quot;#开发环境&quot; class=&quot;headerlink&quot; title=&quot;开发环境&quot;&gt;&lt;/a&gt;开发环境&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-b2f082073e33ca94.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;开发环境&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现步骤&quot;&gt;&lt;a href=&quot;#实现步骤&quot; class=&quot;headerlink&quot; title=&quot;实现步骤&quot;&gt;&lt;/a&gt;实现步骤&lt;/h2&gt;&lt;p&gt;1）打开Qt Creater，创建GUI工程&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-1c06b87e7e219e93.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;创建GUI工程&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-4b288fe958b3e962.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;项目文件结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;2）在mainwindow.h中添加函数声明&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void paintEvent(QPaintEvent *);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3）在mainwindow.cpp中添加函数实现&lt;/p&gt;
&lt;p&gt;导入头文件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;QPainter&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实现&lt;code&gt;void paintEvent(QPaintEvent *)&lt;/code&gt;函数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *Qt中函数paintEvent(QPaintEvent*)是被系统自动调用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *paintEvent(QPaintEvent *)函数是QWidget类中的虚函数，用于ui的绘制，会在多种情况下被其他函数自动调用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void MainWindow::paintEvent(QPaintEvent *)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QPainter painter(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QPen pen; //画笔&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pen.setColor(QColor(255,0,0)); //设置画笔颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    painter.setPen(pen); //添加画笔&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    long int r[kSum] = &amp;#123;0&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int j = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        r[i] = Uniform(0, 300);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;while(i &amp;lt; kSum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while((j + 30) &amp;lt; (kSum + 30))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        painter.drawPoint(j, r[j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;4）添加随机函数实现代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define kSum 1000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//算法一&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *均匀分布随机函数均匀化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;double _uniform(double min, double max, long int *seed) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    double t = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *seed = 2045 * (*seed) + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *seed = *seed - (*seed / 1048576) * 1048576;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t = (*seed) / 1048576.0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t = min + (max - min) * t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *均匀分布随机函数产生随机数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;long int Uniform(double min, double max) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    long int s = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    double r = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //srand((unsigned int)time(NULL)); /*同一个时间种子可能会从产生相同的随机数列*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s = rand();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    r = _uniform(min, max, &amp;amp;s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return ((long int)r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//算法二&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;double AverageRandom(double min, double max) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int minInteger = (int)(min * 10000);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int maxInteger = (int)(max * 10000);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int randInteger = rand() * rand();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int diffInteger = maxInteger - minInteger;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int resultInteger = randInteger % diffInteger + minInteger;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return (resultInteger/10000.0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;实现效果&quot;&gt;&lt;a href=&quot;#实现效果&quot; class=&quot;headerlink&quot; title=&quot;实现效果&quot;&gt;&lt;/a&gt;实现效果&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-af95ccbacb9b3231.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;实现效果&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h1&gt;&lt;p&gt;从图中可以看出，使用上述函数生成的随机数符合均匀分布。&lt;br&gt;本案例主要使用了Qt的绘图功能，用来直观展示生成随机数的效果。检验随机函数生成随机数的效果。&lt;/p&gt;
&lt;h1 id=&quot;附录&quot;&gt;&lt;a href=&quot;#附录&quot; class=&quot;headerlink&quot; title=&quot;附录&quot;&gt;&lt;/a&gt;附录&lt;/h1&gt;&lt;p&gt;最后附上该算法实现的全部代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//mainwindow.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#ifndef MAINWINDOW_H&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define MAINWINDOW_H&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;QMainWindow&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;namespace Ui &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class MainWindow;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class MainWindow : public QMainWindow&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Q_OBJECT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    explicit MainWindow(QWidget *parent = 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ~MainWindow();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void paintEvent(QPaintEvent *);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Ui::MainWindow *ui;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif // MAINWINDOW_H&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//mainwindow.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;mainwindow.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;ui_mainwindow.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;QPainter&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define kSum 1000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MainWindow::MainWindow(QWidget *parent) :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QMainWindow(parent),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui(new Ui::MainWindow)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;setupUi(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MainWindow::~MainWindow()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    delete ui;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *均匀分布随机函数均匀化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;double _uniform(double min, double max, long int *seed) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    double t = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *seed = 2045 * (*seed) + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *seed = *seed - (*seed / 1048576) * 1048576;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t = (*seed) / 1048576.0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t = min + (max - min) * t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *均匀分布随机函数产生随机数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;long int Uniform(double min, double max) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    long int s = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    double r = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //srand((unsigned int)time(NULL)); /*同一个时间种子可能会从产生相同的随机数列*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s = rand();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    r = _uniform(min, max, &amp;amp;s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return ((long int)r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *Qt中函数paintEvent(QPaintEvent*)是被系统自动调用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *paintEvent(QPaintEvent *)函数是QWidget类中的虚函数，用于ui的绘制，会在多种情况下被其他函数自动调用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void MainWindow::paintEvent(QPaintEvent *)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QPainter painter(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QPen pen; //画笔&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pen.setColor(QColor(255,0,0)); //设置画笔颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    painter.setPen(pen); //添加画笔&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    long int r[kSum] = &amp;#123;0&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int j = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        r[i] = Uniform(0, 300);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;while(i &amp;lt; kSum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while((j + 30) &amp;lt; (kSum + 30))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        painter.drawPoint(j, r[j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//main.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;mainwindow.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;QApplication&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main(int argc, char *argv[])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QApplication a(argc, argv);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MainWindow w;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    w.show();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return a.exec();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：随机函数可以说是用途很广。可是，系统提供的random函数，一般符合正态分布，所以说，这是伪随机函数。甚至在一些场合是非随机函数。为了满足项目需要，必须实现均匀分布。在此，分享博主实现均匀随机函数的实现过程与方法。&lt;/p&gt;
    
    </summary>
    
      <category term="进阶" scheme="http://charsdavy.github.io/categories/advance/"/>
    
    
      <category term="算法" scheme="http://charsdavy.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Charles 安装与使用</title>
    <link href="http://charsdavy.github.io/2016/04/20/charles-using/"/>
    <id>http://charsdavy.github.io/2016/04/20/charles-using/</id>
    <published>2016-04-20T13:21:14.000Z</published>
    <updated>2016-06-04T02:09:36.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：Charles是在 Mac 下常用的网络封包截取工具，在做 移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。&lt;/p&gt;
&lt;p&gt;Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。&lt;/p&gt;
&lt;p&gt;除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。&lt;/p&gt;
&lt;p&gt;Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。&lt;/p&gt;
&lt;p&gt;本文将分享如何使用Charles，并且发放福利喔。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h1&gt;&lt;p&gt;Charles 主要的功能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;截取 Http 和 Https 网络封包。&lt;/li&gt;
&lt;li&gt;支持重发网络请求，方便后端调试。&lt;/li&gt;
&lt;li&gt;支持修改网络请求参数。&lt;/li&gt;
&lt;li&gt;支持网络请求的截获并动态修改。&lt;/li&gt;
&lt;li&gt;支持模拟慢速网络。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;安装Charles&quot;&gt;&lt;a href=&quot;#安装Charles&quot; class=&quot;headerlink&quot; title=&quot;安装Charles&quot;&gt;&lt;/a&gt;安装Charles&lt;/h1&gt;&lt;p&gt;1.&lt;a href=&quot;http://www.charlesproxy.com&quot;&gt;官网下载&lt;/a&gt; , 然后安装即可。&lt;/p&gt;
&lt;p&gt;2.&lt;a href=&quot;http://download.csdn.net/detail/dengw0716/9320153&quot;&gt;下载破解版软件&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;将Charles设置成系统代理&quot;&gt;&lt;a href=&quot;#将Charles设置成系统代理&quot; class=&quot;headerlink&quot; title=&quot;将Charles设置成系统代理&quot;&gt;&lt;/a&gt;将Charles设置成系统代理&lt;/h1&gt;&lt;p&gt;使用Charles的第一步就是要将其设置成系统的代理服务器。启动Charles，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:1.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;第一次Charles会请求你给它设置系统代理的权限，你可以输入登录密码授予Charles该权限，也可以选择忽略，然后在需要将Charles设置成系统代理时，选择菜单中的“Proxy”–&amp;gt;“Mac OS X Proxy”来将Charles设置成系统代理，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:2.png?imageView/2/w/400&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;此后，就可以看见源源不绝的网络请求出现在Charles的界面中。&lt;/p&gt;
&lt;p&gt;需要注意的是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888也可达到相同效果。&lt;/p&gt;
&lt;h1 id=&quot;Charles主界面&quot;&gt;&lt;a href=&quot;#Charles主界面&quot; class=&quot;headerlink&quot; title=&quot;Charles主界面&quot;&gt;&lt;/a&gt;Charles主界面&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:3.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;图中，structure和sequence是两种视图模式，structure视图将网络请求按访问的域名分类，sequence视图将网络请求按访问的时间排序，Filter处可以设置过滤关键词，Request显示请求内容，Response显示响应内容。&lt;/p&gt;
&lt;h1 id=&quot;过滤网络请求&quot;&gt;&lt;a href=&quot;#过滤网络请求&quot; class=&quot;headerlink&quot; title=&quot;过滤网络请求&quot;&gt;&lt;/a&gt;过滤网络请求&lt;/h1&gt;&lt;p&gt;方法多种，以下列举几种常用的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一：&lt;/strong&gt;在主界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：&lt;a href=&quot;http://www.baidu.com&quot;&gt;http://www.baidu.com&lt;/a&gt;, 那么只需要在 Filter 栏中填入 baidu 即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法二：&lt;/strong&gt;在 Charles 的菜单栏选择 “Proxy”–&amp;gt;“Recording Settings”，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:4.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;通常情况下，我们使用方法一做一些临时性的封包过滤，使用方法二做一些经常性的封包过滤。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法三：&lt;/strong&gt;在想过滤的网络请求上右击，选择 “Focus”，之后在 Filter 一栏勾选上 Focussed 一项，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:5.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种方式可以临时性的，快速地过滤出一些没有通过关键字的一类网络请求。&lt;/p&gt;
&lt;h1 id=&quot;截取移动设备上的网络封包&quot;&gt;&lt;a href=&quot;#截取移动设备上的网络封包&quot; class=&quot;headerlink&quot; title=&quot;截取移动设备上的网络封包&quot;&gt;&lt;/a&gt;截取移动设备上的网络封包&lt;/h1&gt;&lt;p&gt;下面我们以iPhone为例，讲解步骤。&lt;/p&gt;
&lt;h2 id=&quot;Charles上的设置&quot;&gt;&lt;a href=&quot;#Charles上的设置&quot; class=&quot;headerlink&quot; title=&quot;Charles上的设置&quot;&gt;&lt;/a&gt;Charles上的设置&lt;/h2&gt;&lt;p&gt;要截取 iPhone 上的网络请求，我们首先需要将 Charles 的代理功能打开。在 Charles 的菜单栏上选择 “Proxy”–&amp;gt;“Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:6.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;iPhone上的设置&quot;&gt;&lt;a href=&quot;#iPhone上的设置&quot; class=&quot;headerlink&quot; title=&quot;iPhone上的设置&quot;&gt;&lt;/a&gt;iPhone上的设置&lt;/h2&gt;&lt;p&gt;首先我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”–&amp;gt;“Local IP Address”，即可在弹出的对话框中看到 IP 地址，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:7.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 iPhone 的 “ 设置 ”–&amp;gt;“ 无线局域网 ” 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有“HTTP 代理”一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:8.png?imageView/2/w/300&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置好之后，我们打开 iPhone 上的任意需要网络通讯的程序，就可以看到 Charles 弹出 iPhone 请求连接的确认菜单，点击 “Allow” 即可完成设置。&lt;/p&gt;
&lt;h1 id=&quot;截取HTTPS通讯信息&quot;&gt;&lt;a href=&quot;#截取HTTPS通讯信息&quot; class=&quot;headerlink&quot; title=&quot;截取HTTPS通讯信息&quot;&gt;&lt;/a&gt;截取HTTPS通讯信息&lt;/h1&gt;&lt;h2 id=&quot;安装证书&quot;&gt;&lt;a href=&quot;#安装证书&quot; class=&quot;headerlink&quot; title=&quot;安装证书&quot;&gt;&lt;/a&gt;安装证书&lt;/h2&gt;&lt;p&gt;如果你需要截取分析 Https 协议相关的内容。那么需要安装 Charles 的 CA 证书。具体步骤如下。&lt;/p&gt;
&lt;p&gt;首先我们需要在 Mac 电脑上安装证书。点击 Charles 的顶部菜单，选择 “Help” –&amp;gt; “SSL Proxying” –&amp;gt; “Install Charles Root Certificate”，然后输入系统的帐号密码，即可在 KeyChain 看到添加好的证书。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:9.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，即使是安装完证书之后，Charles 默认也并不截取 Https 网络通讯的信息，如果你想对截取某个网站上的所有 HTTPS 网络请求，可以在该请求上右击，选择 SSL proxy，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:10.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这样，对于该 Host 的所有 SSL 请求可以被截取到了。&lt;/p&gt;
&lt;p&gt;##截取移动设备中的HTTPS通讯信息&lt;br&gt;如果我们需要在 iOS 或 Android 机器上截取 Https 协议的通讯内容，还需要在手机上安装相应的证书。点击 Charles 的顶部菜单，选择 “Help” –&amp;gt; “SSL Proxying” –&amp;gt; “Install Charles Root Certificate on a Mobile Device or Remote Browser”，然后就可以看到 Charles 弹出的简单的安装教程。&lt;/p&gt;
&lt;p&gt;按照我们之前说的教程，在设备上设置好 Charles 为代理后，在手机浏览器中访问地址：&lt;a href=&quot;http://charlesproxy.com/getssl&quot;&gt;http://charlesproxy.com/getssl&lt;/a&gt; ，即可打开证书安装的界面，安装完证书后，就可以截取手机上的 Https 通讯内容了。不过同样需要注意，默认情况下 Charles 并不做截取，你还需要在要截取的网络请求上右击，选择 SSL proxy 菜单项。&lt;/p&gt;
&lt;p&gt;#模拟慢速网络&lt;br&gt;在做移动开发的时候，我们常常需要模拟慢速网络或者高延迟的网络，以测试在移动网络下，应用的表现是否正常。Charles 对此需求提供了很好的支持。&lt;/p&gt;
&lt;p&gt;在 Charles 的菜单上，选择 “Proxy”–&amp;gt;“Throttle Setting” 项，在之后弹出的对话框中，我们可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型。如下图：&lt;br&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:11.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;br&gt;如果我们只想模拟指定网站的慢速网络，可以再勾选上图中的 “Only for selected hosts” 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。&lt;/p&gt;
&lt;p&gt;#修改网络请求内容&lt;br&gt;有些时候为了调试服务器的接口，我们需要反复尝试不同参数的网络请求。Charles 可以方便地提供网络请求的修改和重发功能。只需要在以往的网络请求上点击右键，选择 “Edit”，即可创建一个可编辑的网络请求。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:12.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可以修改该请求的任何信息，包括 URL 地址、端口、参数等，之后点击 “Execute” 即可发送该修改后的网络请求（如下图）。Charles 支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:13.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;给服务器做压力测试&quot;&gt;&lt;a href=&quot;#给服务器做压力测试&quot; class=&quot;headerlink&quot; title=&quot;给服务器做压力测试&quot;&gt;&lt;/a&gt;给服务器做压力测试&lt;/h1&gt;&lt;p&gt;我们可以使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力，方法如下。&lt;/p&gt;
&lt;p&gt;我们在想打压的网络请求上（POST 或 GET 请求均可）右击，然后选择“Repeat Advanced”菜单项，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:14.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;接着我们就可以在弹出的对话框中，选择打压的并发线程数以及打压次数，确定之后，即可开始打压。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:15.png?imageView/2/w/400&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;弱弱的说一句，一些写得很弱的投票网站，也可以用这个办法来快速投票。当然，我也拿 Charles 的 Repeat 功能给一些诈骗的钓鱼网站喂了不少垃圾数据，上次不小心还把一个钓鱼网站的数据库打挂了，嗯，请叫我雷锋。&lt;/p&gt;
&lt;h1 id=&quot;修改服务器返回内容&quot;&gt;&lt;a href=&quot;#修改服务器返回内容&quot; class=&quot;headerlink&quot; title=&quot;修改服务器返回内容&quot;&gt;&lt;/a&gt;修改服务器返回内容&lt;/h1&gt;&lt;p&gt;有些时候我们想让服务器返回一些指定的内容，方便我们调试一些特殊情况。例如列表页面为空的情况，数据异常的情况，部分耗时的网络请求超时的情况等。如果没有 Charles，要服务器配合构造相应的数据显得会比较麻烦。这个时候，使用 Charles 相关的功能就可以满足我们的需求。&lt;/p&gt;
&lt;p&gt;根据具体的需求，Charles 提供了 Map 功能、 Rewrite 功能以及 Breakpoints 功能，都可以达到修改服务器返回内容的目的。这三者在功能上的差异是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Map 功能适合长期地将某一些请求重定向到另一个网络地址或本地文件。&lt;/li&gt;
&lt;li&gt;Rewrite 功能适合对网络请求进行一些正则替换。&lt;/li&gt;
&lt;li&gt;Breakpoints 功能适合做一些临时性的修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Map-功能&quot;&gt;&lt;a href=&quot;#Map-功能&quot; class=&quot;headerlink&quot; title=&quot;Map 功能&quot;&gt;&lt;/a&gt;Map 功能&lt;/h2&gt;&lt;p&gt;Charles 的 Map 功能分 Map Remote 和 Map Local 两种，顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。&lt;/p&gt;
&lt;p&gt;在 Charles 的菜单中，选择 “Tools”–&amp;gt;“Map Remote” 或 “Map Local” 即可进入到相应功能的设置页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:16.png?imageView/2/w/460&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于 Map Remote 功能，我们需要分别填写网络重定向的源地址和目的地址，对于不需要限制的条件，可以留空。下图是一个示例，我将www.sohu.com的请求重定向到了 www.baidu.com&lt;br&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:17.png?imageView/2/w/460&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于 Map Local 功能，我们需要填写的重定向的源地址和本地的目标文件。对于有一些复杂的网络请求结果，我们可以先使用 Charles 提供的 “Save Response…” 功能，将请求结果保存到本地（如下图），然后稍加修改，成为我们的目标映射文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:18.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Rewrite-功能&quot;&gt;&lt;a href=&quot;#Rewrite-功能&quot; class=&quot;headerlink&quot; title=&quot;Rewrite 功能&quot;&gt;&lt;/a&gt;Rewrite 功能&lt;/h2&gt;&lt;p&gt;Rewrite 功能功能适合对某一类网络请求进行一些正则替换，以达到修改结果的目的。&lt;/p&gt;
&lt;h2 id=&quot;Breakpoints-功能&quot;&gt;&lt;a href=&quot;#Breakpoints-功能&quot; class=&quot;headerlink&quot; title=&quot;Breakpoints 功能&quot;&gt;&lt;/a&gt;Breakpoints 功能&lt;/h2&gt;&lt;p&gt;上面提供的 Rewrite 功能最适合做批量和长期的替换，但是很多时候，我们只是想临时修改一次网络请求结果，这个时候，使用 Rewrite 功能虽然也可以达到目的，但是过于麻烦，对于临时性的修改，我们最好使用 Breakpoints 功能。&lt;/p&gt;
&lt;p&gt;Breakpoints 功能类似我们在 Xcode 中设置的断点一样，当指定的网络请求发生时，Charles 会截获该请求，这个时候，我们可以在 Charles 中临时修改网络请求的返回内容。&lt;/p&gt;
&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;通过 Charles 软件，我们可以很方便地在日常开发中，截取和调试网络请求内容，分析封包协议以及模拟慢速网络。Charles 可以极大的方便我们对于带有网络请求的 App 的开发和调试。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：Charles是在 Mac 下常用的网络封包截取工具，在做 移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。&lt;/p&gt;
&lt;p&gt;Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。&lt;/p&gt;
&lt;p&gt;除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。&lt;/p&gt;
&lt;p&gt;Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。&lt;/p&gt;
&lt;p&gt;本文将分享如何使用Charles，并且发放福利喔。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://charsdavy.github.io/categories/tool/"/>
    
    
      <category term="开发助手" scheme="http://charsdavy.github.io/tags/assistant/"/>
    
  </entry>
  
  <entry>
    <title>VFL 语言简介</title>
    <link href="http://charsdavy.github.io/2016/04/17/VFL-introduction/"/>
    <id>http://charsdavy.github.io/2016/04/17/VFL-introduction/</id>
    <published>2016-04-17T13:49:29.000Z</published>
    <updated>2016-06-04T02:09:36.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：VFL（Visual Format Language），“可视化格式语言”。VFL是苹果公司为了简化autolayout的编码而推出的抽象语言。本文分享VFL的基本使用方法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;什么是VFL语言&quot;&gt;&lt;a href=&quot;#什么是VFL语言&quot; class=&quot;headerlink&quot; title=&quot;什么是VFL语言&quot;&gt;&lt;/a&gt;什么是VFL语言&lt;/h1&gt;&lt;p&gt;VFL（Visual Format Language），“可视化格式语言”。&lt;/p&gt;
&lt;p&gt;VFL 是苹果公司为了简化autolayout的编码而推出的抽象语言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:17:VFL-introduction:1.png?imageView/2/w/460&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;语法说明&quot;&gt;&lt;a href=&quot;#语法说明&quot; class=&quot;headerlink&quot; title=&quot;语法说明&quot;&gt;&lt;/a&gt;语法说明&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;H:[cancelButton(72)]-12-[acceptButton(50)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cancelButton宽72，acceptButton宽50，它们之间间距12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;H:[wideView(&amp;gt;=60@700)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wideView宽度大于等于60point，该约束条件优先级为700（优先级最大值为1000，优先级越高的约束条件越先被满足）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;V:[redBox][yellowBox(==redBox)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;垂直方向上，先有一个redBox，其下方紧接一个高度等于redBox高度的yellowBox&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;H:|-10-[Find]-[FindNext]-[FindField(&amp;gt;=20)]-|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;水平方向上，Find距离父view左边缘间隔10，之后是FindNext距离Find间隔默认宽度；再之后是宽度不小于20的FindField，它和FindNext以及父view右边边缘的间距都是默认宽度。（竖线“|”表示superview的边缘）。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;使用方法&quot;&gt;&lt;a href=&quot;#使用方法&quot; class=&quot;headerlink&quot; title=&quot;使用方法&quot;&gt;&lt;/a&gt;使用方法&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;使用VFL来创建约束数组&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+(NSArray *)constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)opts metrics:(NSDictionary *)metrics views:(NSDictionary *)views;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;format：VFL语句&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;opts：约束类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;metrics：VFL语句中用到的具体数值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;views：VFL语句中用到的控件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;创建一个字典（内部包含VFL语句中用到的控件）的快捷宏定义&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDictionaryOfVariableBindings(...)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;实例展示&quot;&gt;&lt;a href=&quot;#实例展示&quot; class=&quot;headerlink&quot; title=&quot;实例展示&quot;&gt;&lt;/a&gt;实例展示&lt;/h1&gt;&lt;p&gt;效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:17:VFL-introduction:2.png?imageView/2/w/340&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:17:VFL-introduction:3.png?imageView/2/w/340&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;实现代码&quot;&gt;&lt;a href=&quot;#实现代码&quot; class=&quot;headerlink&quot; title=&quot;实现代码&quot;&gt;&lt;/a&gt;实现代码&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(void)horizontalLayout&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //1.添加两个控件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIView *blueView = [[UIView alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blueView.backgroundColor = [UIColor blueColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blueView.translatesAutoresizingMaskIntoConstraints = NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:blueView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIView *redView = [[UIView alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    redView.backgroundColor = [UIColor redColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    redView.translatesAutoresizingMaskIntoConstraints = NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:redView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //2.添加约束&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //2.1水平方向的约束&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString *hVFL = @&amp;quot;H:|-30-[blueView]-30-[redView(==blueView)]-30-|&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSArray *hCons = [NSLayoutConstraint constraintsWithVisualFormat:hVFL options:NSLayoutFormatAlignAllBottom | NSLayoutFormatAlignAllTop metrics:nil views:@&amp;#123;@&amp;quot;blueView&amp;quot;:blueView, @&amp;quot;redView&amp;quot;:redView&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addConstraints:hCons];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //2.2垂直方向的约束&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString *vVFL = @&amp;quot;V:[blueView(50)]-30-|&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSArray *vCons = [NSLayoutConstraint constraintsWithVisualFormat:vVFL options:0 metrics:nil views:@&amp;#123;@&amp;quot;blueView&amp;quot;:blueView&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addConstraints:vCons];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)verticalLayout&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //1.添加两个控件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIView *blueView = [[UIView alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blueView.backgroundColor = [UIColor blueColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blueView.translatesAutoresizingMaskIntoConstraints = NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:blueView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIView *redView = [[UIView alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    redView.backgroundColor = [UIColor redColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    redView.translatesAutoresizingMaskIntoConstraints = NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:redView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //2.添加约束&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //2.1水平方向的约束&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString *hVFL = @&amp;quot;H:|-30-[blueView]-30-|&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSArray *hCons = [NSLayoutConstraint constraintsWithVisualFormat:hVFL options:0 metrics:nil views:@&amp;#123;@&amp;quot;blueView&amp;quot;:blueView&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addConstraints:hCons];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //2.2垂直方向的约束&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString *vVFL = @&amp;quot;V:|-30-[blueView(50)]-30-[redView(==blueView)]&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSArray *vCons = [NSLayoutConstraint constraintsWithVisualFormat:vVFL options:NSLayoutFormatAlignAllRight metrics:nil views:@&amp;#123;@&amp;quot;blueView&amp;quot;:blueView, @&amp;quot;redView&amp;quot;:redView&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addConstraints:vCons];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLayoutConstraint *redLeftCon = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:blueView attribute:NSLayoutAttributeCenterX multiplier:1.0 constant:0];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addConstraint:redLeftCon];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h1&gt;&lt;p&gt;最后对格式的字符串作一个总结介绍：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;水平方向&lt;/td&gt;
&lt;td&gt;H:&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;垂直方向&lt;/td&gt;
&lt;td&gt;V:&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Views&lt;/td&gt;
&lt;td&gt;[view]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SuperView&lt;/td&gt;
&lt;td&gt;竖线符号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;关系&lt;/td&gt;
&lt;td&gt;&amp;gt;=,==,&amp;lt;=&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;空间，间隙&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;优先级&lt;/td&gt;
&lt;td&gt;@value&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：VFL（Visual Format Language），“可视化格式语言”。VFL是苹果公司为了简化autolayout的编码而推出的抽象语言。本文分享VFL的基本使用方法。&lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="iOS" scheme="http://charsdavy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods安装与使用</title>
    <link href="http://charsdavy.github.io/2016/04/16/cocoapods-using/"/>
    <id>http://charsdavy.github.io/2016/04/16/cocoapods-using/</id>
    <published>2016-04-16T13:38:49.000Z</published>
    <updated>2016-06-04T02:09:36.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：CocoaPods 是iOS最常用的第三方库依赖管理工具，且绝大多数优秀的开源框架都支持CocoaPods。&lt;/p&gt;
&lt;p&gt;CocoaPods项目的源码 在 Github 上管理。该项目开始于 2011 年 8 月 12 日，开发 iOS 项目不可避免地要使用第三方开源库，CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间。&lt;/p&gt;
&lt;p&gt;文章分享在自己的工程中如何使用CocoaPods 工具管理第三方库。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;CocoaPods 是将所有的依赖库都放到另一个名为 Pods 项目中，然后让主项目依赖 Pods 项目，这样，源码管理工作都从主项目移到了 Pods 项目中。&lt;/p&gt;
&lt;p&gt;1)Pods 项目最终会编译成一个名为 libPods.a 的文件，主项目只需要依赖这个 .a 文件即可。&lt;/p&gt;
&lt;p&gt;2)对于资源文件，CocoaPods 提供了一个名为 Pods-resources.sh 的 bash 脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。&lt;/p&gt;
&lt;p&gt;3)CocoaPods 通过一个名为 Pods.xcconfig 的文件来在编译时设置所有的依赖和参数。&lt;/p&gt;
&lt;h1 id=&quot;CocoaPods-的安装&quot;&gt;&lt;a href=&quot;#CocoaPods-的安装&quot; class=&quot;headerlink&quot; title=&quot;CocoaPods 的安装&quot;&gt;&lt;/a&gt;CocoaPods 的安装&lt;/h1&gt;&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;安装方式异常简单 , Mac 下都自带 ruby，使用 ruby 的 gem 命令即可下载安装：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo gem install cocoapods&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ pod setup&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你的 gem 太老，可能也会有问题，可以尝试用如下命令升级 gem:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo gem update --system&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而这样执行命令，却会出错，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:16:cocoapods-using:1.png?imageView/2/w/460&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是因为ruby 的软件源 &lt;a href=&quot;https://rubygems.org&quot;&gt;https://rubygems.org&lt;/a&gt; 因为使用的是亚马逊的云服务，所以被墙了，需要更新一下 ruby 的源，使用如下代码将官方的 ruby 源替换成国内淘宝的源：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ gem sources --remove https:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//rubygems.org/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ gem sources -a https:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//ruby.taobao.org/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ gem sources -l&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后再执行之前的命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo gem install cocoapods&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ pod setup&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有一点需要注意，pod setup在执行时，会输出Setting up CocoaPods master repo，但是会等待比较久的时间。这一步其实是 Cocoapods 在将它的信息下载到 ~/.cocoapods目录下，如果你等太久，可以试着 cd 到那个目录，用du -sh *来查看下载进度。你也可以使用 cocoapods 的镜像来提高下载速度。&lt;/p&gt;
&lt;h2 id=&quot;使用-CocoaPods-的镜像索引&quot;&gt;&lt;a href=&quot;#使用-CocoaPods-的镜像索引&quot; class=&quot;headerlink&quot; title=&quot;使用 CocoaPods 的镜像索引&quot;&gt;&lt;/a&gt;使用 CocoaPods 的镜像索引&lt;/h2&gt;&lt;p&gt;所有的项目的 Podspec 文件都托管在&lt;a href=&quot;https://github.com/CocoaPods/Specs&quot;&gt;https://github.com/CocoaPods/Specs&lt;/a&gt; 。第一次执行pod setup时，CocoaPods 会将这些podspec索引文件更新到本地的 ~/.cocoapods/&lt;br&gt;目录下，这个索引文件比较大，有 80M 左右。所以第一次更新时非常慢。&lt;/p&gt;
&lt;p&gt;一个叫 akinliu 的朋友在 gitcafe 和 oschina 上建立了 CocoaPods 索引库的镜像，因为 gitcafe 和 oschina 都是国内的服务器，所以在执行索引更新操作时，会快很多。如下操作可以将 CocoaPods 设置成使用 gitcafe 镜像：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pod repo remove master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ pod repo add master https:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//gitcafe.com/akuandev/Specs.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ pod repo update&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将以上代码中的 &lt;a href=&quot;https://gitcafe.com/akuandev/Specs.git&quot;&gt;https://gitcafe.com/akuandev/Specs.git&lt;/a&gt; 替换成 &lt;a href=&quot;http://git.oschina.net/akuandev/Specs.git&quot;&gt;http://git.oschina.net/akuandev/Specs.git&lt;/a&gt; 即可使用 oschina 上的镜像。&lt;/p&gt;
&lt;h2 id=&quot;使用-CocoaPods&quot;&gt;&lt;a href=&quot;#使用-CocoaPods&quot; class=&quot;headerlink&quot; title=&quot;使用 CocoaPods&quot;&gt;&lt;/a&gt;使用 CocoaPods&lt;/h2&gt;&lt;p&gt;使用时需要新建一个名为 Podfile 的文件，以如下格式，将依赖的库名字依次列在文件中即可&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;platform :ios&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;JSONKit&amp;apos;,  &amp;apos;~&amp;gt; 1.4&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;Reachability&amp;apos;, &amp;apos;~&amp;gt; 3.0.0&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后将编辑好的 Podfile 文件放到项目根目录中，执行如下命令即可：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ cd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;your project home&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ pod install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在，所有的第三方库都已经下载完成并且设置好了编译参数和依赖，需要记住如下两点：&lt;/p&gt;
&lt;p&gt;1)使用 CocoaPods 生成的 &lt;em&gt;.xcworkspace &lt;/em&gt;文件来打开工程，而不是以前的&lt;em&gt; &lt;/em&gt;.xcodeproj 文件。&lt;br&gt;2)每次更改了 Podfile 文件，需要重新执行一次pod update命令。&lt;/p&gt;
&lt;h2 id=&quot;查找第三方库&quot;&gt;&lt;a href=&quot;#查找第三方库&quot; class=&quot;headerlink&quot; title=&quot;查找第三方库&quot;&gt;&lt;/a&gt;查找第三方库&lt;/h2&gt;&lt;p&gt;如果不知道 cocoaPods 管理的库中，是否有你想要的库，那么可以通过 pod search 命令进行查找，以下是用 pod search json 查找到的所有可用的库：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;span class=&amp;quot;nv&amp;quot;&amp;gt;$ pod search json&amp;lt;/span&amp;gt;&amp;lt;br&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; AFJSONPRequestOperation (1.0.0)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AFNetworking Extension for the JSONP format.   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;AFJSONPRequestOperation&amp;apos;,&amp;apos;~&amp;gt; 1.0.0&amp;apos;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- Homepage: https:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//github.com/acerbetti/AFJSONPRequestOperation   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- Source:   https:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//github.com/acerbetti/AFJSONPRequestOperation.git   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- Versions: 1.0.0 [master repo]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; AFJSONRPCClient (2.1.1)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A JSON-RPC client build on AFNetworking.   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;AFJSONRPCClient&amp;apos;,&amp;apos;~&amp;gt; 2.1.1&amp;apos;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- Homepage: https:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//github.com/AFNetworking/AFJSONRPCClient  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- Source:   https:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//github.com/AFNetworking/AFJSONRPCClient.git &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- Versions: 2.1.1, 2.1.0, 2.0.0, 1.0.0, 0.4.0, 0.3.1, 0.3.0 [master repo]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; ARSafeJSON (0.0.7)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ARSafeJSON is a small library that will strip all occurences of NSNull from a JSON of any depth.   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;ARSafeJSON&amp;apos;, &amp;apos;~&amp;gt; 0.0.7&amp;apos;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- Homepage: https:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//bitbucket.org/antoine_r/arsafejson   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- Source:   https:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//bitbucket.org/antoine_r/arsafejson.git &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- Versions: 0.0.7, 0.0.3 [master repo]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//以下省去若干行&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;关于-Podfile-lock&quot;&gt;&lt;a href=&quot;#关于-Podfile-lock&quot; class=&quot;headerlink&quot; title=&quot;关于 Podfile.lock&quot;&gt;&lt;/a&gt;关于 Podfile.lock&lt;/h1&gt;&lt;p&gt;当执行pod install之后，除了 Podfile 外，CocoaPods 还会生成一个名为Podfile.lock的文件，Podfile.lock 应该加入到版本控制里面，不应该把这个文件加入到.gitignore中。因为Podfile.lock会锁定当前各依赖库的版本，之后如果多次执行pod install不会更改版本，要pod update才会改Podfile.lock了。这样多人协作的时候，可以防止第三方库升级时造成大家各自的第三方库版本不一致。&lt;/p&gt;
&lt;p&gt;CocoaPods 的这篇 官方文档 也在What is a Podfile.lock一节中介绍了Podfile.lock的作用，并且指出：&lt;br&gt;　　“This file should always be kept under version control.”&lt;br&gt;为自己的项目创建 podspec 文件我们可以为自己的开源项目创建podspec文件，首先通过如下命令初始化一个podspec文件：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pod spec create your_pod_spec_name&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该命令执行之后，CocoaPods 会生成一个名为your_pod_spec_name.podspec的文件，然后我们修改其中的相关内容即可。&lt;/p&gt;
&lt;p&gt;具体步骤可以参看：&lt;/p&gt;
&lt;p&gt;《如何编写一个 CocoaPods 的 spec 文件》&lt;/p&gt;
&lt;p&gt;《Cocoapods 入门》。&lt;/p&gt;
&lt;h1 id=&quot;使用私有的-pods&quot;&gt;&lt;a href=&quot;#使用私有的-pods&quot; class=&quot;headerlink&quot; title=&quot;使用私有的 pods&quot;&gt;&lt;/a&gt;使用私有的 pods&lt;/h1&gt;&lt;p&gt;我们可以直接指定某一个依赖的podspec，这样就可以使用团队内部的私有库。该方案有利于使团队内部的公共项目支持 CocoaPods。如下是一个示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pod&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;apos;MyCommon&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;, :podspec =&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;apos;https://yuantiku.com/common/myCommon.podspec&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;不更新-podspec&quot;&gt;&lt;a href=&quot;#不更新-podspec&quot; class=&quot;headerlink&quot; title=&quot;不更新 podspec&quot;&gt;&lt;/a&gt;不更新 podspec&lt;/h2&gt;&lt;p&gt;CocoaPods 在执行&lt;code&gt;pod install&lt;/code&gt;和&lt;code&gt;pod update&lt;/code&gt;时，会默认先更新一次podspec索引。使用–no-repo-update参数可以禁止其做索引更新操作。如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pod install --no-repo-update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ pod update --no-repo-update&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;生成第三方库的帮助文档&quot;&gt;&lt;a href=&quot;#生成第三方库的帮助文档&quot; class=&quot;headerlink&quot; title=&quot;生成第三方库的帮助文档&quot;&gt;&lt;/a&gt;生成第三方库的帮助文档&lt;/h1&gt;&lt;p&gt;如果想利用 CococaPods 生成第三方库的帮助文档，并集成到 Xcode 中，那么用 brew 安装 appledoc 即可：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ brew install appledoc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;关于 appledoc，可以参看 《使用 Objective-C 的文档生成工具:appledoc》 中有专门介绍。它最大的优点是可以将帮助文档集成到 Xcode 中，这样你在敲代码的时候，按住 option 键单击类名或方法名，就可以显示出相应的帮助文档。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：CocoaPods 是iOS最常用的第三方库依赖管理工具，且绝大多数优秀的开源框架都支持CocoaPods。&lt;/p&gt;
&lt;p&gt;CocoaPods项目的源码 在 Github 上管理。该项目开始于 2011 年 8 月 12 日，开发 iOS 项目不可避免地要使用第三方开源库，CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间。&lt;/p&gt;
&lt;p&gt;文章分享在自己的工程中如何使用CocoaPods 工具管理第三方库。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://charsdavy.github.io/categories/tool/"/>
    
    
      <category term="开发助手" scheme="http://charsdavy.github.io/tags/assistant/"/>
    
  </entry>
  
  <entry>
    <title>认识与入门 - Markdown</title>
    <link href="http://charsdavy.github.io/2016/04/15/markdown-introduction/"/>
    <id>http://charsdavy.github.io/2016/04/15/markdown-introduction/</id>
    <published>2016-04-15T13:09:44.000Z</published>
    <updated>2016-06-04T02:09:36.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。文章介绍markdown基本使用方法，放心，看过之后你肯定会爱上它，无法自拔。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;一、认识-Markdown&quot;&gt;&lt;a href=&quot;#一、认识-Markdown&quot; class=&quot;headerlink&quot; title=&quot;一、认识 Markdown&quot;&gt;&lt;/a&gt;一、认识 Markdown&lt;/h1&gt;&lt;p&gt;在刚才的导语里提到，Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。目前来看，支持 Markdown 语法的编辑器有很多，包括很多网站（例如简书）也支持了 Markdown 的文字录入。Markdown 从写作到完成，导出格式随心所欲，你可以导出 HTML 格式的文件用来网站发布，也可以十分方便的导出 PDF 格式，这种格式写出的简历更能得到 HR 的好感。甚至可以利用 CloudApp 这种云服务工具直接上传至网页用来分享你的文章，全球最大的轻博客平台 Tumblr，也支持使用 Mou 这类 Markdown 工具进行编辑并直接上传。&lt;/p&gt;
&lt;h2 id=&quot;Markdown-官方文档&quot;&gt;&lt;a href=&quot;#Markdown-官方文档&quot; class=&quot;headerlink&quot; title=&quot;Markdown 官方文档&quot;&gt;&lt;/a&gt;Markdown 官方文档&lt;/h2&gt;&lt;p&gt;这里可以看到官方的 Markdown 语法规则文档，当然，后文我也会用自己的方式，阐述这些语法在实际使用中的用法。&lt;/p&gt;
&lt;p&gt;创始人 John Gruber 的 Markdown 语法说明&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://daringfireball.net/projects/markdown/syntax&quot;&gt;http://daringfireball.net/projects/markdown/syntax&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Markdown 中文版语法说明&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wowubuntu.com/markdown/#list&quot;&gt;http://wowubuntu.com/markdown/#list&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用-Markdown-的优点&quot;&gt;&lt;a href=&quot;#使用-Markdown-的优点&quot; class=&quot;headerlink&quot; title=&quot;使用 Markdown 的优点&quot;&gt;&lt;/a&gt;使用 Markdown 的优点&lt;/h2&gt;&lt;p&gt;专注你的文字内容而不是排版样式。&lt;/p&gt;
&lt;p&gt;轻松的导出 HTML、PDF 和本身的 .md 文件。&lt;/p&gt;
&lt;p&gt;纯文本内容，兼容所有的文本编辑器与字处理软件。&lt;/p&gt;
&lt;p&gt;可读，直观。适合所有人的写作语言。&lt;/p&gt;
&lt;h2 id=&quot;我该用什么工具&quot;&gt;&lt;a href=&quot;#我该用什么工具&quot; class=&quot;headerlink&quot; title=&quot;我该用什么工具&quot;&gt;&lt;/a&gt;我该用什么工具&lt;/h2&gt;&lt;h3 id=&quot;Mac-平台&quot;&gt;&lt;a href=&quot;#Mac-平台&quot; class=&quot;headerlink&quot; title=&quot;Mac 平台&quot;&gt;&lt;/a&gt;Mac 平台&lt;/h3&gt;&lt;p&gt;在 Mac OS X 上，我强烈建议你用 Mou 这款免费且十分好用的 Markdown 编辑器，它支持实时预览，既左边是你编辑 Markdown 语言，右边会实时的生成预览效果，笔者文章就是 Mou 这款应用写出来的。&lt;/p&gt;
&lt;p&gt;其次还有很多同类选择。如果你是个编辑作者，我强烈建议你购买 Ulysses Ⅲ，这款应用入围了苹果去年 Mac App Store 的 The Best of 2013，相比 Mou 它支持更多的写作格式、多文档的支持。Mou、iA Writer 这些应用都是基于单文档的管理方式，而 Ulysses Ⅲ 支持 Folder、Filter 的管理，一个 Folder 里面可以创建多个 Sheet，Sheet 之间还可以进行 Combine 处理。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Windows、iOS、Web-平台&quot;&gt;&lt;a href=&quot;#Windows、iOS、Web-平台&quot; class=&quot;headerlink&quot; title=&quot;Windows、iOS、Web 平台&quot;&gt;&lt;/a&gt;Windows、iOS、Web 平台&lt;/h3&gt;&lt;p&gt;笔者并未使用过 Windows 下的 Markdown 工具，但经朋友介绍，有两款还算不错，一款叫 MarkdownPad ，另一款叫 MarkPad。&lt;/p&gt;
&lt;p&gt;iOS 端已有相当多的 app 支持 Markdown 语法编辑，例如 Drafts、Day One、iA Writer 等。&lt;/p&gt;
&lt;p&gt;Web 端上，笔者强烈推荐 简书 这款产品，上面有无数热爱文字的人在不停的创造、分享。在 Web 端使用 Markdown 没有比简书更舒服的地方了，它同样支持左右两栏的实时预览，字体优雅、简洁。&lt;/p&gt;
&lt;p&gt;同样是 Web 端，Draftin 这款在线 MD 编辑器也近乎完美。&lt;/p&gt;
&lt;h1 id=&quot;二、Markdown-语法的简要规则&quot;&gt;&lt;a href=&quot;#二、Markdown-语法的简要规则&quot; class=&quot;headerlink&quot; title=&quot;二、Markdown 语法的简要规则&quot;&gt;&lt;/a&gt;二、Markdown 语法的简要规则&lt;/h1&gt;&lt;h2 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-3f6606d01e29d996.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;标题.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。&lt;/p&gt;
&lt;h1 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot; title=&quot;一级标题&quot;&gt;&lt;/a&gt;一级标题&lt;/h1&gt;&lt;h2 id=&quot;二级标题&quot;&gt;&lt;a href=&quot;#二级标题&quot; class=&quot;headerlink&quot; title=&quot;二级标题&quot;&gt;&lt;/a&gt;二级标题&lt;/h2&gt;&lt;h3 id=&quot;三级标题&quot;&gt;&lt;a href=&quot;#三级标题&quot; class=&quot;headerlink&quot; title=&quot;三级标题&quot;&gt;&lt;/a&gt;三级标题&lt;/h3&gt;&lt;p&gt;以此类推，总共六级标题，建议在#号后加一个空格，这是最标准的 Markdown 语法。&lt;/p&gt;
&lt;h2 id=&quot;列表&quot;&gt;&lt;a href=&quot;#列表&quot; class=&quot;headerlink&quot; title=&quot;列表&quot;&gt;&lt;/a&gt;列表&lt;/h2&gt;&lt;p&gt;熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加 1. 2. 3. 符号要和文字之间加上一个字符的空格。&lt;/p&gt;
&lt;h2 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;p&gt;如果你需要引用一小段别处的句子，那么就要用引用的格式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如这样&lt;br&gt;只需要在文本前加入 &amp;gt; 这种尖括号（大于号）即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-89dff7c1bf5167de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;引用.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;图片与链接&quot;&gt;&lt;a href=&quot;#图片与链接&quot; class=&quot;headerlink&quot; title=&quot;图片与链接&quot;&gt;&lt;/a&gt;图片与链接&lt;/h2&gt;&lt;p&gt;插入链接与插入图片的语法很像，区别在一个 !号&lt;br&gt;插入图片的地址需要图床，这里推荐 CloudApp 的服务，生成URL地址即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-aa3bd9ef3b8cfb9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图片与链接.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;粗体与斜体&quot;&gt;&lt;a href=&quot;#粗体与斜体&quot; class=&quot;headerlink&quot; title=&quot;粗体与斜体&quot;&gt;&lt;/a&gt;粗体与斜体&lt;/h2&gt;&lt;p&gt;Markdown 的粗体和斜体也非常简单，用两个 &lt;em&gt; 包含一段文本就是粗体的语法，用一个 &lt;/em&gt; 包含一段文本就是斜体的语法。&lt;/p&gt;
&lt;p&gt;例如：&lt;strong&gt;这里是粗体&lt;/strong&gt; &lt;em&gt;这里是斜体&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;表格&quot;&gt;&lt;a href=&quot;#表格&quot; class=&quot;headerlink&quot; title=&quot;表格&quot;&gt;&lt;/a&gt;表格&lt;/h2&gt;&lt;p&gt;表格是我觉得 Markdown 比较累人的地方，例子如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-70d3dcdde3f27fde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;表格.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码框&quot;&gt;&lt;a href=&quot;#代码框&quot; class=&quot;headerlink&quot; title=&quot;代码框&quot;&gt;&lt;/a&gt;代码框&lt;/h2&gt;&lt;p&gt;如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown 下实现也非常简单，只需要用两个 连续三个顿点符号 把中间的代码包裹起来，如 ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-2a96aad92c711885.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;代码框.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用 tab 键即可缩进。&lt;/p&gt;
&lt;h2 id=&quot;分割线&quot;&gt;&lt;a href=&quot;#分割线&quot; class=&quot;headerlink&quot; title=&quot;分割线&quot;&gt;&lt;/a&gt;分割线&lt;/h2&gt;&lt;p&gt;分割线的语法只需要另起一行，连续输入三个星号 &lt;em&gt;*&lt;/em&gt; 即可。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h2&gt;&lt;p&gt;到这里，Markdown 的基本语法在日常的使用中基本就没什么大问题了，只要多加练习，配合好用的工具，写起东西来肯定会行云流水。更多的语法规则，其实 Mou 的 Help 文档例子很好，当你第一次使用 Mou 时，就会显示该文档，其次，你也可在撰写过程中，使用 CMD+R 快捷键来快速打开文档，以随时查阅和学习语法。&lt;/p&gt;
&lt;h1 id=&quot;三、与-Markdown-相关的一些推荐&quot;&gt;&lt;a href=&quot;#三、与-Markdown-相关的一些推荐&quot; class=&quot;headerlink&quot; title=&quot;三、与 Markdown 相关的一些推荐&quot;&gt;&lt;/a&gt;三、与 Markdown 相关的一些推荐&lt;/h1&gt;&lt;h2 id=&quot;可配套使用的工具&quot;&gt;&lt;a href=&quot;#可配套使用的工具&quot; class=&quot;headerlink&quot; title=&quot;可配套使用的工具&quot;&gt;&lt;/a&gt;可配套使用的工具&lt;/h2&gt;&lt;p&gt;Droplr&lt;/p&gt;
&lt;p&gt;Cloudapp&lt;/p&gt;
&lt;p&gt;ezShare for Mac&lt;/p&gt;
&lt;p&gt;围脖图床修复计划&lt;/p&gt;
&lt;p&gt;马克飞象，专为印象笔记打造的 Markdown 编辑器，非常推荐&lt;/p&gt;
&lt;h2 id=&quot;相关文章阅读&quot;&gt;&lt;a href=&quot;#相关文章阅读&quot; class=&quot;headerlink&quot; title=&quot;相关文章阅读&quot;&gt;&lt;/a&gt;相关文章阅读&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://apple4us.com/2012/02/why-writers-should-use-markdown&quot;&gt;为什么作家应该用 Markdown 保存自己的文稿&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.yangzhiping.com/tech/r-markdown-knitr.html&quot;&gt;Markdown 写作浅谈&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.appinn.com/markdown-tools&quot;&gt;Markdown 工具补完&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/63HYZ6&quot;&gt;Drafts + Scriptogr.am + Dropbox 打造移动端 Markdown 风格博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ituring.com.cn/article/23&quot;&gt;图灵社区 - 怎样使用 Markdown&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://news.cnblogs.com/n/139649&quot;&gt;为什么我们要学习 Markdown 的三个理由&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后，分享一个MarkDown开源编辑工具MacDown，源代码地址&lt;br&gt;&lt;a href=&quot;https://github.com/uranusjr/macdown&quot;&gt;https://github.com/uranusjr/macdown&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。文章介绍markdown基本使用方法，放心，看过之后你肯定会爱上它，无法自拔。&lt;/p&gt;
    
    </summary>
    
      <category term="应用实战" scheme="http://charsdavy.github.io/categories/apply/"/>
    
    
      <category term="markdown" scheme="http://charsdavy.github.io/tags/script/"/>
    
  </entry>
  
  <entry>
    <title>GCD（Grand Central Dispatch）</title>
    <link href="http://charsdavy.github.io/2016/04/14/Grand-Central-Dispatch/"/>
    <id>http://charsdavy.github.io/2016/04/14/Grand-Central-Dispatch/</id>
    <published>2016-04-14T00:24:46.000Z</published>
    <updated>2016-06-04T02:09:36.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：GCD（Grand Central Dispatch），是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如NSThread,NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术。文章分享关于GCD的种种概念以及使用。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;GCD（Grand Central Dispatch），是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如NSThread,NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术。&lt;/p&gt;
&lt;p&gt;GCD 和 block 的配合使用，可以方便地进行多线程编程。&lt;/p&gt;
&lt;h1 id=&quot;优势&quot;&gt;&lt;a href=&quot;#优势&quot; class=&quot;headerlink&quot; title=&quot;优势&quot;&gt;&lt;/a&gt;优势&lt;/h1&gt;&lt;p&gt;1）  苹果官方为多核的并行运算提出的解决方案。&lt;/p&gt;
&lt;p&gt;2）  会自动利用更多的CPU内核。&lt;/p&gt;
&lt;p&gt;3）  会自动管理线程的生命周期（创建线程、调度任务、销毁线程）。&lt;/p&gt;
&lt;h1 id=&quot;核心概念&quot;&gt;&lt;a href=&quot;#核心概念&quot; class=&quot;headerlink&quot; title=&quot;核心概念&quot;&gt;&lt;/a&gt;核心概念&lt;/h1&gt;&lt;p&gt;1）  任务：执行什么操作。block&lt;/p&gt;
&lt;p&gt;2）  队列：用来存放任务。&lt;/p&gt;
&lt;p&gt;串行队列：顺序，一个一个执行。一个任务执行完毕后才执行下一个任务。&lt;/p&gt;
&lt;p&gt;并发队列：同时，同时执行很多个任务。自动开启多个线程同时执行任务。并发功能只有在异步函数下才生效。&lt;/p&gt;
&lt;h1 id=&quot;使用步骤：&quot;&gt;&lt;a href=&quot;#使用步骤：&quot; class=&quot;headerlink&quot; title=&quot;使用步骤：&quot;&gt;&lt;/a&gt;使用步骤：&lt;/h1&gt;&lt;p&gt;1）  定制任务&lt;/p&gt;
&lt;p&gt;确定想要做的事情。&lt;/p&gt;
&lt;p&gt;2）  将任务添加到队列中&lt;/p&gt;
&lt;p&gt;GCD会自动将队列中的任务取出，放到对应的线程中执行。&lt;/p&gt;
&lt;p&gt;任务的取出原则遵循队列的原则：先进先出，后进后出。&lt;/p&gt;
&lt;h1 id=&quot;执行任务的函数&quot;&gt;&lt;a href=&quot;#执行任务的函数&quot; class=&quot;headerlink&quot; title=&quot;执行任务的函数&quot;&gt;&lt;/a&gt;执行任务的函数&lt;/h1&gt;&lt;p&gt;1）同步方式　　&lt;/p&gt;
&lt;p&gt;dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);&lt;/p&gt;
&lt;p&gt;queue:队列&lt;/p&gt;
&lt;p&gt;block:任务&lt;/p&gt;
&lt;p&gt;2）异步方式&lt;/p&gt;
&lt;p&gt;dispatch_async(dispatch_queue_t queue, dispatch_block_t block);&lt;/p&gt;
&lt;p&gt;queue:队列&lt;/p&gt;
&lt;p&gt;block:任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步和异步的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步：在当前线程中执行。&lt;/p&gt;
&lt;p&gt;异步：在另一条线程中执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步任务的作用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）  用户登录&lt;/p&gt;
&lt;p&gt;2）  下载任务1&lt;/p&gt;
&lt;p&gt;3）  下载任务2&lt;/p&gt;
&lt;h1 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot; class=&quot;headerlink&quot; title=&quot;术语&quot;&gt;&lt;/a&gt;术语&lt;/h1&gt;&lt;p&gt;1）  同步和异步决定了是否要开辟新线程。&lt;/p&gt;
&lt;p&gt;同步：在当前线程中执行任务，不具备开启新线程的能力。&lt;/p&gt;
&lt;p&gt;异步：在新的线程中执行任务，具备开启新线程的能力。&lt;/p&gt;
&lt;p&gt;2）  并发和串行决定了任务执行的方式。&lt;/p&gt;
&lt;p&gt;并发：多个任务同时执行。&lt;/p&gt;
&lt;p&gt;串行：一个任务执行完毕后，再执行下一个任务。&lt;/p&gt;
&lt;h1 id=&quot;代码使用&quot;&gt;&lt;a href=&quot;#代码使用&quot; class=&quot;headerlink&quot; title=&quot;代码使用　&quot;&gt;&lt;/a&gt;代码使用　&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*串行队列*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*创建队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数：1.队列标签。 2.队列属性。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(”dengw”,DISPATCH_QUEUE_SERIAL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*同步执行任务，不会开辟新线程，在当前线程中顺序执行。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一般只要使用“同步”执行，串行队列对添加的同步任务，立马执行*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_sync(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*异步执行任务，开辟新线程，在新线程中执行。开辟新线程的数量与队列模式有关。串行队列中异步执行只会开启一个新线程。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int I = 0; I &amp;lt; 10; I++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*并发队列：需要程序员释放。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*创建队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数：1.队列标签。 2.队列属性。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(”dengw”,DISPATCH_QUEUE_CONCURRENT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*异步执行任务，开辟新线程，在新线程中执行。开辟新线程的数量程序员无法控制。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int I = 0; I &amp;lt; 10; I++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*同步执行任务，不开辟新线程，顺序执行*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int I = 0; I &amp;lt; 10; I++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_sync(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*主队列，专门负责在主线程上调度任务。程序启动以后至少有一个主线程，则会创建主队列。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*主队列不允许开辟新线程。不会在子线程调度任务。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*获得主队列*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_get_main_queue();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*异步执行任务，在主队列中，只能顺序执行。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int I = 0; I &amp;lt; 10; I++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*异步：把任务放到主队列中，但不需要马上执行。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*同步执行任务*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int I = 0; I &amp;lt; 10; I++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*同步：把任务放到主队列中，需要马上执行。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*阻塞*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_sync(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*全局队列：本质是并发队列。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;与并发队列的区别：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1）全局队列没有名字，而并发队列有名字。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2）全局队列，是供所有的应用程序使用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3）在MRC中，全局队列不需要释放，并发队列需要释放。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*获得全局队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iOS7中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_HEGH    2 高优先级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT  0 默认优先级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_LOW   (-2) 低优先级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_BACKGROUND    INT16_MIN 后台优先级（最低）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iOS8中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_HEGH:QOS_CLASS_USER_INITIATED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT:QOS_CLASS_USER_DEFAULT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_LOW:QOS_CLASS_USER_UTILITY&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_BACKGROUND: QOS_CLASS_USER_BACKGROUND&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;保留参数。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_get_global_queue(QOS_CLASS_USER_DEFAULT,0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*异步执行任务*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int I = 0; I &amp;lt; 10; I++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;各队列的执行效果&quot;&gt;&lt;a href=&quot;#各队列的执行效果&quot; class=&quot;headerlink&quot; title=&quot;各队列的执行效果&quot;&gt;&lt;/a&gt;各队列的执行效果&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;全局并行队列&lt;/th&gt;
&lt;th&gt;手动创建串行队列&lt;/th&gt;
&lt;th&gt;主队列&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;同步（sync）&lt;/td&gt;
&lt;td&gt;没有开启新线程。串行执行任务。&lt;/td&gt;
&lt;td&gt;没有开启新线程。串行执行任务。&lt;/td&gt;
&lt;td&gt;会死锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;异步（async）&lt;/td&gt;
&lt;td&gt;有开启新线程。并行执行任务。&lt;/td&gt;
&lt;td&gt;有开启新线程。串行执行任务。&lt;/td&gt;
&lt;td&gt;没有开启新线程。串行执行任务。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;队列的选择&quot;&gt;&lt;a href=&quot;#队列的选择&quot; class=&quot;headerlink&quot; title=&quot;队列的选择&quot;&gt;&lt;/a&gt;队列的选择&lt;/h1&gt;&lt;p&gt;1）串行队列异步执行&lt;/p&gt;
&lt;p&gt;开一条线程，顺序执行。&lt;/p&gt;
&lt;p&gt;效率不高，执行比较慢，资源占用小，省电。&lt;/p&gt;
&lt;p&gt;应用场景：一般3G网络，对性能要求不高。&lt;/p&gt;
&lt;p&gt;2）并发队列异步执行&lt;/p&gt;
&lt;p&gt;开启多条线程，并发执行。&lt;/p&gt;
&lt;p&gt;效率高，执行快，资源消耗大，费电。&lt;/p&gt;
&lt;p&gt;应用场景：WIFI网络，或需要快速响应，用户体验要求高，对任务执行顺序没有要求。&lt;/p&gt;
&lt;p&gt;3）  同步任务&lt;/p&gt;
&lt;p&gt;一般只会在并发队列，需要阻塞后续任务，必须等待同步任务执行完毕，再去执行其他任务。“依赖关系” &lt;/p&gt;
&lt;h1 id=&quot;线程间通信&quot;&gt;&lt;a href=&quot;#线程间通信&quot; class=&quot;headerlink&quot; title=&quot;线程间通信&quot;&gt;&lt;/a&gt;线程间通信&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*从子线程回到主线程*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //执行耗时的异步操作…&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(dispatch_get_main_queue(), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //回到主线程，执行UI刷新操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;延时操作&quot;&gt;&lt;a href=&quot;#延时操作&quot; class=&quot;headerlink&quot; title=&quot;延时操作&quot;&gt;&lt;/a&gt;延时操作&lt;/h1&gt;&lt;p&gt;1）方式一，调用NSObject的方法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//2秒后再调用run方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self performSelector:@selector(run) withObject:nil afterDelay:2.0];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2）方式二，使用GCD函数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)),dispatch_get_main_queue(), ^&amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //2秒后再异步执行这里的代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;调度组（分组）&quot;&gt;&lt;a href=&quot;#调度组（分组）&quot; class=&quot;headerlink&quot; title=&quot;调度组（分组）&quot;&gt;&lt;/a&gt;调度组（分组）&lt;/h1&gt;&lt;p&gt;应用场景：开发的时候，有的时候出现多个网络请求（每一个网络请求时间长短不一），都完成以后统一更新UI或通知用户。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*实例化一个调度组*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_t group = dispatch_group_create();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_get_global_queue(0, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//将任务添加到队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_async(group, queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@”A %@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_async(group, queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@”B %@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//获得所有调度组里面的异步任务完成的通知&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*在调度组完成通知里，可以跨队列通信*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_notifity(group, queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //异步的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@”finished”);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;一次性执行&quot;&gt;&lt;a href=&quot;#一次性执行&quot; class=&quot;headerlink&quot; title=&quot;一次性执行&quot;&gt;&lt;/a&gt;一次性执行&lt;/h1&gt;&lt;p&gt;常见于单例模型中代码使用。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static dispatch_once_t onceToken;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_once(&amp;amp;onceToken, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //只执行一次&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@”hi”);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：GCD（Grand Central Dispatch），是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如NSThread,NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术。文章分享关于GCD的种种概念以及使用。&lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="iOS" scheme="http://charsdavy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Ruby 正则表达式</title>
    <link href="http://charsdavy.github.io/2016/04/13/ruby-regular-expression/"/>
    <id>http://charsdavy.github.io/2016/04/13/ruby-regular-expression/</id>
    <published>2016-04-13T14:17:11.000Z</published>
    <updated>2016-06-04T02:09:36.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：正则表达式是一种特殊序列的字符，它通过使用有专门语法的模式来匹配或查找字符串集合。&lt;br&gt;正则表达式用事先定义好的一些特定字符、及这些特定字符的组合，组成一个”规则字符串”，这个”规则字符串”用来表达对字符串的一种过滤逻辑。&lt;br&gt;文章分享关于Ruby中的正则表达式的相关知识与使用。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h1&gt;&lt;p&gt;正则表达式从字面上看是一种介于斜杠之间或介于跟在 %r 后的任意分隔符之间的模式，如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/pattern/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/pattern/im    # 可以指定选项&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%r!/usr/local! # 使用分隔符的正则表达式&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;实例&quot;&gt;&lt;a href=&quot;#实例&quot; class=&quot;headerlink&quot; title=&quot;实例&quot;&gt;&lt;/a&gt;实例&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#!/usr/bin/ruby&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;line1 = &amp;quot;Cats are smarter than dogs&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;line2 = &amp;quot;Dogs also like meat&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if ( line1 =~ /Cats(.*)/ )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  puts &amp;quot;Line1 contains Cats&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if ( line2 =~ /Cats(.*)/ )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  puts &amp;quot;Line2 contains  Dogs&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实例运行输出结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Line1 contains Cats&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;正则表达式修饰符&quot;&gt;&lt;a href=&quot;#正则表达式修饰符&quot; class=&quot;headerlink&quot; title=&quot;正则表达式修饰符&quot;&gt;&lt;/a&gt;正则表达式修饰符&lt;/h1&gt;&lt;p&gt;正则表达式从字面上看可能包含一个可选的修饰符，用于控制各方面的匹配。修饰符在第二个斜杠字符后指定，如上面实例所示。下标列出了 可能的修饰符：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;修饰符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;当匹配文本时忽略大小写。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;只执行一次 #{} 插值，正则表达式在第一次时就进行判断。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;忽略空格，允许在整个表达式中放入空白符和注释。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;匹配多行，把换行字符识别为正常字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u,e,s,n&lt;/td&gt;
&lt;td&gt;把正则表达式解释为 Unicode（UTF-8）、EUC、SJIS 或 ASCII。如果没有指定修饰符，则认为正则表达式使用的是源编码。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;就像字符串通过 %Q 进行分隔一样，Ruby 允许您以 %r 作为正则表达式的开头，后面跟着任意分隔符。这在描述包含大量您不想转义的斜杠字符时非常有用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# 下面匹配单个斜杠字符，不转义&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%r|/|&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;# Flag 字符可通过下面的语法进行匹配&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%r[&amp;lt;/(.*)&amp;gt;]i&lt;/code&gt; &lt;/p&gt;
&lt;h1 id=&quot;正则表达式模式&quot;&gt;&lt;a href=&quot;#正则表达式模式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式模式&quot;&gt;&lt;/a&gt;正则表达式模式&lt;/h1&gt;&lt;p&gt;除了控制字符，(+ ? . * ^ $ ( ) [ ] { } | )，其他所有字符都匹配本身。您可以通过在控制字符前放置一个反斜杠来对控制字符进行转义。&lt;/p&gt;
&lt;p&gt;下表列出了 Ruby 中可用的正则表达式语法。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模式&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;匹配行的开头。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;匹配行的结尾。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;匹配除了换行符以外的任意单字符。使用 m 选项时，它也可以匹配换行符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[…]&lt;/td&gt;
&lt;td&gt;匹配在方括号中的任意单字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[^…]&lt;/td&gt;
&lt;td&gt;匹配不在方括号中的任意单字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;re*&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式零次或多次。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;re+&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式一次或多次。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;re?&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式零次或一次。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;re{ n}&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式 n 次。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;re{ n,}&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式 n 次或 n 次以上。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;re{ n, m}&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式至少 n 次至多 m 次。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(re)&lt;/td&gt;
&lt;td&gt;对正则表达式进行分组，并记住匹配文本。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?imx)&lt;/td&gt;
&lt;td&gt;暂时打开正则表达式内的 i、 m 或 x 选项。如果在圆括号中，则只影响圆括号内的部分。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?-imx)&lt;/td&gt;
&lt;td&gt;暂时关闭正则表达式内的 i、 m 或 x 选项。如果在圆括号中，则只影响圆括号内的部分。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?: re)&lt;/td&gt;
&lt;td&gt;对正则表达式进行分组，但不记住匹配文本。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?imx: re)&lt;/td&gt;
&lt;td&gt;暂时打开圆括号内的 i、 m 或 x 选项。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?-imx: re)&lt;/td&gt;
&lt;td&gt;暂时关闭圆括号内的 i、 m 或 x 选项。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?#…)&lt;/td&gt;
&lt;td&gt;注释。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?= re)&lt;/td&gt;
&lt;td&gt;使用模式指定位置。没有范围。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?! re)&lt;/td&gt;
&lt;td&gt;使用模式的否定指定位置。没有范围。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?&amp;gt; re)&lt;/td&gt;
&lt;td&gt;匹配无回溯的独立模式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;匹配单词字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\W&lt;/td&gt;
&lt;td&gt;匹配非单词字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\s&lt;/td&gt;
&lt;td&gt;匹配空白字符。等价于 [\t\n\r\f]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\S&lt;/td&gt;
&lt;td&gt;匹配非空白字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\d&lt;/td&gt;
&lt;td&gt;匹配数字。等价于 [0-9]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\D&lt;/td&gt;
&lt;td&gt;匹配非数字。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\A&lt;/td&gt;
&lt;td&gt;匹配字符串的开头。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\Z&lt;/td&gt;
&lt;td&gt;匹配字符串的结尾。如果存在换行符，则只匹配到换行符之前。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\z&lt;/td&gt;
&lt;td&gt;匹配字符串的结尾。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\G&lt;/td&gt;
&lt;td&gt;匹配最后一个匹配完成的点。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\b&lt;/td&gt;
&lt;td&gt;当在括号外时匹配单词边界，当在括号内时匹配退格键（0x08）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\B&lt;/td&gt;
&lt;td&gt;匹配非单词边界。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\n, \t, etc.&lt;/td&gt;
&lt;td&gt;匹配换行符、回车符、制表符，等等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\1…\9&lt;/td&gt;
&lt;td&gt;匹配第 n 个分组子表达式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\10&lt;/td&gt;
&lt;td&gt;如果已匹配过，则匹配第 n 个分组子表达式。否则指向字符编码的八进制表示。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;补充：&lt;/strong&gt; &lt;code&gt;a|b&lt;/code&gt; ：匹配 a 或 b。&lt;/p&gt;
&lt;h1 id=&quot;正则表达式实例&quot;&gt;&lt;a href=&quot;#正则表达式实例&quot; class=&quot;headerlink&quot; title=&quot;正则表达式实例&quot;&gt;&lt;/a&gt;正则表达式实例&lt;/h1&gt;&lt;h2 id=&quot;字符&quot;&gt;&lt;a href=&quot;#字符&quot; class=&quot;headerlink&quot; title=&quot;字符&quot;&gt;&lt;/a&gt;字符&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/ruby/&lt;/td&gt;
&lt;td&gt;匹配 “ruby”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;¥&lt;/td&gt;
&lt;td&gt;匹配 Yen 符号。Ruby 1.9 和 Ruby 1.8 支持多个字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;字符类&quot;&gt;&lt;a href=&quot;#字符类&quot; class=&quot;headerlink&quot; title=&quot;字符类&quot;&gt;&lt;/a&gt;字符类&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/[Rr]uby/&lt;/td&gt;
&lt;td&gt;匹配 “Ruby” 或 “ruby”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/rub[ye]/&lt;/td&gt;
&lt;td&gt;匹配 “ruby” 或 “rube”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/[aeiou]/&lt;/td&gt;
&lt;td&gt;匹配任何一个小写元音字母&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/[0-9]/&lt;/td&gt;
&lt;td&gt;匹配任何一个数字，与 /[0123456789]/ 相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/[a-z]/&lt;/td&gt;
&lt;td&gt;匹配任何一个小写 ASCII 字母&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/[A-Z]/&lt;/td&gt;
&lt;td&gt;匹配任何一个大写 ASCII 字母&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/[a-zA-Z0-9]/&lt;/td&gt;
&lt;td&gt;匹配任何一个括号内的字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/[^aeiou]/&lt;/td&gt;
&lt;td&gt;匹配任何一个非小写元音字母的字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/[^0-9]/&lt;/td&gt;
&lt;td&gt;匹配任何一个非数字字符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;特殊字符类&quot;&gt;&lt;a href=&quot;#特殊字符类&quot; class=&quot;headerlink&quot; title=&quot;特殊字符类&quot;&gt;&lt;/a&gt;特殊字符类&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/./&lt;/td&gt;
&lt;td&gt;匹配除了换行符以外的其他任意字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/./m&lt;/td&gt;
&lt;td&gt;在多行模式下，也能匹配换行符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\d/&lt;/td&gt;
&lt;td&gt;匹配一个数字，等同于 /[0-9]/&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\D/&lt;/td&gt;
&lt;td&gt;匹配一个非数字，等同于 /[^0-9]/&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\s/&lt;/td&gt;
&lt;td&gt;匹配一个空白字符，等同于 /[ \t\r\n\f]/&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\S/&lt;/td&gt;
&lt;td&gt;匹配一个非空白字符，等同于 /[^ \t\r\n\f]/&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\w/&lt;/td&gt;
&lt;td&gt;匹配一个单词字符，等同于 /[A-Za-z0-9_]/&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\W/&lt;/td&gt;
&lt;td&gt;匹配一个非单词字符，等同于 /[^A-Za-z0-9_]/&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;重复&quot;&gt;&lt;a href=&quot;#重复&quot; class=&quot;headerlink&quot; title=&quot;重复&quot;&gt;&lt;/a&gt;重复&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/ruby?/&lt;/td&gt;
&lt;td&gt;匹配 “rub” 或 “ruby”。其中，y 是可有可无的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/ruby*/&lt;/td&gt;
&lt;td&gt;匹配 “rub” 加上 0 个或多个的 y。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/ruby+/&lt;/td&gt;
&lt;td&gt;匹配 “rub” 加上 1 个或多个的 y。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\d{3}/&lt;/td&gt;
&lt;td&gt;刚好匹配 3 个数字。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\d{3,}/&lt;/td&gt;
&lt;td&gt;匹配 3 个或多个数字。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\d{3,5}/&lt;/td&gt;
&lt;td&gt;匹配 3 个、4 个或 5 个数字。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;非贪婪重复&quot;&gt;&lt;a href=&quot;#非贪婪重复&quot; class=&quot;headerlink&quot; title=&quot;非贪婪重复&quot;&gt;&lt;/a&gt;非贪婪重复&lt;/h2&gt;&lt;p&gt;这会匹配最小次数的重复。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/&amp;lt;.*&amp;gt;/&lt;/td&gt;
&lt;td&gt;贪婪重复：匹配 “&lt;ruby&gt;perl&amp;gt;”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/&amp;lt;.*?&amp;gt;/&lt;/td&gt;
&lt;td&gt;非贪婪重复：匹配 “&lt;ruby&gt;perl&amp;gt;” 中的 “&lt;ruby&gt;“&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;通过圆括号进行分组&quot;&gt;&lt;a href=&quot;#通过圆括号进行分组&quot; class=&quot;headerlink&quot; title=&quot;通过圆括号进行分组&quot;&gt;&lt;/a&gt;通过圆括号进行分组&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/\D\d+/&lt;/td&gt;
&lt;td&gt;无分组： + 重复 \d&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/(\D\d)+/&lt;/td&gt;
&lt;td&gt;分组： + 重复 \D\d 对&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/([Rr]uby(, )?)+/&lt;/td&gt;
&lt;td&gt;匹配 “Ruby”、”Ruby, ruby, ruby”，等等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;反向引用&quot;&gt;&lt;a href=&quot;#反向引用&quot; class=&quot;headerlink&quot; title=&quot;反向引用&quot;&gt;&lt;/a&gt;反向引用&lt;/h2&gt;&lt;p&gt;这会再次匹配之前匹配过的分组。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/([Rr])uby&amp;amp;\1ails/&lt;/td&gt;
&lt;td&gt;匹配 ruby&amp;amp;rails 或 Ruby&amp;amp;Rails&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/([‘“])(?:(?!\1).)*\1/&lt;/td&gt;
&lt;td&gt;单引号或双引号字符串。\1 匹配第一个分组所匹配的字符，\2 匹配第二个分组所匹配的字符，依此类推。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;替换&quot;&gt;&lt;a href=&quot;#替换&quot; class=&quot;headerlink&quot; title=&quot;替换&quot;&gt;&lt;/a&gt;替换&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/ruby&lt;/td&gt;
&lt;td&gt;rube/&lt;/td&gt;
&lt;td&gt;匹配 “ruby” 或 “rube”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/rub(y&lt;/td&gt;
&lt;td&gt;le))/&lt;/td&gt;
&lt;td&gt;匹配 “ruby” 或 “ruble”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/ruby(!+&lt;/td&gt;
&lt;td&gt;\?)/&lt;/td&gt;
&lt;td&gt;“ruby” 后跟一个或多个 ! 或者跟一个 ?&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;锚&quot;&gt;&lt;a href=&quot;#锚&quot; class=&quot;headerlink&quot; title=&quot;锚&quot;&gt;&lt;/a&gt;锚&lt;/h2&gt;&lt;p&gt;这需要指定匹配位置。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/^Ruby/&lt;/td&gt;
&lt;td&gt;匹配以 “Ruby” 开头的字符串或行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/Ruby$/&lt;/td&gt;
&lt;td&gt;匹配以 “Ruby” 结尾的字符串或行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\ARuby/&lt;/td&gt;
&lt;td&gt;匹配以 “Ruby” 开头的字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/Ruby\Z/&lt;/td&gt;
&lt;td&gt;匹配以 “Ruby” 结尾的字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\bRuby\b/&lt;/td&gt;
&lt;td&gt;匹配单词边界的 “Ruby”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\brub\B/&lt;/td&gt;
&lt;td&gt;\B 是非单词边界：匹配 “rube” 和 “ruby” 中的 “rub”，但不匹配单独的 “rub”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/Ruby(?=!)/&lt;/td&gt;
&lt;td&gt;如果 “Ruby” 后跟着一个感叹号，则匹配 “Ruby”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/Ruby(?!!)/&lt;/td&gt;
&lt;td&gt;如果 “Ruby” 后没有跟着一个感叹号，则匹配 “Ruby”&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;圆括号的特殊语法&quot;&gt;&lt;a href=&quot;#圆括号的特殊语法&quot; class=&quot;headerlink&quot; title=&quot;圆括号的特殊语法&quot;&gt;&lt;/a&gt;圆括号的特殊语法&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/R(?#comment)/&lt;/td&gt;
&lt;td&gt;匹配 “R”。所有剩余的字符都是注释。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/R(?i)uby/&lt;/td&gt;
&lt;td&gt;当匹配 “uby” 时不区分大小写。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/R(?i:uby)/&lt;/td&gt;
&lt;td&gt;与上面相同。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt; &lt;code&gt;/rub(?:y|le))/&lt;/code&gt; ：只分组，不进行 \1 反向引用&lt;/p&gt;
&lt;h1 id=&quot;搜索和替换&quot;&gt;&lt;a href=&quot;#搜索和替换&quot; class=&quot;headerlink&quot; title=&quot;搜索和替换&quot;&gt;&lt;/a&gt;搜索和替换&lt;/h1&gt;&lt;p&gt;sub 和 gsub 及它们的替代变量 sub! 和 gsub! 是使用正则表达式时重要的字符串方法。&lt;/p&gt;
&lt;p&gt;所有这些方法都是使用正则表达式模式执行搜索与替换操作。sub 和 sub! 替换模式的第一次出现，gsub 和 gsub! 替换模式的所有出现。&lt;/p&gt;
&lt;p&gt;sub 和 gsub 返回一个新的字符串，保持原始的字符串不被修改，而 sub! 和 gsub! 则会修改它们调用的字符串。&lt;/p&gt;
&lt;p&gt;下面是一个实例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#!/usr/bin/ruby&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# -*- coding: UTF-8 -*-&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;phone = &amp;quot;138-3453-1111 #这是一个电话号码&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 删除 Ruby 的注释&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;phone = phone.sub!(/#.*$/, &amp;quot;&amp;quot;)   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   puts &amp;quot;电话号码 : #&amp;#123;phone&amp;#125;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 移除数字以外的其他字符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;phone = phone.gsub!(/\D/, &amp;quot;&amp;quot;)    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    puts &amp;quot;电话号码 : #&amp;#123;phone&amp;#125;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;以上实例运行结果：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;电话号码 : 138-3453-1111 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;电话号码 : 13834531111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;下面是另一个实例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#!/usr/bin/ruby&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# -*- coding: UTF-8 -*-&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;text = &amp;quot;rails 是 rails,  Ruby on Rails 非常好的 Ruby 框架&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 把所有的 &amp;quot;rails&amp;quot; 改为 &amp;quot;Rails&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;text.gsub!(&amp;quot;rails&amp;quot;, &amp;quot;Rails&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 把所有的单词 &amp;quot;Rails&amp;quot; 都改成首字母大写&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;text.gsub!(/\brails\b/, &amp;quot;Rails&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;puts &amp;quot;#&amp;#123;text&amp;#125;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上实例运行结果：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Rails 是 Rails,  Ruby on Rails 非常好的 Ruby 框架&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：正则表达式是一种特殊序列的字符，它通过使用有专门语法的模式来匹配或查找字符串集合。&lt;br&gt;正则表达式用事先定义好的一些特定字符、及这些特定字符的组合，组成一个”规则字符串”，这个”规则字符串”用来表达对字符串的一种过滤逻辑。&lt;br&gt;文章分享关于Ruby中的正则表达式的相关知识与使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Ruby" scheme="http://charsdavy.github.io/categories/script/"/>
    
    
      <category term="正则表达式" scheme="http://charsdavy.github.io/tags/script/"/>
    
  </entry>
  
</feed>
