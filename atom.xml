<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chars&#39;s Tech Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://charsdavy.github.io/"/>
  <updated>2016-06-02T00:22:17.000Z</updated>
  <id>http://charsdavy.github.io/</id>
  
  <author>
    <name>Chars Davy</name>
    <email>chars_d@126.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>七牛云存储应用</title>
    <link href="http://charsdavy.github.io/2016/06/02/qiniu-using/"/>
    <id>http://charsdavy.github.io/2016/06/02/qiniu-using/</id>
    <published>2016-06-02T00:17:42.000Z</published>
    <updated>2016-06-02T00:22:17.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：七牛云存储，是专为移动时代开发者打造的数据管理平台，为互联网网站和移动App提供数据的在线托管、传输加速以及图片、音视频等富媒体的云处理服务。本文讲述如何使用七牛云存储来作为自己APP的数据云存储空间。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;七牛云存储，是专为移动时代开发者打造的数据管理平台，为互联网网站和移动App提供数据的在线托管、传输加速以及图片、音视频等富媒体的云处理服务。&lt;br&gt;七牛云官网&lt;a href=&quot;http://www.qiniu.com/&quot;&gt;http://www.qiniu.com/&lt;/a&gt; ，进入开发者平台，浏览了所有的开发指南，可是却是没有具体清晰的操作步骤。今天自己试着通过网络，实现了使用七牛云存储文件。现在，将操作步骤记录如下。&lt;/p&gt;
&lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h1&gt;&lt;p&gt;1.注册七牛云账号。&lt;/p&gt;
&lt;p&gt;2.创建空间。&lt;/p&gt;
&lt;p&gt;3.获取Access Key。&lt;/p&gt;
&lt;p&gt;4.获取Secret Key。&lt;/p&gt;
&lt;p&gt;5.获取官方SDK（&lt;a href=&quot;https://github.com/qiniu/objc-sdk&quot;&gt;https://github.com/qiniu/objc-sdk&lt;/a&gt; ）。&lt;/p&gt;
&lt;h1 id=&quot;导入工程&quot;&gt;&lt;a href=&quot;#导入工程&quot; class=&quot;headerlink&quot; title=&quot;导入工程&quot;&gt;&lt;/a&gt;导入工程&lt;/h1&gt;&lt;p&gt;1.打开Xcode创建Project。&lt;/p&gt;
&lt;p&gt;2.从获取的官方SDK导入库，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-cd5c98eeccbbaef5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;br&gt;3.获取token&lt;/p&gt;
&lt;p&gt;这一步，网上大家都说得很简单，在这一步卡壳许久。现在说说自己使用的方法：&lt;/p&gt;
&lt;p&gt;1）获取服务器代码，编译工程，以备生成token。&lt;/p&gt;
&lt;p&gt;服务器代码地址：&lt;a href=&quot;https://github.com/CharsDavy/QiNiuGenertorToken&quot;&gt;https://github.com/CharsDavy/QiNiuGenertorToken&lt;/a&gt;&lt;br&gt;2）使用Eclipse导入上述服务器代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-825661cf6c402c56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Test.java文件中，修改自己的空间名称，Access Key和Secret Key。运行程序，即可获得token。&lt;/p&gt;
&lt;p&gt;这种方式生成的token的有效期是可以自己设定的，如果你想，设定1000年过期也是可以的。&lt;/p&gt;
&lt;p&gt;4.使用代码上传文件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;QiniuSDK.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString token = @&amp;quot;从服务端SDK获取&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QNUploadManager *upManager = [[QNUploadManager alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSData *data = [@&amp;quot;Hello, World!&amp;quot; dataUsingEncoding : NSUTF8StringEncoding];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [upManager putData:data key:@&amp;quot;hello&amp;quot; token:token&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        complete: ^(QNResponseInfo *info, NSString *key, NSDictionary *resp) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;%@&amp;quot;, info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;%@&amp;quot;, resp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; option:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;调试&quot;&gt;&lt;a href=&quot;#调试&quot; class=&quot;headerlink&quot; title=&quot;调试&quot;&gt;&lt;/a&gt;调试&lt;/h1&gt;&lt;p&gt;工程导入之后，可能会出现以下几种可能的错误。&lt;/p&gt;
&lt;p&gt;1.若报 &lt;code&gt;Undefined symbols for architecture x86_64: &amp;quot;_crc32&amp;quot;, referenced from:&lt;/code&gt;，项目中需导入 libz.dylib。(Build Phases—Link Binary With Libraries)&lt;/p&gt;
&lt;p&gt;2.若报&lt;code&gt;&amp;quot;_res_9_ninit&amp;quot;, referenced from: _setup_dns_server in QNResolver.o&lt;/code&gt;等，&lt;/p&gt;
&lt;p&gt;1）项目中需导入 libresolv.dylib或libresolv.9.dylib。(Build Phases— Link Binary With Libraries)；&lt;/p&gt;
&lt;p&gt;2）或 (Build Settings— Linking— Other Linker Flags) 添加 -lresolv选项。&lt;/p&gt;
&lt;p&gt;3.若报 Thread 1: EXC_BAD_ACCESS(code=1,address=0x180f4beb8)类似错误，将 QN打头的都设置 arc (Build Phases — Compile Sources)&lt;/p&gt;
&lt;p&gt;4.可能需要修改部分内容，如 &lt;code&gt;#import &amp;lt;AFNetworking/AFNetworking.h&amp;gt;&lt;/code&gt;改为 &lt;code&gt;#import &amp;quot;AFNetworking.h&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h1&gt;&lt;p&gt;以上就是本人在工程中使用七牛云进行文件云存储的过程，本文中使用的仅仅是上传文件，更多其他操作功能请参照官方文档。&lt;/p&gt;
&lt;p&gt;最后，附上一个使用七牛云存储的软件，源码地址：&lt;a href=&quot;https://github.com/CharsDavy/MyNotes&quot;&gt;https://github.com/CharsDavy/MyNotes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实，对于获取token来完成上载操作，也可以参考官方文档，地址&lt;br&gt;&lt;a href=&quot;http://developer.qiniu.com/docs/v6/api/reference/security/put-policy.html&quot;&gt;http://developer.qiniu.com/docs/v6/api/reference/security/put-policy.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：七牛云存储，是专为移动时代开发者打造的数据管理平台，为互联网网站和移动App提供数据的在线托管、传输加速以及图片、音视频等富媒体的云处理服务。本文讲述如何使用七牛云存储来作为自己APP的数据云存储空间。&lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="iOS" scheme="http://charsdavy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>你和日本的距离只差5mm</title>
    <link href="http://charsdavy.github.io/2016/06/01/chopsticks-using/"/>
    <id>http://charsdavy.github.io/2016/06/01/chopsticks-using/</id>
    <published>2016-06-01T12:38:19.000Z</published>
    <updated>2016-06-01T23:56:52.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：世界上使用筷子的国家并不是很多，很多人都认为能够使用筷子是件很神奇的事情。那么，不同的国家地区使用筷子的讲究也有所不同。这里主要说说日本使用筷子的禁忌，有些也很符合天朝国情的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;日本在使用筷子的时候，也有很大的「箸（はし）」学问，有什么禁忌是千万不要犯的呢？！&lt;/p&gt;
&lt;p&gt;✖握り箸（にぎりばし）——握筷子，这是初级错误，一般来说只有初学使用筷子的孩子和外国人会犯。&lt;/p&gt;
&lt;p&gt;✖クロス箸——两根筷子交叉，很不雅观。 &lt;/p&gt;
&lt;p&gt;✖迷い箸（まよいばし）——拿起筷子犹豫不决，前后左右晃动，似乎在挑拣食物。&lt;/p&gt;
&lt;p&gt;✖移り箸（うつりばし）——前面食物的味道还残留在口中，就取另外的食物。&lt;/p&gt;
&lt;p&gt;✖こじ箸——在碗底翻腾取食物。&lt;/p&gt;
&lt;p&gt;✖寄せ箸（よせばし）——用筷子拨动、移动盘子。&lt;/p&gt;
&lt;p&gt;✖刺し箸（さしばし）——用筷子扎取食物（对于不会用筷子的人来说，吃丸子的时候不这样会很难~）。&lt;/p&gt;
&lt;p&gt;✖涙箸——“泪筷子”，这个名称很形象，筷子夹起食物滴滴答答的流汤。&lt;/p&gt;
&lt;p&gt;✖かき箸——把碗放在嘴边，用筷子把食品拨拉到嘴里。&lt;/p&gt;
&lt;p&gt;✖込み箸（こみばし）——筷子进嘴塞食。&lt;/p&gt;
&lt;p&gt;✖持ち箸（もちばし）——把筷子拿在手里，端起碗吸食，日本农民 。&lt;/p&gt;
&lt;p&gt;✖ねぶり箸——把筷子放在嘴里吸允。&lt;/p&gt;
&lt;p&gt;✖渡し箸（わたしばし）——把筷子架在碗上。&lt;/p&gt;
&lt;p&gt;✖叩き箸（はたきばし）——用筷子敲碗催促他人（这样真的很招人烦）。&lt;/p&gt;
&lt;p&gt;✖指さし箸（ゆびさしばし）——用筷子指人（用手指人也是很不好的）。&lt;/p&gt;
&lt;p&gt;✖直箸（じかばし）——有公筷不用，直接使用自己的筷子在盘内取食。&lt;/p&gt;
&lt;p&gt;✖立箸——把筷子插在米饭碗里。&lt;/p&gt;
&lt;p&gt;✖そろえ箸——用舌头、嘴唇或者其他平面整理、理顺两根筷子（为什么不用手，这样多累啊）。 &lt;/p&gt;
&lt;p&gt;✖探り箸（さぐりばし）——用筷子在盘子里搅拌、寻找食物（瞄准一个直接吃得了，在那ba la啥）。&lt;/p&gt;
&lt;p&gt;✖せせり箸——把筷子当牙签使（小花儿表示：她的牙缝没这么大）。&lt;/p&gt;
&lt;p&gt;✖かみ箸——用牙齿咬筷子。&lt;/p&gt;
&lt;p&gt;✖振り箸（ふりばし）——甩手抖落筷子上的汤汁（轻微洁癖真的有点接受不了）。&lt;/p&gt;
&lt;p&gt;✖洗い箸（あらい）——在碗盘汤中涮洗筷子。&lt;/p&gt;
&lt;p&gt;✖箸渡し（はしわたし）——用筷子向他人的筷子递送食品。&lt;br&gt;✖そら箸——筷子靠近了盘子，却又不取食品。&lt;/p&gt;
&lt;p&gt;以上是25条使用筷子的禁忌。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：世界上使用筷子的国家并不是很多，很多人都认为能够使用筷子是件很神奇的事情。那么，不同的国家地区使用筷子的讲究也有所不同。这里主要说说日本使用筷子的禁忌，有些也很符合天朝国情的。&lt;/p&gt;
    
    </summary>
    
      <category term="爱好" scheme="http://charsdavy.github.io/categories/hobby/"/>
    
    
      <category term="日语" scheme="http://charsdavy.github.io/tags/Japanese/"/>
    
  </entry>
  
  <entry>
    <title>手把手教 GitHub + Hexo 搭建博客</title>
    <link href="http://charsdavy.github.io/2016/05/31/build-blog-by-hexo/"/>
    <id>http://charsdavy.github.io/2016/05/31/build-blog-by-hexo/</id>
    <published>2016-05-31T14:07:27.000Z</published>
    <updated>2016-06-01T23:54:52.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：本文章主要介绍使用hexo框架搭建博客，使用GitHub免费托管自己的博客代码，并使用GitHub Pages提供的免费服务。换句话说，就是使用免费资源搭建属于自己的博客网站。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在很久以前，博主就想着要有自主的博客专栏或者网站。经历了博客园这个需要所谓的编辑审核，一直比较困惑，这些编辑是什么出身，怎么知道技术博客的价值性。&lt;/p&gt;
&lt;p&gt;接下来找到了开源中国，这个可以自由发言的地方。不过，不知道是不是受众面不广，访问量都不是很理想。&lt;/p&gt;
&lt;p&gt;再然后就来自己动手开始搭建博客。从手写html发布文章，到使用jekyll，最后到了hexo阵营。&lt;/p&gt;
&lt;p&gt;终于，有种找到家的赶脚。hexo不仅搭建方便，而且在后续的功能扩展以及文章发布都是非常方便的。不仅如此，还可以本地调试，预览效果。最方便的是支持markdown编写文档。&lt;/p&gt;
&lt;p&gt;本文就是介绍如何安装使用hexo搭建属于自己的博客。从此不再担心投稿被莫名拒绝。可以在自己的一亩三分地讲述着自己的故事。&lt;/p&gt;
&lt;h1 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h1&gt;&lt;h2 id=&quot;安装Git&quot;&gt;&lt;a href=&quot;#安装Git&quot; class=&quot;headerlink&quot; title=&quot;安装Git&quot;&gt;&lt;/a&gt;安装Git&lt;/h2&gt;&lt;p&gt;MAC OS X 是自带Git命令行工具。&lt;/p&gt;
&lt;p&gt;Windows 可以安装Git Bash。&lt;/p&gt;
&lt;h2 id=&quot;安装Node-js&quot;&gt;&lt;a href=&quot;#安装Node-js&quot; class=&quot;headerlink&quot; title=&quot;安装Node.js&quot;&gt;&lt;/a&gt;安装Node.js&lt;/h2&gt;&lt;p&gt;前往&lt;a href=&quot;https://nodejs.org/en/&quot;&gt;官网地址&lt;/a&gt;，根据教程安装即可。&lt;/p&gt;
&lt;h2 id=&quot;安装hexo&quot;&gt;&lt;a href=&quot;#安装hexo&quot; class=&quot;headerlink&quot; title=&quot;安装hexo&quot;&gt;&lt;/a&gt;安装hexo&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo npm install hexo-cli -g&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;使用hexo&quot;&gt;&lt;a href=&quot;#使用hexo&quot; class=&quot;headerlink&quot; title=&quot;使用hexo&quot;&gt;&lt;/a&gt;使用hexo&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 创建hexo文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ mkdir hexo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 进入hexo文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd hexo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 初始化hexo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ hexo init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 安装依赖包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ npm install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 本地查看&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 先运行下面的命令，再在浏览器输入localhost:4000即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 问题：执行hexo server提示找不到该指令&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 解决办法：在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ npm install hexo -server --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;生成静态网站&quot;&gt;&lt;a href=&quot;#生成静态网站&quot; class=&quot;headerlink&quot; title=&quot;生成静态网站&quot;&gt;&lt;/a&gt;生成静态网站&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── .deploy #需要部署的文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── node_modules #Hexo插件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── public #生成的静态网页文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── scaffolds #模板&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| ├── _drafts #草稿&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| └── _posts #文章&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── themes #主题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── _config.yml #全局配置文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;└── package.json&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;全局配置-config-yml&quot;&gt;&lt;a href=&quot;#全局配置-config-yml&quot; class=&quot;headerlink&quot; title=&quot;全局配置 _config.yml&quot;&gt;&lt;/a&gt;全局配置 _config.yml&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# Hexo Configuration&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## Docs: http://hexo.io/docs/configuration.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## Source: https://github.com/hexojs/hexo/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Site #站点信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;title:  #标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;subtitle:  #副标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;description:  #站点描述，给搜索引擎看的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;author:  #作者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;email:  #电子邮箱&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;language: zh-CN #语言&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# URL #链接格式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;url:  #网址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root: / #根目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;permalink: :year/:month/:day/:title/ #文章的链接格式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tag_dir: tags #标签目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;archive_dir: archives #存档目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;category_dir: categories #分类目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;code_dir: downloads/code&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;permalink_defaults:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Directory #目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;source_dir: source #源文件目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public_dir: public #生成的网页文件目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Writing #写作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new_post_name: :title.md #新文章标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;titlecase: false #标题转换成大写&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;external_link: true #在新选项卡中打开连接&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;filename_case: 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;render_drafts: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;post_asset_folder: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;relative_link: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;highlight: #语法高亮&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  enable: true #是否启用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  line_number: true #显示行号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  tab_replace:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Category &amp;amp; Tag #分类和标签&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;default_category: uncategorized #默认分类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;category_map:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tag_map:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Archives&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2: 开启分页&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1: 禁用分页&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0: 全部禁用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;archive: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;category: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tag: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Server #本地服务器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;port: 4000 #端口号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;server_ip: localhost #IP 地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;logger: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;logger_format: dev&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Date / Time format #日期时间格式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;time_format: H:mm:ss&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Pagination #分页&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;per_page: 10 #每页文章数，设置成 0 禁用分页&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pagination_dir: page&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Disqus #Disqus评论，替换为多说&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;disqus_shortname:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Extensions #拓展插件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;theme: landscape-plus #主题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exclude_generator:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plugins: #插件，例如生成 RSS 和站点地图的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- hexo-generator-feed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- hexo-generator-sitemap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Deployment #部署，将 lmintlcx 改成用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;deploy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type: git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  repo: github创库地址.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  branch: master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置文件的冒号“:”后面有一个空格&lt;/li&gt;
&lt;li&gt;repo: github创库地址.git&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;hexo命令行使用&quot;&gt;&lt;a href=&quot;#hexo命令行使用&quot; class=&quot;headerlink&quot; title=&quot;hexo命令行使用&quot;&gt;&lt;/a&gt;hexo命令行使用&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;常用命令：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo help #查看帮助&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo init #初始化一个目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo new &amp;quot;postName&amp;quot; #新建文章&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo new page &amp;quot;pageName&amp;quot; #新建页面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo generate #生成网页，可以在 public 目录查看整个网站的文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo server #本地预览，&amp;apos;Ctrl+C&amp;apos;关闭&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo deploy #部署.deploy目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo clean #清除缓存，强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;简写：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo n == hexo new&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo g == hexo generate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo s == hexo server&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo d == hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;使用GitHub&quot;&gt;&lt;a href=&quot;#使用GitHub&quot; class=&quot;headerlink&quot; title=&quot;使用GitHub&quot;&gt;&lt;/a&gt;使用GitHub&lt;/h1&gt;&lt;h2 id=&quot;注册账号&quot;&gt;&lt;a href=&quot;#注册账号&quot; class=&quot;headerlink&quot; title=&quot;注册账号&quot;&gt;&lt;/a&gt;注册账号&lt;/h2&gt;&lt;p&gt;前往GitHub官网注册账号，按照网站提示注册。&lt;/p&gt;
&lt;h2 id=&quot;创建代码仓库&quot;&gt;&lt;a href=&quot;#创建代码仓库&quot; class=&quot;headerlink&quot; title=&quot;创建代码仓库&quot;&gt;&lt;/a&gt;创建代码仓库&lt;/h2&gt;&lt;p&gt;这个仓库的名字需要和你的账号对应。格式: yourname.github.io&lt;/p&gt;
&lt;p&gt;具体使用GitHub可以参考：&lt;a href=&quot;http://charsdavy.github.io/2016/05/20/github-using/&quot;&gt;《GitHub 使用》&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;编辑文章&quot;&gt;&lt;a href=&quot;#编辑文章&quot; class=&quot;headerlink&quot; title=&quot;编辑文章&quot;&gt;&lt;/a&gt;编辑文章&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 新建文章&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &amp;quot;标题&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 _posts 目录下会生成文件标题.md&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;title: Hello World&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;date: 2015-07-30 07:56:29 #发表日期，一般不改动&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;categories: hexo #文章文类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tags: [hexo,github] #文章标签，多于一项时用这种格式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;正文，使用Markdown语法书写&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;编辑完后保存, 预览&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;hexo部署&quot;&gt;&lt;a href=&quot;#hexo部署&quot; class=&quot;headerlink&quot; title=&quot;hexo部署&quot;&gt;&lt;/a&gt;hexo部署&lt;/h1&gt;&lt;p&gt;执行下列指令完成部署&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo generate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以下提示说明部署成功&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[info] Deploy done: git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;hexo插件使用&quot;&gt;&lt;a href=&quot;#hexo插件使用&quot; class=&quot;headerlink&quot; title=&quot;hexo插件使用&quot;&gt;&lt;/a&gt;hexo插件使用&lt;/h1&gt;&lt;h2 id=&quot;添加rss订阅功能&quot;&gt;&lt;a href=&quot;#添加rss订阅功能&quot; class=&quot;headerlink&quot; title=&quot;添加rss订阅功能&quot;&gt;&lt;/a&gt;添加rss订阅功能&lt;/h2&gt;&lt;p&gt;安装hexo-generator-feed插件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm install hexo-generator-feed --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;安装完后，会在node_modules目录下生成hexo-generator-feed目录。然后将其配置到根目录的_config.yml&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# Extensions&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## Plugins: http://hexo.io/plugins/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#RSS订阅&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plugin:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- hexo-generator-feed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#Feed Atom&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;feed: #可选项，可以不填&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;type: atom&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;path: atom.xml&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;limit: 20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后，在你当前主题下的_config.yml下，添加RSS订阅链接即可，这里博主用的是Yilia主题，subnav下添加rss：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# SubNav&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;subnav:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rss: &amp;quot;/atom.xml&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;至此，博客搭建完成，基本使用介绍完毕。希望对大家有所帮助。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：本文章主要介绍使用hexo框架搭建博客，使用GitHub免费托管自己的博客代码，并使用GitHub Pages提供的免费服务。换句话说，就是使用免费资源搭建属于自己的博客网站。&lt;/p&gt;
    
    </summary>
    
      <category term="应用实战" scheme="http://charsdavy.github.io/categories/apply/"/>
    
    
      <category term="hexo" scheme="http://charsdavy.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>YYModel源代码阅读 - 基础知识</title>
    <link href="http://charsdavy.github.io/2016/05/27/YYModel-reading/"/>
    <id>http://charsdavy.github.io/2016/05/27/YYModel-reading/</id>
    <published>2016-05-27T12:51:21.000Z</published>
    <updated>2016-06-02T00:05:03.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：YYModel堪称神级大作，虽然不免一些小bug，但是完全不影响膝盖碎一地。文章主要分享在阅读YYModel源代码时，所引发的知识点的补充与思考。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这段时间因为工作需要，阅读了YYModel这个开源框架，至于它能做什么，最直白的讲述就是JSON与Model之间的相互转化。&lt;/p&gt;
&lt;p&gt;源代码在&lt;a href=&quot;https://github.com/ibireme/YYModel&quot;&gt;Github&lt;/a&gt;，大家可以自行&lt;code&gt;git clone&lt;/code&gt;或者download。&lt;/p&gt;
&lt;p&gt;接下来，笔者主要分析阅读源代码而引出的各种问题与知识点，不足之处请大家指正。&lt;/p&gt;
&lt;h1 id=&quot;NS-ASSUME-NONNULL-BEGIN-amp-NS-ASSUME-NONNULL-END&quot;&gt;&lt;a href=&quot;#NS-ASSUME-NONNULL-BEGIN-amp-NS-ASSUME-NONNULL-END&quot; class=&quot;headerlink&quot; title=&quot;NS_ASSUME_NONNULL_BEGIN &amp;amp; NS_ASSUME_NONNULL_END&quot;&gt;&lt;/a&gt;NS_ASSUME_NONNULL_BEGIN &amp;amp; NS_ASSUME_NONNULL_END&lt;/h1&gt;&lt;p&gt;这组宏是成对使用的，不得不说我们自己写代码的时候使用的很少，以至于遗漏这个知识点，现在我们就来看看这两个宏会引出什么问题。&lt;/p&gt;
&lt;p&gt;这组宏会引出几个关于Objective-C新特性的知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Nullability Annotations&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Lightweight Generics&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;__kindof&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Nullability-Annotations&quot;&gt;&lt;a href=&quot;#Nullability-Annotations&quot; class=&quot;headerlink&quot; title=&quot;Nullability Annotations&quot;&gt;&lt;/a&gt;Nullability Annotations&lt;/h2&gt;&lt;p&gt;我们都知道在swift中，可以使用!和?来表示一个对象是optional的还是non-optional，如view?和view!。而在 Objective-C中则没有这一区分，view既可表示这个对象是optional，也可表示是non-optioanl。这样就会造成一个问题：在 Swift与Objective-C混编时，Swift编译器并不知道一个Objective-C对象到底是optional还是non-optional，因此这种情况下编译器会隐式地将Objective-C的对象当成是non-optional。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，苹果在Xcode 6.3引入了一个Objective-C的新特性：&lt;strong&gt;nullability annotations&lt;/strong&gt;。这一新特性的核心是两个新的类型注释：&lt;strong&gt; __nullable&lt;/strong&gt; 和 &lt;strong&gt;__nonnull&lt;/strong&gt; 。从字面上我们可以猜到，&lt;code&gt;__nullable&lt;/code&gt;表示对象可以是NULL或nil，而&lt;code&gt;__nonnull&lt;/code&gt;表示对象不应该为空。当我们不遵循这一规则时，编译器就会给出警告。&lt;/p&gt;
&lt;p&gt;我们来看看以下的实例，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface TestNullabilityClass ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, copy) NSArray * items;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)itemWithName:(NSString * __nonnull)name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation TestNullabilityClass&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)testNullability &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self itemWithName:nil];    // 编译器警告：Null passed to a callee that requires a non-null argument&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)itemWithName:(NSString * __nonnull)name &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不过这只是一个警告，程序还是能编译通过并运行。&lt;/p&gt;
&lt;p&gt;事实上，在任何可以使用const关键字的地方都可以使用&lt;code&gt;__nullable&lt;/code&gt;和&lt;code&gt;__nonnull&lt;/code&gt;，不过这两个关键字仅限于使用在指针类型上。而在方法的声明中，我们还可以使用不带下划线的&lt;code&gt;nullable&lt;/code&gt;和&lt;code&gt;nonnull&lt;/code&gt;，如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (nullable id)itemWithName:(NSString * nonnull)name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在属性声明中，也增加了两个相应的特性，因此上例中的items属性可以如下声明：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, copy, nonnull) NSArray * items;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当然也可以用以下这种方式：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, copy) NSArray * __nonnull items;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;推荐使用nonnull这种方式，这样可以让属性声明看起来更清晰。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Nonnull区域设置-Audited-Regions&quot;&gt;&lt;a href=&quot;#Nonnull区域设置-Audited-Regions&quot; class=&quot;headerlink&quot; title=&quot;Nonnull区域设置(Audited Regions)&quot;&gt;&lt;/a&gt;Nonnull区域设置(Audited Regions)&lt;/h3&gt;&lt;p&gt;如果需要每个属性或每个方法都去指定&lt;code&gt;nonnull&lt;/code&gt;和&lt;code&gt;nullable&lt;/code&gt;，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：&lt;strong&gt;NS_ASSUME_NONNULL_BEGIN&lt;/strong&gt;和&lt;strong&gt;NS_ASSUME_NONNULL_END&lt;/strong&gt;。在这两个宏之间的代码，所有简单指针对象都被假定为 &lt;code&gt;nonnull&lt;/code&gt;，因此我们只需要去指定那些&lt;code&gt;nullable&lt;/code&gt;的指针。如下代码所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NS_ASSUME_NONNULL_BEGIN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface TestNullabilityClass ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, copy) NSArray * items;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)itemWithName:(nullable NSString *)name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NS_ASSUME_NONNULL_END&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在上面的代码中，items属性默认是nonnull的，itemWithName:方法的返回值也是nonnull，而参数是指定为nullable的。&lt;/p&gt;
&lt;p&gt;不过，为了安全起见，苹果还制定了几条规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;typedef定义的类型的nullability特性通常依赖于上下文，即使是在Audited Regions中，也不能假定它为nonnull。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;复杂的指针类型(如id &lt;em&gt;)必须显示去指定是nonnull还是nullable。例如，指定一个指向nullable对象的nonnull指针，可以使用”__nullable id &lt;/em&gt; __nonnull”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们经常使用的NSError **通常是被假定为一个指向nullable NSError对象的nullable指针。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;兼容性&quot;&gt;&lt;a href=&quot;#兼容性&quot; class=&quot;headerlink&quot; title=&quot;兼容性&quot;&gt;&lt;/a&gt;兼容性&lt;/h3&gt;&lt;p&gt;因为Nullability Annotations是Xcode 6.3新加入的，所以我们需要考虑之前的老代码。实际上，苹果已以帮我们处理好了这种兼容问题，我们可以安全地使用它们：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;老代码仍然能正常工作，即使对nonnull对象使用了nil也没有问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;老代码在需要和swift混编时，在新的swift编译器下会给出一个警告。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;nonnull不会影响性能。事实上，我们仍然可以在运行时去判断我们的对象是否为nil。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事实上，我们可以将nonnull/nullable与我们的断言和异常一起看待，其需要处理的问题都是同一个：违反约定是一个程序员的错误。特别是，返回值是我们可控的东西，如果返回值是nonnull的，则我们不应该返回nil，除非是为了向后兼容。&lt;/p&gt;
&lt;h2 id=&quot;Lightweight-Generics&quot;&gt;&lt;a href=&quot;#Lightweight-Generics&quot; class=&quot;headerlink&quot; title=&quot;Lightweight Generics&quot;&gt;&lt;/a&gt;Lightweight Generics&lt;/h2&gt;&lt;p&gt;Lightweight Generics 轻量级泛型，轻量是因为这是个纯编译器的语法支持（LLVM 7.0），和 Nullability 一样，没有借助任何 objc runtime 的升级，也就是说，这个新语法在 Xcode 7 上可以使用且完全向下兼容（更低的 iOS 版本）&lt;/p&gt;
&lt;h3 id=&quot;带泛型的容器&quot;&gt;&lt;a href=&quot;#带泛型的容器&quot; class=&quot;headerlink&quot; title=&quot;带泛型的容器&quot;&gt;&lt;/a&gt;带泛型的容器&lt;/h3&gt;&lt;p&gt;这无疑是本次最重大的改进，有了泛型后终于可以指定容器类中对象的类型了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSArray&amp;lt;NSString *&amp;gt; *strings = @[@&amp;quot;sun&amp;quot;, @&amp;quot;yuan&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDictionary&amp;lt;NSString *, NSNumber *&amp;gt; *mapping = @&amp;#123;@&amp;quot;a&amp;quot;: @1, @&amp;quot;b&amp;quot;: @2&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回值的 id 被替换成具体的类型后，令人感动的代码提示也出来了。&lt;/p&gt;
&lt;p&gt;假如向泛型容器中加入错误的对象，编译器会不开心的。&lt;/p&gt;
&lt;p&gt;系统中常用的一系列容器类型都增加了泛型支持，甚至连 &lt;code&gt;NSEnumerator&lt;/code&gt; 都支持了，这是非常 Nice 的改进。和 &lt;code&gt;Nullability&lt;/code&gt; 一样，我认为最大的意义还是丰富了接口描述信息，对比下面两种写法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (readonly) NSArray *imageURLs;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (readonly) NSArray&amp;lt;NSURL *&amp;gt; *imageURLs;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不用多想就清楚下面的数组中存的是什么，避免了 &lt;code&gt;NSString&lt;/code&gt; 和 &lt;code&gt;NSURL&lt;/code&gt; 的混乱。&lt;/p&gt;
&lt;h3 id=&quot;自定义泛型类&quot;&gt;&lt;a href=&quot;#自定义泛型类&quot; class=&quot;headerlink&quot; title=&quot;自定义泛型类&quot;&gt;&lt;/a&gt;自定义泛型类&lt;/h3&gt;&lt;p&gt;比起使用系统的泛型容器，更好玩的是自定义一个泛型类，目前这里还没什么文档，但拦不住我们写测试代码，假设我们要自定义一个 Stack 容器类：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface Stack&amp;lt;ObjectType&amp;gt; : NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)pushObject:(ObjectType)object;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (ObjectType)popObject;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, readonly) NSArray&amp;lt;ObjectType&amp;gt; *allObjects;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个 &lt;code&gt;ObjectType&lt;/code&gt; 是传入类型的 &lt;code&gt;placeholder&lt;/code&gt;，它只能在 &lt;code&gt;@interface&lt;/code&gt; 上定义（类声明、类扩展、Category），如果你喜欢用 T 表示也 OK，这个类型在 &lt;code&gt;@interface&lt;/code&gt; 和 &lt;code&gt;@end&lt;/code&gt; 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型，应该说一切都是符合预期的。我们还可以给 ObjectType 增加类型限制，比如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 只接受 NSNumber * 的泛型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface Stack&amp;lt;ObjectType: NSNumber *&amp;gt; : NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 只接受满足 NSCopying 协议的泛型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface Stack&amp;lt;ObjectType: id&amp;lt;NSCopying&amp;gt;&amp;gt; : NSObject&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;若什么都不加，表示接受任意类型 ( id )；当类型不满足时编译器将产生 error。&lt;br&gt;实例化一个 Stack，一切工作正常：&lt;/p&gt;
&lt;p&gt;对于多参数的泛型，用逗号隔开，其他都一样，可以参考 NSDictionary 的头文件。&lt;/p&gt;
&lt;h3 id=&quot;协变性和逆变性&quot;&gt;&lt;a href=&quot;#协变性和逆变性&quot; class=&quot;headerlink&quot; title=&quot;协变性和逆变性&quot;&gt;&lt;/a&gt;协变性和逆变性&lt;/h3&gt;&lt;p&gt;当类支持泛型后，它们的 Type 发生了变化，比如下面三个对象看上去都是 Stack，但实际上属于三个 Type：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Stack *stack; // Stack *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack&amp;lt;NSString *&amp;gt; *stringStack; // Stack&amp;lt;NSString *&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack&amp;lt;NSMutableString *&amp;gt; *mutableStringStack; // Stack&amp;lt;NSMutableString *&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当其中两种类型做类型转化时，编译器需要知道哪些转化是允许的，哪些是禁止的，比如，默认情况下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Stack *stack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack&amp;lt;NSString *&amp;gt; *stringStack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack&amp;lt;NSMutableString *&amp;gt; *mutableStringStack; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stack = stringStack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stack = mutableStringStack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stringStack = stack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stringStack = mutableStringStack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mutableStringStack = stack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mutableStringStack = stringStack&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在Xcode中我们可以看到，不指定泛型类型的 Stack 可以和任意泛型类型转化，但指定了泛型类型后，两个不同类型间是不可以强转的，假如你希望主动控制转化关系，就需要使用泛型的协变性和逆变性修饰符了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__covariant - 协变性，子类型可以强转到父类型（里氏替换原则）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__contravariant - 逆变性，父类型可以强转到子类型（WTF）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;协变&quot;&gt;&lt;a href=&quot;#协变&quot; class=&quot;headerlink&quot; title=&quot;协变&quot;&gt;&lt;/a&gt;协变&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface Stack&amp;lt;__covariant ObjectType&amp;gt; : NSObject&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;逆变&quot;&gt;&lt;a href=&quot;#逆变&quot; class=&quot;headerlink&quot; title=&quot;逆变&quot;&gt;&lt;/a&gt;逆变&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface Stack&amp;lt;__contravariant ObjectType&amp;gt; : NSObject&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;协变是非常好理解的，像 &lt;code&gt;NSArray&lt;/code&gt; 的泛型就用了协变的修饰符。&lt;/p&gt;
&lt;h2 id=&quot;kindof&quot;&gt;&lt;a href=&quot;#kindof&quot; class=&quot;headerlink&quot; title=&quot;__kindof&quot;&gt;&lt;/a&gt;__kindof&lt;/h2&gt;&lt;p&gt;&lt;code&gt;__kindof&lt;/code&gt; 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 &lt;code&gt;UITableView&lt;/code&gt; 的这个方法来说：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用时前面基本会使用 &lt;code&gt;UITableViewCell&lt;/code&gt; 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 &lt;code&gt;UITableViewCell&lt;/code&gt; 或 &lt;code&gt;UITableViewCell&lt;/code&gt; 子类的实例，于是新的 &lt;code&gt;__kindof&lt;/code&gt; 关键字解决了这个问题：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView 的 subviews 属性被修改成了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, readonly, copy) NSArray&amp;lt;__kindof UIView *&amp;gt; *subviews;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，写下面的代码时就没有任何警告了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIButton *button = view.subviews.lastObject;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;NS-ENUM-amp-NS-OPTIONS&quot;&gt;&lt;a href=&quot;#NS-ENUM-amp-NS-OPTIONS&quot; class=&quot;headerlink&quot; title=&quot;NS_ENUM &amp;amp; NS_OPTIONS&quot;&gt;&lt;/a&gt;NS_ENUM &amp;amp; NS_OPTIONS&lt;/h1&gt;&lt;p&gt;枚举是指将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。&lt;/p&gt;
&lt;p&gt;枚举本质上是一个整数，枚举的作用是把值限定在指定的范围内，并且增加代码的可读性。 枚举的成员如果没有显示指定值，那么第一个成员的值总是0，后面成员的值依次递增。枚举可以直接用于比较。&lt;/p&gt;
&lt;p&gt;一般我们声明枚举：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 声明枚举类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;enum Direction &amp;#123;up, down, left = 10, right&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main(int argc, const char * argv[])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其中up = 0, down = 1, left = 10, right = 11。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们会发现枚举中一些不可自定义的部分，例如，枚举名。&lt;/p&gt;
&lt;p&gt;NS_ENUM 和 NS_OPTIONS 都不算太古老的宏，在iOS 6 / OS X Mountain Lion才开始有，它们都是代替 enum 的更好的办法。&lt;/p&gt;
&lt;h2 id=&quot;NS-ENUM&quot;&gt;&lt;a href=&quot;#NS-ENUM&quot; class=&quot;headerlink&quot; title=&quot;NS_ENUM&quot;&gt;&lt;/a&gt;NS_ENUM&lt;/h2&gt;&lt;p&gt;如果要在早期的iOS或OS X系统中使用这两个宏，简单定义一下就好&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#ifndef NS_ENUM&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在OS X 10.4 中的原始定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define NS_ENUM(_type, _name) CF_ENUM(_type, _name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define NS_OPTIONS(_type, _name) CF_OPTIONS(_type, _name)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在之前枚举可以这么定义：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef enum &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellStyleDefault,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellStyleValue1,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellStyleValue2,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellStyleSubtitle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef NSInteger UITableViewCellStyle;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在，有了统一的风格&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef NS_ENUM(NSInteger, UITableViewCellSelectionStyle) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellSelectionStyleNone,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellSelectionStyleBlue,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellSelectionStyleGray,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellSelectionStyleDefault&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;NS_ENUM&lt;/code&gt; 的第一个参数是用于存储的新类型的类型。在64位环境下，&lt;code&gt;UITableViewCellStyle&lt;/code&gt; 和 &lt;code&gt;NSInteger&lt;/code&gt; 一样有8 bytes长。你要保证你给出的所有值能被该类型容纳，否则就会产生错误。第二个参数是新类型的名字。大括号里面和以前一样，是你要定义的各种值。&lt;/p&gt;
&lt;h2 id=&quot;NS-OPTIONS&quot;&gt;&lt;a href=&quot;#NS-OPTIONS&quot; class=&quot;headerlink&quot; title=&quot;NS_OPTIONS&quot;&gt;&lt;/a&gt;NS_OPTIONS&lt;/h2&gt;&lt;p&gt;语法和 &lt;code&gt;NS_ENUM&lt;/code&gt; 完全相同，但这个宏提示编译器值是如何通过位掩码 | 组合在一起的。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef NS_OPTIONS(NSUInteger, AMGResizing) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AMGResizingNone            = 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AMGResizingFlexibleWidth   = 1 &amp;lt;&amp;lt; 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AMGResizingFlexibleHeight  = 1 &amp;lt;&amp;lt; 1,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AMGResizingFlexibleUnicorn = 1 &amp;lt;&amp;lt; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;attribute-always-inline&quot;&gt;&lt;a href=&quot;#attribute-always-inline&quot; class=&quot;headerlink&quot; title=&quot;attribute((always_inline))&quot;&gt;&lt;/a&gt;&lt;strong&gt;attribute&lt;/strong&gt;((always_inline))&lt;/h1&gt;&lt;p&gt;我们知道一般的函数调用都会通过call的方式来调用，这样让攻击很容易对一个函数做手脚，如果是以&lt;code&gt;inline&lt;/code&gt;的方式编译的会，会把该函数的code拷贝到每次调用该函数的地方。而&lt;code&gt;static&lt;/code&gt;会让生成的二进制文件中没有清晰的符号表，让逆向的人很难弄清楚逻辑。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__attribute__((always_inline))&lt;/code&gt; 的意思是强制内联，所有加了&lt;code&gt;__attribute__((always_inline))&lt;/code&gt; 的函数再被调用时不会被编译成函数调用而是直接扩展到调用函数体内，比如定义了函数&lt;br&gt;&lt;code&gt;__attribute__((always_inline)) void a()&lt;/code&gt;&lt;br&gt;和&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void b()｛  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;｝&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;b 调用 a 函数的汇编代码不会是跳转到a执行，而是 a 函数的代码直接在 b 内成为 b 的一部分。&lt;br&gt;&lt;code&gt;#define __inline __attribute__((always_inline))&lt;/code&gt; 的意思就是用&lt;br&gt;&lt;code&gt;__inline&lt;/code&gt; 代替&lt;code&gt;__attribute__((always_inline))&lt;/code&gt;&lt;br&gt;内声明a的时候可以直接写成&lt;code&gt;__inline void a()&lt;/code&gt; 这样比较方便因为&lt;code&gt;__attribute__((always_inline))&lt;/code&gt; 字多。&lt;/p&gt;
&lt;h1 id=&quot;undef&quot;&gt;&lt;a href=&quot;#undef&quot; class=&quot;headerlink&quot; title=&quot;undef&quot;&gt;&lt;/a&gt;undef&lt;/h1&gt;&lt;p&gt;这是预编译指令，和&lt;code&gt;#define&lt;/code&gt;搭配使用，意思是取消之前的宏定义。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define PROC_ADD &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void main(void) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#ifdef PROC_ADD &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Do this code here then undefined it to run the code in the else &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// processing work &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#undef PROC_ADD &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#else &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// now that PROC_ADD has been undefined run this code &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// processing work &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;unsafe-unretained&quot;&gt;&lt;a href=&quot;#unsafe-unretained&quot; class=&quot;headerlink&quot; title=&quot;__unsafe_unretained&quot;&gt;&lt;/a&gt;__unsafe_unretained&lt;/h1&gt;&lt;p&gt;&lt;code&gt;__unsafe_unretained&lt;/code&gt;是对对象的非zeroing的weak reference，意思是当对象所指向的内存被销毁了，对象还存在，称为“野指针”。&lt;/p&gt;
&lt;p&gt;在iOS引入了Automatic Reference Count（ARC）之后，编译器可以在编译时对obj-c对象进行内存管理。大致规则如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;alloc的要release;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;retain/copy的要release;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSAutoreleasePool在ARC中被禁止使用,替换成@autoreleasepool 函数体;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;使用@ autoreleasepool,在函数入口的时候,autorelease pool入栈,正常退出时,autorelease pool出栈,从而释放变量.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;注意:@ autoreleasepool在非ARC模式下,也能使用,并据说使用@autoreleasepool比使用NSAutoreleasePool速度能快6倍, 明显提升程序性能.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;package&quot;&gt;&lt;a href=&quot;#package&quot; class=&quot;headerlink&quot; title=&quot;@package&quot;&gt;&lt;/a&gt;@package&lt;/h1&gt;&lt;p&gt;为了强制一个对象隐藏其数据，编译器限制实例变量范围以限制其在程序中的可见性，但是为了提供灵活性，苹果也让开发者显式设置范围。&lt;/p&gt;
&lt;p&gt;以下是这些关键字的使用范围：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@private&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The instance variable is accessible only within the class that declares it.&lt;/p&gt;
&lt;p&gt;实例变量只能被声明它的类访问.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@protected&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The instance variable is accessible within the class that declares it and within classes that inherit it. All instance variables without an explicit scope directive have @protected scope.&lt;/p&gt;
&lt;p&gt;实例变量能被声明它的类和子类访问，所有没有显式制定范围的实例变量都是.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@public&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The instance variable is accessible everywhere.&lt;/p&gt;
&lt;p&gt;实例变量可以被在任何地方访问.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@package&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Using the modern runtime, an &lt;code&gt;@package&lt;/code&gt; instance variable has &lt;code&gt;@public&lt;/code&gt; scope inside the executable image that implements the class, but acts like &lt;code&gt;@private&lt;/code&gt; outside.使用modern运行时，一个&lt;code&gt;@package&lt;/code&gt;实例变量在实现这个类的可执行文件镜像中实际上是&lt;code&gt;@public&lt;/code&gt;的，但是在外面就是&lt;code&gt;@private&lt;/code&gt;【runtime需要再看一下苹果文档Runtime Programming Guide】&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;@package&lt;/code&gt; scope for Objective-C instance variables is analogous to private_extern for C variables and functions. Any code outside the class implementation’s image that tries to use the instance variable gets a link error.&lt;/p&gt;
&lt;p&gt;Objective-C中的&lt;code&gt;@package&lt;/code&gt;与C语言中变量和函数的private_extern类似。任何在实现类的镜像之外的代码想使用这个实例变量都会引发link error&lt;/p&gt;
&lt;p&gt;This scope is most useful for instance variables in framework classes, where &lt;code&gt;@private&lt;/code&gt; may be too restrictive but &lt;code&gt;@protected&lt;/code&gt; or &lt;code&gt;@public&lt;/code&gt; too permissive.&lt;/p&gt;
&lt;p&gt;这个类型最常用于框架类的实例变量，使用&lt;code&gt;@private&lt;/code&gt;太限制，使用&lt;code&gt;@protected&lt;/code&gt;或者&lt;code&gt;@public&lt;/code&gt;又太开放. |&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：YYModel堪称神级大作，虽然不免一些小bug，但是完全不影响膝盖碎一地。文章主要分享在阅读YYModel源代码时，所引发的知识点的补充与思考。&lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="开源框架" scheme="http://charsdavy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 并发概念浅析</title>
    <link href="http://charsdavy.github.io/2016/05/26/ios-simultaneously/"/>
    <id>http://charsdavy.github.io/2016/05/26/ios-simultaneously/</id>
    <published>2016-05-26T00:32:15.000Z</published>
    <updated>2016-06-02T00:00:50.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：并发（concurrency）是一个常用且较好的解决APP的流畅度方法，但并发涉及串行、并发、并行、同步、异步、多线程、GCD、NSOperation和NSOperationQueue等诸多容易混淆的概念。本文主要分享对一些易混淆概念的理解。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在进行iOS开发过程中，我们常会遇到网络请求、复杂计算、数据存取等比较耗时的操作，如果处理不合理，将对APP的流畅度产生较大影响。除了优化APP架构，并发（concurrency）是一个常用且较好的解决方法，但并发涉及串行、并发、并行、同步、异步、多线程、GCD、NSOperation和NSOperationQueue等诸多容易混淆的概念。接下来，主要分享对一些易混淆概念的理解。&lt;/p&gt;
&lt;h1 id=&quot;一、线程和任务&quot;&gt;&lt;a href=&quot;#一、线程和任务&quot; class=&quot;headerlink&quot; title=&quot;一、线程和任务&quot;&gt;&lt;/a&gt;一、线程和任务&lt;/h1&gt;&lt;p&gt;线程（thread） 和任务（task）是其他并发概念的基础，因此也是首要需理清的概念，以下是其要点，详细可参考&lt;a href=&quot;https://en.wikipedia.org/wiki/Thread_%28computing%29&quot;&gt;Thread (computing)&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Task_%28computing&quot;&gt;Task (computing)&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;1）任务（task）&quot;&gt;&lt;a href=&quot;#1）任务（task）&quot; class=&quot;headerlink&quot; title=&quot;1）任务（task）&quot;&gt;&lt;/a&gt;1）任务（task）&lt;/h2&gt;&lt;p&gt;a）任务（task）是从程序中划分出来，可以独立执行的代码片段；&lt;/p&gt;
&lt;p&gt;b）任务间可以添加依赖关系，如B任务依赖A任务，taskB.addDependency(taskA)，这意味着B任务的执行以A任务完成为前提。&lt;/p&gt;
&lt;p&gt;需要注意的是一个任务是否可以添加依赖，完全取决于任务封装类和其相关管理类的具体实现，GCD不支持任务依赖，NSOperationQueue就支持任务依赖。&lt;/p&gt;
&lt;p&gt;下面的代码是对一个任务的简单封装，并支持任务间的依赖。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//Task是一个任务的简单封装类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Task &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let taskBlock: () -&amp;gt; ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var dependencies = [Task]() &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    init(block: () -&amp;gt; ()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        taskBlock = block&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func addDependency(task: Task) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dependencies.append(task)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//初始化两个自定义任务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var taskA = Task()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //自定义任务A，自定义需要执行的代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var taskB = Task()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //自定义任务B，自定义需要执行的代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//添加依赖关系&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;taskB.addDependency(taskA)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;2）线程（thread）&quot;&gt;&lt;a href=&quot;#2）线程（thread）&quot; class=&quot;headerlink&quot; title=&quot;2）线程（thread）&quot;&gt;&lt;/a&gt;2）线程（thread）&lt;/h2&gt;&lt;p&gt;a）线程（thread）是代码执行的独立路径，一条线程只能同时执行一行代码（一行代码，其实就是一条处理器命令）。&lt;/p&gt;
&lt;p&gt;b）线程中代码管理是以任务（task）为单位，一条线程逐行执行一个任务中的代码（任务可以取消），完成后再逐行执行下一个任务中的代码。&lt;/p&gt;
&lt;p&gt;c）一条线程跳出一个任务的执行，即意味着这个任务的完成。因此，一条线程不能执行taskA一段时间后，还未完成就开始执行taskB，然后又返回执行taskA（这其实是单线程内的并发，与单核处理器的并发概念相同，具体实践中不存在线程内并发）。&lt;/p&gt;
&lt;h1 id=&quot;二、概念释疑&quot;&gt;&lt;a href=&quot;#二、概念释疑&quot; class=&quot;headerlink&quot; title=&quot;二、概念释疑&quot;&gt;&lt;/a&gt;二、概念释疑&lt;/h1&gt;&lt;h2 id=&quot;1）并行（parallelism）和并发（concurrency）&quot;&gt;&lt;a href=&quot;#1）并行（parallelism）和并发（concurrency）&quot; class=&quot;headerlink&quot; title=&quot;1）并行（parallelism）和并发（concurrency）&quot;&gt;&lt;/a&gt;1）并行（parallelism）和并发（concurrency）&lt;/h2&gt;&lt;p&gt;并发和并行都是指多个任务可以同时执行，都属于多线程编程概念，因此二者必然十分相近，容易混淆。二者区别只有一点，即是否多任务执行于严格的同一时刻。并发不是，而并行是。&lt;/p&gt;
&lt;p&gt;单核处理器时代（一个处理器同一时刻只能执行一条命令），为了实现多任务的同时执行，系统利用时间分片（time-slicing）技术，将处理器的执行时间切分为多个小片段，一会执行threadA，一会执行threadB，一会再执行threadA，即在多个线程（任务是在线程上执行的）之间来回跳动执行。虽不是真的多线程多任务同时执行，但由于处理器的处理速度非常快，在用户看来，仍然是同时执行的。这种伪多线程就是并发。&lt;/p&gt;
&lt;p&gt;多核处理器时代（不同处理器相互独立，可以同时执行各自的命令），多条线程完全可以严格同一时刻执行，这种真多线程就是并行。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//三个线程的并发&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread1 -&amp;gt; |---A---|             -&amp;gt;|---A---|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread2 ------&amp;gt;    -&amp;gt;|------B----|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread3 ------------------------------------&amp;gt; |------C------|&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述代码是三个线程的并发执行，可以看出thread1、thread2和thread3不可能严格同一时刻执行，但也都获得了处理器的一小段执行时间。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//三个线程的并行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread1 -&amp;gt; |-----A-----|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread2 -&amp;gt;       |------B----|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread3 -&amp;gt;     |------C------|&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述代码是三个线程的并行执行，可以看出thread1、thread2和thread3有一段时间同时执行。&lt;/p&gt;
&lt;p&gt;现在的终端设备无论是手机还是PC的处理器，大多都已是多核处理器，可以实现并行计算，但为了最大化的利用处理器的性能，现代处理器还是融合了time-slicing技术和多核技术，因此实际运行中，有时并发，有时并行。但相对来说，并发是个更广泛的概念，因此Apple的多线程编程叫做concurrency programming并发编程。汉语中，并发和并行的区别其实没那么清晰，可以互用，而且有时用并行更加明确，如串并行比串行、并发针对性更强。（为概念清晰起见，下文中有时会用并行，其实即是并发。）&lt;/p&gt;
&lt;h2 id=&quot;2）串并行与线程&quot;&gt;&lt;a href=&quot;#2）串并行与线程&quot; class=&quot;headerlink&quot; title=&quot;2）串并行与线程&quot;&gt;&lt;/a&gt;2）串并行与线程&lt;/h2&gt;&lt;h3 id=&quot;串行（serial）和并行&quot;&gt;&lt;a href=&quot;#串行（serial）和并行&quot; class=&quot;headerlink&quot; title=&quot;串行（serial）和并行&quot;&gt;&lt;/a&gt;串行（serial）和并行&lt;/h3&gt;&lt;p&gt;串行和并行主要区别在于一个任务的执行是否以上一个任务的完成为前提。串行中，一个任务的执行必须以上一个任务执行结束为前提；并行中，一个任务的执行与上一个任务的执行状态无关。以排队买票为例，串行像单个买票队伍，单个卖票窗口，必须一个一个来；串行像单个买票队伍，多个卖票窗口，多个人可以同时买票。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//三个串行任务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|-----A-----||------B--------||----C--|&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上文为三个串行任务，任务A完成后，才执行任务B，B结束后，才最后执行任务C。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//三个并发任务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|-----A-----|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      |------B----|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   |--C---|&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上文为三个并行任务，任务A早于任务C开始，却晚于任务C结束。&lt;/p&gt;
&lt;h3 id=&quot;串并行与线程&quot;&gt;&lt;a href=&quot;#串并行与线程&quot; class=&quot;headerlink&quot; title=&quot;串并行与线程&quot;&gt;&lt;/a&gt;串并行与线程&lt;/h3&gt;&lt;p&gt;串并行主要关注多个任务之间的相互依赖关系，与线程无关。但实际中，任务是在线程中执行的，是否串行一定在单线程上执行，并行一定在多个线程中执行呢？并非如此。&lt;/p&gt;
&lt;p&gt;单线程既可以实现串行，也可以实现并行。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//单线程串行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 thread -&amp;gt;   |----A-----||-----B-----------||-------C------|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//单线程并行（理论上，实际中不可行）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         A-Start ---------------------------------------- A-End  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           | B-Start ----------------------------------------|--- B-End  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           |   |     C-Start -------------------- C-End      |     |  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           V   V       V                           V         V     V      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 thread-&amp;gt; |-A-|---B---|-C-|-A-|-C-|--A--|-B-|--C--|---A-----|--B--|&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要指出的是单线程内的并行已经类似单核处理器，并不是本文提及的常规线程，现实中也不常见。&lt;/p&gt;
&lt;p&gt;多线程既可以实现串行，也可以实现并行，实际上，多线程串行和并行都很常见。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//多线程串行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread1 -&amp;gt; |----A-----|  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       \  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread2 ---------------&amp;gt;|-----B-----------|  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                           \  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread3 -----------------------------------&amp;gt;|-------C------|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//多线程并发&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread1 -&amp;gt;     |----A-----|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread2 -----&amp;gt;     |-----B-----------|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread3 ---------&amp;gt;     |-------C----------|&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;3）同步（synchronize）、异步（asynchronous）与线程&quot;&gt;&lt;a href=&quot;#3）同步（synchronize）、异步（asynchronous）与线程&quot; class=&quot;headerlink&quot; title=&quot;3）同步（synchronize）、异步（asynchronous）与线程&quot;&gt;&lt;/a&gt;3）同步（synchronize）、异步（asynchronous）与线程&lt;/h2&gt;&lt;p&gt;同步和异步是站在当前线程的角度，考察添加任务到新线程后，何时返回到当前线程执行下面的代码的问题，也即新添加的线程阻不阻塞当前线程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;override viewDidLoad() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_sync(queue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //block1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&amp;quot;-----1-----&amp;quot;) //1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&amp;quot;-----2-----&amp;quot;) //2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;block1是添加到系统全局队列中的新任务，由于是同步的，因此block1执行返回后，才会回到当前主线程，执行//2及以后的代码。输出结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-----1-----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-----2-----&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//viewDidLoad()在主线程中执行，因此当前线程为主线程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;override viewDidLoad() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //block1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&amp;quot;-----1-----&amp;quot;) //1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&amp;quot;-----2-----&amp;quot;) //2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;block1是添加到系统全局队列中的新任务，由于是异步的，因此block1添加全局队列后（会在另外一个线程上执行），不等到执行完成，就会返回到当前主线程，执行//2及以后的代码，所以输出结果可能为 21 12。但由于block1和主线程中的任务都是不耗时的简单任务，而创建新的线程是要消耗一定时间的（主线程一直存在，不用新创建），因此很可能的输出结果是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-----2-----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-----1-----&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;同异步结合的情形&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果同异步结合:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//viewDidLoad()在主线程中执行，因此当前线程为主线程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;override viewDidLoad() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //block1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&amp;quot;-----A-----&amp;quot;) //1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dispatch_async(dispatch_get_main_queue()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //block2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            print(&amp;quot;-----B-----&amp;quot;) //2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&amp;quot;-----C-----&amp;quot;) //3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&amp;quot;-----D-----&amp;quot;) //4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(true) &amp;#123; &amp;#125; //5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&amp;quot;-----E-----&amp;quot;) //6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;block1是添加到系统全局队列中的新任务，由于是异步的，因此block1添加全局队列后（会在另外一个线程上执行），不等到执行完成，就返回到当前主线程，执行//4及以后的代码，结果是block1所在的线程与主线程同时执行，因此理论上，D和A谁先输出不一定。但由于block1和主线程中的任务都是不耗时的简单任务，而创建新的线程是要消耗一定时间的（主线程一直存在，不用新创建），因此一般输出结果为DA。&lt;/p&gt;
&lt;p&gt;block1所在线程输出完A后，将block2添加到主调度队列中，由于是异步的，因此block2添加主调度队列后（会在主线程上执行），不等到执行完成，就返回到block2所在的线程，继续执行，因此A和C一定会输出，且C一定在A之后输出。但block2却不一定能执行，因为block1在执行时，主线程也在执行（主线程是串行单线程，任务按顺序一个一个执行），如果此时主线程执行到//5对应的死循环，则block2一定不能被执行，B一定不能被输出，如果此时主线程尚未执行到//5对应的死循环，block2已经添加到主线程中，则block2会被执行，B能被输出。但由于主线程无需另外创建，block1（所对应的线程需另外创建）执行到添加block2到主调度队列时，主线程很可能已经执行到//5对应的死循环，因此block2很可能不被执行。&lt;/p&gt;
&lt;p&gt;//6前有个死循环，因此E一定不会被输出。&lt;/p&gt;
&lt;p&gt;因此可能的输出结果是；DAC ADC ADCB DACB ACDB ACBD ABDC ABCD&lt;/p&gt;
&lt;p&gt;但很可能的输出结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-----D-----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-----A-----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-----C-----&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;4）同异步与串并行&quot;&gt;&lt;a href=&quot;#4）同异步与串并行&quot; class=&quot;headerlink&quot; title=&quot;4）同异步与串并行&quot;&gt;&lt;/a&gt;4）同异步与串并行&lt;/h2&gt;&lt;p&gt;串行和同步，并行和异步似是完全不同的概念，一个关注任务的独立关系，一个看中的是返回的时机。但事实上，串行和同步近似，并发和异步相同，他们指代的事情几乎完全相同。&lt;br&gt;就同步和串行而言，需要任务执行结束后才能返回，其实就是一个任务执行完成后，才能执行其他的任务，反应的就是串行依赖关系。&lt;/p&gt;
&lt;p&gt;而异步和并行就更相同了，不等任务执行完成，就直接返回，反应的就是并发任务之间的独立性。&lt;/p&gt;
&lt;p&gt;当然，同异步所暗含的串行和并行是当前线程的任务与新线程的任务之间的相互关系。&lt;/p&gt;
&lt;h1 id=&quot;三、GCD与NSOperationQueue&quot;&gt;&lt;a href=&quot;#三、GCD与NSOperationQueue&quot; class=&quot;headerlink&quot; title=&quot;三、GCD与NSOperationQueue&quot;&gt;&lt;/a&gt;三、GCD与NSOperationQueue&lt;/h1&gt;&lt;p&gt;GCD(grand central dispatch)和NSOperationQueue二者均是系统级的多线程封装，在使用时，我们只需创建任务队列即可，其他的如线程创立、任务分配等，均由系统自动处理。不得不说，这让多线程编程变得更高效，更简单，当然并不是没有坑。&lt;br&gt;需要强调的是，GCD和NSOperationQueue的使用核心是任务（task）和任务队列（task queue），暂时可以忘了线程（thread）这烦人的概念。&lt;/p&gt;
&lt;p&gt;关于GCD和NSOperationQueue网上已经有不少高质量的文章对其详细介绍，推荐&lt;a href=&quot;http://www.cocoachina.com/ios/20160201/15179.html&quot;&gt;《iOS并行开发：从NSOperation和调度队列开始》&lt;/a&gt;，其对基本概念、使用方法等的介绍非常清晰详尽，这里就不再赘述，只写一些个人认为容易忽略却影响认知深度的小知识点。当然如果你英语过硬，去直接看官方文档&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html&quot;&gt;《ConcurrencyProgrammingGuide》&lt;/a&gt;是最好的。&lt;/p&gt;
&lt;h2 id=&quot;1）GCD&quot;&gt;&lt;a href=&quot;#1）GCD&quot; class=&quot;headerlink&quot; title=&quot;1）GCD&quot;&gt;&lt;/a&gt;1）GCD&lt;/h2&gt;&lt;p&gt;GCD是基于C的API，因此比较底层。&lt;/p&gt;
&lt;p&gt;GCD所管理的调度队列（dispatch queue）主要有三类：串行队列（private dispatch queue）、并发队列 （global dispatch queue，又称全局调度队列）和主队列（main dispatch queue）。&lt;/p&gt;
&lt;p&gt;我们常用的 dispatch_get_global&lt;em&gt;queue(&lt;/em&gt;: _:)所获得的dispatch queue就是全局调度队列(global dispatch queue)，并发，而且全局调度队列是全局共用的，每一个优先级的全局调度队列只有一个实体。四种不同优先级的全局调度队列对应的四种优先级的线程，同一个优先级的全局调度队列可以同时拥有多条相应优先级的线程。&lt;/p&gt;
&lt;p&gt;dispatch_get_main_queue()所获得的dispatch queue是主调度队列，主调度队列是串行队列。&lt;/p&gt;
&lt;h2 id=&quot;2）NSOperationQueue&quot;&gt;&lt;a href=&quot;#2）NSOperationQueue&quot; class=&quot;headerlink&quot; title=&quot;2）NSOperationQueue&quot;&gt;&lt;/a&gt;2）NSOperationQueue&lt;/h2&gt;&lt;p&gt;NSOperationQueue是对GCD的Objective-C封装，相对于GCD具有更多先进的特性，如可以添加NSOperation依赖，取消NSOperation等。&lt;/p&gt;
&lt;p&gt;NSOperationQueue是并发队列，且不遵循先进先出（FIFO）排序原则。&lt;/p&gt;
&lt;h1 id=&quot;四、总结与感悟&quot;&gt;&lt;a href=&quot;#四、总结与感悟&quot; class=&quot;headerlink&quot; title=&quot;四、总结与感悟&quot;&gt;&lt;/a&gt;四、总结与感悟&lt;/h1&gt;&lt;p&gt;1）串并行、同异步与线程无关，单线程、多线程都可以实现串并行和同异步。&lt;/p&gt;
&lt;p&gt;2）串行和同步相同，异步和并行相同，他们只是看待同一件事物的角度不同。&lt;/p&gt;
&lt;p&gt;3）GCD和NSOperationQueue的使用核心是任务（task）和任务队列（task queue）。&lt;/p&gt;
&lt;p&gt;4）全局调度队列(global dispatch queue)是全局共用的，系统有时也会向这些调度队列添加系统任务。&lt;/p&gt;
&lt;p&gt;5) App的主调度队列是串行单线程队列。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：并发（concurrency）是一个常用且较好的解决APP的流畅度方法，但并发涉及串行、并发、并行、同步、异步、多线程、GCD、NSOperation和NSOperationQueue等诸多容易混淆的概念。本文主要分享对一些易混淆概念的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="iOS" scheme="http://charsdavy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>GitHub 使用</title>
    <link href="http://charsdavy.github.io/2016/05/20/github-using/"/>
    <id>http://charsdavy.github.io/2016/05/20/github-using/</id>
    <published>2016-05-20T14:17:11.000Z</published>
    <updated>2016-06-01T23:59:17.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：GitHub就是程序员的facebook，在这个开源、大神云集的地方，小菜是可以学到，找到很多很棒的资源的。那么，如何进入这个圈子呢？我们从使用开始。这篇文章主要讲解如何使用GitHub托管自己的代码，注意，托管是公开的喔，私有的要付费的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;下载github客户端软件&quot;&gt;&lt;a href=&quot;#下载github客户端软件&quot; class=&quot;headerlink&quot; title=&quot;下载github客户端软件&quot;&gt;&lt;/a&gt;下载github客户端软件&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;官网&lt;a href=&quot;https://help.github.com/&quot;&gt;下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Google搜索，一般用于windows7以前的系统&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;安装github软件&quot;&gt;&lt;a href=&quot;#安装github软件&quot; class=&quot;headerlink&quot; title=&quot;安装github软件&quot;&gt;&lt;/a&gt;安装github软件&lt;/h1&gt;&lt;p&gt;根据软件安装指导，按步骤安装即可。&lt;/p&gt;
&lt;h1 id=&quot;使用git命令提交&quot;&gt;&lt;a href=&quot;#使用git命令提交&quot; class=&quot;headerlink&quot; title=&quot;使用git命令提交&quot;&gt;&lt;/a&gt;使用git命令提交&lt;/h1&gt;&lt;h2 id=&quot;git-config&quot;&gt;&lt;a href=&quot;#git-config&quot; class=&quot;headerlink&quot; title=&quot;git config&quot;&gt;&lt;/a&gt;git config&lt;/h2&gt;&lt;p&gt;安装Git后首先要做的事情是设置用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.name &amp;quot;Chars Davy&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.email chars_d@example.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;重申一遍，只需要做一次这个设置。如果传递了 &lt;code&gt;--global&lt;/code&gt; 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要&lt;code&gt;--global&lt;/code&gt;选项。&lt;/p&gt;
&lt;h2 id=&quot;git-clone&quot;&gt;&lt;a href=&quot;#git-clone&quot; class=&quot;headerlink&quot; title=&quot;git clone&quot;&gt;&lt;/a&gt;git clone&lt;/h2&gt;&lt;p&gt;这是一种较为简单的初始化方式，当你已经有一个远程的Git版本库，只需要在本地克隆一份:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git  clone  git://github.com/someone/some_project.git   some_project&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的命令就是将&lt;code&gt;git://github.com/someone/some_project.git&lt;/code&gt;这个URL地址的远程版本库，完全克隆到本地some_project目录下。&lt;/p&gt;
&lt;h2 id=&quot;git-init-和-git-remote&quot;&gt;&lt;a href=&quot;#git-init-和-git-remote&quot; class=&quot;headerlink&quot; title=&quot;git init 和 git remote&quot;&gt;&lt;/a&gt;git init 和 git remote&lt;/h2&gt;&lt;p&gt;这种方式稍微复杂一些，当你本地创建了一个工作目录，你可以进入这个目录，使用&lt;code&gt;git init&lt;/code&gt;命令进行初始化；Git以后就会对该目录下的文件进行版本控制，这时候如果你需要将它放到远程服务器上，可以在远程服务器上创建一个目录，并把可访问的URL记录下来，此时你就可以利用&lt;code&gt;git remote add&lt;/code&gt;命令来增加一个远程服务器端，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git  remote  add  origin  git://github.com/someone/another_project.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的命令就会增加URL地址为&lt;code&gt;git: //github.com/someone/another_project.git&lt;/code&gt;，名称为origin的远程服务器，以后提交代码的时候只需要使用 origin别名即可。&lt;/p&gt;
&lt;h2 id=&quot;git-add&quot;&gt;&lt;a href=&quot;#git-add&quot; class=&quot;headerlink&quot; title=&quot;git add&quot;&gt;&lt;/a&gt;git add&lt;/h2&gt;&lt;p&gt;将当前更改或者新增的文件加入到Git的索引中，加入到Git的索引中就表示记入了版本历史中，这也是提交之前所需要执行的一步，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git add app/model/user.rb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就会增加&lt;code&gt;app/model/user.rb&lt;/code&gt;文件到Git的索引中，该功能类似于SVN的add，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git add .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的命令会将所有改动过的文件及文件夹迭代全部添加进本地代码仓库。&lt;/p&gt;
&lt;h2 id=&quot;git-commit&quot;&gt;&lt;a href=&quot;#git-commit&quot; class=&quot;headerlink&quot; title=&quot;git commit&quot;&gt;&lt;/a&gt;git commit&lt;/h2&gt;&lt;p&gt;提交当前工作空间的修改内容，类似于SVN的commit命令，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git commit -m story #3, add user model&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;提交的时候必须用-m来输入一条提交信息，该功能类似于SVN的commit，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git commit –m beta&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的命令会将beta作为log显示在代码提交记录中。&lt;/p&gt;
&lt;h2 id=&quot;git-push&quot;&gt;&lt;a href=&quot;#git-push&quot; class=&quot;headerlink&quot; title=&quot;git push&quot;&gt;&lt;/a&gt;git push&lt;/h2&gt;&lt;p&gt;将本地commit的代码更新到远程版本库中，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git push origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的命令就会将本地的代码更新到名为orgin的远程版本库中。&lt;/p&gt;
&lt;h1 id=&quot;git代码提交中可能遇到的问题&quot;&gt;&lt;a href=&quot;#git代码提交中可能遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;git代码提交中可能遇到的问题&quot;&gt;&lt;/a&gt;git代码提交中可能遇到的问题&lt;/h1&gt;&lt;p&gt;问题1：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;You can&amp;apos;t push to git://github.com/example/example_pro.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Use https://github.com/ example/example_pro.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote remove origin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git remote add origin git@github.com:user_name/user_repo.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;p&gt;如果在&lt;code&gt;git clone&lt;/code&gt;的时候用的是&lt;code&gt;git://github.com:xx/xxx.git&lt;/code&gt; 的形式, 那么就会出现这个问题，因为这个protocol是不支持push的，而使用&lt;code&gt;git clone git@github.com:lujinjianst/myNCCL.git&lt;/code&gt;就可以用git push。&lt;/p&gt;
&lt;p&gt;问题2：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Permission denied(publickey).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fatal:Could not read from remote repository.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;p&gt;在终端输入:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh-keygen -t rsa -C &amp;quot;chars&amp;quot;//注意,chars为用户名&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果执行成功。返回:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Generating public/private rsa key pair. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Enter file in which to save the key (/home/forwhat.cn/.ssh/id_rsa):&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这里就是设置存储地址了.反正我是直接按的回车,然后还会返回:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Enter passphrase (empty for no passphrase):&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再次直接回车。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Enter same passphrase again:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再次回车。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Your identification has been saved in /home/forwhat.cn/.ssh/id_rsa. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Your public key has been saved in /home/forwhat.cn/.ssh/id_rsa.pub. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The key fingerprint is:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;The key&amp;apos;s randomart image is: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+--[ RSA 2048]----+ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                 | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                 | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                 | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|    o            | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|   + .  S        | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  . = .  o       | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|   o + +o.o      | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|E o . o.=+.      | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|.+   ==+ooo.     | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+-----------------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样SSH key就生成了。直接cat一下就好了。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;:~/a$ cat /home/forwhat.cn/.ssh/id_rsa.pub&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;把显示出来的直接添加到github账户设置里边的SSH keys。&lt;br&gt;回来再git pull就开始远程拷贝代码了。&lt;/p&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;p&gt;没有在github账号添加SSH key。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：GitHub就是程序员的facebook，在这个开源、大神云集的地方，小菜是可以学到，找到很多很棒的资源的。那么，如何进入这个圈子呢？我们从使用开始。这篇文章主要讲解如何使用GitHub托管自己的代码，注意，托管是公开的喔，私有的要付费的。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://charsdavy.github.io/categories/tool/"/>
    
    
      <category term="Git" scheme="http://charsdavy.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>均匀分布随机函数的实现</title>
    <link href="http://charsdavy.github.io/2016/04/30/uniform-random/"/>
    <id>http://charsdavy.github.io/2016/04/30/uniform-random/</id>
    <published>2016-04-30T01:37:10.000Z</published>
    <updated>2016-06-02T00:03:00.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：随机函数可以说是用途很广。可是，系统提供的random函数，一般符合正态分布，所以说，这是伪随机函数。甚至在一些场合是非随机函数。为了满足项目需要，必须实现均匀分布。在此，分享博主实现均匀随机函数的实现过程与方法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;随机函数就是产生数的函数，C语言里使用rand(),srand()等随机函数实现随机数生成。&lt;/p&gt;
&lt;h1 id=&quot;函数简介&quot;&gt;&lt;a href=&quot;#函数简介&quot; class=&quot;headerlink&quot; title=&quot;函数简介&quot;&gt;&lt;/a&gt;函数简介&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int rand( void );&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回的是一个界于0～32767（0x7FFF）之间的伪随机数，包括0和32767。&lt;br&gt;C预先生成一组随机数，每次调用随机函数时从指针所指向的位置开始取值，因此使用rand()重复运行程序产生的随机数都是相同的，可以通过srand()函数来改变指针位置。&lt;br&gt;srand()会设置供rand()使用的随机数种子。如果在第一次使用rand()之前没有调用srand()，那么系统会自动调用srand()。而使用同种子相同的数调用 rand()会导致相同的随机数序列被生成。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void srand( unsigned int seed );&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;改变随机数表的指针位置（用seed变量控制）。&lt;br&gt;使用系统定时/计数器的值作为随机种子。每个种子对应一组根据算法预先生成的随机数，所以，在相同的平台环境下，不同时间产生的随机数会是不同的，相应的，若将srand（unsigned）time(NULL)改为srand(TP)（TP为任一常量），则无论何时运行、运行多少次得到的“随机数”都会是一组固定的序列，因此srand生成的随机数是伪随机数。&lt;br&gt;一般配合time(NULL)使用，因为时间每时每刻都在改变，产生的seed值都不同。&lt;/p&gt;
&lt;h1 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h1&gt;&lt;p&gt;使用rand函数生成的随机数严格满足正态分布。而在很多时候，我们希望随机数的生成不要满足正态分布，特别是在处理网络通信报文的时候。&lt;br&gt;例如，我们需要在交换机处理到海量报文时，能够使远端的从设备尽可能的分段同时向局端回应报文，以减轻局部报文处理压力。&lt;/p&gt;
&lt;h1 id=&quot;均匀分布随机函数实现&quot;&gt;&lt;a href=&quot;#均匀分布随机函数实现&quot; class=&quot;headerlink&quot; title=&quot;均匀分布随机函数实现&quot;&gt;&lt;/a&gt;均匀分布随机函数实现&lt;/h1&gt;&lt;h2 id=&quot;开发环境&quot;&gt;&lt;a href=&quot;#开发环境&quot; class=&quot;headerlink&quot; title=&quot;开发环境&quot;&gt;&lt;/a&gt;开发环境&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-b2f082073e33ca94.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;开发环境&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现步骤&quot;&gt;&lt;a href=&quot;#实现步骤&quot; class=&quot;headerlink&quot; title=&quot;实现步骤&quot;&gt;&lt;/a&gt;实现步骤&lt;/h2&gt;&lt;p&gt;1）打开Qt Creater，创建GUI工程&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-1c06b87e7e219e93.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;创建GUI工程&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-4b288fe958b3e962.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;项目文件结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;2）在mainwindow.h中添加函数声明&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void paintEvent(QPaintEvent *);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3）在mainwindow.cpp中添加函数实现&lt;/p&gt;
&lt;p&gt;导入头文件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;QPainter&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实现&lt;code&gt;void paintEvent(QPaintEvent *)&lt;/code&gt;函数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *Qt中函数paintEvent(QPaintEvent*)是被系统自动调用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *paintEvent(QPaintEvent *)函数是QWidget类中的虚函数，用于ui的绘制，会在多种情况下被其他函数自动调用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void MainWindow::paintEvent(QPaintEvent *)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QPainter painter(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QPen pen; //画笔&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pen.setColor(QColor(255,0,0)); //设置画笔颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    painter.setPen(pen); //添加画笔&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    long int r[kSum] = &amp;#123;0&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int j = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        r[i] = Uniform(0, 300);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;while(i &amp;lt; kSum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while((j + 30) &amp;lt; (kSum + 30))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        painter.drawPoint(j, r[j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;4）添加随机函数实现代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define kSum 1000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//算法一&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *均匀分布随机函数均匀化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;double _uniform(double min, double max, long int *seed) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    double t = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *seed = 2045 * (*seed) + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *seed = *seed - (*seed / 1048576) * 1048576;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t = (*seed) / 1048576.0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t = min + (max - min) * t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *均匀分布随机函数产生随机数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;long int Uniform(double min, double max) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    long int s = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    double r = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //srand((unsigned int)time(NULL)); /*同一个时间种子可能会从产生相同的随机数列*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s = rand();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    r = _uniform(min, max, &amp;amp;s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return ((long int)r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//算法二&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;double AverageRandom(double min, double max) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int minInteger = (int)(min * 10000);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int maxInteger = (int)(max * 10000);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int randInteger = rand() * rand();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int diffInteger = maxInteger - minInteger;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int resultInteger = randInteger % diffInteger + minInteger;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return (resultInteger/10000.0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;实现效果&quot;&gt;&lt;a href=&quot;#实现效果&quot; class=&quot;headerlink&quot; title=&quot;实现效果&quot;&gt;&lt;/a&gt;实现效果&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-af95ccbacb9b3231.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;实现效果&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h1&gt;&lt;p&gt;从图中可以看出，使用上述函数生成的随机数符合均匀分布。&lt;br&gt;本案例主要使用了Qt的绘图功能，用来直观展示生成随机数的效果。检验随机函数生成随机数的效果。&lt;/p&gt;
&lt;h1 id=&quot;附录&quot;&gt;&lt;a href=&quot;#附录&quot; class=&quot;headerlink&quot; title=&quot;附录&quot;&gt;&lt;/a&gt;附录&lt;/h1&gt;&lt;p&gt;最后附上该算法实现的全部代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//mainwindow.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#ifndef MAINWINDOW_H&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define MAINWINDOW_H&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;QMainWindow&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;namespace Ui &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class MainWindow;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class MainWindow : public QMainWindow&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Q_OBJECT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    explicit MainWindow(QWidget *parent = 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ~MainWindow();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void paintEvent(QPaintEvent *);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Ui::MainWindow *ui;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif // MAINWINDOW_H&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//mainwindow.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;mainwindow.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;ui_mainwindow.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;QPainter&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define kSum 1000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MainWindow::MainWindow(QWidget *parent) :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QMainWindow(parent),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui(new Ui::MainWindow)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;setupUi(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MainWindow::~MainWindow()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    delete ui;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *均匀分布随机函数均匀化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;double _uniform(double min, double max, long int *seed) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    double t = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *seed = 2045 * (*seed) + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *seed = *seed - (*seed / 1048576) * 1048576;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t = (*seed) / 1048576.0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t = min + (max - min) * t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *均匀分布随机函数产生随机数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;long int Uniform(double min, double max) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    long int s = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    double r = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //srand((unsigned int)time(NULL)); /*同一个时间种子可能会从产生相同的随机数列*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s = rand();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    r = _uniform(min, max, &amp;amp;s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return ((long int)r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *Qt中函数paintEvent(QPaintEvent*)是被系统自动调用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *paintEvent(QPaintEvent *)函数是QWidget类中的虚函数，用于ui的绘制，会在多种情况下被其他函数自动调用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void MainWindow::paintEvent(QPaintEvent *)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QPainter painter(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QPen pen; //画笔&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pen.setColor(QColor(255,0,0)); //设置画笔颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    painter.setPen(pen); //添加画笔&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    long int r[kSum] = &amp;#123;0&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int j = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        r[i] = Uniform(0, 300);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;while(i &amp;lt; kSum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while((j + 30) &amp;lt; (kSum + 30))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        painter.drawPoint(j, r[j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//main.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;mainwindow.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;QApplication&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main(int argc, char *argv[])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QApplication a(argc, argv);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MainWindow w;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    w.show();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return a.exec();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：随机函数可以说是用途很广。可是，系统提供的random函数，一般符合正态分布，所以说，这是伪随机函数。甚至在一些场合是非随机函数。为了满足项目需要，必须实现均匀分布。在此，分享博主实现均匀随机函数的实现过程与方法。&lt;/p&gt;
    
    </summary>
    
      <category term="进阶" scheme="http://charsdavy.github.io/categories/advance/"/>
    
    
      <category term="算法" scheme="http://charsdavy.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>GCD（Grand Central Dispatch）</title>
    <link href="http://charsdavy.github.io/2016/04/14/Grand-Central-Dispatch/"/>
    <id>http://charsdavy.github.io/2016/04/14/Grand-Central-Dispatch/</id>
    <published>2016-04-14T00:24:46.000Z</published>
    <updated>2016-06-02T00:31:21.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：GCD（Grand Central Dispatch），是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如NSThread,NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术。文章分享关于GCD的种种概念以及使用。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;GCD（Grand Central Dispatch），是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如NSThread,NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术。&lt;/p&gt;
&lt;p&gt;GCD 和 block 的配合使用，可以方便地进行多线程编程。&lt;/p&gt;
&lt;h1 id=&quot;优势&quot;&gt;&lt;a href=&quot;#优势&quot; class=&quot;headerlink&quot; title=&quot;优势&quot;&gt;&lt;/a&gt;优势&lt;/h1&gt;&lt;p&gt;1）  苹果官方为多核的并行运算提出的解决方案。&lt;/p&gt;
&lt;p&gt;2）  会自动利用更多的CPU内核。&lt;/p&gt;
&lt;p&gt;3）  会自动管理线程的生命周期（创建线程、调度任务、销毁线程）。&lt;/p&gt;
&lt;h1 id=&quot;核心概念&quot;&gt;&lt;a href=&quot;#核心概念&quot; class=&quot;headerlink&quot; title=&quot;核心概念&quot;&gt;&lt;/a&gt;核心概念&lt;/h1&gt;&lt;p&gt;1）  任务：执行什么操作。block&lt;/p&gt;
&lt;p&gt;2）  队列：用来存放任务。&lt;/p&gt;
&lt;p&gt;串行队列：顺序，一个一个执行。一个任务执行完毕后才执行下一个任务。&lt;/p&gt;
&lt;p&gt;并发队列：同时，同时执行很多个任务。自动开启多个线程同时执行任务。并发功能只有在异步函数下才生效。&lt;/p&gt;
&lt;h1 id=&quot;使用步骤：&quot;&gt;&lt;a href=&quot;#使用步骤：&quot; class=&quot;headerlink&quot; title=&quot;使用步骤：&quot;&gt;&lt;/a&gt;使用步骤：&lt;/h1&gt;&lt;p&gt;1）  定制任务&lt;/p&gt;
&lt;p&gt;确定想要做的事情。&lt;/p&gt;
&lt;p&gt;2）  将任务添加到队列中&lt;/p&gt;
&lt;p&gt;GCD会自动将队列中的任务取出，放到对应的线程中执行。&lt;/p&gt;
&lt;p&gt;任务的取出原则遵循队列的原则：先进先出，后进后出。&lt;/p&gt;
&lt;h1 id=&quot;执行任务的函数&quot;&gt;&lt;a href=&quot;#执行任务的函数&quot; class=&quot;headerlink&quot; title=&quot;执行任务的函数&quot;&gt;&lt;/a&gt;执行任务的函数&lt;/h1&gt;&lt;p&gt;1）同步方式　　&lt;/p&gt;
&lt;p&gt;dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);&lt;/p&gt;
&lt;p&gt;queue:队列&lt;/p&gt;
&lt;p&gt;block:任务&lt;/p&gt;
&lt;p&gt;2）异步方式&lt;/p&gt;
&lt;p&gt;dispatch_async(dispatch_queue_t queue, dispatch_block_t block);&lt;/p&gt;
&lt;p&gt;queue:队列&lt;/p&gt;
&lt;p&gt;block:任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步和异步的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步：在当前线程中执行。&lt;/p&gt;
&lt;p&gt;异步：在另一条线程中执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步任务的作用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）  用户登录&lt;/p&gt;
&lt;p&gt;2）  下载任务1&lt;/p&gt;
&lt;p&gt;3）  下载任务2&lt;/p&gt;
&lt;h1 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot; class=&quot;headerlink&quot; title=&quot;术语&quot;&gt;&lt;/a&gt;术语&lt;/h1&gt;&lt;p&gt;1）  同步和异步决定了是否要开辟新线程。&lt;/p&gt;
&lt;p&gt;同步：在当前线程中执行任务，不具备开启新线程的能力。&lt;/p&gt;
&lt;p&gt;异步：在新的线程中执行任务，具备开启新线程的能力。&lt;/p&gt;
&lt;p&gt;2）  并发和串行决定了任务执行的方式。&lt;/p&gt;
&lt;p&gt;并发：多个任务同时执行。&lt;/p&gt;
&lt;p&gt;串行：一个任务执行完毕后，再执行下一个任务。&lt;/p&gt;
&lt;h1 id=&quot;代码使用&quot;&gt;&lt;a href=&quot;#代码使用&quot; class=&quot;headerlink&quot; title=&quot;代码使用　&quot;&gt;&lt;/a&gt;代码使用　&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*串行队列*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*创建队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数：1.队列标签。 2.队列属性。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(”dengw”,DISPATCH_QUEUE_SERIAL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*同步执行任务，不会开辟新线程，在当前线程中顺序执行。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一般只要使用“同步”执行，串行队列对添加的同步任务，立马执行*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_sync(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*异步执行任务，开辟新线程，在新线程中执行。开辟新线程的数量与队列模式有关。串行队列中异步执行只会开启一个新线程。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int I = 0; I &amp;lt; 10; I++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*并发队列：需要程序员释放。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*创建队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数：1.队列标签。 2.队列属性。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(”dengw”,DISPATCH_QUEUE_CONCURRENT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*异步执行任务，开辟新线程，在新线程中执行。开辟新线程的数量程序员无法控制。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int I = 0; I &amp;lt; 10; I++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*同步执行任务，不开辟新线程，顺序执行*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int I = 0; I &amp;lt; 10; I++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_sync(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*主队列，专门负责在主线程上调度任务。程序启动以后至少有一个主线程，则会创建主队列。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*主队列不允许开辟新线程。不会在子线程调度任务。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*获得主队列*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_get_main_queue();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*异步执行任务，在主队列中，只能顺序执行。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int I = 0; I &amp;lt; 10; I++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*异步：把任务放到主队列中，但不需要马上执行。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*同步执行任务*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int I = 0; I &amp;lt; 10; I++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*同步：把任务放到主队列中，需要马上执行。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*阻塞*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_sync(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*全局队列：本质是并发队列。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;与并发队列的区别：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1）全局队列没有名字，而并发队列有名字。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2）全局队列，是供所有的应用程序使用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3）在MRC中，全局队列不需要释放，并发队列需要释放。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*获得全局队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iOS7中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_HEGH    2 高优先级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT  0 默认优先级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_LOW   (-2) 低优先级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_BACKGROUND    INT16_MIN 后台优先级（最低）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iOS8中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_HEGH:QOS_CLASS_USER_INITIATED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT:QOS_CLASS_USER_DEFAULT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_LOW:QOS_CLASS_USER_UTILITY&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_BACKGROUND: QOS_CLASS_USER_BACKGROUND&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;保留参数。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_get_global_queue(QOS_CLASS_USER_DEFAULT,0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*异步执行任务*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int I = 0; I &amp;lt; 10; I++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;各队列的执行效果&quot;&gt;&lt;a href=&quot;#各队列的执行效果&quot; class=&quot;headerlink&quot; title=&quot;各队列的执行效果&quot;&gt;&lt;/a&gt;各队列的执行效果&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;全局并行队列&lt;/th&gt;
&lt;th&gt;手动创建串行队列&lt;/th&gt;
&lt;th&gt;主队列&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;同步（sync）&lt;/td&gt;
&lt;td&gt;没有开启新线程。串行执行任务。&lt;/td&gt;
&lt;td&gt;没有开启新线程。串行执行任务。&lt;/td&gt;
&lt;td&gt;会死锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;异步（async）&lt;/td&gt;
&lt;td&gt;有开启新线程。并行执行任务。&lt;/td&gt;
&lt;td&gt;有开启新线程。串行执行任务。&lt;/td&gt;
&lt;td&gt;没有开启新线程。串行执行任务。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;队列的选择&quot;&gt;&lt;a href=&quot;#队列的选择&quot; class=&quot;headerlink&quot; title=&quot;队列的选择&quot;&gt;&lt;/a&gt;队列的选择&lt;/h1&gt;&lt;p&gt;1）串行队列异步执行&lt;/p&gt;
&lt;p&gt;开一条线程，顺序执行。&lt;/p&gt;
&lt;p&gt;效率不高，执行比较慢，资源占用小，省电。&lt;/p&gt;
&lt;p&gt;应用场景：一般3G网络，对性能要求不高。&lt;/p&gt;
&lt;p&gt;2）并发队列异步执行&lt;/p&gt;
&lt;p&gt;开启多条线程，并发执行。&lt;/p&gt;
&lt;p&gt;效率高，执行快，资源消耗大，费电。&lt;/p&gt;
&lt;p&gt;应用场景：WIFI网络，或需要快速响应，用户体验要求高，对任务执行顺序没有要求。&lt;/p&gt;
&lt;p&gt;3）  同步任务&lt;/p&gt;
&lt;p&gt;一般只会在并发队列，需要阻塞后续任务，必须等待同步任务执行完毕，再去执行其他任务。“依赖关系” &lt;/p&gt;
&lt;h1 id=&quot;线程间通信&quot;&gt;&lt;a href=&quot;#线程间通信&quot; class=&quot;headerlink&quot; title=&quot;线程间通信&quot;&gt;&lt;/a&gt;线程间通信&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*从子线程回到主线程*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //执行耗时的异步操作…&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(dispatch_get_main_queue(), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //回到主线程，执行UI刷新操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;延时操作&quot;&gt;&lt;a href=&quot;#延时操作&quot; class=&quot;headerlink&quot; title=&quot;延时操作&quot;&gt;&lt;/a&gt;延时操作&lt;/h1&gt;&lt;p&gt;1）方式一，调用NSObject的方法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//2秒后再调用run方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self performSelector:@selector(run) withObject:nil afterDelay:2.0];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2）方式二，使用GCD函数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)),dispatch_get_main_queue(), ^&amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //2秒后再异步执行这里的代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;调度组（分组）&quot;&gt;&lt;a href=&quot;#调度组（分组）&quot; class=&quot;headerlink&quot; title=&quot;调度组（分组）&quot;&gt;&lt;/a&gt;调度组（分组）&lt;/h1&gt;&lt;p&gt;应用场景：开发的时候，有的时候出现多个网络请求（每一个网络请求时间长短不一），都完成以后统一更新UI或通知用户。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*实例化一个调度组*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_t group = dispatch_group_create();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_get_global_queue(0, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//将任务添加到队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_async(group, queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@”A %@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_async(group, queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@”B %@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//获得所有调度组里面的异步任务完成的通知&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*在调度组完成通知里，可以跨队列通信*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_notifity(group, queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //异步的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@”finished”);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;一次性执行&quot;&gt;&lt;a href=&quot;#一次性执行&quot; class=&quot;headerlink&quot; title=&quot;一次性执行&quot;&gt;&lt;/a&gt;一次性执行&lt;/h1&gt;&lt;p&gt;常见于单例模型中代码使用。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static dispatch_once_t onceToken;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_once(&amp;amp;onceToken, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //只执行一次&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@”hi”);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：GCD（Grand Central Dispatch），是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如NSThread,NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术。文章分享关于GCD的种种概念以及使用。&lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="iOS" scheme="http://charsdavy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://charsdavy.github.io/2016/04/13/singleton-pattern/"/>
    <id>http://charsdavy.github.io/2016/04/13/singleton-pattern/</id>
    <published>2016-04-13T00:23:37.000Z</published>
    <updated>2016-06-02T00:16:06.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：单例模式的作用是解决“应用中只有一个实例”的一类问题。本文主要介绍单例模式所谓何物，以及如何实现。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;问题的提出&quot;&gt;&lt;a href=&quot;#问题的提出&quot; class=&quot;headerlink&quot; title=&quot;问题的提出　&quot;&gt;&lt;/a&gt;问题的提出　&lt;/h1&gt;&lt;p&gt;在一个iOS 应用的生命周期中，有时候我们只需要某个类的一个实例。例如，iOS 设备都有一个重力加速计硬件设备，要访问设备在x轴、y轴和z轴上的重力加速度，就必然要有一个类能够与硬件设备沟通来实时获得这些数据，这个类就是UIAccelerometer 。除了实时地获得数据，该类还能够保持x 轴、y轴和z 轴的状态。但是这个类只需要一个实例就够了，如果有多个实例，就会占用过多的内存。 再有，当应用程序启动时，应用的状态由UIApplication 类的一个实例维护，这个实例代表了整个“应用程序对象”，它只能是一个实例，其作用是实现应用程序中一些共享资源的访问和状态的保持等。&lt;/p&gt;
&lt;h1 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h1&gt;&lt;p&gt;单例模式一般会封装一个静态属性，并提供静态实例的创建方法，其UML类图如图所示。&lt;br&gt;                               &lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-9459606ff1303fea.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;单例设计模式类图&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;示例代码：&quot;&gt;&lt;a href=&quot;#示例代码：&quot; class=&quot;headerlink&quot; title=&quot;示例代码：&quot;&gt;&lt;/a&gt;示例代码：&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//Singleton.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface Singleton : NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (Singleton*)sharedManager;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic ,strong) NSString* singletonData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//Singleton.m &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;Singleton.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation Singleton&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@synthesize singletonData = _singletonData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static Singleton *sharedManager = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (Singleton*)sharedManager&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static dispatch_once_t once;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_once(&amp;amp;once, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sharedManager = [[self alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return sharedManager;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中&lt;code&gt;static Singleton *sharedManager&lt;/code&gt; 为静态变量，类方法为&lt;code&gt;+ (Singleton*)sharedManager&lt;/code&gt;。sharedManager 方法采用了GCD（Grand Central Dispatch）技术，这是一种基于C语言的多线程访问技术。在上述代码中，&lt;code&gt;dispatch_once&lt;/code&gt; 函数就是由GCD提供的，它的作用是在整个应用程序生命周期中只执行一次代码块（^{…}）。 &lt;code&gt;dispatch_once_t&lt;/code&gt; 是GCD提供的结构体，使用时需要将GCD地址传给&lt;code&gt;dispatch_once&lt;/code&gt; 函数。&lt;code&gt;dispatch_once&lt;/code&gt; 函数能够记录该代码块是否被调用过。&lt;code&gt;dispatch_once&lt;/code&gt;函数不仅意味着代码仅会被运行一次，而且还意味着此运行还是线程同步的。也就是说，当我们使用了&lt;code&gt;dispatch_once&lt;/code&gt;函数时，就不再需要使用诸如&lt;code&gt;@synchronized&lt;/code&gt;之类的语句。&lt;/p&gt;
&lt;p&gt;将以上单例实现代码，抽成宏，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// @interface&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define singleton_interface(className) \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (className *)shared##className;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// @implementation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define singleton_implementation(className) \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static className *_instance; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (id)allocWithZone:(NSZone *)zone \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static dispatch_once_t onceToken; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_once(&amp;amp;onceToken, ^&amp;#123; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _instance = [super allocWithZone:zone]; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;); \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return _instance; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (className *)shared##className \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static dispatch_once_t onceToken; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_once(&amp;amp;onceToken, ^&amp;#123; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _instance = [[self alloc] init]; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;); \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return _instance; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;应用案例&quot;&gt;&lt;a href=&quot;#应用案例&quot; class=&quot;headerlink&quot; title=&quot;应用案例&quot;&gt;&lt;/a&gt;应用案例&lt;/h1&gt;&lt;p&gt;在Cocoa Touch框架中，有UIApplication、UIAccelerometer 、NSUserDefaults和NSNotificationCenter等单例类。另外，NSFileManager 和NSBundle 类虽然属于Cocoa框架的内容，但也可以在Cocoa Touch框架中使用（Cocoa框架中的单例类有NSFileManager 、NSBundle 、NSWorkspace和NSApplication 等）。 &lt;/p&gt;
&lt;h2 id=&quot;1-UIApplication&quot;&gt;&lt;a href=&quot;#1-UIApplication&quot; class=&quot;headerlink&quot; title=&quot;1. UIApplication&quot;&gt;&lt;/a&gt;1. UIApplication&lt;/h2&gt;&lt;p&gt;UIApplication 类的实例提供了应用程序的集中控制点来保持应用的状态。UIApplication 实例总是分配给应用程序委托对象（UIApplicationDelegate ），通过应用程序委托对象来响应低内存、应用启动、后台运行和应用终止等事件。在HelloWorld 案例中，AppDelegate 就是这个应用程序的委托对象，它实现了UIApplicationDelegate协议。&lt;/p&gt;
&lt;p&gt;UIApplication 类有很多方法和属性，下面我们重点介绍其中几个：&lt;br&gt;&lt;code&gt;+ sharedApplication&lt;/code&gt; 方法。创建和获得UIApplication 实例的方法。&lt;br&gt;&lt;code&gt;idleTimerDisabled&lt;/code&gt;属性。设定和获得“空闲时间禁止”的状态。idleTimerDisabled属性的默认值是NO，即默认情况下系统会锁定屏幕。当idleTimerDisabled = YES 时，则不会开启“空闲时间禁止”状态，系统不会锁定屏幕。开启这项设定需要谨慎，它会使你的应用比较耗电。&lt;br&gt;&lt;code&gt;- openURL:&lt;/code&gt;方法。可以打开一些内置的iOS 应用，其中包括打开浏览器、打开Google 地图、拨打电话、发送短信和发送E-mail 等。&lt;/p&gt;
&lt;p&gt;打开浏览器的示例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSURL *url = [NSURL URLWithString:@&amp;quot;http://www.cnblogs.com/chars&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[UIApplication sharedApplication] openURL:url];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;打开Google 地图时，实际上是通过内置浏览器来打开，示例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString* searchQuery = @&amp;quot;清华大学&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;searchQuery = [searchQuery stringByAddingPercentEscapesUsingEncoding: NSUTF8StringEncoding];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString* urlString = [NSString stringWithFormat: @&amp;quot;http://maps.google.com/maps?q=%@&amp;quot;, searchQuery];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中NSString 的&lt;code&gt;stringByAddingPercentEscapesUsingEncoding&lt;/code&gt;方法将字符串转换为URL编码，例如 “%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6 ”是“清华大学”的 URL 编码。 拨打电话时，苹果官方要求使用该方法调用内置拨号程序，示例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&amp;quot;tel://10010&amp;quot;]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;发送短信时，苹果官方要求使用该方法调用内置发送短信程序，示例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&amp;quot;sms:10010&amp;quot;]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;发送E-mail 时，这种方式可以发送简单的不带附件的E-mail ，示例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&amp;quot;mailto://eorient@sina.com&amp;quot;]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-UIAccelerometer&quot;&gt;&lt;a href=&quot;#2-UIAccelerometer&quot; class=&quot;headerlink&quot; title=&quot;2.   UIAccelerometer&quot;&gt;&lt;/a&gt;2.   UIAccelerometer&lt;/h2&gt;&lt;p&gt;单例类UIAccelerometer 前面也讲过，它可以访问重力加速计硬件设备，实时获得设备在x 轴、y轴和z 轴方向上的重力加速度。&lt;br&gt;&lt;code&gt;+ sharedAccelerometer&lt;/code&gt;方法是创建和获得UIAccelerometer实例的共享方法。&lt;/p&gt;
&lt;p&gt;与UIApplication类似，UIAccelerometer也有对应的委托对象，其委托对象为UIAccelerometerDelegate。UIAccelerometer 将实例分配给委托对象UIAccelerometerDelegate ，然后由委托对象响应重力加速计事件。&lt;/p&gt;
&lt;h2 id=&quot;3-NSUserDefaults&quot;&gt;&lt;a href=&quot;#3-NSUserDefaults&quot; class=&quot;headerlink&quot; title=&quot;3.   NSUserDefaults&quot;&gt;&lt;/a&gt;3.   NSUserDefaults&lt;/h2&gt;&lt;p&gt;单例类NSUserDefaults可以很方便地读取应用设置项目。&lt;br&gt;&lt;code&gt;+ standardUserDefaults&lt;/code&gt;方法是创建和获得NSUserDefaults实例的静态方法。&lt;/p&gt;
&lt;h2 id=&quot;4-NSNotificationCenter&quot;&gt;&lt;a href=&quot;#4-NSNotificationCenter&quot; class=&quot;headerlink&quot; title=&quot;4.   NSNotificationCenter&quot;&gt;&lt;/a&gt;4.   NSNotificationCenter&lt;/h2&gt;&lt;p&gt;单例类NSNotificationCenter提供信息广播通知，它采用观察者模式的通知机制。&lt;br&gt;&lt;code&gt;+ defaultCenter&lt;/code&gt;方法是创建和获得NSNotificationCenter实例的共享方法。&lt;/p&gt;
&lt;h2 id=&quot;5-NSFileManager&quot;&gt;&lt;a href=&quot;#5-NSFileManager&quot; class=&quot;headerlink&quot; title=&quot;5.   NSFileManager&quot;&gt;&lt;/a&gt;5.   NSFileManager&lt;/h2&gt;&lt;p&gt;NSFileManager 提供了访问文件系统的通用操作，可以定位、创建、复制文件和文件夹。在iOS 5和Mac OS X v10.7之后，它还可以管理存储在iCloud 上的数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+ defaultManager&lt;/code&gt;方法是创建和获得NSFileManager 实例的方法。除了该方法外，创建NSFileMa nager对象时还可以使用实例构造方法– init。这两种方法有着比较大的差别，+ defaultManager方法总是返回相同的NSFileManager 对象，但如果要使用委托（NSFileManagerDelegate）完成基于文件的操作并接收通知，应该使用– init 方法创建一个新的实例，而不是使用共享的对象。&lt;/p&gt;
&lt;h2 id=&quot;6-NSBundle&quot;&gt;&lt;a href=&quot;#6-NSBundle&quot; class=&quot;headerlink&quot; title=&quot;6.   NSBundle&quot;&gt;&lt;/a&gt;6.   NSBundle&lt;/h2&gt;&lt;p&gt;NSBundle 提供了动态加载（或卸载）可执行代码、定位资源文件以及资源本地化、访问文件系统等功能。&lt;br&gt;&lt;code&gt;+ mainBundle&lt;/code&gt;方法是创建和获得NSBundle 实例的共享方法。&lt;/p&gt;
&lt;h1 id=&quot;尾声&quot;&gt;&lt;a href=&quot;#尾声&quot; class=&quot;headerlink&quot; title=&quot;尾声&quot;&gt;&lt;/a&gt;尾声&lt;/h1&gt;&lt;p&gt;单例模式无疑是Cocoa框架下最重要的设计模式之一。灵活而有机地运用设计模式，意味着编程工作的高效性和产品健壮性、安全性的提高。因此，我们应该要善于使用设计模式，将自己的开发经验与代码、设计模式完美融合起来，提高软件代码质量。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：单例模式的作用是解决“应用中只有一个实例”的一类问题。本文主要介绍单例模式所谓何物，以及如何实现。&lt;/p&gt;
    
    </summary>
    
      <category term="进阶" scheme="http://charsdavy.github.io/categories/advance/"/>
    
    
      <category term="设计模式" scheme="http://charsdavy.github.io/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 - 概述</title>
    <link href="http://charsdavy.github.io/2016/04/12/design-pattern-introduction/"/>
    <id>http://charsdavy.github.io/2016/04/12/design-pattern-introduction/</id>
    <published>2016-04-12T00:08:59.000Z</published>
    <updated>2016-06-02T00:11:41.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是 GOF（四人帮，全拼 Gang of Four）？&lt;/strong&gt;&lt;br&gt;在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 &lt;strong&gt;Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）&lt;/strong&gt; 的书，该书首次提到了软件开发中设计模式的概念。&lt;br&gt;四位作者合称 &lt;strong&gt;GOF（四人帮，全拼 Gang of Four）&lt;/strong&gt;。他们所提出的设计模式主要是基于以下的面向对象设计原则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对接口编程而不是对实现编程。&lt;/li&gt;
&lt;li&gt;优先使用对象组合而不是继承。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;设计模式的使用&lt;/strong&gt;&lt;br&gt;设计模式在软件开发中的两个主要用途。&lt;br&gt;&lt;strong&gt;开发人员的共同平台&lt;/strong&gt;&lt;br&gt;设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。&lt;br&gt;&lt;strong&gt;最佳的实践&lt;/strong&gt;&lt;br&gt;设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计模式的类型&lt;/strong&gt;&lt;br&gt;根据设计模式的参考书 &lt;strong&gt;Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）&lt;/strong&gt; 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建型模式&lt;/strong&gt;&lt;br&gt;这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工厂模式（Factory Pattern）&lt;/li&gt;
&lt;li&gt;抽象工厂模式（Abstract Factory Pattern）&lt;/li&gt;
&lt;li&gt;单例模式（Singleton Pattern）&lt;/li&gt;
&lt;li&gt;建造者模式（Builder Pattern）&lt;/li&gt;
&lt;li&gt;原型模式（Prototype Pattern）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;结构型模式&lt;/strong&gt;&lt;br&gt;这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适配器模式（Adapter Pattern）&lt;/li&gt;
&lt;li&gt;桥接模式（Bridge Pattern）&lt;/li&gt;
&lt;li&gt;过滤器模式（Filter、Criteria Pattern）&lt;/li&gt;
&lt;li&gt;组合模式（Composite Pattern）&lt;/li&gt;
&lt;li&gt;装饰器模式（Decorator Pattern）&lt;/li&gt;
&lt;li&gt;外观模式（Facade Pattern）&lt;/li&gt;
&lt;li&gt;享元模式（Flyweight Pattern）&lt;/li&gt;
&lt;li&gt;代理模式（Proxy Pattern）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;行为型模式&lt;/strong&gt;&lt;br&gt;这些设计模式特别关注对象之间的通信。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;责任链模式（Chain of Responsibility Pattern）&lt;/li&gt;
&lt;li&gt;命令模式（Command Pattern）&lt;/li&gt;
&lt;li&gt;解释器模式（Interpreter Pattern）&lt;/li&gt;
&lt;li&gt;迭代器模式（Iterator Pattern）&lt;/li&gt;
&lt;li&gt;中介者模式（Mediator Pattern）&lt;/li&gt;
&lt;li&gt;备忘录模式（Memento Pattern）&lt;/li&gt;
&lt;li&gt;观察者模式（Observer Pattern）&lt;/li&gt;
&lt;li&gt;状态模式（State Pattern）&lt;/li&gt;
&lt;li&gt;空对象模式（Null Object Pattern）&lt;/li&gt;
&lt;li&gt;策略模式（Strategy Pattern）&lt;/li&gt;
&lt;li&gt;模板模式（Template Pattern）&lt;/li&gt;
&lt;li&gt;访问者模式（Visitor Pattern）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;J2EE 模式&lt;/strong&gt;&lt;br&gt;这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MVC 模式（MVC Pattern）&lt;/li&gt;
&lt;li&gt;业务代表模式（Business Delegate Pattern）&lt;/li&gt;
&lt;li&gt;组合实体模式（Composite Entity Pattern）&lt;/li&gt;
&lt;li&gt;数据访问对象模式（Data Access Object Pattern）&lt;/li&gt;
&lt;li&gt;前端控制器模式（Front Controller Pattern）&lt;/li&gt;
&lt;li&gt;拦截过滤器模式（Intercepting Filter Pattern）&lt;/li&gt;
&lt;li&gt;服务定位器模式（Service Locator Pattern）&lt;/li&gt;
&lt;li&gt;传输对象模式（Transfer Object Pattern）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面用一个图片来整体描述一下设计模式之间的关系：&lt;br&gt;&lt;img src=&quot;https://mmbiz.qlogo.cn/mmbiz/y4YjDeP3XHQeqQatAA0oaZ8EeehcSgwbETlkDGicqpmby422NM4n75NCOrPKgh2BRmVJHocO6WzRia6gW4gibMFibA/0?wx_fmt=jpeg&quot; alt=&quot;设计模式之间的关系&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计模式的六大原则&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;1、开闭原则（Open Close Principle）&lt;/strong&gt;&lt;br&gt;开闭原则的意思是：&lt;strong&gt;对扩展开放，对修改关闭&lt;/strong&gt;。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。&lt;br&gt;&lt;strong&gt;2、里氏代换原则（Liskov Substitution Principle）&lt;/strong&gt;&lt;br&gt;里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。&lt;br&gt;&lt;strong&gt;3、依赖倒转原则（Dependence Inversion Principle）&lt;/strong&gt;&lt;br&gt;这个原则是开闭原则的基础，具体内容：针对对接口编程，依赖于抽象而不依赖于具体。&lt;br&gt;&lt;strong&gt;4、接口隔离原则（Interface Segregation Principle）&lt;/strong&gt;&lt;br&gt;这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。&lt;br&gt;&lt;strong&gt;5、迪米特法则，又称最少知道原则（Demeter Principle）&lt;/strong&gt;&lt;br&gt;最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。&lt;br&gt;&lt;strong&gt;6、合成复用原则（Composite Reuse Principle）&lt;/strong&gt;&lt;br&gt;合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。&lt;/p&gt;
    
    </summary>
    
      <category term="进阶" scheme="http://charsdavy.github.io/categories/advance/"/>
    
    
      <category term="设计模式" scheme="http://charsdavy.github.io/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://charsdavy.github.io/2016/04/10/hello-world/"/>
    <id>http://charsdavy.github.io/2016/04/10/hello-world/</id>
    <published>2016-04-10T10:32:15.000Z</published>
    <updated>2016-06-02T00:07:56.000Z</updated>
    
    <content type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate-static-files&quot;&gt;&lt;a href=&quot;#Generate-static-files&quot; class=&quot;headerlink&quot; title=&quot;Generate static files&quot;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/generating.html&quot;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Deploy-to-remote-sites&quot;&gt;&lt;a href=&quot;#Deploy-to-remote-sites&quot; class=&quot;headerlink&quot; title=&quot;Deploy to remote sites&quot;&gt;&lt;/a&gt;Deploy to remote sites&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/deployment.html&quot;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="应用实战" scheme="http://charsdavy.github.io/categories/apply/"/>
    
    
      <category term="hexo" scheme="http://charsdavy.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
