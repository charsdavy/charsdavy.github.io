<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chars&#39;s Blog</title>
  
  <subtitle>Never stop living and learning</subtitle>
  <link href="https://chars.tech/atom.xml" rel="self"/>
  
  <link href="https://chars.tech/"/>
  <updated>2020-01-26T09:24:10.000Z</updated>
  <id>https://chars.tech/</id>
  
  <author>
    <name>Chars</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>X-Callback-URL 在‘今日账单’中的使用</title>
    <link href="https://chars.tech/2019-11-24-x-callback-url-cn/"/>
    <id>https://chars.tech/2019-11-24-x-callback-url-cn/</id>
    <published>2019-11-23T16:00:00.000Z</published>
    <updated>2020-01-26T09:24:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>今日账单</strong> 实现了 <a href="http://x-callback-url.com/">x-callback-url</a> 协议，这是一种通用的 URL Scheme 协议。它能让你在不通的 App 之间通信，<a href="https://workflow.is/">Workflow</a>、<a href="https://contrast.co/launch-center-pro/">Launch Center Pro</a> 等 App 都支持了 x-callback-url，因此 <strong>今日账单</strong> 也支持与他们协作。</p><span id="more"></span><p>今日账单 的 <code>x-callback-url</code> 格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">niffler://x-callback-url/[动作]?[动作参数]&amp;[x-callback 参数]</span><br></pre></td></tr></table></figure><h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p><code>/account</code></p><p>使用指定的名字创建账本</p><p><code>/bill</code></p><p>使用指定的名称和数字创建账单</p><h3 id="动作参数"><a href="#动作参数" class="headerlink" title="动作参数"></a>动作参数</h3><p><code>name</code>（必选）账本或账单项目名称</p><p><code>value</code>，当动作为bill时，为必选参数。账单开销数值。</p><p><code>type</code>，当动作为bill时，为必选参数。账单开销类型，0 支出，1 收入，2 已报销。</p><p><code>remark</code>（可选），备注信息</p><p><code>payway</code>（可选），账单支付方式</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>1.创建一个名为“装修”，备注信息为“店铺”的账本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">niffler://x-callback-url/account?name=装修&amp;remark=店铺</span><br></pre></td></tr></table></figure><p>2.创建一条类别为“饮食”的“午餐”通过“现金”支出 12 元的账单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">niffler://x-callback-url/bill?name=饮食&amp;type=0&amp;remark=午餐&amp;value=12&amp;payway=现金</span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本文档对应 App 版本为 3.7.6 及以上</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;今日账单&lt;/strong&gt; 实现了 &lt;a href=&quot;http://x-callback-url.com/&quot;&gt;x-callback-url&lt;/a&gt; 协议，这是一种通用的 URL Scheme 协议。它能让你在不通的 App 之间通信，&lt;a href=&quot;https://workflow.is/&quot;&gt;Workflow&lt;/a&gt;、&lt;a href=&quot;https://contrast.co/launch-center-pro/&quot;&gt;Launch Center Pro&lt;/a&gt; 等 App 都支持了 x-callback-url，因此 &lt;strong&gt;今日账单&lt;/strong&gt; 也支持与他们协作。&lt;/p&gt;</summary>
    
    
    
    <category term="project" scheme="https://chars.tech/categories/project/"/>
    
    
    <category term="Niffler" scheme="https://chars.tech/tags/Niffler/"/>
    
  </entry>
  
  <entry>
    <title>Use of X-Callback-URL in &#39;Niffler&#39;</title>
    <link href="https://chars.tech/2019-11-24-x-callback-url-en/"/>
    <id>https://chars.tech/2019-11-24-x-callback-url-en/</id>
    <published>2019-11-23T16:00:00.000Z</published>
    <updated>2020-01-26T09:27:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Niffler</strong> implements the <a href="http://x-callback-url.com/">x-callback-url</a> protocol, a generic URL Scheme protocol. It allows you to communicate between different apps. <a href="https://workflow.is/">Workflow</a>, <a href="https://contrast.co/launch-center-pro/">Launch Center Pro</a> and other apps support x-callback-url, so <strong>Niffler</strong> also supports working with them.</p><span id="more"></span><p>Niffler’s <code>x-callback-url</code> format is:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">niffler://x-callback-url/[action]?[action parameter]&amp;[x-callback parameter]</span><br></pre></td></tr></table></figure><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p><code>/account</code></p><p>Create account with specified name</p><p><code>/bill</code></p><p>Create a bill with the specified name and number</p><h3 id="Action-Parameters"><a href="#Action-Parameters" class="headerlink" title="Action Parameters"></a>Action Parameters</h3><p><code>name</code>(required), Account or bill item name</p><p><code>value</code>, This parameter is required when the action is bill. Billing overhead figures.</p><p><code>type</code>, This parameter is required when the action is bill. Billing expense type, 0 expenses, 1 income, 2 reimbursed.</p><p><code>remark</code>(optional), Remark Information</p><p><code>payway</code>(optional), Bill payment method</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>1.Create a account named “Decoration” with a remark of “Shop”.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">niffler://x-callback-url/account?name=Decoration&amp;remark=Shop</span><br></pre></td></tr></table></figure><p>2.Create a bill of “Lunch” with the category “Diet” to spend $ 12 in “Cash”.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">niffler://x-callback-url/bill?name=Diet&amp;type=0&amp;remark=Lunch&amp;value=12&amp;payway=Cash</span><br></pre></td></tr></table></figure><h3 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h3><p>This document corresponds to the App version 3.7.6 and above</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Niffler&lt;/strong&gt; implements the &lt;a href=&quot;http://x-callback-url.com/&quot;&gt;x-callback-url&lt;/a&gt; protocol, a generic URL Scheme protocol. It allows you to communicate between different apps. &lt;a href=&quot;https://workflow.is/&quot;&gt;Workflow&lt;/a&gt;, &lt;a href=&quot;https://contrast.co/launch-center-pro/&quot;&gt;Launch Center Pro&lt;/a&gt; and other apps support x-callback-url, so &lt;strong&gt;Niffler&lt;/strong&gt; also supports working with them.&lt;/p&gt;</summary>
    
    
    
    <category term="project" scheme="https://chars.tech/categories/project/"/>
    
    
    <category term="Niffler" scheme="https://chars.tech/tags/Niffler/"/>
    
  </entry>
  
  <entry>
    <title>iOS 单元测试</title>
    <link href="https://chars.tech/2019-06-24-ios-unit-test/"/>
    <id>https://chars.tech/2019-06-24-ios-unit-test/</id>
    <published>2019-06-23T16:00:00.000Z</published>
    <updated>2019-06-24T11:40:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如 C 语言中单元指一个函数，Java 里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。</p><p>单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。</p><span id="more"></span><h2 id="为什么要做单元测试"><a href="#为什么要做单元测试" class="headerlink" title="为什么要做单元测试"></a>为什么要做单元测试</h2><p>1）在一个复杂的项目中添加某功能模块时，可以快捷的进行针对性测试，而不用将整个项目 Run 起来。</p><p>2）可以便捷的对某个具体方法进行测试。</p><h2 id="单元测试有哪些"><a href="#单元测试有哪些" class="headerlink" title="单元测试有哪些"></a>单元测试有哪些</h2><p>iOS 开发（或者 MacOS、tvOS、watchOS 等）中，单元测试有多种方式，主要分为 Xcode 提供的以及第三方测试框架这两类：</p><ul><li><p>Xcode自带<br>XCTest：XCTest 是 Xcode自带的单元测试工具，其前身是 OCUnit，随着 Xcode 的发展，XCTest 已经越来越完善，功能也越强大。</p></li><li><p>第三方框架<br>GHUnit：GHUnit  是 GitHub 上著名的开源测试框架，可视化、开源、扩展等功能，让其相比 XCTest 更加强大（现在的 XCTest 也很完善了，不过 GHUnit 比较老，现在已经停止维护，不建议使用）<br>OCMock：OCMock 也是 Github 上的著名开源测试框架，用于 Mock、Stub，为测试提供数据作假功能。</p></li></ul><p>以上三种就是比较主流的测试 Xcode 单元测试途径，还有一些 BDD 行为测试框架：</p><blockquote><p>什么是 BDD<br>BDD（Behavior Driven Development），即行为驱动开发，是敏捷开发技术之一，通过自然语言定义系统行为，以功能使用者的角度，编写需求场景，且这些行为描述可以直接形成需求文档，同时也是测试标准。</p></blockquote><ul><li>Specta：GitHub 上轻量级的 BDD 测试框架。</li><li>Expecta：与 Specta 同个作者，是一个功能强大的匹配框架。</li><li>Kiwi：Kiwi 是重量级的，集 OCMock、Specta、Expecta 所拥有的功能与一身的 BDD DSL 测试框架。</li></ul><p>其他的，还有一些其他测试工具、测试方式，如：</p><ul><li>Nocilla：强大的 HTTP 模拟测试工具。</li><li>OHHTTPStubs：也是 HTTP 模拟测试工具。</li><li>TUDelorean：基于 Objective-C 的时间模拟测试工具。</li><li>KIF：集成／界面测试工具，其它的还有 Frank、Calabash 等。</li><li>GitHub + Jenkins + TestFlight：自动化测试。</li><li>Monkey Test：随机测试。</li></ul><h2 id="XCTest-测试"><a href="#XCTest-测试" class="headerlink" title="XCTest 测试"></a>XCTest 测试</h2><p>1、创建测试类</p><p>注意，所有测试类都继承自 XCTestCase。</p><p>2、测试类的结构</p><p>默认创建的单元测试类为一个 <code>.m</code> 文件，里面包含了以下四个方法：</p><ul><li><code>- (void)setUp</code>：在每个测试用例开始前调用，可以做一些测试准备工作，为可选方法。</li><li><code>- (void)tearDown</code>：在每个测试用例结束后调用，可以做一些测试收尾工作，为可选方法。</li><li><code>- (void)testExample</code>：默认创建的测试用例。</li><li><code>- (void)testPerformanceExample</code>：性能测试方法。</li></ul><p>3、测试流程</p><p>当我们默认执行测试时，系统找到所有的测试类，并执行每个测试方法；我们也可以选择性地执行某些测试而已，比如，在 scheme 中 disable 某个用例，或者直接在测试导航栏中每个测试用例后面的运行按钮，单独执行某个测试。</p><p>默认流程如下：</p><p>上一个测试类 -&gt; 当前类<code>+ (void)setUp</code> -&gt; [ <code>- (void)setUp</code> -&gt; 测试方法 -&gt; <code>- (void)tearDown</code> ] (循环直至当前类测试方法全部执行完) -&gt; 当前类 <code>+ (void)tearDown</code> -&gt; 下一个测试类</p><p>4、测试方法</p><p>测试方法以 test 为前缀，没有参数，返回值为 void，方法中用断言来判断测试的正确性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)testColorIsRed &#123;</span><br><span class="line">   // Set up, call test subject API. (Code could be shared in setUp method.)</span><br><span class="line">   // Test logic and values, assertions report pass/fail to testing framework.</span><br><span class="line">   // Tear down. (Code could be shared in tearDown method.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)testThatItDoesURLEncoding &#123;</span><br><span class="line">    // given</span><br><span class="line">    NSString *searchQuery = @&quot;$content$amp;?@&quot;;</span><br><span class="line">    HTTPRequest *request = [HTTPRequest requestWithURL:@&quot;/search?q=%@&quot;, searchQuery];</span><br><span class="line"></span><br><span class="line">    // when</span><br><span class="line">    NSString *encodedURL = request.URL;</span><br><span class="line"></span><br><span class="line">    // then</span><br><span class="line">    XCTAssertEqualObjects(encodedURL, @&quot;/search?q=%24%26%3F%40&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、测试断言</p><p>断言一般由判断条件、字符串 format、字符串参数组成，参数可选，在 XCTest 中，断言有以下分类：</p><ul><li>Unconditional Fail：XCTFail，失败时候抛出。</li><li>Equality Tests：用于断言两个表达式相等或不相等，如：XCTAssertEqual、XCTAssertEqualWithAccuracy、XCTAssertNotEqual、 XCTAssertGreaterThan。</li><li>Boolean Tests：断言布尔表达式真假，如：XCTAssertTrue、XCTAssertFalse。</li><li>Nil Tests：空断言，如：XCTAssertNil、XCTAssertNotNil。</li><li>Exception Tests：断言表达式抛出或不抛出异常，如：XCTAssertThrows、XCTAssertThrowsSpecific、XCTAssertNoThrow。</li></ul><h2 id="Specta、Expecta-测试"><a href="#Specta、Expecta-测试" class="headerlink" title="Specta、Expecta 测试"></a>Specta、Expecta 测试</h2><p><a href="https://github.com/specta/specta">Specta</a> 和 <a href="https://github.com/specta/expecta">Expecta</a> 都是出自 Github 作者 <a href="https://github.com/orta">Orta</a> 之手，他最出名的开源框架莫过于 <a href="https://github.com/CocoaPods/CocoaPods">Cocoapods</a>。</p><h3 id="Specta"><a href="#Specta" class="headerlink" title="Specta"></a>Specta</h3><p>Specta 是一个轻量级 BBD 测试框架，其为 <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL (Domain-Specific Language)</a> 模式，让测试更加接近于自然语言描述，更加易懂。</p><p>1、主要有以下特点：</p><ul><li>容易集成到项目中。</li><li>基于XCTest编写，可以很好地与XCTest配合使用。</li></ul><p>2、语法介绍</p><ol><li><p>SpecBegin 声明了一个测试类，SpecEnd 结束类声明</p></li><li><p>describe (context) 块声明了一组实例</p></li><li><p>it (example&#x2F;specify) 是一个单一的样例</p></li><li><p>beforeAll 是一个执行于全部同级块之前的块，仅仅执行一次。afterAll 与beforeAll相反，是在全部同级块之后执行的块。仅仅执行一次。</p></li><li><p>beforeEach&#x2F;afterEach，在每一个同级块执行的时候，都会执行一次，而beforeAll&#x2F;afterAll仅仅会执行一次</p></li><li><p>it&#x2F;waitUntil&#x2F;done()。异步调用，注意完毕异步操作之后。必须调用done()函数。例如以下：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it(@&quot;should do some stuff asynchronously&quot;, ^&#123;</span><br><span class="line">waitUntil(^(DoneCallback done) &#123;</span><br><span class="line">  // Async example blocks need to invoke done() callback.</span><br><span class="line">  done();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="7"><li>sharedExamplesFor 和 itShouldBehaveLike结合在一起。能够实如今不同的spec之间共享同一套test case<br>sharedExamplesFor 设置多个spec之间共享的test case，第一个參数作为标识符。通过itShouldBehaveLike来执行spec中test case。第一个參数传入sharedExamplesFor设置时使用的标识符。</li></ol><p>注意：在describe局部使用sharedExamplesFor定义shared examples。能够在它作用域内覆盖全局的shared examples。</p><ol start="8"><li>pending，仅仅打印一条log信息。不做测试。这个语句会给出一条警告，能够作为一开始集中书写行为描写叙述时还未实现的测试的提示。</li></ol><p>3、一般使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">SpecBegin(Car)</span><br><span class="line">    describe(@&quot;Car&quot;, ^&#123;</span><br><span class="line">        __block Car *car;</span><br><span class="line"></span><br><span class="line">        // Will be run before each enclosed it</span><br><span class="line">        beforeEach(^&#123;</span><br><span class="line">            car = [Car new];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // Will be run after each enclosed it</span><br><span class="line">        afterEach(^&#123;</span><br><span class="line">            car = nil;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // An actual test</span><br><span class="line">        it(@&quot;should be red&quot;, ^&#123;</span><br><span class="line">            expect(car.color).to.equal([UIColor redColor]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        describe(@&quot;when it is started&quot;, ^&#123;</span><br><span class="line">            beforeEach(^&#123;</span><br><span class="line">                [car start];</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            it(@&quot;should have engine running&quot;, ^&#123;</span><br><span class="line">                expect(car.engine.running).to.beTruthy();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        describe(@&quot;move to&quot;, ^&#123;</span><br><span class="line">            context(@&quot;when the engine is running&quot;, ^&#123;</span><br><span class="line">                beforeEach(^&#123;</span><br><span class="line">                    car.engine.running = YES;</span><br><span class="line">                    [car moveTo:CGPointMake(42,0)];</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                it(@&quot;should move to given position&quot;, ^&#123;</span><br><span class="line">                    expect(car.position).to.equal(CGPointMake(42, 0));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            context(@&quot;when the engine is not running&quot;, ^&#123;</span><br><span class="line">                beforeEach(^&#123;</span><br><span class="line">                    car.engine.running = NO;</span><br><span class="line">                    [car moveTo:CGPointMake(42,0)];</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                it(@&quot;should not move to given position&quot;, ^&#123;</span><br><span class="line">                    expect(car.engine.running).to.beTruthy();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">SpecEnd</span><br></pre></td></tr></table></figure><p>上面例子对 Car 这个类做测试，通过多个上下文嵌套（describe&#x2F;context），结合不同的条件（beforeEach)，来作出不同的断言（it)；当我们某个测试失败时，我们会收到一段很明确的错误信息，比如：汽车启动后应该移动到指定位置这个用例测试失败，那么我们会收到 Car move to when the engine is running should move to given position 这么一段话。这样非常接近自然语言的描述会让我们很快知道错误出在哪里。</p><p>4、注意：</p><ul><li><p>如果想用 SPEC_BEGIN 和 SPEC_END 替代 SpecBegin and SpecEnd，应该在引入头文件之前写上 #define SPT_CEDAR_SYNTAX</p></li><li><p>如果要使用 XCTest Resporter，那么在 Test Scheme 中，把 SPTXCTestReporter 字段值改为 SPECTA_REPORTER_CLASS</p></li><li><p>把环境变量 SPECTA_SHUFFLE 设置为 1 启用测试拖拽（test shuffling)</p></li></ul><h3 id="Expecta"><a href="#Expecta" class="headerlink" title="Expecta"></a>Expecta</h3><p>Expecta 是基于 Objective-C／Cocoa 的断言框架，XCTest 自带的断言 XCAssert 有好几个基础操作，不过基础的断言不太丰富，和 Specta 也没有很适配。 Expecta 不一样，将匹配过程从断言中剥离开，可以很好地适配 Specta 的 DSL 断言块。</p><p>1、Expecta 有以下几个特点：</p><ul><li><p>没有类型限制，比如数值 1，并不用关心它是整形还是浮点数</p></li><li><p>链式编程，可读性高，如：expect(foo).notTo.equal(1)</p></li><li><p>反向匹配，断言不匹配只需加上 .notTo 或者 .toNot，如：expect(x).notTo.equal(y)</p></li><li><p>延时匹配，可以在链式表达式中加入 .will、.willNot、.after(interval) 等操作来延时匹配</p></li><li><p>可扩展，支持增加自定义匹配</p></li></ul><p>2、基础匹配 API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(x).to.equal(y); // x 与 y 相等</span><br><span class="line">expect(x).to.beIdenticalTo(y); // x 与 y 相等且内存地址相同</span><br><span class="line">expect(x).to.beNil(); // x 为 nil</span><br><span class="line">expect(x).to.beTruthy(); // x 为 true（非 0）</span><br><span class="line">expect(x).to.beFalsy(); // x 为 false（0 值）</span><br></pre></td></tr></table></figure><p>3、异步匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">describe(@&quot;WebImage&quot;, ^&#123;</span><br><span class="line">beforeAll(^&#123;</span><br><span class="line">    // 设置默认延时匹配时间</span><br><span class="line">    [Expecta setAsynchronousTestTimeout:2];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(@&quot;will not be nil&quot;, ^&#123;</span><br><span class="line">    //使用默认延时匹配</span><br><span class="line">    expect(webImage).willNot.beNil();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(@&quot;should equal 42 after 3 seconds&quot;, ^&#123;</span><br><span class="line">    // 不使用默认延时匹配，手动设置为3秒</span><br><span class="line">    expect(webImage).after(3).to.equal(42);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>4、自定义使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Specta/Specta.h&gt;</span><br><span class="line">#import &lt;Expecta/Expecta.h&gt;</span><br><span class="line">#import &quot;ImageModel.h&quot;</span><br><span class="line"></span><br><span class="line">SpecBegin(ImageModel);</span><br><span class="line"></span><br><span class="line">__block ImageModel *model;</span><br><span class="line"></span><br><span class="line">beforeEach(^&#123;</span><br><span class="line">    model = [[ImageModel alloc] initWithUrl:@&quot;http://pic37.nipic.com/20140113/8800276_184927469000_2.png&quot; title:@&quot;天空独角马&quot; described:@&quot;在黄色的沙漠里，特别突兀&quot;];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(@&quot;should not nil&quot;, ^&#123;</span><br><span class="line">    expect(model).toNot.beNil();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(@&quot;equal&quot;, ^&#123;</span><br><span class="line">    expect(model.url).to.equal(@&quot;http://pic37.nipic.com/20140113/8800276_184927469000_2.png&quot;);</span><br><span class="line">    expect(model.title).to.equal(@&quot;天空独角马&quot;);</span><br><span class="line">    expect(model.described).to.equal(@&quot;在黄色的沙漠里，特别突兀&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">SpecEnd;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Expecta 和 Specta 需要配合使用，与 XCTest 一样都是基于 XCTestCase 实现。在断言的使用上，XCTest 太过死板，Expecta 和 Specta 则很灵活，可以满足大部分场景需求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如 C 语言中单元指一个函数，Java 里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。&lt;/p&gt;
&lt;p&gt;单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。&lt;/p&gt;</summary>
    
    
    
    <category term="pieces" scheme="https://chars.tech/categories/pieces/"/>
    
    
    <category term="objc" scheme="https://chars.tech/tags/objc/"/>
    
    <category term="ios" scheme="https://chars.tech/tags/ios/"/>
    
    <category term="test" scheme="https://chars.tech/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Core Data 是什么样子的</title>
    <link href="https://chars.tech/2019-03-22-core-data-junior-learn/"/>
    <id>https://chars.tech/2019-03-22-core-data-junior-learn/</id>
    <published>2019-03-21T16:00:00.000Z</published>
    <updated>2019-04-08T11:58:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Core Data 是 iOS3.0 时引入的一个数据持久化的框架。与 sqlite 对比最大的优点莫过于支持对象的存储，苹果的官方文档说其简化了数据库的操作，使用 Core Data 确实可以大量减少代码中的 SQL 语句。</p><p>可是现状，大家对于持久化的选择方案仍多数是 FMDB。笔者猜测，最大的原因可能就是性能。</p><span id="more"></span><p><img src="/assets/images/tech/core-data-junior-learn-queries.jpg" alt="各种持久化方案性能比较"></p><h2 id="Core-Data-是什么"><a href="#Core-Data-是什么" class="headerlink" title="Core Data 是什么"></a>Core Data 是什么</h2><p>Core Data 是一个模型层的技术，帮助开发者建立代表程序状态的模型层。同时也是一种持久化技术，它能将模型对象的状态持久化到磁盘。它是完全独立于 UI 层级的框架，是作为模型层框架被设计出来的。</p><p>Core Data 不是一个 O&#x2F;RM，但它比 O&#x2F;RM 能做的更多。它也不是一个 SQL wrapper。它默认使用 SQL，但它是一种更高级的抽象概念。</p><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>Core Data 有相当多可用的组件。当所有的组件都捆绑到一起的时候，我们把它称作 Core Data 堆栈，这个堆栈有两个主要部分。</p><p>一部分是关于对象图管理，这正是你需要很好掌握的那一部分，并且知道怎么使用。<br>另一部分是关于持久化，比如，保存你模型对象的状态，然后再恢复模型对象的状态。</p><p>堆栈结构如下</p><p><img src="/assets/images/tech/core-data-junior-learn-stack-complex.png" alt="Core Data 堆栈"></p><p>NSPersistentStoreCoordinator 是一个位于本地存储文件与缓存层（NSManagedObjectContext）之间的一个持久化层，它是真实操作数据库本地文件。</p><p>NSManagedObjectContext 是一个被管理数据的上下文，它实际上是对所有数据库操作的一个缓存层，把所有的操作都先缓存起来避免大量磁盘 IO 造成不流畅，在操作完数据库后调用其 save 方法，就可以把数据库操作提交给持久化层（NSPersistentStoreCoordinator），由持久化层一次性写入数据库文件。</p><p>NSManagedObject 是被管理的数据记录，对应数据库的一个表。</p><p>另外，Core Data 可以将多个 stores 附属于同一个持久化存储协调器，并且除了存储 SQL 格式外，还有很多存储类型可供选择。<br>最常见的方案如下</p><p><img src="/assets/images/tech/core-data-junior-learn-stack-simple.png" alt="多个 stores 持久化"></p><h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>下面是笔者定义的一个 Event 表的元素组成</p><p><img src="/assets/images/tech/core-data-junior-learn-event-struct.png" alt="数据表元素"></p><p>定义数据模型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MXWEventModel</span>: <span class="title class_">NSObject</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">Int64</span></span><br><span class="line">    <span class="keyword">var</span> time: <span class="type">Date</span></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> detail: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> addr: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">id</span>: <span class="type">Int64</span>, <span class="params">title</span>: <span class="type">String</span>, <span class="params">detail</span>: <span class="type">String</span>, <span class="params">addr</span>: <span class="type">String</span>, <span class="params">time</span>: <span class="type">Date</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> context <span class="operator">=</span> persistentContainer.viewContext</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">add</span>(<span class="params">model</span>: <span class="type">AnyObject</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> eventModel: <span class="type">MXWEventModel</span> <span class="operator">=</span> model <span class="keyword">as!</span> <span class="type">MXWEventModel</span></span><br><span class="line"><span class="keyword">let</span> entity <span class="operator">=</span> <span class="type">NSEntityDescription</span>.entity(forEntityName: @<span class="string">&quot;MXWEvent&quot;</span>, in: context<span class="operator">!</span>)</span><br><span class="line"><span class="keyword">let</span> obj <span class="operator">=</span> <span class="type">NSManagedObject</span>(entity: entity<span class="operator">!</span>, insertInto: context)</span><br><span class="line">obj.setValue(eventModel.id, forKey: <span class="string">&quot;id&quot;</span>)</span><br><span class="line">obj.setValue(eventModel.title, forKey: <span class="string">&quot;title&quot;</span>)</span><br><span class="line">obj.setValue(eventModel.detail, forKey: <span class="string">&quot;detail&quot;</span>)</span><br><span class="line">obj.setValue(eventModel.time, forKey: <span class="string">&quot;time&quot;</span>)</span><br><span class="line">obj.setValue(eventModel.addr, forKey: <span class="string">&quot;addr&quot;</span>)</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">try</span> context<span class="operator">?</span>.save()</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">delete</span>(<span class="params">id</span>: <span class="type">Int64</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> request <span class="operator">=</span> <span class="type">NSFetchRequest</span>&lt;<span class="type">NSFetchRequestResult</span>&gt;(entityName: @<span class="string">&quot;MXWEvent&quot;</span>)</span><br><span class="line">request.predicate <span class="operator">=</span> <span class="type">NSPredicate</span>(format: <span class="string">&quot;id==<span class="subst">\(id)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> deleteRequest <span class="operator">=</span> <span class="type">NSBatchDeleteRequest</span>(fetchRequest: request)</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">try</span> context<span class="operator">?</span>.execute(deleteRequest)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">update</span>(<span class="params">id</span>: <span class="type">Int64</span>, <span class="params">model</span>: <span class="type">AnyObject</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> eventModel: <span class="type">MXWEventModel</span> <span class="operator">=</span> model <span class="keyword">as!</span> <span class="type">MXWEventModel</span></span><br><span class="line"><span class="keyword">let</span> request <span class="operator">=</span> <span class="type">NSFetchRequest</span>&lt;<span class="type">NSFetchRequestResult</span>&gt;(entityName: @<span class="string">&quot;MXWEvent&quot;</span>)</span><br><span class="line">request.predicate <span class="operator">=</span> <span class="type">NSPredicate</span>(format: <span class="string">&quot;id==<span class="subst">\(id)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">let</span> eventObj <span class="operator">=</span> <span class="keyword">try</span> context<span class="operator">?</span>.fetch(request)</span><br><span class="line"><span class="keyword">let</span> updateObj <span class="operator">=</span> eventObj<span class="operator">?</span>.first <span class="keyword">as!</span> <span class="type">NSManagedObject</span></span><br><span class="line">updateObj.setValue(eventModel.title, forKey: <span class="string">&quot;title&quot;</span>)</span><br><span class="line">updateObj.setValue(eventModel.detail, forKey: <span class="string">&quot;detail&quot;</span>)</span><br><span class="line">updateObj.setValue(eventModel.time, forKey: <span class="string">&quot;time&quot;</span>)</span><br><span class="line">updateObj.setValue(eventModel.addr, forKey: <span class="string">&quot;addr&quot;</span>)</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">try</span> context<span class="operator">?</span>.save()</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">fetch</span>(<span class="params">id</span>: <span class="type">Int64</span>) -&gt; <span class="type">AnyObject</span>? &#123;</span><br><span class="line"><span class="keyword">let</span> request <span class="operator">=</span> <span class="type">NSFetchRequest</span>&lt;<span class="type">NSFetchRequestResult</span>&gt;(entityName: @<span class="string">&quot;MXWEvent&quot;</span>)</span><br><span class="line">request.predicate <span class="operator">=</span> <span class="type">NSPredicate</span>(format: <span class="string">&quot;id==<span class="subst">\(id)</span>&quot;</span>)</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">let</span> r <span class="operator">=</span> <span class="keyword">try</span> context<span class="operator">?</span>.fetch(request)</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> r <span class="keyword">as!</span> [<span class="type">NSManagedObject</span>] &#123;</span><br><span class="line"><span class="keyword">let</span> m <span class="operator">=</span> <span class="type">MXWEventModel</span>(id: data.value(forKey: <span class="string">&quot;id&quot;</span>) <span class="keyword">as!</span> <span class="type">Int64</span>, title: data.value(forKey: <span class="string">&quot;title&quot;</span>) <span class="keyword">as!</span> <span class="type">String</span>, detail: data.value(forKey: <span class="string">&quot;detail&quot;</span>) <span class="keyword">as!</span> <span class="type">String</span>, addr: data.value(forKey: <span class="string">&quot;addr&quot;</span>) <span class="keyword">as!</span> <span class="type">String</span>, time: data.value(forKey: <span class="string">&quot;time&quot;</span>) <span class="keyword">as!</span> <span class="type">Date</span>)</span><br><span class="line"><span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(error)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><p>在功能迭代过程中，难免会遇到要修改 <code>.xcdatamodeld</code> 文件。例如，新增或删除一个实体、增加或删除一个原有实体的属性等。如果开发者没有设置数据迁移，那更新后原有的数据将会被清空，所以此时需要进行数据的迁移操作。</p><p>Core Data 可以设置轻量级的数据迁移，系统会自动分析差异，进行映射，这种方式只适用于简单的增删实体或是增删属性等操作。除此之外还有一种相当复杂的自定义数据迁移。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - Core Data stack</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> persistentContainer: <span class="type">NSPersistentContainer</span> <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> container <span class="operator">=</span> <span class="type">NSPersistentContainer</span>(name: <span class="string">&quot;Demo&quot;</span>)</span><br><span class="line">    container.loadPersistentStores(completionHandler: &#123; storeDescription, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error <span class="keyword">as</span> <span class="type">NSError</span>? &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">&quot;Unresolved error <span class="subst">\(error)</span>, <span class="subst">\(error.userInfo)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置数据迁移（shouldMigrateStoreAutomatically 默认值为 true）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> sDescription: <span class="type">NSPersistentStoreDescription</span> <span class="operator">=</span> storeDescription <span class="keyword">as</span> <span class="type">NSPersistentStoreDescription</span> &#123;</span><br><span class="line">            sDescription.shouldMigrateStoreAutomatically <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">            sDescription.shouldInferMappingModelAutomatically <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> container</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>对于 Core Data，Apple 官方很久之前就已经推出，但是并不受开发者青睐。笔者在这段时间的学习过程中也在思考这个问题。</p><p>下面是笔者学习中遇到的注意点：</p><ol><li>Core Data 中没有自增数据类型。因为 Core Data 不能使用数据库思维去使用，所以也就很好解释了。</li><li>设置 context 的 merge 策略，减少数据迁移的麻烦。</li><li>最好使用多线程，可以进一步提升性能。</li></ol><p>最后，文章开头给出了性能比较。但是，笔者认为，在客户端并没有很大量的数据写入，只要开发者在使用过程中稍作注意，性能应该不是否决 Core Data 技术方案的理由。反倒，Core Data 对 iCloud 很好的支持，以及数据迁移备份，这些都可以很容易实现。笔者认为，完全可以考虑使用它做客户端的数据持久化方案。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/#//apple_ref/doc/uid/TP40001075-CH2-SW1">《Core Data Programming Guide》</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Core Data 是 iOS3.0 时引入的一个数据持久化的框架。与 sqlite 对比最大的优点莫过于支持对象的存储，苹果的官方文档说其简化了数据库的操作，使用 Core Data 确实可以大量减少代码中的 SQL 语句。&lt;/p&gt;
&lt;p&gt;可是现状，大家对于持久化的选择方案仍多数是 FMDB。笔者猜测，最大的原因可能就是性能。&lt;/p&gt;</summary>
    
    
    
    <category term="pieces" scheme="https://chars.tech/categories/pieces/"/>
    
    
    <category term="ios" scheme="https://chars.tech/tags/ios/"/>
    
    <category term="swift" scheme="https://chars.tech/tags/swift/"/>
    
    <category term="persistence" scheme="https://chars.tech/tags/persistence/"/>
    
    <category term="core data" scheme="https://chars.tech/tags/core-data/"/>
    
  </entry>
  
  <entry>
    <title>日本，我眼中的样子</title>
    <link href="https://chars.tech/2018-12-01-japan-life-experience/"/>
    <id>https://chars.tech/2018-12-01-japan-life-experience/</id>
    <published>2018-11-30T16:00:00.000Z</published>
    <updated>2022-12-05T09:38:10.475Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-1.JPG" alt="礁岸"></p><p>来到日本已经有一段时间了，为什么直到现在才开始想起来写一点感想呢。一是，时间不多。二是，之前体验不多。</p><p>这次来日本，抱着学习、求证的心态。身边的人问起，笔者的回答一向都是，过来“浪”了。因为不是有很具体的目的过来的。在大学毕业时，就因为一些原因，对这边有兴趣。而现在，有机会过来了。那么，就能好好验证之前自己的困惑了。</p><p>目前为止，最大的体会就是，日本绝对是个生活的好地方。</p><span id="more"></span><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-24.JPG" alt="居住区"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-23.JPG" alt="马路"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-22.JPG" alt="公园"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-21.JPG" alt="公园"></p><p>环境很不错，在大马路上走，都基本闻不到尾气。晨跑笔者是直接在马路边、公园里、居住区进行。</p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-25.JPG" alt="街道"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-4.JPG" alt="街道"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-20.JPG" alt="街道"></p><p>周末出去逛逛街，看看各种地方。</p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-5.JPG" alt="街道"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-10.JPG" alt="街道"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-6.JPG" alt="街道"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-15.JPG" alt="街道"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-18.JPG" alt="街道"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-16.JPG" alt="街道"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-19.JPG" alt="街道"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-3.JPG" alt="街道"></p><p>除了这些安静，空寂的街道。在人气比较旺的旅游区，也是大同小异。</p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-9.JPG" alt="街道"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-8.JPG" alt="街道"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-7.JPG" alt="街道"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-26.JPG" alt="街道"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-27.JPG" alt="街道"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-28.JPG" alt="街道"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-29.JPG" alt="街道"></p><p>这个红色的邮筒，超级有个性，很难得见到在发达国家还保持着一些比较原始的习惯，还包括看报纸。</p><p>久负盛名的团地。</p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-31.JPG" alt="团地"></p><p>至于吃的嘛，那就很随意了。</p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-30.JPG" alt="寿司"></p><p>当然，具有标志性的建筑，东京塔，也要来看看的。</p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-13.jpg" alt="东京塔"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-14.jpg" alt="东京塔"></p><p>最后，附上一些生活杂类拍照。</p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-12.JPG" alt="生活"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-11.JPG" alt="生活"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-16.JPG" alt="生活"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-17.JPG" alt="生活"></p><p><img src="/assets/images/life/japan-life-experience/japan-life-experience-2.JPG" alt="生活"></p><p>看了这么多，应该很多人都会想过来体验一把。客观来说，这边除了工作，其他都很好。为什么这么说呢？工作就涉及到了日本文化问题了，或许有很多人喜欢，但是对于我们这些受欧美影响较多的人来说，或许，当真的亲身体验时，可能又是另一番感受了吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/assets/images/life/japan-life-experience/japan-life-experience-1.JPG&quot; alt=&quot;礁岸&quot;&gt;&lt;/p&gt;
&lt;p&gt;来到日本已经有一段时间了，为什么直到现在才开始想起来写一点感想呢。一是，时间不多。二是，之前体验不多。&lt;/p&gt;
&lt;p&gt;这次来日本，抱着学习、求证的心态。身边的人问起，笔者的回答一向都是，过来“浪”了。因为不是有很具体的目的过来的。在大学毕业时，就因为一些原因，对这边有兴趣。而现在，有机会过来了。那么，就能好好验证之前自己的困惑了。&lt;/p&gt;
&lt;p&gt;目前为止，最大的体会就是，日本绝对是个生活的好地方。&lt;/p&gt;</summary>
    
    
    
    <category term="talk" scheme="https://chars.tech/categories/talk/"/>
    
    
    <category term="碎碎念" scheme="https://chars.tech/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Privacy Policy</title>
    <link href="https://chars.tech/2018-10-28-privacy-policy-en/"/>
    <id>https://chars.tech/2018-10-28-privacy-policy-en/</id>
    <published>2018-10-27T16:00:00.000Z</published>
    <updated>2020-01-17T16:43:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Privacy-Policy"><a href="#Privacy-Policy" class="headerlink" title="Privacy Policy"></a>Privacy Policy</h2><p>Effective date: October 28, 2018</p><p>Niffler (“us”, “we”, or “our”) operates the Niffler mobile application (the “Service”).</p><p>This page informs you of our policies regarding the collection, use, and disclosure of personal data when you use our Service and the choices you have associated with that data. Our Privacy Policy for Niffler is created with the help of the Free Privacy Policy Generator.</p><span id="more"></span><p>We use your data to provide and improve the Service. By using the Service, you agree to the collection and use of information in accordance with this policy. Unless otherwise defined in this Privacy Policy, terms used in this Privacy Policy have the same meanings as in our Terms and Conditions.</p><h3 id="Information-Collection-And-Use"><a href="#Information-Collection-And-Use" class="headerlink" title="Information Collection And Use"></a>Information Collection And Use</h3><p>We collect several different types of information for various purposes to provide and improve our Service to you.</p><h3 id="Types-of-Data-Collected"><a href="#Types-of-Data-Collected" class="headerlink" title="Types of Data Collected"></a>Types of Data Collected</h3><h4 id="Personal-Data"><a href="#Personal-Data" class="headerlink" title="Personal Data"></a>Personal Data</h4><p>While using our Service, we may ask you to provide us with certain personally identifiable information that can be used to contact or identify you (“Personal Data”). Personally identifiable information may include, but is not limited to:</p><ul><li>Cookies and Usage Data</li></ul><h4 id="Usage-Data"><a href="#Usage-Data" class="headerlink" title="Usage Data"></a>Usage Data</h4><p>When you access the Service by or through a mobile device, we may collect certain information automatically, including, but not limited to, the type of mobile device you use, your mobile device unique ID, the IP address of your mobile device, your mobile operating system, the type of mobile Internet browser you use, unique device identifiers and other diagnostic data (“Usage Data”).</p><h4 id="Tracking-amp-Cookies-Data"><a href="#Tracking-amp-Cookies-Data" class="headerlink" title="Tracking &amp; Cookies Data"></a>Tracking &amp; Cookies Data</h4><p>We use cookies and similar tracking technologies to track the activity on our Service and hold certain information.</p><p>Cookies are files with small amount of data which may include an anonymous unique identifier. Cookies are sent to your browser from a website and stored on your device. Tracking technologies also used are beacons, tags, and scripts to collect and track information and to improve and analyze our Service.</p><p>You can instruct your browser to refuse all cookies or to indicate when a cookie is being sent. However, if you do not accept cookies, you may not be able to use some portions of our Service.</p><h4 id="Examples-of-Cookies-we-use"><a href="#Examples-of-Cookies-we-use" class="headerlink" title="Examples of Cookies we use:"></a>Examples of Cookies we use:</h4><ul><li>Session Cookies. We use Session Cookies to operate our Service.</li><li>Preference Cookies. We use Preference Cookies to remember your preferences and various settings.</li><li>Security Cookies. We use Security Cookies for security purposes.</li></ul><h3 id="Use-of-Data"><a href="#Use-of-Data" class="headerlink" title="Use of Data"></a>Use of Data</h3><p>Niffler uses the collected data for various purposes:</p><ul><li>To provide and maintain the Service</li><li>To notify you about changes to our Service</li><li>To allow you to participate in interactive features of our Service when you choose to do so</li><li>To provide customer care and support</li><li>To provide analysis or valuable information so that we can improve the Service</li><li>To monitor the usage of the Service</li><li>To detect, prevent and address technical issues</li></ul><h3 id="Transfer-Of-Data"><a href="#Transfer-Of-Data" class="headerlink" title="Transfer Of Data"></a>Transfer Of Data</h3><p>Your information, including Personal Data, may be transferred to — and maintained on — computers located outside of your state, province, country or other governmental jurisdiction where the data protection laws may differ than those from your jurisdiction.</p><p>If you are located outside China and choose to provide information to us, please note that we transfer the data, including Personal Data, to China and process it there.</p><p>Your consent to this Privacy Policy followed by your submission of such information represents your agreement to that transfer.</p><p>Niffler will take all steps reasonably necessary to ensure that your data is treated securely and in accordance with this Privacy Policy and no transfer of your Personal Data will take place to an organization or a country unless there are adequate controls in place including the security of your data and other personal information.</p><h3 id="Disclosure-Of-Data"><a href="#Disclosure-Of-Data" class="headerlink" title="Disclosure Of Data"></a>Disclosure Of Data</h3><h4 id="Legal-Requirements"><a href="#Legal-Requirements" class="headerlink" title="Legal Requirements"></a>Legal Requirements</h4><p>Niffler may disclose your Personal Data in the good faith belief that such action is necessary to:</p><ul><li>To comply with a legal obligation</li><li>To protect and defend the rights or property of Niffler</li><li>To prevent or investigate possible wrongdoing in connection with the Service</li><li>To protect the personal safety of users of the Service or the public</li><li>To protect against legal liability</li></ul><h3 id="Security-Of-Data"><a href="#Security-Of-Data" class="headerlink" title="Security Of Data"></a>Security Of Data</h3><p>The security of your data is important to us, but remember that no method of transmission over the Internet, or method of electronic storage is 100% secure. While we strive to use commercially acceptable means to protect your Personal Data, we cannot guarantee its absolute security.</p><h3 id="Service-Providers"><a href="#Service-Providers" class="headerlink" title="Service Providers"></a>Service Providers</h3><p>We may employ third party companies and individuals to facilitate our Service (“Service Providers”), to provide the Service on our behalf, to perform Service-related services or to assist us in analyzing how our Service is used.</p><p>These third parties have access to your Personal Data only to perform these tasks on our behalf and are obligated not to disclose or use it for any other purpose.</p><h4 id="Analytics"><a href="#Analytics" class="headerlink" title="Analytics"></a>Analytics</h4><p>We may use third-party Service Providers to monitor and analyze the use of our Service.</p><ul><li>Firebase</li></ul><p>Firebase is analytics service provided by Google Inc.</p><p>You may opt-out of certain Firebase features through your mobile device settings, such as your device advertising settings or by following the instructions provided by Google in their <a href="https://policies.google.com/privacy?hl=en">Privacy Policy</a>.</p><p>We also encourage you to review the Google’s policy for safeguarding your data: <a href="https://support.google.com/analytics/answer/6004245">https://support.google.com/analytics/answer/6004245</a>. For more information on what type of information Firebase collects, please visit please visit the Google Privacy &amp; Terms <a href="https://policies.google.com/privacy?hl=en">web page</a>.</p><h3 id="Links-To-Other-Sites"><a href="#Links-To-Other-Sites" class="headerlink" title="Links To Other Sites"></a>Links To Other Sites</h3><p>Our Service may contain links to other sites that are not operated by us. If you click on a third party link, you will be directed to that third party’s site. We strongly advise you to review the Privacy Policy of every site you visit.</p><p>We have no control over and assume no responsibility for the content, privacy policies or practices of any third party sites or services.</p><h3 id="Children’s-Privacy"><a href="#Children’s-Privacy" class="headerlink" title="Children’s Privacy"></a>Children’s Privacy</h3><p>Our Service does not address anyone under the age of 18 (“Children”).</p><p>We do not knowingly collect personally identifiable information from anyone under the age of 18. If you are a parent or guardian and you are aware that your Children has provided us with Personal Data, please contact us. If we become aware that we have collected Personal Data from children without verification of parental consent, we take steps to remove that information from our servers.</p><h3 id="Changes-To-This-Privacy-Policy"><a href="#Changes-To-This-Privacy-Policy" class="headerlink" title="Changes To This Privacy Policy"></a>Changes To This Privacy Policy</h3><p>We may update our Privacy Policy from time to time. We will notify you of any changes by posting the new Privacy Policy on this page.</p><p>We will let you know via email and&#x2F;or a prominent notice on our Service, prior to the change becoming effective and update the “effective date” at the top of this Privacy Policy.</p><p>You are advised to review this Privacy Policy periodically for any changes. Changes to this Privacy Policy are effective when they are posted on this page.</p><h3 id="Contact-Us"><a href="#Contact-Us" class="headerlink" title="Contact Us"></a>Contact Us</h3><p>If you have any questions about this Privacy Policy, please contact us:</p><p>By email: <a href="mailto:&#x61;&#112;&#112;&#x5f;&#x73;&#x65;&#x76;&#64;&#49;&#x36;&#51;&#46;&#99;&#x6f;&#x6d;">&#x61;&#112;&#112;&#x5f;&#x73;&#x65;&#x76;&#64;&#49;&#x36;&#51;&#46;&#99;&#x6f;&#x6d;</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Privacy-Policy&quot;&gt;&lt;a href=&quot;#Privacy-Policy&quot; class=&quot;headerlink&quot; title=&quot;Privacy Policy&quot;&gt;&lt;/a&gt;Privacy Policy&lt;/h2&gt;&lt;p&gt;Effective date: October 28, 2018&lt;/p&gt;
&lt;p&gt;Niffler (“us”, “we”, or “our”) operates the Niffler mobile application (the “Service”).&lt;/p&gt;
&lt;p&gt;This page informs you of our policies regarding the collection, use, and disclosure of personal data when you use our Service and the choices you have associated with that data. Our Privacy Policy for Niffler is created with the help of the Free Privacy Policy Generator.&lt;/p&gt;</summary>
    
    
    
    <category term="project" scheme="https://chars.tech/categories/project/"/>
    
    
    <category term="Niffler" scheme="https://chars.tech/tags/Niffler/"/>
    
  </entry>
  
  <entry>
    <title>不是结束，只是开始</title>
    <link href="https://chars.tech/2018-09-14-just-begin-not-leave/"/>
    <id>https://chars.tech/2018-09-14-just-begin-not-leave/</id>
    <published>2018-09-13T16:00:00.000Z</published>
    <updated>2018-09-29T12:57:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天自己已经没有上班了，心里却是莫名的失落。没有开心与轻松，自己现在并不累。今天终于发现自己真的很恋旧。在 ZAKER 呆了 912 天，说来也不是很短了。本来以为自己可以继续呆下去，依旧可以做着一边工作一边兼顾自己的项目，在工作中迸发自己的 idea，然后付诸行动。</p><span id="more"></span><p>正如离开时对领导所说，自己是带着情怀来的，但是很可惜，要带着遗憾离开。</p><p>自己在很早就使用 ZAKER 来看新闻，当时来到广州，经过各种面试考验，如愿来到老东家。慢慢的想着要将它变得更好，或者是说自己能够为它的成长贡献力量。两年多下来，看着它慢慢迭代，和两年前比较，已经不是同一个产品啦，变化还是很大的。</p><p>最开始进来时，就被小组的团队氛围所触动。没错，我们是一个很年轻的团队，大家可以很自然的沟通，可以很放松，可以很时髦，但是我们也很努力。</p><p>两年多来，自己不断被影响，努力前行。从一个开发新手，到一个完全可以自己 hold 住需求的开发人员。自己的成长，也得到了肯定。期间经历团队同事的离开，经历引导人的离开，这些无不是一种心理磨练。特别是当面试自己的领导同事离开时，那种说出不的滋味。虽然明白天下无不散之宴席，但当自己真的面对时，还是需要心理建设的。苟富贵，勿相忘。江湖再见。这几句话我们会在散场的时候诉说的。或许若干年后，我们会真的体会它的深意。</p><p>最后，自己也不知道想要写什么，或许就是想留下一个印记吧。ZAKER 我曾经来过，ZAKER 我曾经为你激情付出。ZAKER 希望你越来越好！ </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天自己已经没有上班了，心里却是莫名的失落。没有开心与轻松，自己现在并不累。今天终于发现自己真的很恋旧。在 ZAKER 呆了 912 天，说来也不是很短了。本来以为自己可以继续呆下去，依旧可以做着一边工作一边兼顾自己的项目，在工作中迸发自己的 idea，然后付诸行动。&lt;/p&gt;</summary>
    
    
    
    <category term="talk" scheme="https://chars.tech/categories/talk/"/>
    
    
    <category term="碎碎念" scheme="https://chars.tech/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>如何通过浏览器上网</title>
    <link href="https://chars.tech/2018-08-10-how-to-surfing-via-browser/"/>
    <id>https://chars.tech/2018-08-10-how-to-surfing-via-browser/</id>
    <published>2018-08-09T16:00:00.000Z</published>
    <updated>2018-12-04T14:48:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>当我们在网页浏览器（Web browser）的地址栏中输入 URL 时，Web 页面是如何呈现的吗？</strong></p><p>Web 页面当然不能凭空显示出来。根据 Web 浏览器地址栏中指定的 URL，Web 浏览器从 Web 服务器端获取文件资源（resource）等信息，从而显示出 Web 页面。像这种通过发送请求获取服务器资源的 Web 浏览器等，都可称为客户端（client）。</p><p>Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器端等一系列运作流程。而协议是指规则的约定，可以说，Web 是建立在 HTTP 协议上通信的。</p><blockquote><p>超文本传输协议（HTTP，HyperText Transfer Protocol) 是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。1960 年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext），这成为了 HTTP 超文本传输协议标准架构的发展根基。Ted Nelson 组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的 RFC，其中著名的 RFC 2616 定义了 HTTP 1.1。</p></blockquote><span id="more"></span><h2 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h2><p>HTTP 的出生时间是 1989 年 3 月，那时候互联网还属于少数人。</p><p>CERN（欧洲核子研究组织）的蒂姆 • 伯纳斯 - 李（Tim BernersLee）博士提出了一种能让远隔两地的研究者们共享知识的设想。</p><p>最初设想的基本理念是：借助多文档之间相互关联形成的超文本（HyperText），连成可相互参阅的 WWW（World Wide Web，万维网）。</p><p>现在已提出了 3 项 WWW 构建技术，分别是：把 SGML（Standard Generalized Markup Language，标准通用标记语言）作为页面的文本标记语言的 HTML（HyperText Markup Language，超文本标记语言）；作为文档传递协议的 HTTP ；指定文档所在地址的 URL（Uniform Resource Locator，统一资源定位符）。</p><p>WWW 这一名称，是 Web 浏览器当年用来浏览超文本的客户端应用程序时的名称。现在则用来表示这一系列的集合，也可简称为 Web。 </p><p>1990 年 11 月，CERN 成功研发了世界上第一台 Web 服务器和 Web 浏览器。</p><h2 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h2><h3 id="HTTP-x2F-0-9"><a href="#HTTP-x2F-0-9" class="headerlink" title="HTTP&#x2F;0.9"></a>HTTP&#x2F;0.9</h3><p>HTTP 于 1990 年问世。那时的 HTTP 并没有作为正式的标准被建立。现在的 HTTP 其实含有 HTTP1.0 之前版本的意思，因此被称为 HTTP&#x2F;0.9。</p><h3 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><p>HTTP 正式作为标准被公布是在 1996 年的 5 月，版本被命名为 HTTP&#x2F;1.0，并记载于 <a href="http://www.ietf.org/rfc/rfc1945.txt">RFC1945</a>。虽说是初期标准，但该协议标准至今仍被广泛使用在服务器端。 </p><h3 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h3><p>1997 年 1 月公布的 HTTP&#x2F;1.1 是目前主流的 HTTP 协议版本。当初的标准是 RFC2068，之后发布的修订版 <a href="http://www.ietf.org/rfc/rfc2616.txt">RFC2616</a> 就是当前的最新版本。 </p><h2 id="TCP-x2F-IP-简介"><a href="#TCP-x2F-IP-简介" class="headerlink" title="TCP&#x2F;IP 简介"></a>TCP&#x2F;IP 简介</h2><p>为了理解 HTTP，我们有必要事先了解一下 TCP&#x2F;IP 协议族。通常使用的网络（包括互联网）是在 TCP&#x2F;IP 协议族的基础上运作的。而 HTTP 属于它内部的一个子集。</p><p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。 </p><p><img src="/assets/images/tech/how-to-surfing-via-browser-TCP-IP-Protocol.png" alt="TCP/IP 协议族"></p><h3 id="分层管理"><a href="#分层管理" class="headerlink" title="分层管理"></a>分层管理</h3><p>TCP&#x2F;IP 协议族里重要的一点就是分层。TCP&#x2F;IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。</p><p><strong>分层的好处：</strong>若某个地方需要改变设计时，不需要把所有部分整体替换掉，只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层决定了向用户提供应用服务时通信的活动。</p><p>TCP&#x2F;IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）。HTTP 协议也处于该层。</p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>传输层为应用层，提供处于网络连接中的两台计算机之间的数据传输。</p><p>在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。</p><p>TCP 提供可靠的字节流服务。所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。简单来说，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。而为了准确无误地将数据传输到目标，TCP 采用了三次握手策略。</p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。</p><p>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。</p><h5 id="负责传输的-IP-协议"><a href="#负责传输的-IP-协议" class="headerlink" title="负责传输的 IP 协议"></a>负责传输的 IP 协议</h5><p>IP（Internet Protocol）网际协议位于网络层。需要注意的是可“IP”和“IP 地址”的区别，“IP”其实是一种协议的名称。 </p><p>IP 协议的作用是把各种数据包传送给对方。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。</p><p>IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。基本上各大网卡制作厂商都被预制分配了 MAC 地址区间段。</p><p>IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。</p><p>在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线。这种机制称为路由选择（routing）。 </p><p><img src="/assets/images/tech/how-to-surfing-via-browser-routing.png" alt="路由选择"></p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。</p><p>硬件上的范畴均在链路层的作用范围之内。</p><p>在数据链路层还有一个常见的网络协议 LLDP。了解更多可以查看<a href="/blog/data-link-layer-lldp">《数据链路层之 LLDP》</a>。</p><h3 id="通信传输流"><a href="#通信传输流" class="headerlink" title="通信传输流"></a>通信传输流</h3><p><img src="/assets/images/tech/how-to-surfing-via-browser-stram.png" alt="TCP/IP 通信传输流"></p><p>为了更好的理解上图，我们使用 HTTP 🌰 说明。</p><p><img src="/assets/images/tech/how-to-surfing-via-browser-HTTP-transport.png" alt="HTTP 通信"></p><ol><li><p>作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。</p></li><li><p>在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</p></li><li><p>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。</p></li><li><p>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。</p></li></ol><p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法称为封装（encapsulate）。</p><h2 id="DNS-简述"><a href="#DNS-简述" class="headerlink" title="DNS 简述"></a>DNS 简述</h2><p>DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。</p><p>计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。🌰 <a href="http://www.chars.tech/">www.chars.tech</a>。</p><p>用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。</p><p>但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。</p><p><img src="/assets/images/tech/how-to-surfing-via-browser-DNS.jpg" alt="DNS 服务"></p><h2 id="访问网站"><a href="#访问网站" class="headerlink" title="访问网站"></a>访问网站</h2><p>至此，大致可以回答开篇的问题了，我们在浏览器输入框中输入想浏览的网页地址之后，发生了哪些事情呢？</p><p><img src="/assets/images/tech/how-to-surfing-via-browser-Step.jpg" alt="HTTP 浏览网页"></p><ol><li>客户端发起页面网址请求给 DNS。</li><li>DNS 解析出对应 IP 地址返回给客户端。</li><li>客户端填充请求 IP 地址。</li><li>客户端根据 HTTP 交互封装请求数据包。</li><li>请求数据包经过路由机制到达目的地址。</li><li>目的地址服务器返回数据给客户端。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;当我们在网页浏览器（Web browser）的地址栏中输入 URL 时，Web 页面是如何呈现的吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Web 页面当然不能凭空显示出来。根据 Web 浏览器地址栏中指定的 URL，Web 浏览器从 Web 服务器端获取文件资源（resource）等信息，从而显示出 Web 页面。像这种通过发送请求获取服务器资源的 Web 浏览器等，都可称为客户端（client）。&lt;/p&gt;
&lt;p&gt;Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器端等一系列运作流程。而协议是指规则的约定，可以说，Web 是建立在 HTTP 协议上通信的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;超文本传输协议（HTTP，HyperText Transfer Protocol) 是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。1960 年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext），这成为了 HTTP 超文本传输协议标准架构的发展根基。Ted Nelson 组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的 RFC，其中著名的 RFC 2616 定义了 HTTP 1.1。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="web" scheme="https://chars.tech/categories/web/"/>
    
    
    <category term="网络" scheme="https://chars.tech/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>云南，一片上天眷顾的土地</title>
    <link href="https://chars.tech/2018-08-09-yunnan-travel-notes/"/>
    <id>https://chars.tech/2018-08-09-yunnan-travel-notes/</id>
    <published>2018-08-08T16:00:00.000Z</published>
    <updated>2018-12-01T09:49:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-12.jpg" alt="丽江古城"></p><p>距离从云南回来已经好些天了。但，脑海中还会时常回忆起那里的景色。或许对于一些人来说，那些也是很通常的环境。旅行，不就是不同环境生活的人，暂时交换体验吗？这次的旅行，发现自己变化很大，从心性上来说，应该成熟些了吧。对于这次的旅行，还是想能够记下来，毕竟对于我来说，是一份很珍贵的记忆。</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-1.jpg" alt="泸沽湖畔蒲公英"></p><span id="more"></span><p>云南（不对，应该还包括四川。因为这次出行，已经各种跨省跨境的游玩了）不仅是个景色优美的地方，而且美食也是很重要的角色。相信我辈吃货们很关注那里有什么好吃的吧。这里首先来推荐几款一定要尝尝的美食吧。</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-8.jpg" alt="四川麻辣面"></p><p>这是当时在扎窝洛码头住民宿时老板做的。看着很辣，一向清淡饮食的我被吓着了，试着吃了一口之后，完全停不下来，不仅不辣，还香气扑鼻。好吃！爽！</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-38.jpg" alt="黄李子"></p><p>这种黄李子只能在丽江买到，可能是特色水果吧。最棒的吃法是，使用当地泉水或井水，洗干净吃。不要问为什么，你自己去了尝试一下就明白了。至于是不是叫黄李子，这个就很难说了，一路上问了不少人。感觉没有一个是认真回答这个问题的，都随便叫一个名字。哈哈哈，这个“随便”的用法也是和当地人学的。</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-15.jpg" alt="相思草"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-11.jpg" alt="水性杨花"></p><p>以上这两种菜是在大理洱海畔的双廊一家餐馆吃的，味道嘛，和吃一般蔬菜一样，只不过名字比较有意思。</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-22.jpg" alt="炸昆虫"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-35.jpg" alt="棱角"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-36.jpg" alt="折洱根"></p><p>以上三样都是在大理古城逛吃发现的。</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-40.jpg" alt="云南米线"></p><p>到了云南，肯定不能不吃云南米线。不过，有点分不清这个和米粉有什么区别啦。</p><p>当然，吃的东西不仅仅如此，只不过这些都是比较有意思的。</p><p>除了吃，当然就是玩啦。</p><p>第一天早上来到丽江，因为太早。从火车站，直接坐18路公交进入市区，18路，记得郴州火车站的公交也是18路。好巧呀。</p><p>车子可以直接到达丽江古城的忠义市场，以前需要的古城维修费，现在也不需要啦。下车之后找个地方吃了碗当地的云南米线，物价也不是很贵。加下来，绕着古城，找到南门，然后进去逛一逛。清晨空气很棒，古城里的公园很多运动的爷爷奶奶。还看到一对夫妻，前一天晚上就在他们的SUV中度过的，居然还带着宠物狗出门。真的很惬意呀！把行李寄存在客栈之后，就直接去丽江古城逛吃咯。</p><p>丽江古城由束河古镇、大研古城、白沙古镇组成。最方便、最热闹的是大研古城，也就是人们常说的丽江古城。这里商业气息比较重，有很多小吃和店铺，人流量也是比较大的。虽然束河古城比较清净，但相应的是交通不怎么方便。因为客栈距离丽江古城东门，所以吃住还是很方便的。古城不是封闭的，你可以从任何你喜欢的地方进入。</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-18.jpg" alt="丽江古城"></p><p>这是在狮子山附近看到的古城全貌。真的很幸运，前一天这里还在下雨，到的这一天却赶上放晴。</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-21.jpg" alt="丽江古城"></p><p>“大水车”不仅是古城的一个景点，它旁边也是古城北门。这附近有去泸沽湖的汽车，也有去其他景点的车。</p><p>之前也去过乌镇，这种旧时建筑，可能风格都差不多，美不美，在于你！</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-9.jpg" alt="丽江古城"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-34.jpg" alt="丽江古城"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-10.jpg" alt="丽江古城"></p><p>走累了，坐在这石桥上吃黄李子，桥木有拍，当然看不见啦。</p><p>逛吃饱了之后，买了两件纳西族的衣服，准备期间穿起来。走出古城，办理好入住。准备出发去“拉市海”。拉市海边的花田和草地，让人眼前一亮，很久不见了。</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-23.jpg" alt="拉市海"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-19.jpg" alt="拉市海"></p><p>租条皮划艇，自己划着。心之所往，片刻即至。</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-28.jpg" alt="拉市海"></p><p>划了半天皮划艇，晚上都不想出门啦，在客栈收拾好，准备次日的行程–玉龙雪山。没错，奔着4680去的。</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-14.jpg" alt="玉龙雪山"></p><p>不能不说是遗憾，这个也不由想起大四时候，和室友去爬华山，想看日出。然后那天大雾！这个玉龙雪山是准备了一天的时间，所以除了登4680，还有蓝月谷可以玩。</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-33.jpg" alt="蓝月谷"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-2.jpg" alt="蓝月谷"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-39.jpg" alt="蓝月谷"></p><p>下午5:30准时下山返程，回到客栈。次日，就要去泸沽湖啦。</p><p>泸沽湖三分之一在云南 ，三分之二在四川，由湖泊和万亩草海组成。云南、 四川两省都可以进入。</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-17.jpg" alt="泸沽湖"></p><p>先来一个全景，不错，这个就是一个未被污染的天然水域。迎面出来凉凉的风，好久没有这样的感觉啦。</p><p>在泸沽湖，是住在四川境内的扎窝洛码头【老知青之家】民宿，这里是摩梭族人聚居区。在这里，体验当地人生活。</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-37.jpg" alt="草海"></p><p>来看看漂亮的民宿。</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-20.jpg" alt="草海"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-5.jpg" alt="草海"></p><p>老板有两个和我一般年纪的儿子，下午刚好跟着一起去了【摩梭博物馆】</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-32.jpg" alt="草海"></p><p>这个是“莫言”题字的哟！不清楚是在获奖前还是后啦。</p><p>晚上还去看了当地的篝火晚会！</p><p>次日，和两个小老板一起环湖游啦，因为景区现在已经禁止骑行啦，少了一大乐趣！</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-13.jpg" alt="泸沽湖"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-31.jpg" alt="泸沽湖"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-6.jpg" alt="泸沽湖"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-16.jpg" alt="泸沽湖"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-7.jpg" alt="泸沽湖"></p><p>看见水面上的水性杨花了吗？那个就是可以吃的！</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-27.jpg" alt="草海"></p><p>这两天在泸沽湖呆得都不想离开啦。</p><p>次日，来到大理古城。</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-3.jpg" alt="大理古城"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-24.jpg" alt="大理古城"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-26.jpg" alt="大理古城"></p><p>晚上逛吃，休息好。因为～</p><p>次日清晨起来，在古城里逛悠个早餐，租了个小电驴，开启洱海环行！</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-4.jpg" alt="崇圣寺三塔"></p><p>先来到崇圣寺三塔，不错，就是那个明信片经常出现的地方！</p><p>中午到双廊吃午餐，继续一路向前，出发。</p><p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-29.jpg" alt="大理洱海"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-25.jpg" alt="大理洱海"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-30.jpg" alt="大理洱海"></p><p>晚上回到客栈，都不敢想象，今天环洱海有150公里。到了这个时候，旅行进度条也要撑不住啦。不久就要返程啦。</p><p>最后一天还是在大理，不过没有具体目标，早上多睡了一会，然后出门觅食。最后在洱海公园好好逛了逛。</p><p>这次旅行，真的很放松。这期间，可以不管手机上的信息，不用理会各种事物。在那里，都是使用现金，离开网络，离开忙碌的世界。</p><p>社会在快速发展，人到底是变得更幸福快乐了吗？</p><p>回来之后，又要开启自己的学习节奏，既然走了这条路，就要坚持下去。现在已经开设了知乎专栏<a href="https://zhuanlan.zhihu.com/easy-to-understand-algorithm">《通俗易懂的算法》</a>、<a href="https://zhuanlan.zhihu.com/health-go">《如何独立开发一个完整应用》</a>，有兴趣的童鞋欢迎关注和推荐给他人。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-12.jpg&quot; alt=&quot;丽江古城&quot;&gt;&lt;/p&gt;
&lt;p&gt;距离从云南回来已经好些天了。但，脑海中还会时常回忆起那里的景色。或许对于一些人来说，那些也是很通常的环境。旅行，不就是不同环境生活的人，暂时交换体验吗？这次的旅行，发现自己变化很大，从心性上来说，应该成熟些了吧。对于这次的旅行，还是想能够记下来，毕竟对于我来说，是一份很珍贵的记忆。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-1.jpg&quot; alt=&quot;泸沽湖畔蒲公英&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="talk" scheme="https://chars.tech/categories/talk/"/>
    
    
    <category term="碎碎念" scheme="https://chars.tech/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>什么是大 O 表示法</title>
    <link href="https://chars.tech/2018-08-05-big-o-notation/"/>
    <id>https://chars.tech/2018-08-05-big-o-notation/</id>
    <published>2018-08-04T16:00:00.000Z</published>
    <updated>2019-10-08T16:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>“大O表示法”是一种特殊的表示法，指出了算法的速度有多快。但是它却不是指具体的时间，那么该如何正确理解它呢？</p><span id="more"></span><h2 id="算法的运行时间以不同的速度增加"><a href="#算法的运行时间以不同的速度增加" class="headerlink" title="算法的运行时间以不同的速度增加"></a>算法的运行时间以不同的速度增加</h2><p>“算法的运行时间以不同的速度增加”这句话应该如何理解呢？下面我们通过🌰来看看这句话到底想表达什么。</p><p>小明现在需要编写一个查找算法，这个算法服务于学校图书馆，目的是帮助童鞋们能够快速的找到自己需要的书籍所在位置。</p><p>假设小明现在只会“二分查找”和“简单查找”。一方面，二分查找的速度很快，小明必须在 10 秒钟内找到书籍所在位置，否则童鞋们没有更多耐心等待。另一方面，简单查找算法编写起来更容易，因此出现 bug 的可能性更小。</p><p>为了检验这两种算法的耗时，小明决定计算两种算法在列表包含 100 个元素的情况下需要的时间。</p><p>假设检查一个元素需要 1 毫秒。使用简单查找时，小明必须检查 100 个元素，因此需要 100 毫秒才能查找完毕。而使用二分查找时，只需检查 7 个元素（log2 100大约为7），因此需要 7 毫秒就能查找完毕。然而，实际要查找的列表可能包含 10 亿个元素，在这种情况下，简单查找需要多长时间呢？二分查找又需要多长时间呢？</p><p>小明使用包含 10 亿个元素的列表运行二分查找，运行时间为 30 毫秒（log2 1 000 000 000大约为30）。他心里想，二分查找的速度大约为简单查找的 15 倍，因为列表包含 100 个元素时，简单查找需要 100 毫秒，而二分查找需要 7 毫秒。因此，列表包含 10 亿个元素时，简单查找需要 30 × 15 &#x3D; 450 毫秒，完全符合在 10 秒内查找完毕的要求。小明决定使用简单查找。这是正确的选择吗？</p><p>不是。实际上，小明错了，而且错得离谱。列表包含 10 亿个元素时，简单查找需要 10 亿毫秒，相当于 11 天！为什么会这样呢？因为二分查找和简单查找的运行时间的增速不同。</p><table><thead><tr><th>简单查找</th><th>二分查找</th><th>元素个数</th></tr></thead><tbody><tr><td>100 毫秒</td><td>7 毫秒</td><td>100</td></tr><tr><td>10 秒</td><td>14 毫秒</td><td>10 000</td></tr><tr><td>11 天</td><td>30 毫秒</td><td>1 000 000 000</td></tr></tbody></table><p>随着元素数量的增加，二分查找需要的额外时间并不多，而简单查找需要的额外时间却很多。因此，随着列表的增长，二分查找的速度比简单查找快得多。小明以为二分查找速度为简单查找的 15 倍，这不对：列表包含 10 亿个元素时，为 3300 万倍。有鉴于此，仅知道算法需要多长时间才能运行完毕还不够，还需知道运行时间如何随列表增长而增加。这正是大O表示法的用武之地。</p><p>大O表示法指出了算法有多快。例如，假设列表包含 n 个元素。简单查找需要检查每个元素，因此需要执行 n 次操作。使用大O表示法，这个运行时间为 O(n)。单位秒呢？没有！大O表示法指的并非以秒为单位的速度。大O表示法让你能够比较操作数，它指出了算法运行时间的增速。</p><h2 id="最糟糕情况下的运行时间"><a href="#最糟糕情况下的运行时间" class="headerlink" title="最糟糕情况下的运行时间"></a>最糟糕情况下的运行时间</h2><p>假设你使用简单查找在电话簿中找人。你知道，简单查找的运行时间为 O(n)，这意味着在最糟情况下，必须查看电话簿中的每个条目。如果要查找的是 Chars ——电话簿中的第一个人，一次就能找到，无需查看每个条目。考虑到一次就找到了 Chars，请问这种算法的运行时间是 O(n)还是 O(1) 呢？</p><p>简单查找的运行时间总是为 O(n)。查找 Chars 时，一次就找到了，这是最佳的情形，但大O表示法说的是最糟的情形。因此，你可以说，在最糟情况下，必须查看电话簿中的每个条目，对应的运行时间为 O(n)。这是一个保证——你知道简单查找的运行时间不可能超过 O(n)。</p><blockquote><p>说明</p><p>除最糟情况下的运行时间外，还应考虑平均情况的运行时间，这很重要。最糟情况和平均情况将在第4章讨论。</p></blockquote><h2 id="一些常见的大O运行时间"><a href="#一些常见的大O运行时间" class="headerlink" title="一些常见的大O运行时间"></a>一些常见的大O运行时间</h2><p>下面按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。</p><ul><li>O (log n )，也叫对数时间 ，这样的算法包括二分查找。</li><li>O (n )，也叫线性时间 ，这样的算法包括简单查找。</li><li>O (n * log n )，这样的算法包括快速排序——一种速度较快的排序算法。</li><li>O (n 2 )，这样的算法包括选择排序——一种速度较慢的排序算法。</li><li>O (n !)，这样的算法包括旅行商问题的解决方案——一种非常慢的算法。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、算法的速度指的并非时间，而是操作数的增速。</p><p>2、谈论算法的速度时，说的是随着输入的增加，其运行时间将以什么样的速度增加。</p><p>3、算法的运行时间用大O表示法表示。</p><p>4、O(log n) 比 O(n)快，当需要搜索的元素越多时，前者比后者快得越多。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>对算法有兴趣的童鞋可以关注专栏<a href="https://zhuanlan.zhihu.com/easy-to-understand-algorithm">《通俗易懂的算法》</a>，也欢迎大家多多投稿分享。</p><p>同时欢迎大家加入移动开发交流Q群交流讨论，Q群号：811237468</p><p><img src="/assets/images/Q811237468.jpg" alt="Q811237468"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;“大O表示法”是一种特殊的表示法，指出了算法的速度有多快。但是它却不是指具体的时间，那么该如何正确理解它呢？&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="https://chars.tech/categories/algorithm/"/>
    
    
    <category term="概念" scheme="https://chars.tech/tags/%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层之 LLDP</title>
    <link href="https://chars.tech/2018-01-29-data-link-layer-lldp/"/>
    <id>https://chars.tech/2018-01-29-data-link-layer-lldp/</id>
    <published>2018-08-03T05:05:27.000Z</published>
    <updated>2018-12-06T14:14:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着网络技术的发展，接入网络的设备的种类越来越多，配置越来越复杂，来自不同设备厂商的设备也往往会增加自己特有的功能，这就导致在一个网络中往往会有很多具有不同特性的、来自不同厂商的设备，为了方便对这样的网络进行管理，就需要使得不同厂商的设备能够在网络中相互发现并交互各自的系统及配置信息。 </p><p>LLDP（Link Layer Discovery Protocol，链路层发现协议）就是用于这个目的的协议。LLDP 定义在 802.1ab 中，它是一个二层协议，它提供了一种标准的链路层发现方式。LLDP 协议使得接入网络的一台设备可以将其主要的<strong>能力，管理地址，设备标识，接口标识</strong>等信息发送给接入同一个局域网络的其它设备。当一个设备从网络中接收到其它设备的这些信息时，它就将这些信息以MIB的形式存储起来。</p><p>这些 MIB 信息可用于发现设备的物理拓扑结构以及管理配置信息。需要注意的是 LLDP 仅仅被设计用于进行信息通告，它被用于通告一个设备的信息并可以获得其它设备的信息，进而得到相关的 MIB 信息。它不是一个配置、控制协议，无法通过该协议对远端设备进行配置，<strong>它只是提供了关于网络拓扑以及管理配置的信息，这些信息可以被用于管理、配置的目的，如何用取决于信息的使用者。</strong></p><span id="more"></span><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>LLDP 的框架结构如图所示</p><p><img src="/assets/images/tech/data-link-layer-lldp-struct.png" alt="LLDP 结构图"></p><p>此图也表明 LLDP 就是一个信息发现与通告协议，LLDP 的实体主要维护了两个 MIB 库，一个 local system MIB，一个 remote system MIB。从其名字也可以看出，一个用于维护本地相关的设备 MIB 信息，一个用于维护远端设备 MIB 信息。</p><p>LLDP 通过与上图中右侧的几个 MIB 库交互来初始化并维护 local system MIB，并将本地的相关信息通告出去；同时当接收到来自其它设备的信息时就将其更新到remote system MIB 中。通过这种工作方式，一个设备就可以将自己的信息通告出去并获得网络中其它设备的相关信息，最终获得反应网络拓扑以及其它配置信息的两个 MIB 库。这两个库可以被其用户用来完成各种功能。需要说明的是<strong>LLDP 信息的通告以及接收处理不受端口的STP状态的影响。</strong></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><p>封装有 LLDPDU 的报文称为 LLDP 帧，其封装格式有两种：Ethernet II 和 SNAP（Subnetwork Access Protocol，子网访问协议）。</p><h4 id="Ethernet-II-格式封装的-LLDP-帧"><a href="#Ethernet-II-格式封装的-LLDP-帧" class="headerlink" title="Ethernet II 格式封装的 LLDP 帧"></a>Ethernet II 格式封装的 LLDP 帧</h4><p><img src="/assets/images/tech/data-link-layer-lldp-ethernet-ii-frame.png" alt="Ethernet II 格式封装的 LLDP 帧"></p><p>上图是以 Ethernet II 格式封装的 LLDP 帧，其中各字段的含义如下： </p><ul><li>DA：目的 MAC 地址，为固定的组播 MAC 地址 0x0180-C200-000E。 </li><li>SA：源 MAC 地址，为端口 MAC 地址或设备 MAC 地址（如有端口地址则用端口 MAC 地址，否则用设备 MAC 地址）。 指与设备相邻连接设备的桥 MAC。</li><li>LLDP Ethertype：帧类型，为 0x88CC。 </li><li>LLDPDU：LLDP Data Unit，LLDP 数据单元，它是 LLDP 信息交换的主体。</li><li>FCS：帧检验序列。</li></ul><h4 id="SNAP-格式封装的-LLDP-帧"><a href="#SNAP-格式封装的-LLDP-帧" class="headerlink" title="SNAP 格式封装的 LLDP 帧"></a>SNAP 格式封装的 LLDP 帧</h4><p><img src="/assets/images/tech/data-link-layer-lldp-snap-frame.png" alt="SNAP 格式封装的 LLDP 帧"></p><p>上图是以 SNAP 格式封装的 LLDP 帧，其中各字段的含义如下：</p><ul><li>DA：目的 MAC 地址，为固定的组播 MAC 地址 01-80-C2-00-00-0E。 </li><li>SA：源 MAC 地址，为端口 MAC 地址或设备 MAC 地址（如有端口地址则用端口 MAC 地址，否则用设备 MAC 地址）。 </li><li>Type：帧类型，为 0xAAAA-0300-0000-88CC。 </li><li>Data：数据，为 LLDPDU。 </li><li>FCS：帧检验序列。</li></ul><h4 id="目的地址"><a href="#目的地址" class="headerlink" title="目的地址"></a>目的地址</h4><p>目的地址实际上包括三个，分别为 01-80-C2-00-00-0E，01-80-C2-00-00-03，01-80-C2-00-00-00。这三个地址分别用于不同的目的，它们可以跨越不同的网络。</p><ul><li>01-80-C2-00-00-0E，也被称为 Nearest Bridge 组地址：无论是 Two-Port MAC Relay (TPMR)组件、S-VLAN 组件、C-VLAN 组件，还是 802.1D 网桥都不能转发目的为该地址的帧。简单的说任何类型的网桥都不能转发目的为该地址的帧，目的为该地址的帧被限制在连接两个网桥接口的连接上传输。</li><li>01-80-C2-00-00-03，也被称为 Nearest non-TPMR Bridge 组地址：对于目的地址为该地址的帧，Two-Port MAC Relay (TPMR)组件将成为一个中继器，即不接收它。而 S-VLAN（Service Provider VLAN）组件，C-VLAN（Customer VLAN）组件，以及 802.1D 网桥都不能转发它，而是需要进行接收并处理。因此目的地址为该地址的帧将跨越 TPMR。</li><li>01-80-C2-00-00-00，也被称为 Nearest Customer Bridge 组地址：对于目的地址为该地址的帧，Two-Port MAC Relay (TPMR)组件以及 S-VLAN 组件将成为中继器，即不接收它。而 C-VLAN 组件，以及 802.1D 网桥都不能转发它，而是需要进行接收并处理。因此目的地址为该地址的帧将跨越 TPMR 以及 S-VLAN。</li></ul><h3 id="TPMR-介绍"><a href="#TPMR-介绍" class="headerlink" title="TPMR 介绍"></a>TPMR 介绍</h3><p>TPMR 以及 S-VLAN，C-VLAN 都是 802.1Q 中的概念，包括这三者的网络以及各个地址的作用范围如下图所示</p><p><img src="/assets/images/tech/data-link-layer-lldp-mac-addr.png" alt="MAC Addr"></p><p><img src="/assets/images/tech/data-link-layer-lldp-group-mac-addr.png" alt="Group MAC Addr"></p><p><img src="/assets/images/tech/data-link-layer-lldp-diff-os-mac-addr.png" alt="OS MAC Addr"></p><ul><li>C-VLAN：Customer VLAN，是用户网络内部使用的 VLAN；</li><li>S-VLAN：Service VLAN，服务提供商网络中使用的 VLAN，该 VLAN 标识 VPN 用户或者是用户的业务；</li><li>Customer Bridge: Customer 网络中的 Bridge，只能识别 C-VLAN；</li><li>Provider Bridge：服务提供商网络中的 Bridge，根据处理内容的不同又分为S-VLAN Bridge 和 Provider Edge Bridge。其中 S-VLAN Bridge 只能识别 S-VLAN； Provider Edge Bridge 可以同时识别 C-VLAN 和 S-VLAN；</li><li>C-VLAN Component：在 Bridge 内可识别、插入、删除 C-VLAN 的实体，每个端口一个，对 C-VLAN 的操作互相独立（两个端口上接收到相同的 C-VLAN，但由于属于不同的客户最后的处理结果会不同）；</li><li>S-VLAN Component：在 Bridge 内可识别、插入、删除 S-VLAN 的实体，由于在一个 Bridge 内不存在相同的 S-VLAN 属于不同服务提供商的情况，因此在一个桥内只有一个 S-VLAN 的实体。</li></ul><h3 id="QinQ-介绍"><a href="#QinQ-介绍" class="headerlink" title="QinQ 介绍"></a>QinQ 介绍</h3><p>QinQ 的理论基础，是 IEEE 定义的 802.1ad。在这个规范里面，IEEE 提出了一个概念，它认为汇聚和接入层那里有这么两种设备：S-VLAN Bridge 和 Provider Edge Bridge，再往下就是 Customer System 了（注意，这里说 System 而不是 Bridge，是因为 Customer 接进来的未必是二层设备，可能也是三层设备）。VLAN 空间也被分成两个 VLAN 空间，即 S-VLAN 和 C-VLAN，S 即 Service Provider，C 即 Customer。在 S-VLAN Bridge 上，只有 S-VLAN 空间，而在 Provider Edge Bridge 上，则既有 S-VLAN 空间，又有 C-VLAN 空间。相应的，这个 Bridge 就被从逻辑上划分为两部分，支持 S-VLAN 功能的部分称之为 S-VLAN Component，支持 C-VLAN 功能的部分称之为 C-VLAN Component。S-VLAN Bridge 只包含 S-VLAN Component。</p><p>除了两种 Bridge 的概念，802.1ad 还提出了三种 Service 类型和四种 Port 类型，其中一种 Port 是内部 Port，对用户不可见，其它三种 Port 分别对应了三种不同的 Service，即运营商可以通过在交换机上配置三种不同的 Port 类型，来相应的为用户提供三种不同类型的 Service。三种 Service 分别是 Port Based Service，C-Tag Based Service 和 S-Tag Based Service。四种Port 分别是 Customer Network Port （CN）， Customer Edge Port（CE），Provider Network Port（PN），Provider Edge Port（内部 Port）。</p><p>所谓 Port Based Service，就是说某个 Service 是基于 Port 的，从该 Port 进来的所有报文，都被认为是属于某一个特定的 Customer 的，不管它是否带 C-Tag，带了什么样的 C-Tag，这些信息统统被忽视。所有从这个 Port 进来的报文被赋予一个 S-VLAN，该 S-VLAN 被用来标识该 Customer，或说该 Service。提供这种 Service 的 Port 就是CN Port。CN Port 的实质就是运营商为一个 Customer 提供一个专门的 Port，不跟别的 Customer 共享。注意，从这个 Port 上进来的报文不能带 S-Tag，否则会被丢弃。也就是说，对于 S-Tag 而言，这个 Port 是 Access Port，而不是 Trunk Port。这是跟后面的 S-Tag Based service 本质的不同。</p><p><img src="/assets/images/tech/data-link-layer-lldp-port-based-pbn.png" alt="Port Base PBN"></p><p>所谓的 S-Tag Based Service，就是说从一个 Port 上进来的报文，根据 S-VLAN 来把它们划分到不同的 Customer，换句话说，是用 S-VLAN 来标记 Customer。提供这种 Service 的 Port 也是 CN Port，只不过这个时候的 CN Port，必须配置成 Trunk Port，只识别 S-VLAN，根据 S-VLAN 来标识 Customer，转发报文。</p><p><img src="/assets/images/tech/data-link-layer-lldp-port-based-pbn-struct.png" alt="PBN Struct"></p><p>所谓的 C-Tag Based Service，就是指报文携带 C-Tag 进入 Port，在该 Port 上基于 C-VLAN 来标识 Customer，一个 Port 上可以支持多个 Customer。用来支持 C-Tag Based Service 的 Port 就是 CE Port，CE Port 是 C-VLAN Component 的一部分，对于 C-VLAN 而言，CE Port 是 Trunk Port。它不识别 S-Tag。</p><p>PN Port 是 S-VLAN Component 的一部分，它跟 CN Port 唯一的不同是 CN Port 面向 Customer Network，而它面向 Provider Network，在实际的交换机中通常被配置成 Uplink Port，而且通常都是 VLAN Trunk Mode（相对于 Access Mode）。</p><p>对于一个拥有 S-VLAN Component 和 C-VLAN Component 的 Provider Edge Bridge 而言，在做 Mac Forwarding&#x2F;Learning 的时候，有两种模式，一种是用 <code>S-VLAN+MAC</code>，另外一种则是 <code>S-VLAN+C-VLAN+MAC</code>，前者即所谓的 C-VLAN Unaware Mode，而后者则是 C-VLAN Aware Mode。</p><p>C-VLAN Aware Mode 带来的好处是显而易见的，因为它将 VLAN 空间从 4K 扩展到了 16M，但是它的问题在于，当前绝大多数芯片都不支持，就算支持了，也不太可能支持到理论上的 16M。</p><h4 id="一种独创的-QinQ-模式"><a href="#一种独创的-QinQ-模式" class="headerlink" title="一种独创的 QinQ 模式"></a>一种独创的 QinQ 模式</h4><p>现实世界中用户的需求是千奇百怪，有一种需求，是市场上现存的交换机所解决不了的。在讨论这种需求之前，先看一下当前交换机的做法。无论各个厂家的实现差别有多大，但是有一点大家都是一样的，就是在接入交换机上，通过 Port 或者 C-VLAN 来识别用户，然后为每个用户分配一个 S-VLAN，然后用 S-VLAN 来做后续处理，如 ACL&#x2F;QoS&#x2F;Mac Learning&#x2F;Mac Forwarding 等。</p><p>但是运营商，特别是欧美的一些运营商可能有这样的需求，为了描述的方便，我们假设有个运营商 A，它在为它的客户提供服务的时候，有的时候需要租用别的运营商，假设是运营商 B 的网络，在租用网络的时候，A 这些 B 的客户，运营商 B 需要给 A 分配 S-VLAN，而且往往是一个 S-VLAN 多少钱，因为 VLAN 是稀缺资源，特别是网络比较大的时候。这个时候，如果运营商 A 为它自己的客户每个都分配一个 S-VLAN，那么相应的它就需要向 B 也申请很多个 S-VLAN，不划算，这个时候它就想在自己的接入设备上，不用 S-VLAN 来标识 Customer，给所有的 Customer 分配同一个 S-VLAN，用该 S-VLAN 来穿越 B 的网络，这个时候，S-VLAN 的意义不是代表 Customer，而是代表一个 Tunnel。</p><p>问题关键在于，如果不用 S-VLAN 来代表 Customer，在 A 的接入设备上，如何来对不同的 Customer 来做区分处理呢？用 C-VLAN 肯定是不行的，因为不同 Port 上的 C-VLAN 代表的 Customer 可能是不同的。Centec 的交换机，在芯片内部用一个不同于 C-VLAN 和 S-VLAN 的 CustomerID 来标识 Customer，用这个值来做后续的一系列 Customer 的处理，非常强大。</p><h4 id="QinQ-的不足"><a href="#QinQ-的不足" class="headerlink" title="QinQ 的不足"></a>QinQ 的不足</h4><p>尽管 QinQ 貌似很好很强大，并且受到热烈追捧，但是这不能掩盖它的先天不足。</p><p>QinQ 的最大不足就是它无法对运营商网络完全隐藏 Customer 信息，因为它可以让运营商 Core Network 的设备看不到 Customer VLAN，但是无法让它们看不到 Customer MAC。而这一点有两个不利的影响，一个是 Scalability 非常差，如果中间的设备都是二层设备，会导致 MAC 表非常大；第二个不利的影响则是，一旦 Customer 网络出现了环路，会导致 Provider Network 里面的设备不断进行 MAC Learning，万一有 ARP 之类报文，还可能冲击 CPU。</p><p>如果 Customer VLAN 对运营商网络不可见，那么就起不到扩展 VLAN 空间的作用，运营商的 VLAN 空间就仍然只有 4K。</p><p>而 PBB，即所谓的 MAC-in-MAC 则能很好的解决 QinQ 的这个不足，因为 PBB 不仅在原来的报文上新增一个 VLAN，还新增 MACSa&#x2F;MACDa 以及 24 个 bit 的 Isid（用来标识 Service），它可以完全对运营商的 Core Network 设备隐藏 Customer 信息，且能利用 Isid 来支持 16M Customer&#x2F;Service。</p><p>当然PBB也有PBB的问题，目前看不到它有成为主流技术的趋势。</p><h2 id="LLDPDU"><a href="#LLDPDU" class="headerlink" title="LLDPDU"></a>LLDPDU</h2><p>LLDPDU 是 LLDP 的有效负载，用于承载要发送的消息。LLDPDU 的格式如下图所示</p><p><img src="/assets/images/tech/data-link-layer-lldp-du.png" alt="LLDPDU"></p><p>LLDPDU 采用了 TLV 的格式，即 <code>type+length+value</code> 的格式，type 表示 TLV 的类型，length 是以字节为单位的 TLV 的长度，value 是该 TLV 的值。其中 Chassis ID TLV，Port ID TLV Time To Live TLV 以及 End Of LLDPDU TLV 是强制的，必须包含的部分，除此之外在 TLV Time To Live TLV 和 End Of LLDPDU TLV 之间可以包含 0 个到多个可选的其它 TLV。</p><h2 id="TLV"><a href="#TLV" class="headerlink" title="TLV"></a>TLV</h2><p>TLV 是组成 LLDPDU 的单元，每个 TLV 都代表一个信息。LLDPDU 的 TLV 可以分为两大类</p><ul><li>被认为是网络管理的基础的 TLV 集合，所有的 LLDP 实现都需要支持。</li><li>组织定义的 TLV 扩展集合，包括 <code>802.1</code> 组织定义 TLV、<code>802.3</code> 组织定义 TLV 以及其他组织定义的 TLV。这些 TLV 用于增强对网络设备的管理，可根据实际需要选择是否在 LLDPDU 中发送。</li></ul><p> </p><p>TLV 的基本格式如图所示</p><p><img src="/assets/images/tech/data-link-layer-lldp-tlv-format.png" alt="TLV基本格式图"></p><p>TLV的类型域的定义及分配如下图所示</p><p><img src="/assets/images/tech/data-link-layer-lldp-tlv-list.png" alt="TLV类型域"></p><p>其中 <code>type0-8</code> 属于基本的 TLV 集合。对于其中的 Mandatory 的 TLV，它是必须包含在 LLDP 中的。 组织定义 TLV 集合的格式如下图所示</p><p><img src="/assets/images/tech/data-link-layer-lldp-tlv-frame.png" alt="TLV集合格式"></p><p>其中</p><ul><li>OUI：组织机构的 ID。</li><li>organizationally defined subtype：组织自定义的类型。</li><li>organizationally defined information string：传输的信息。</li></ul><h2 id="基础-TLV-集合"><a href="#基础-TLV-集合" class="headerlink" title="基础 TLV 集合"></a>基础 TLV 集合</h2><p>几个强制的必须包含的 TLV 的定义如下。非强制的可以参考 IEEE802.1AB。</p><h3 id="End-Of-LLDPDU-TLV"><a href="#End-Of-LLDPDU-TLV" class="headerlink" title="End Of LLDPDU TLV"></a>End Of LLDPDU TLV</h3><p>该 TLV 用于标识 LLDPDU 的结束。其格式如下</p><p><img src="/assets/images/tech/data-link-layer-lldp-tlv-end.png" alt="TLV End"></p><p>由于 length&#x3D;0，因此它不包含 value 域。</p><h3 id="Chassis-ID-TLV"><a href="#Chassis-ID-TLV" class="headerlink" title="Chassis ID TLV"></a>Chassis ID TLV</h3><p>该 TLV 用于通告该 LLDPDU 发送者的 Chassis ID。由于有很多方式可用来标识一个 Chassis，因此在该类 TLV 中包含一个子类型域用于告诉接收者，发送者的 Chassis ID 采用的是哪一种标识方式。其格式如图所示</p><p><img src="/assets/images/tech/data-link-layer-lldp-tlv-chassis.png" alt="TLV Chassis"></p><p>每个 LLDPDU 必须包含且仅包含一个该类型的 TLV。由于 Chassis ID 实际上是用于标识设备的，因此在连接可用时它应该保持不变。 Chassis 子类型所可能的取值如图所示</p><p><img src="/assets/images/tech/data-link-layer-lldp-tlv-chassis-list.png" alt="TLV Chassis List"></p><h3 id="Port-ID-TLV"><a href="#Port-ID-TLV" class="headerlink" title="Port ID TLV"></a>Port ID TLV</h3><p>它用于标识发送该 LLDPDU 的设备的端口。类似于 Chassis ID，有很多方式可以标识一个 Port，因此该 TLV 也包含一个子类型域。其格式如下图所示</p><p><img src="/assets/images/tech/data-link-layer-lldp-tlv-port.png" alt="TLV Port"></p><p>每个 LLDPDU 必须包含一个且只能包含一个该类型的 TLV。同时，当端口可用时，从该端口发送出去的 LLDPDU 的该 TLV 应该保持不变。 其子类型的可能取值如下图所示</p><p><img src="/assets/images/tech/data-link-layer-lldp-tlv-port-list.png" alt="TLV Port List"></p><h3 id="Time-To-Live-TLV"><a href="#Time-To-Live-TLV" class="headerlink" title="Time To Live TLV"></a>Time To Live TLV</h3><p>该 TLV 用于告诉接收端，它接收到的这些信息的有效期有多长。其格式如图所示</p><p><img src="/assets/images/tech/data-link-layer-lldp-tlv-ttl.png" alt="TLV TTL"></p><p>TTL 的时间单位是秒，由于只有 2 个字节长，因而最大有效时间是 65536 秒。如果在这个时间到期了还没有新的 LLDPDU 被收到，则该 TLV 所属的那个 LLDPDU 携带的信息会被从 MIB 中删除。如果收到了新的 LLDPDU，则</p><ul><li>如果 TTL 不为 0，则会用新收到的 LLDPDU 的信息替换 MIB 库中的相应的信息（即与该 LLDPDU 的发送者相关的 MIB 信息，LLDP 使用 <code>Chassis ID+Port ID</code> 来判断是否来自于同一个源，这也是要求这两者保持不变的原因）。</li><li>如果 TTL 为 0，则删除相应的 MIB 库中的信息（即与该 LLDPDU 的发送者相关的 MIB 信息）。因此 TTL 为 0 的 LLDPDU 又被称为SHUTDOWN LLDPDU。</li></ul><p>每一个 LLDPDU 必须包含且只能包含一个该类型的 TLV。</p><h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><p>LLDP 是一个用于信息通告和获取的协议，但是需要注意的一点是，LLDP 发送的信息通告不需要确认，不能发送一个请求来请求获取某些信息，也就是说 LLDP 是一个单向的协议，只有主动通告一种工作方式，无需确认，不能查询、请求（比如像 ARP 协议那样请求某个 IP 的 MAC 地址）。</p><p>LLDP 主要完成如下工作：</p><ol><li>初始化并维护本地 MIB 库中的信息。<ol start="2"><li><pre><code>从本地 MIB 库中提取信息，并将信息封装到 LLDP 帧中。LLDP 帧的发送有两种触发方式，一是定时器到期触发，一是设备状态发生了变化触发。</code></pre><ol start="3"><li><pre><code>识别并处理接收到的 LLDPDU 帧。</code></pre><ol start="4"><li><pre><code>维护远端设备 LLDP MIB 信息库。</code></pre><ol start="5"><li><pre><code>当本地或远端设备 MIB 信息库中有信息发生变化时，发出通告事件。</code></pre></li></ol></li></ol></li></ol></li></ol></li></ol><h3 id="LLDPDU-发送"><a href="#LLDPDU-发送" class="headerlink" title="LLDPDU 发送"></a>LLDPDU 发送</h3><h4 id="发送机制"><a href="#发送机制" class="headerlink" title="发送机制"></a>发送机制</h4><p>LLDPDU 的发送可以被如下事件触发：</p><ul><li>与本地 MIB 信息库相关联的定时器 txTTR 到期时，这将确保远端接收系统中的相关信息不会因为 TTL 到期而过期。</li><li>本地 MIB 信息库中的信息发生了改变时，会立即发送 LLDPDU，这将保证改变能及时被更新。</li><li>如果一个“新邻居”被识别，将会启用快速发送机制，在很短的时间内连续发送指定数量（txFastInit，默认值为 4）的 LLDPDU，以确保“新邻居”能被快速更新。如果远端系统 MIB 信息库因为过载（tooManyNeighbors）而不能容纳新的邻居信息，则会为了避免过多的LLDPDU 传输而抑制快速发送行为。</li></ul><p>LLDP 的常规发送时间是建立在系统的 Tick 之上的，间隔为 1 秒一个，为了防止在共享介质的 LAN（shared media LAN）中同时出现大量的 LLDPDU（因为接入同一个LAN的多个系统的时间是同步的，因而多个系统上的基于 Tick 的1秒定时器可能同时到期），发送定时器引入了一个随机的抖动，这就使得常规的 LLDP 帧的发送间隔时间的平均值仍是 1 秒，但是具体到某一次到期时间可能并不是准确的 1 秒。</p><p>同时为了防止在有多个端口需要发送 LLDPDU 的系统中，所有的端口的定时器都在同一时间到期，因而标准建议将采用某种机制将多个发送实例的定时器到期时间给错开，以避免一个系统在同一时刻发送大量的 LLDPDU。</p><h4 id="发送状态机"><a href="#发送状态机" class="headerlink" title="发送状态机"></a>发送状态机</h4><p>LLDPDU 的发送状态机如图所示</p><p><img src="/assets/images/tech/data-link-layer-lldp-send-state-machine.png" alt="Send SM"></p><p>对于该状态机：</p><ul><li>为了防止过于频繁的重新初始化发送状态机，在 LLDP 的发送状态机中引入了一个延时，该延时限制了在关闭发送状态机后，必须至少等待多长时间才能重新初始化发送状态机。</li><li>是否发送 SHUTDOWN LLDPDU 由本地的 LLDP 工作状态决定。</li><li>是否发送正常的 LLDPDU 由 txNow 和 txCredit 决定。这两个变量都由发送定时器状态机更新。txNow 决定是否发送，而 txCredit 则是一个信用量，决定了可以发送的量，如果是 0 则不允许发送，只有大于 0 的值才允许发送，每发送一个该值就减 1。更重要的是在本地信息快速改变时，txCredit 既允许连续发送多个 LLDPDU，但是又对可以连续发送的 LLDPDU 帧数做了限制，这使得本地状态的快速改变可以及时被通告出去，但是又不能无限发送导致网络出现大量 LLDPDU 帧。</li></ul><h4 id="发送定时器状态机"><a href="#发送定时器状态机" class="headerlink" title="发送定时器状态机"></a>发送定时器状态机</h4><p>LLDP 发送定时器状态机如图所示</p><p><img src="/assets/images/tech/data-link-layer-lldp-send-timer-state-machine.png" alt="Send Timer SM"></p><p>localChange 表示本地信息是否发生改变；txTTR 表示下一次定时器到期的时间；newNeighbor 表示是否发现了新的邻居，并由接收状态设置，由该状态机清除；txTick 表示基于系统时间的1秒定时器是否到期。</p><p>对于该状态机：</p><ul><li>SIGNAL_TX 用于触发发送，它会将 txNow 设置为允许发送，并设置本地信息发生改变为 FALSE，如果当前不是在快速发送状态（txFast &#x3D; 0）就设置发送定时器下次到期时间为 msgTxInterval（msgTxInterval默认为30秒，取值范围1-3600秒），否则设置发送定时器下次到期时间为 msgFastTx（msgFastTx默认值为1秒，取值范围1-3600秒）。</li><li>如果本地信息发生了改变，就立即进入 SIGNAL_TX。</li><li>如果定时器到期，则如果 txFast 大于 0，则将其减 1 并进入 SIGNAL_TX，否则直接进入 SIGNAL_TX。</li><li>如果发现了新邻居，则首先将发现新邻居的标识更新为没有发现新邻居，然后如果当前已经处于快速发送状态就直接进入发送定时器到期状态（以触发一次立即发送），否则设置 txFast 的值为 txFastInit 的值（txFastInit 默认值为 4，取值范围 1-8）。</li><li>如果基于系统时间的 1 秒定时器到期，则给 txCredit 增加信用量，其最大值为 txCreditMax，txCreditMax 是一个取值在 1 到 10 之间的值，默认值为 5。</li></ul><p>这里有取值范围的几个变量都是可配置的变量。</p><p>从上述两个状态机的工作状态可以看出，发送定时器状态机用于维护信用量以及是否允许发送 LLDPDU 帧，而发送状态机根据这两个信息来决定是否发送。另外需要注意的是 LLDP 所使用的所有定时器操作都是“基于系统时间的 1 秒定时器的”，每当这个定时器到期时它除了会将 txTick 设置为 TRUE 外，还会处理其它的定时功能。</p><h3 id="LLDPDU-接收"><a href="#LLDPDU-接收" class="headerlink" title="LLDPDU 接收"></a>LLDPDU 接收</h3><h4 id="接收机制"><a href="#接收机制" class="headerlink" title="接收机制"></a>接收机制</h4><p>LLDP 帧的接收由 3 个阶段组成：帧的识别、帧的校验、LLDP 远端 MIB 信息库更新。</p><h5 id="帧的识别"><a href="#帧的识别" class="headerlink" title="帧的识别"></a>帧的识别</h5><p>由在 LLDP&#x2F;LSAP（链路服务访问点）进行，检查的内容是帧的目的地是否是 LLDP 的组播 MAC 地址，帧的类型是否是 LLDP。</p><h5 id="帧的验证"><a href="#帧的验证" class="headerlink" title="帧的验证"></a>帧的验证</h5><p>该过程会首先根据 TLV 的格式定义依次校验 Chassis ID TLV，Port ID TLV， Time To Live TLV，如果这三个 TLV 都存在且有效，才会进一步的解码可选的 TLV 直到遇到 End Of LLDPDU TLV，然后根据获得的信息更新远端 MIB 信息库。</p><h5 id="远端-MIB-信息库更新"><a href="#远端-MIB-信息库更新" class="headerlink" title="远端 MIB 信息库更新"></a>远端 MIB 信息库更新</h5><p>在前两步都通过之后，LLDPDU 的接收者就需要根据解析出来的信息更新远端 MIB 信息库。在 MIB 信息库中，LLDP 使用 <code>Chassis ID+Port ID</code> 来标识、存储来自不同源的信息。</p><ul><li>如果远端MIB库中已经有对应于该 <code>Chassis ID+Port ID</code> 的信息，则使用收到的帧中的新的 TTL 来更新 TTL。并用对于收到的新的 LLDPPDU 中的每一种 type，如果有变化就进行更新，如果某种 type 原来不存在，则需要将其添加到 MIB 库中。</li><li>如果实现不支持某种类型的 type，则</li></ul><ol><li>如果 type 不是 127，则按照基本 TLV 的格式将其存储到远端 MIB 库，存储格式为 type，length，value。</li><li>如果 type 是 127，则按照组织定义 TLV 的格式将其存储到远端 MIB 库，存储格式为 type，length，value，OUI，组织自定义子类型，以及信息域。</li></ol><p>更新时，如果需要添加新的 <code>Chassis ID+Port ID</code> 的表项，或者为某个 <code>Chassis ID+Port ID</code> 添加新的 TLV，则可能遇到没有内存的问题，标准没有规定必须如何处理，只是给出了一些建议：</p><ul><li>忽略新的 LLDPDU 的信息</li><li>删除最旧的信息以释放空间给新的信息</li><li>随机删除一些旧的信息以释放空间给新的信息</li></ul><p>LLDPDU 携带的 TTL（Time To Live）值会影响接收端的处理方式，如果它不为 0，则更新相应信息的老化时间，如果接收到的 LLDPDU 中的 TTL 等于 0，则将立刻老化掉相应的信息（即与该 LLDPDU 的发送者相关的MIB信息）。</p><p>如果一个 <code>Chassis ID+Port ID</code> 标识的信息的 TTL 超时，则相应的 MIB 信息会被删除。</p><h4 id="接收状态机"><a href="#接收状态机" class="headerlink" title="接收状态机"></a>接收状态机</h4><p>LLDPDU 的接收状态机如图所示</p><p><img src="/assets/images/tech/data-link-layer-lldp-receive-state-machine.png" alt="Receive SM"></p><h3 id="LLDP-工作模式"><a href="#LLDP-工作模式" class="headerlink" title="LLDP 工作模式"></a>LLDP 工作模式</h3><p>LLDP 可以工作在多种模式下：</p><ul><li>TxRx：既发送也接收 LLDP 帧。</li><li>Tx：只发送不接收 LLDP 帧。</li><li>Rx：只接收不发送 LLDP 帧。</li><li>Disable：既不发送也不接收 LLDP 帧（准确的说，这并不是一个 LLDP 的状态，这可能是 LLDP 功能被关闭了，也可能是设备就不支持）。</li></ul><p>由于 LLDP 可以单独工作在发送或接收模式下，因此 LLDP 协议的实现需要支持单独初始化发送或者接收功能。当工作模式发生变化时，需要根据老的&#x2F;新的工作模式来关闭&#x2F;打开发送或者接收的功能。</p><p><img src="/assets/images/tech/data-link-layer-lldp-mib-block.png" alt="MIB Block"></p><p><img src="/assets/images/tech/data-link-layer-lldp-state-machine-symbol.png" alt="SM Symbol"></p><p>至此，LLDP 相关知识点已经介绍完，希望对大家有所帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着网络技术的发展，接入网络的设备的种类越来越多，配置越来越复杂，来自不同设备厂商的设备也往往会增加自己特有的功能，这就导致在一个网络中往往会有很多具有不同特性的、来自不同厂商的设备，为了方便对这样的网络进行管理，就需要使得不同厂商的设备能够在网络中相互发现并交互各自的系统及配置信息。 &lt;/p&gt;
&lt;p&gt;LLDP（Link Layer Discovery Protocol，链路层发现协议）就是用于这个目的的协议。LLDP 定义在 802.1ab 中，它是一个二层协议，它提供了一种标准的链路层发现方式。LLDP 协议使得接入网络的一台设备可以将其主要的&lt;strong&gt;能力，管理地址，设备标识，接口标识&lt;/strong&gt;等信息发送给接入同一个局域网络的其它设备。当一个设备从网络中接收到其它设备的这些信息时，它就将这些信息以MIB的形式存储起来。&lt;/p&gt;
&lt;p&gt;这些 MIB 信息可用于发现设备的物理拓扑结构以及管理配置信息。需要注意的是 LLDP 仅仅被设计用于进行信息通告，它被用于通告一个设备的信息并可以获得其它设备的信息，进而得到相关的 MIB 信息。它不是一个配置、控制协议，无法通过该协议对远端设备进行配置，&lt;strong&gt;它只是提供了关于网络拓扑以及管理配置的信息，这些信息可以被用于管理、配置的目的，如何用取决于信息的使用者。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="https://chars.tech/categories/web/"/>
    
    
    <category term="LLDP" scheme="https://chars.tech/tags/LLDP/"/>
    
  </entry>
  
  <entry>
    <title>实现一个 RESTful API 服务器</title>
    <link href="https://chars.tech/2018-07-31-restful-api-go/"/>
    <id>https://chars.tech/2018-07-31-restful-api-go/</id>
    <published>2018-07-30T16:00:00.000Z</published>
    <updated>2018-12-06T13:46:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>RESTful 是目前最为流行的一种互联网软件结构。因为它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p><span id="more"></span><h2 id="什么是-REST"><a href="#什么是-REST" class="headerlink" title="什么是 REST"></a>什么是 REST</h2><p>REST（REpresentational State Transfer），首次出现在 2000 年 Roy Thomas Fielding 的博士论文中，它指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful 的。</p><ul><li>资源（Resources），REST 是“表现层状态转化”，其实它省略了主语。“表现层”其实指的是“资源”的“表现层”。那么什么是资源呢？我们平时网上访问到图片、文字、文档、多媒体等就是资源，一般通过 URI 来定位。也就是说，一个 URI 就表示一个资源。</li><li>表现层（Representation），资源是作为一个具体的实体信息，它可以有多种的展现方式。而把实体展现出来就是表现层。例如一个 txt 文本信息，它可以输出成 html、json 等。</li><li>状态转化（State Transfer），访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，就涉及到数据和状态的变化。而 HTTP 协议是无状态的，那么这些状态肯定保存在服务器端，所以如果客户端想要通知服务器端改变数据和状态的变化，就要通过某种方式来通知它。客户端能通知服务器端的手段，只能是 HTTP 协议。具体来说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源。</li></ul><p>综上所述，我们总结一下什么是 RESTful 架构：</p><p>1、每一个 URI 代表一种资源</p><p>2、客户端和服务端之间，传递这种资源的某种表现层</p><p>3、客户端通过四个 HTTP 动词，对服务端资源进行操作，实现“表现层状态转化”</p><p>将它们概述为图片形式，则 REST 架构图为：</p><p><img src="/assets/images/tech/restful-api-go-REST-struct.png" alt="REST架构图"></p><p>REST 的扩展性：</p><p><img src="/assets/images/tech/restful-api-go-REST-extern.png" alt="REST 的扩展性"></p><h2 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC"></a>什么是 RPC</h2><p>RPC（Remote Procedure Call Protocol）远程过程调用协议，是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。它假定某些传输协议的存在，如 TCP 或 UDP，以便为通信程序之间携带信息数据。通过它可以使函数调用模式网络化。在 OSI 网络通信模型中，RPC 跨越了传输层和应用层。RPC 使得开发包括网络分布式多程序在内的应用程序更加容易。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="/assets/images/tech/restful-api-go-RPC-flow.png" alt="RPC工作流程图"></p><p>运行时，一次客户端对服务器的 RPC 调用，其内部操作大致有如下步骤：</p><p>1、调用客户端句柄；执行传送参数</p><p>2、调用本地系统内核发送网络消息</p><p>3、消息传送到服务端</p><p>4、服务器句柄得到消息并取得参数</p><p>5、执行远程过程</p><p>6、执行的过程将结果返回服务器句柄</p><p>7、服务器句柄返回结果，调用远程系统内核</p><p>8、消息传回本地主机</p><p>9、客户端句柄由内核接收消息</p><p>10、客户端接收句柄返回的数据</p><h2 id="REST-vs-RPC"><a href="#REST-vs-RPC" class="headerlink" title="REST vs RPC"></a>REST vs RPC</h2><p>在做 API 服务器开发时，很多人都会遇到这个问题 —— 选择 REST 还是 RPC。RPC 相比 REST 的优点主要有 3 点：</p><p>1、RPC+Protobuf 采用的是 TCP 做传输协议，REST 直接使用 HTTP 做应用层协议，这种区别导致 REST 在调用性能上会比 RPC+Protobuf 低</p><p>2、RPC 不像 REST 那样，每一个操作都要抽象成对资源的增删改查，在实际开发中，有很多操作很难抽象成资源，比如登录操作。所以在实际开发中并不能严格按照 REST 规范来写 API，RPC 就不存在这个问题</p><p>3、RPC 屏蔽网络细节、易用，和本地调用类似</p><p>但是 REST 相较 RPC 也有很多优势：</p><p>1、轻量级，简单易用，维护性和扩展性都比较好</p><p>2、REST 相对更规范，更标准，更通用，无论哪种语言都支持 HTTP 协议，可以对接外部很多系统，只要满足 HTTP 调用即可，更适合对外，RPC 会有语言限制，不同语言的 RPC 调用起来很麻烦</p><p>3、JSON 格式可读性更强，开发调试都很方便</p><p>4、在开发过程中，如果严格按照 REST 规范来写 API，API 看起来更清晰，更容易被大家理解</p><p>其实业界普遍采用的做法是，内部系统之间调用用 RPC，对外用 REST，因为内部系统之间可能调用很频繁，需要 RPC 的高性能支撑。对外用 REST 更易理解，更通用些。</p><h2 id="一个基本的-Web-Server"><a href="#一个基本的-Web-Server" class="headerlink" title="一个基本的 Web Server"></a>一个基本的 Web Server</h2><p>一个 RESTful 服务本质上首先是一个 Web service。下面是一个最简单的 Web server，对于任何请求都简单的直接返回请求链接：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;html&quot;</span></span><br><span class="line">        <span class="string">&quot;log&quot;</span></span><br><span class="line">        <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">            fmt.Fprintf(w, <span class="string">&quot;Hello, %q&quot;</span>, html.EscapeString(r.URL.Path))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行之后，使用 curl 测试，结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v -XGET -H <span class="string">&quot;Content-Type: application/json&quot;</span> http://127.0.0.1:8080/user</span><br><span class="line"></span><br><span class="line">Hello, <span class="string">&quot;/user&quot;</span></span><br></pre></td></tr></table></figure><h2 id="路由功能"><a href="#路由功能" class="headerlink" title="路由功能"></a>路由功能</h2><p>很显然，我们的线上项目不可能使用这么简单的 API 服务器。当用户增加，请求也会不断上涨，该如何处理好这些请求？作者使用了一个开源路由框架 <a href="https://github.com/gorilla/mux">mux</a>。这是一个小巧高效，且使用较广的第三方框架。接下来的篇幅里，作者会使用 mux 搭建一个 API 服务器框架。</p><h3 id="安装-mux"><a href="#安装-mux" class="headerlink" title="安装 mux"></a>安装 mux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$go</span> get github.com/gorilla/mux</span><br></pre></td></tr></table></figure><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Router.go</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/gorilla/mux&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Route <span class="keyword">struct</span> &#123;</span><br><span class="line">Name        <span class="type">string</span></span><br><span class="line">Method      <span class="type">string</span></span><br><span class="line">Pattern     <span class="type">string</span></span><br><span class="line">HandlerFunc http.HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Routes []Route</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRouter</span><span class="params">()</span></span> *mux.Router &#123;</span><br><span class="line">router := mux.NewRouter().StrictSlash(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">for</span> _, route := <span class="keyword">range</span> routes &#123;</span><br><span class="line"><span class="keyword">var</span> handler http.Handler</span><br><span class="line"></span><br><span class="line">handler = route.HandlerFunc</span><br><span class="line">handler = http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">handler.ServeHTTP(w, r)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.Methods(route.Method).Path(route.Pattern).Name(route.Name).Handler(handler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> router</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> routes = Routes&#123;</span><br><span class="line">Route&#123;</span><br><span class="line"><span class="string">&quot;DeleteItem&quot;</span>,</span><br><span class="line"><span class="string">&quot;DELETE&quot;</span>,</span><br><span class="line"><span class="string">&quot;/v1/delete&quot;</span>,</span><br><span class="line">v1_deleteItem,</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Handler.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">v1_deleteItem</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json; charset=UTF-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">w.WriteHeader(http.StatusOK)</span><br><span class="line"><span class="keyword">if</span> err := json.NewEncoder(w).Encode(jsonErr&#123;Code: http.StatusOK, Text: <span class="string">&quot;操作成功&quot;</span>&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.<span class="built_in">print</span>(<span class="string">&quot;%s\n%s&quot;</span>, err.Error(), debug.Stack())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体 mux 功能实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := NewRouter()</span><br><span class="line"></span><br><span class="line">log.<span class="built_in">print</span>(<span class="string">&quot;service running(PID:%d)...&quot;</span>, os.Getpid())</span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, router))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>API 基本框架已经实现，接下来就是将相应功能实现模块与相应接口对接即可。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>对于想要学习作为一个客户端开发者如何独立完成一个具有 API 服务器功能的线上 APP，可以参考专栏<a href="https://zhuanlan.zhihu.com/health-go">《如何独立开发一个完整应用》</a>，专栏中使用线上 APP <a href="https://itunes.apple.com/cn/app/id1177823334">靓手艺</a> 作为案例，详细分享了笔者如何实现 APP 全部功能。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;RESTful 是目前最为流行的一种互联网软件结构。因为它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="https://chars.tech/categories/web/"/>
    
    
    <category term="go" scheme="https://chars.tech/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods 提交代码踩坑</title>
    <link href="https://chars.tech/2018-07-16-cocoapods-source-commit/"/>
    <id>https://chars.tech/2018-07-16-cocoapods-source-commit/</id>
    <published>2018-07-15T16:00:00.000Z</published>
    <updated>2018-08-02T13:00:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何提交代码至 CocoaPods？这个问题在 Google 一搜索可以有很多文章出来，不过，其中遇到的坑却无人提及。笔者现在将实际操作工程记录如下，并总结踩坑注意事项：操作顺序、文件配置、命令使用。</p><span id="more"></span><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h3><p>将需要提交至 CocoaPods 的代码提交至代码托管服务器，例如：GitHub。</p><p>这里需要注意的是，提交的代码需要包含 <code>tag</code> 标签。其实就是 git 里面的 <code>git tag</code>。</p><h3 id="安装或更新-CocoaPods"><a href="#安装或更新-CocoaPods" class="headerlink" title="安装或更新 CocoaPods"></a>安装或更新 CocoaPods</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install cocoapods</span><br></pre></td></tr></table></figure><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod update</span><br></pre></td></tr></table></figure><h3 id="注册-Trunk"><a href="#注册-Trunk" class="headerlink" title="注册 Trunk"></a>注册 Trunk</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod trunk register e_mail_address <span class="string">&#x27;your_name&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>记得去注册邮箱激活</p><h4 id="查看注册信息"><a href="#查看注册信息" class="headerlink" title="查看注册信息"></a>查看注册信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ pod trunk me</span><br><span class="line"></span><br><span class="line">  - Name:     charsdavy</span><br><span class="line">  - Email:    chars.davy@gmail.com</span><br><span class="line">  - Since:    July 15th, 21:38</span><br><span class="line">  - Pods:</span><br><span class="line">    - JCCNavigationController</span><br><span class="line">  - Sessions:</span><br><span class="line">    - July 15th, 21:38 - November 21st, 01:45. IP: xx.xx.xx.xx</span><br></pre></td></tr></table></figure><h2 id="创建-podspec-文件"><a href="#创建-podspec-文件" class="headerlink" title="创建 .podspec 文件"></a>创建 .podspec 文件</h2><p><code>.podspec</code> 文件的作用是为了让 CocoaPods 搜索引擎知道该代码的作者、版本号、概要、描述、源代码地址、部署版本、依赖的框架等描述信息。 </p><p><code>.podspec</code>文件可以自动生成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod spec create JCCNavigationController // 生成 JCCNavigationController.podspec 文件</span><br></pre></td></tr></table></figure><p><code>JCCNavigationController.podspec</code> 文件内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">#  Be sure to run `pod spec lint JCCNavigationController.podspec&#x27; to ensure this is a</span><br><span class="line">#  valid spec and to remove all comments including this before submitting the spec.</span><br><span class="line">#</span><br><span class="line">#  To learn more about Podspec attributes see http://docs.cocoapods.org/specification.html</span><br><span class="line">#  To see working Podspecs in the CocoaPods repo see https://github.com/CocoaPods/Specs/</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">Pod::Spec.new do |s|</span><br><span class="line"></span><br><span class="line">  # ―――  Spec Metadata  ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  These will help people to find your library, and whilst it</span><br><span class="line">  #  can feel like a chore to fill in it&#x27;s definitely to your advantage. The</span><br><span class="line">  #  summary should be tweet-length, and the description more in depth.</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  s.name         = &quot;JCCNavigationController&quot;</span><br><span class="line">  s.version      = &quot;1.0&quot;</span><br><span class="line">  s.summary      = &quot;A navigation bar integrated transition animation effect.&quot;</span><br><span class="line"></span><br><span class="line">  # This description is used to generate tags and improve search results.</span><br><span class="line">  #   * Think: What does it do? Why did you write it? What is the focus?</span><br><span class="line">  #   * Try to keep it short, snappy and to the point.</span><br><span class="line">  #   * Write the description between the DESC delimiters below.</span><br><span class="line">  #   * Finally, don&#x27;t worry about the indent, CocoaPods strips it!</span><br><span class="line">  s.description  = &lt;&lt;-DESC</span><br><span class="line">                  With zoom interactive animation, A navigation bar integrated transition animation effect.</span><br><span class="line">                  DESC</span><br><span class="line"></span><br><span class="line">  s.homepage     = &quot;https://github.com/charsdavy/JCCNavigationController&quot;</span><br><span class="line">  s.screenshots  = &quot;https://raw.githubusercontent.com/charsdavy/JCCNavigationController/master/Screenshot.gif&quot;</span><br><span class="line">  # s.screenshots  = &quot;www.example.com/screenshots_1.gif&quot;, &quot;www.example.com/screenshots_2.gif&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # ―――  Spec License  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  Licensing your code is important. See http://choosealicense.com for more info.</span><br><span class="line">  #  CocoaPods will detect a license file if there is a named LICENSE*</span><br><span class="line">  #  Popular ones are &#x27;MIT&#x27;, &#x27;BSD&#x27; and &#x27;Apache License, Version 2.0&#x27;.</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; &#125;</span><br><span class="line">  # s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # ――― Author Metadata  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  Specify the authors of the library, with email addresses. Email addresses</span><br><span class="line">  #  of the authors are extracted from the SCM log. E.g. $ git log. CocoaPods also</span><br><span class="line">  #  accepts just a name if you&#x27;d rather not provide an email address.</span><br><span class="line">  #</span><br><span class="line">  #  Specify a social_media_url where others can refer to, for example a twitter</span><br><span class="line">  #  profile URL.</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  s.author             = &#123; &quot;charsdavy&quot; =&gt; &quot;charsdavy@gamil.com&quot; &#125;</span><br><span class="line">  s.social_media_url   = &quot;https://twitter.com/charsdavy&quot;</span><br><span class="line"></span><br><span class="line">  s.swift_version = &quot;4.0&quot;</span><br><span class="line">  # ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  If this Pod runs only on iOS or OS X, then specify the platform and</span><br><span class="line">  #  the deployment target. You can optionally include the target after the platform.</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  s.platform     = :ios</span><br><span class="line">  s.platform     = :ios, &quot;8.0&quot;</span><br><span class="line"></span><br><span class="line">  #  When using multiple platforms</span><br><span class="line">  s.ios.deployment_target = &quot;8.0&quot;</span><br><span class="line">  # s.osx.deployment_target = &quot;10.7&quot;</span><br><span class="line">  # s.watchos.deployment_target = &quot;2.0&quot;</span><br><span class="line">  # s.tvos.deployment_target = &quot;9.0&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  Specify the location from where the source should be retrieved.</span><br><span class="line">  #  Supports git, hg, bzr, svn and HTTP.</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  s.source       = &#123; :git =&gt; &quot;https://github.com/charsdavy/JCCNavigationController.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  CocoaPods is smart about how it includes source code. For source files</span><br><span class="line">  #  giving a folder will include any swift, h, m, mm, c &amp; cpp files.</span><br><span class="line">  #  For header files it will include any header in the folder.</span><br><span class="line">  #  Not including the public_header_files will make all headers public.</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  s.source_files  = &quot;JCCNavigationController/*.swift&quot;</span><br><span class="line">  # s.exclude_files = &quot;Classes/Exclude&quot;</span><br><span class="line"></span><br><span class="line">  # s.public_header_files = &quot;Classes/**/*.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # ――― Resources ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  A list of resources included with the Pod. These are copied into the</span><br><span class="line">  #  target bundle with a build phase script. Anything else will be cleaned.</span><br><span class="line">  #  You can preserve files from being cleaned, please don&#x27;t preserve</span><br><span class="line">  #  non-essential files like tests, examples and documentation.</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  # s.resource  = &quot;icon.png&quot;</span><br><span class="line">  # s.resources = &quot;Resources/*.png&quot;</span><br><span class="line"></span><br><span class="line">  # s.preserve_paths = &quot;FilesToSave&quot;, &quot;MoreFilesToSave&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # ――― Project Linking ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  Link your library with frameworks, or libraries. Libraries do not include</span><br><span class="line">  #  the lib prefix of their name.</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  # s.framework  = &quot;SomeFramework&quot;</span><br><span class="line">  # s.frameworks = &quot;SomeFramework&quot;, &quot;AnotherFramework&quot;</span><br><span class="line"></span><br><span class="line">  # s.library   = &quot;iconv&quot;</span><br><span class="line">  # s.libraries = &quot;iconv&quot;, &quot;xml2&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  If your library depends on compiler flags you can set them in the xcconfig hash</span><br><span class="line">  #  where they will only apply to your library. If you depend on other Podspecs</span><br><span class="line">  #  you can include multiple dependencies to ensure it works.</span><br><span class="line"></span><br><span class="line">  # s.requires_arc = true</span><br><span class="line"></span><br><span class="line">  # s.xcconfig = &#123; &quot;HEADER_SEARCH_PATHS&quot; =&gt; &quot;$(SDKROOT)/usr/include/libxml2&quot; &#125;</span><br><span class="line">  # s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>以上文件，需要注意 <code>s.platform</code> 这个字段，文本中的注释说的很明白，默认是全平台都支持的，如果只支持某一个平台，则需要细心配置完善。</p><h2 id="验证-podspec-文件是否合法"><a href="#验证-podspec-文件是否合法" class="headerlink" title="验证 .podspec 文件是否合法"></a>验证 <code>.podspec</code> 文件是否合法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod spec lint JCCNavigationController.podspec</span><br></pre></td></tr></table></figure><p>如果配置文件仍存在错误，则根据错误提示修复错误。</p><p>如果只有以下一个错误，则只需提交代码即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR | unknown: Encountered an unknown error (uninitialized constant REST::DisconnectedError) during validation.</span><br></pre></td></tr></table></figure><h2 id="提交-podspec-文件"><a href="#提交-podspec-文件" class="headerlink" title="提交 .podspec 文件"></a>提交 <code>.podspec</code> 文件</h2><p>将 <code>.podspec</code> 文件提交至代码托管服务器，例如，将 <code>JCCNavigationController.podspec</code> 文件提交至 <code>JCCNavigationController</code> 项目。</p><h2 id="提交代码至-CocoaPods"><a href="#提交代码至-CocoaPods" class="headerlink" title="提交代码至 CocoaPods"></a>提交代码至 CocoaPods</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod trunk push JCCNavigationController.podspec --allow-warnings</span><br></pre></td></tr></table></figure><p>返回以下信息则为成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"> 🎉  Congrats</span><br><span class="line"></span><br><span class="line"> 🚀  JCCNavigationController (1.0) successfully published</span><br><span class="line"> 📅  July 16th, 00:58</span><br><span class="line"> 🌎  https://cocoapods.org/pods/JCCNavigationController</span><br><span class="line"> 👍  Tell your friends!</span><br><span class="line">--------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="JCCNavigationController"><a href="#JCCNavigationController" class="headerlink" title="JCCNavigationController"></a><a href="https://github.com/charsdavy/JCCNavigationController">JCCNavigationController</a></h3><p><a href="https://github.com/charsdavy/JCCNavigationController">JCCNavigationController</a>，一种导航栏一体化转场动画效果。</p><p><img src="https://raw.githubusercontent.com/charsdavy/JCCNavigationController/master/Screenshot.gif" alt="JCCNavigationController"></p><h3 id="DDCornerRadius"><a href="#DDCornerRadius" class="headerlink" title="DDCornerRadius"></a><a href="https://github.com/charsdavy/JCCNavigationController">DDCornerRadius</a></h3><p><a href="https://github.com/charsdavy/DDCornerRadius">DDCornerRadius</a>，优化圆角实现方案，避免离屏渲染。</p><p><img src="https://raw.githubusercontent.com/charsdavy/DDCornerRadius/master/Screenshot.gif" alt="DDCornerRadius"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何提交代码至 CocoaPods？这个问题在 Google 一搜索可以有很多文章出来，不过，其中遇到的坑却无人提及。笔者现在将实际操作工程记录如下，并总结踩坑注意事项：操作顺序、文件配置、命令使用。&lt;/p&gt;</summary>
    
    
    
    <category term="pieces" scheme="https://chars.tech/categories/pieces/"/>
    
    
    <category term="cocoapods" scheme="https://chars.tech/tags/cocoapods/"/>
    
    <category term="开源" scheme="https://chars.tech/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow -- 基准</title>
    <link href="https://chars.tech/2018-02-05-tensorflow-performance-benchmarks/"/>
    <id>https://chars.tech/2018-02-05-tensorflow-performance-benchmarks/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-09-29T12:57:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>TensorFlow 社区创建了一系列用于多平台测试的图像分类模型参考点。在 <a href="#methodology">方法</a> 章节中会详细说明如何执行测试，并给出使用的脚本链接。</p><span id="more"></span><h2 id="图像分类模型的结果"><a href="#图像分类模型的结果" class="headerlink" title="图像分类模型的结果"></a>图像分类模型的结果</h2><p>InceptionV3 (<a href="https://arxiv.org/abs/1512.00567">arXiv:1512.00567</a>), ResNet-50<br>(<a href="https://arxiv.org/abs/1512.03385">arXiv:1512.03385</a>), ResNet-152<br>(<a href="https://arxiv.org/abs/1512.03385">arXiv:1512.03385</a>), VGG16<br>(<a href="https://arxiv.org/abs/1409.1556">arXiv:1409.1556</a>), 和<br><a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf">AlexNet</a> 使用 <a href="http://www.image-net.org/">ImageNet</a> 数据集测试。这些测试运行在 Google 计算云引擎，亚马逊计算云 (Amazon EC2) 和 NVIDIA® DGX-1™ 。大部分测试使用合成和真实的数据。</p><p>对合成数据的测试是通过使用一个 <code>tf.Variable</code> 设置相同的 shape，除了每个 ImageNet 模型。我们认为，当评估一个平台的基准时包含真实数据是很重要的。底层硬件和框架的加载测试是为了训练实际数据。我们开始合成数据用来移除磁盘 I&#x2F;O 作为一个变量，并设置一个基准。然后使用真实的数据来验证 TensorFlow 的输入和底层磁盘 I&#x2F;O 的计算单元。</p><h3 id="使用-NVIDIA®-DGX-1™-NVIDIA®-Tesla®-P100-训练"><a href="#使用-NVIDIA®-DGX-1™-NVIDIA®-Tesla®-P100-训练" class="headerlink" title="使用 NVIDIA® DGX-1™ (NVIDIA® Tesla® P100) 训练"></a>使用 NVIDIA® DGX-1™ (NVIDIA® Tesla® P100) 训练</h3><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">  <img style="width:80%" src="https://www.tensorflow.org/images/perf_summary_p100_single_server.png"></div><p>细节和附加结果在 <a href="#details_for_nvidia_dgx-1tm_nvidia_tesla_p100">NVIDIA® DGX-1™ (NVIDIA®<br>Tesla® P100) 的细节</a> 章节中。</p><h3 id="使用-NVIDIA®-Tesla®-K80-训练"><a href="#使用-NVIDIA®-Tesla®-K80-训练" class="headerlink" title="使用 NVIDIA® Tesla® K80 训练"></a>使用 NVIDIA® Tesla® K80 训练</h3><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">  <img style="width:80%" src="https://www.tensorflow.org/images/perf_summary_k80_single_server.png"></div><p>细节和附加结果在 <a href="#details_for_google_compute_engine_nvidia_tesla_k80">Google 计算引擎<br>(NVIDIA® Tesla® K80) 的细节</a> 和<br><a href="#details_for_amazon_ec2_nvidia_tesla_k80">Amazon EC2 (NVIDIA® Tesla®<br>K80) 的细节</a> 章节中。</p><h3 id="使用-NVIDIA®-Tesla®-K80-分布式训练"><a href="#使用-NVIDIA®-Tesla®-K80-分布式训练" class="headerlink" title="使用 NVIDIA® Tesla® K80 分布式训练"></a>使用 NVIDIA® Tesla® K80 分布式训练</h3><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">  <img style="width:80%" src="https://www.tensorflow.org/images/perf_summary_k80_aws_distributed.png"></div><p>细节和附加结果在 <a href="#details_for_amazon_ec2_distributed_nvidia_tesla_k80">分布式 Amazon EC2<br>(NVIDIA® Tesla® K80) 的细节</a><br>章节中。</p><h3 id="比较合成和真实训练数据"><a href="#比较合成和真实训练数据" class="headerlink" title="比较合成和真实训练数据"></a>比较合成和真实训练数据</h3><p><strong>NVIDIA® Tesla® P100</strong></p><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">  <img style="width:35%" src="https://www.tensorflow.org/images/perf_summary_p100_data_compare_inceptionv3.png">  <img style="width:35%" src="https://www.tensorflow.org/images/perf_summary_p100_data_compare_resnet50.png"></div><p><strong>NVIDIA® Tesla® K80</strong></p><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">  <img style="width:35%" src="https://www.tensorflow.org/images/perf_summary_k80_data_compare_inceptionv3.png">  <img style="width:35%" src="https://www.tensorflow.org/images/perf_summary_k80_data_compare_resnet50.png"></div><h2 id="NVIDIA®-DGX-1™-NVIDIA®-Tesla®-P100-的细节"><a href="#NVIDIA®-DGX-1™-NVIDIA®-Tesla®-P100-的细节" class="headerlink" title="NVIDIA® DGX-1™ (NVIDIA® Tesla® P100) 的细节"></a>NVIDIA® DGX-1™ (NVIDIA® Tesla® P100) 的细节</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ul><li><strong>Instance type</strong>: NVIDIA® DGX-1™</li><li><strong>GPU:</strong> 8x NVIDIA® Tesla® P100</li><li><strong>OS:</strong> Ubuntu 16.04 LTS with tests run via Docker</li><li><strong>CUDA &#x2F; cuDNN:</strong> 8.0 &#x2F; 5.1</li><li><strong>TensorFlow GitHub hash:</strong> b1e174e</li><li><strong>Benchmark GitHub hash:</strong> 9165a70</li><li><strong>Build Command:</strong> <code>bazel build -c opt --copt=-march=&quot;haswell&quot; --config=cuda //tensorflow/tools/pip_package:build_pip_package</code></li><li><strong>Disk:</strong> Local SSD</li><li><strong>DataSet:</strong> ImageNet</li><li><strong>Test Date:</strong> May 2017</li></ul><p>每个模型的批处理大小和优化器如下表所示。除了下表所示的批处理大小，InceptionV3、ResNet-50、ResNet-152 和 VGG16 也用批处理大小为 32 进行测试。这些结果在 <em>其他结果</em> 章节。</p><table><thead><tr><th>Options</th><th>InceptionV3</th><th>ResNet-50</th><th>ResNet-152</th><th>AlexNet</th><th>VGG16</th></tr></thead><tbody><tr><td>Batch size per GPU</td><td>64</td><td>64</td><td>64</td><td>512</td><td>64</td></tr><tr><td>Optimizer</td><td>sgd</td><td>sgd</td><td>sgd</td><td>sgd</td><td>sgd</td></tr></tbody></table><p>用于每个模型的配置。</p><table><thead><tr><th>Model</th><th>variable_update</th><th>local_parameter_device</th></tr></thead><tbody><tr><td>InceptionV3</td><td>parameter_server</td><td>cpu</td></tr><tr><td>ResNet50</td><td>parameter_server</td><td>cpu</td></tr><tr><td>ResNet152</td><td>parameter_server</td><td>cpu</td></tr><tr><td>AlexNet</td><td>replicated (with NCCL)</td><td>n&#x2F;a</td></tr><tr><td>VGG16</td><td>replicated (with NCCL)</td><td>n&#x2F;a</td></tr></tbody></table><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">  <img style="width:80%" src="https://www.tensorflow.org/images/perf_summary_p100_single_server.png"></div><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">  <img style="width:35%" src="https://www.tensorflow.org/images/perf_dgx1_synth_p100_single_server_scaling.png">  <img style="width:35%" src="https://www.tensorflow.org/images/perf_dgx1_real_p100_single_server_scaling.png"></div><p><strong>训练合成数据</strong></p><table><thead><tr><th>GPUs</th><th>InceptionV3</th><th>ResNet-50</th><th>ResNet-152</th><th>AlexNet</th><th>VGG16</th></tr></thead><tbody><tr><td>1</td><td>142</td><td>219</td><td>91.8</td><td>2987</td><td>154</td></tr><tr><td>2</td><td>284</td><td>422</td><td>181</td><td>5658</td><td>295</td></tr><tr><td>4</td><td>569</td><td>852</td><td>356</td><td>10509</td><td>584</td></tr><tr><td>8</td><td>1131</td><td>1734</td><td>716</td><td>17822</td><td>1081</td></tr></tbody></table><p><strong>训练真实数据</strong></p><table><thead><tr><th>GPUs</th><th>InceptionV3</th><th>ResNet-50</th><th>ResNet-152</th><th>AlexNet</th><th>VGG16</th></tr></thead><tbody><tr><td>1</td><td>142</td><td>218</td><td>91.4</td><td>2890</td><td>154</td></tr><tr><td>2</td><td>278</td><td>425</td><td>179</td><td>4448</td><td>284</td></tr><tr><td>4</td><td>551</td><td>853</td><td>359</td><td>7105</td><td>534</td></tr><tr><td>8</td><td>1079</td><td>1630</td><td>708</td><td>N&#x2F;A</td><td>898</td></tr></tbody></table><p>从上图表可以看出，由于最大输入的限制，AlexNet 模型没有使用 8 个 GPU 来训练数据。</p><h3 id="其他结果"><a href="#其他结果" class="headerlink" title="其他结果"></a>其他结果</h3><p>以下是批处理大小为 32 的结果。</p><p><strong>训练合成数据</strong></p><table><thead><tr><th>GPUs</th><th>InceptionV3</th><th>ResNet-50</th><th>ResNet-152</th><th>VGG16</th></tr></thead><tbody><tr><td>1</td><td>128</td><td>195</td><td>82.7</td><td>144</td></tr><tr><td>2</td><td>259</td><td>368</td><td>160</td><td>281</td></tr><tr><td>4</td><td>520</td><td>768</td><td>317</td><td>549</td></tr><tr><td>8</td><td>995</td><td>1485</td><td>632</td><td>820</td></tr></tbody></table><p><strong>训练真实数据</strong></p><table><thead><tr><th>GPUs</th><th>InceptionV3</th><th>ResNet-50</th><th>ResNet-152</th><th>VGG16</th></tr></thead><tbody><tr><td>1</td><td>130</td><td>193</td><td>82.4</td><td>144</td></tr><tr><td>2</td><td>257</td><td>369</td><td>159</td><td>253</td></tr><tr><td>4</td><td>507</td><td>760</td><td>317</td><td>457</td></tr><tr><td>8</td><td>966</td><td>1410</td><td>609</td><td>690</td></tr></tbody></table><h2 id="Google-Compute-Engine-NVIDIA®-Tesla®-K80-的细节"><a href="#Google-Compute-Engine-NVIDIA®-Tesla®-K80-的细节" class="headerlink" title="Google Compute Engine (NVIDIA® Tesla® K80) 的细节"></a>Google Compute Engine (NVIDIA® Tesla® K80) 的细节</h2><h3 id="环境配置-1"><a href="#环境配置-1" class="headerlink" title="环境配置"></a>环境配置</h3><ul><li><strong>Instance type</strong>: n1-standard-32-k80x8</li><li><strong>GPU:</strong> 8x NVIDIA® Tesla® K80</li><li><strong>OS:</strong> Ubuntu 16.04 LTS</li><li><strong>CUDA &#x2F; cuDNN:</strong> 8.0 &#x2F; 5.1</li><li><strong>TensorFlow GitHub hash:</strong> b1e174e</li><li><strong>Benchmark GitHub hash:</strong> 9165a70</li><li><strong>Build Command:</strong> <code>bazel build -c opt --copt=-march=&quot;haswell&quot; --config=cuda //tensorflow/tools/pip_package:build_pip_package</code></li><li><strong>Disk:</strong> 1.7 TB Shared SSD persistent disk (800 MB&#x2F;s)</li><li><strong>DataSet:</strong> ImageNet</li><li><strong>Test Date:</strong> May 2017</li></ul><p>每个模型的批处理大小和优化器如下表所示。除了下表所示的批处理大小，InceptionV3 和 ResNet-50 也用批处理大小为 32 进行测试。这些结果在 <em>其他结果</em> 章节。</p><table><thead><tr><th>Options</th><th>InceptionV3</th><th>ResNet-50</th><th>ResNet-152</th><th>AlexNet</th><th>VGG16</th></tr></thead><tbody><tr><td>Batch size per GPU</td><td>64</td><td>64</td><td>32</td><td>512</td><td>32</td></tr><tr><td>Optimizer</td><td>sgd</td><td>sgd</td><td>sgd</td><td>sgd</td><td>sgd</td></tr></tbody></table><p>每个模型所用的配置中， variable_update 和 parameter_server 配置相同，local_parameter_device 和 cpu 配置相同。</p><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">  <img style="width:35%" src="https://www.tensorflow.org/images/perf_gce_synth_k80_single_server_scaling.png">  <img style="width:35%" src="https://www.tensorflow.org/images/perf_gce_real_k80_single_server_scaling.png"></div><p><strong>训练合成数据</strong></p><table><thead><tr><th>GPUs</th><th>InceptionV3</th><th>ResNet-50</th><th>ResNet-152</th><th>AlexNet</th><th>VGG16</th></tr></thead><tbody><tr><td>1</td><td>30.5</td><td>51.9</td><td>20.0</td><td>656</td><td>35.4</td></tr><tr><td>2</td><td>57.8</td><td>99.0</td><td>38.2</td><td>1209</td><td>64.8</td></tr><tr><td>4</td><td>116</td><td>195</td><td>75.8</td><td>2328</td><td>120</td></tr><tr><td>8</td><td>227</td><td>387</td><td>148</td><td>4640</td><td>234</td></tr></tbody></table><p><strong>训练真实数据</strong></p><table><thead><tr><th>GPUs</th><th>InceptionV3</th><th>ResNet-50</th><th>ResNet-152</th><th>AlexNet</th><th>VGG16</th></tr></thead><tbody><tr><td>1</td><td>30.6</td><td>51.2</td><td>20.0</td><td>639</td><td>34.2</td></tr><tr><td>2</td><td>58.4</td><td>98.8</td><td>38.3</td><td>1136</td><td>62.9</td></tr><tr><td>4</td><td>115</td><td>194</td><td>75.4</td><td>2067</td><td>118</td></tr><tr><td>8</td><td>225</td><td>381</td><td>148</td><td>4056</td><td>230</td></tr></tbody></table><h3 id="其他结果-1"><a href="#其他结果-1" class="headerlink" title="其他结果"></a>其他结果</h3><p><strong>训练合成数据</strong></p><table><thead><tr><th>GPUs</th><th>InceptionV3 (batch size 32)</th><th>ResNet-50 (batch size 32)</th></tr></thead><tbody><tr><td>1</td><td>29.3</td><td>49.5</td></tr><tr><td>2</td><td>55.0</td><td>95.4</td></tr><tr><td>4</td><td>109</td><td>183</td></tr><tr><td>8</td><td>216</td><td>362</td></tr></tbody></table><p><strong>训练真实数据</strong></p><table><thead><tr><th>GPUs</th><th>InceptionV3 (batch size 32)</th><th>ResNet-50 (batch size 32)</th></tr></thead><tbody><tr><td>1</td><td>29.5</td><td>49.3</td></tr><tr><td>2</td><td>55.4</td><td>95.3</td></tr><tr><td>4</td><td>110</td><td>186</td></tr><tr><td>8</td><td>216</td><td>359</td></tr></tbody></table><h2 id="Amazon-EC2-NVIDIA®-Tesla®-K80-的细节"><a href="#Amazon-EC2-NVIDIA®-Tesla®-K80-的细节" class="headerlink" title="Amazon EC2 (NVIDIA® Tesla® K80) 的细节"></a>Amazon EC2 (NVIDIA® Tesla® K80) 的细节</h2><h3 id="环境配置-2"><a href="#环境配置-2" class="headerlink" title="环境配置"></a>环境配置</h3><ul><li><strong>Instance type</strong>: p2.8xlarge</li><li><strong>GPU:</strong> 8x NVIDIA® Tesla® K80</li><li><strong>OS:</strong> Ubuntu 16.04 LTS</li><li><strong>CUDA &#x2F; cuDNN:</strong> 8.0 &#x2F; 5.1</li><li><strong>TensorFlow GitHub hash:</strong> b1e174e</li><li><strong>Benchmark GitHub hash:</strong> 9165a70</li><li><strong>Build Command:</strong> <code>bazel build -c opt --copt=-march=&quot;haswell&quot; --config=cuda //tensorflow/tools/pip_package:build_pip_package</code></li><li><strong>Disk:</strong> 1TB Amazon EFS (burst 100 MiB&#x2F;sec for 12 hours, continuous 50<br>MiB&#x2F;sec)</li><li><strong>DataSet:</strong> ImageNet</li><li><strong>Test Date:</strong> May 2017</li></ul><p>每个模型的批处理大小和优化器如下表所示。除了下表所示的批处理大小，InceptionV3 和 ResNet-50 也用批处理大小为 32 进行测试。这些结果在 <em>其他结果</em> 章节。</p><table><thead><tr><th>Options</th><th>InceptionV3</th><th>ResNet-50</th><th>ResNet-152</th><th>AlexNet</th><th>VGG16</th></tr></thead><tbody><tr><td>Batch size per GPU</td><td>64</td><td>64</td><td>32</td><td>512</td><td>32</td></tr><tr><td>Optimizer</td><td>sgd</td><td>sgd</td><td>sgd</td><td>sgd</td><td>sgd</td></tr></tbody></table><p>用于每个模型的配置。</p><table><thead><tr><th>Model</th><th>variable_update</th><th>local_parameter_device</th></tr></thead><tbody><tr><td>InceptionV3</td><td>parameter_server</td><td>cpu</td></tr><tr><td>ResNet-50</td><td>replicated (without NCCL)</td><td>gpu</td></tr><tr><td>ResNet-152</td><td>replicated (without NCCL)</td><td>gpu</td></tr><tr><td>AlexNet</td><td>parameter_server</td><td>gpu</td></tr><tr><td>VGG16</td><td>parameter_server</td><td>gpu</td></tr></tbody></table><h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">  <img style="width:35%" src="https://www.tensorflow.org/images/perf_aws_synth_k80_single_server_scaling.png">  <img style="width:35%" src="https://www.tensorflow.org/images/perf_aws_real_k80_single_server_scaling.png"></div><p><strong>训练合成数据</strong></p><table><thead><tr><th>GPUs</th><th>InceptionV3</th><th>ResNet-50</th><th>ResNet-152</th><th>AlexNet</th><th>VGG16</th></tr></thead><tbody><tr><td>1</td><td>30.8</td><td>51.5</td><td>19.7</td><td>684</td><td>36.3</td></tr><tr><td>2</td><td>58.7</td><td>98.0</td><td>37.6</td><td>1244</td><td>69.4</td></tr><tr><td>4</td><td>117</td><td>195</td><td>74.9</td><td>2479</td><td>141</td></tr><tr><td>8</td><td>230</td><td>384</td><td>149</td><td>4853</td><td>260</td></tr></tbody></table><p><strong>训练真实数据</strong></p><table><thead><tr><th>GPUs</th><th>InceptionV3</th><th>ResNet-50</th><th>ResNet-152</th><th>AlexNet</th><th>VGG16</th></tr></thead><tbody><tr><td>1</td><td>30.5</td><td>51.3</td><td>19.7</td><td>674</td><td>36.3</td></tr><tr><td>2</td><td>59.0</td><td>94.9</td><td>38.2</td><td>1227</td><td>67.5</td></tr><tr><td>4</td><td>118</td><td>188</td><td>75.2</td><td>2201</td><td>136</td></tr><tr><td>8</td><td>228</td><td>373</td><td>149</td><td>N&#x2F;A</td><td>242</td></tr></tbody></table><p>由于我们的 EFS 没有提供足够的吞吐量，上面的图表中我们排出了使用 8 个 GPU 来训练 AlexNet 模型的统计。</p><h3 id="其他结果-2"><a href="#其他结果-2" class="headerlink" title="其他结果"></a>其他结果</h3><p><strong>训练合成数据</strong></p><table><thead><tr><th>GPUs</th><th>InceptionV3 (batch size 32)</th><th>ResNet-50 (batch size 32)</th></tr></thead><tbody><tr><td>1</td><td>29.9</td><td>49.0</td></tr><tr><td>2</td><td>57.5</td><td>94.1</td></tr><tr><td>4</td><td>114</td><td>184</td></tr><tr><td>8</td><td>216</td><td>355</td></tr></tbody></table><p><strong>训练真实数据</strong></p><table><thead><tr><th>GPUs</th><th>InceptionV3 (batch size 32)</th><th>ResNet-50 (batch size 32)</th></tr></thead><tbody><tr><td>1</td><td>30.0</td><td>49.1</td></tr><tr><td>2</td><td>57.5</td><td>95.1</td></tr><tr><td>4</td><td>113</td><td>185</td></tr><tr><td>8</td><td>212</td><td>353</td></tr></tbody></table><h2 id="Amazon-EC2-Distributed-NVIDIA®-Tesla®-K80-的细节"><a href="#Amazon-EC2-Distributed-NVIDIA®-Tesla®-K80-的细节" class="headerlink" title="Amazon EC2 Distributed (NVIDIA® Tesla® K80) 的细节"></a>Amazon EC2 Distributed (NVIDIA® Tesla® K80) 的细节</h2><h3 id="环境配置-3"><a href="#环境配置-3" class="headerlink" title="环境配置"></a>环境配置</h3><ul><li><strong>Instance type</strong>: p2.8xlarge</li><li><strong>GPU:</strong> 8x NVIDIA® Tesla® K80</li><li><strong>OS:</strong> Ubuntu 16.04 LTS</li><li><strong>CUDA &#x2F; cuDNN:</strong> 8.0 &#x2F; 5.1</li><li><strong>TensorFlow GitHub hash:</strong> b1e174e</li><li><strong>Benchmark GitHub hash:</strong> 9165a70</li><li><strong>Build Command:</strong> <code>bazel build -c opt --copt=-march=&quot;haswell&quot; --config=cuda //tensorflow/tools/pip_package:build_pip_package</code></li><li><strong>Disk:</strong> 1.0 TB EFS (burst 100 MB&#x2F;sec for 12 hours, continuous 50 MB&#x2F;sec)</li><li><strong>DataSet:</strong> ImageNet</li><li><strong>Test Date:</strong> May 2017</li></ul><p>每个模型的批处理大小和优化器如下表所示。除了下表所示的批处理大小，InceptionV3 和 ResNet-50 也用批处理大小为 32 进行测试。这些结果在 <em>其他结果</em> 章节。</p><table><thead><tr><th>Options</th><th>InceptionV3</th><th>ResNet-50</th><th>ResNet-152</th></tr></thead><tbody><tr><td>Batch size per GPU</td><td>64</td><td>64</td><td>32</td></tr><tr><td>Optimizer</td><td>sgd</td><td>sgd</td><td>sgd</td></tr></tbody></table><p>用于每个模型的配置。</p><table><thead><tr><th>Model</th><th>variable_update</th><th>local_parameter_device</th><th>cross_replica_sync</th></tr></thead><tbody><tr><td>InceptionV3</td><td>distributed_replicated</td><td>n&#x2F;a</td><td>True</td></tr><tr><td>ResNet-50</td><td>distributed_replicated</td><td>n&#x2F;a</td><td>True</td></tr><tr><td>ResNet-152</td><td>distributed_replicated</td><td>n&#x2F;a</td><td>True</td></tr></tbody></table><p>为了简化服务器设置，EC2 实例（p2.8xlarge）运行了 worker 服务器和 parameter 服务器。相同数量的 worker 服务器和 parameter 服务器使用了下述的配置：</p><ul><li>InceptionV3: 8 instances &#x2F; 6 parameter servers</li><li>ResNet-50: (batch size 32) 8 instances &#x2F; 4 parameter servers</li><li>ResNet-152: 8 instances &#x2F; 4 parameter servers</li></ul><h3 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h3><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">  <img style="width:80%" src="https://www.tensorflow.org/images/perf_summary_k80_aws_distributed.png"></div><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">  <img style="width:70%" src="https://www.tensorflow.org/images/perf_aws_synth_k80_distributed_scaling.png"></div><p><strong>训练合成数据</strong></p><table><thead><tr><th>GPUs</th><th>InceptionV3</th><th>ResNet-50</th><th>ResNet-152</th></tr></thead><tbody><tr><td>1</td><td>29.7</td><td>52.4</td><td>19.4</td></tr><tr><td>8</td><td>229</td><td>378</td><td>146</td></tr><tr><td>16</td><td>459</td><td>751</td><td>291</td></tr><tr><td>32</td><td>902</td><td>1388</td><td>565</td></tr><tr><td>64</td><td>1783</td><td>2744</td><td>981</td></tr></tbody></table><h3 id="其他结果-3"><a href="#其他结果-3" class="headerlink" title="其他结果"></a>其他结果</h3><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">  <img style="width:50%" src="https://www.tensorflow.org/images/perf_aws_synth_k80_multi_server_batch32.png"></div><p><strong>训练合成数据</strong></p><table><thead><tr><th>GPUs</th><th>InceptionV3 (batch size 32)</th><th>ResNet-50 (batch size 32)</th></tr></thead><tbody><tr><td>1</td><td>29.2</td><td>48.4</td></tr><tr><td>8</td><td>219</td><td>333</td></tr><tr><td>16</td><td>427</td><td>667</td></tr><tr><td>32</td><td>820</td><td>1180</td></tr><tr><td>64</td><td>1608</td><td>2315</td></tr></tbody></table><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>上述结果是使用该 <a href="https://github.com/tensorflow/benchmarks/tree/master/scripts/tf_cnn_benchmarks">脚本</a> 运行在各种平台上而生成。<a href="https://www.tensorflow.org/performance/performance_models">《High-Performance Models》</a> 文章详细描述了脚本中的技术，以及如何执行脚本的示例。</p><p>为了创建尽可能重复的结果，每个测试运行 5 次，然后取平均值。在给定的平台上，GPU 是在默认状态下运行的。对于 NVIDIA® Tesla® K80 来说这意味着不使用 <a href="https://devblogs.nvidia.com/parallelforall/increase-performance-gpu-boost-k80-autoboost/">GPU<br>Boost</a>。</p><p>对于每个测试，需要完成 10 次预热，然后再平均完成 100 次测试。</p><blockquote><ul><li>原文地址：<a href="https://www.tensorflow.org/performance/benchmarks">https://www.tensorflow.org/performance/benchmarks</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li><li>译者：<a href="https://github.com/charsdavy">charsdavy</a></li><li>校对者：<a href="https://github.com/joyking7">joyking7</a></li></ul></blockquote><blockquote><p><a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im/">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android">Android</a>、<a href="https://github.com/xitu/gold-miner#ios">iOS</a>、<a href="https://github.com/xitu/gold-miner#%E5%89%8D%E7%AB%AF">前端</a>、<a href="https://github.com/xitu/gold-miner#%E5%90%8E%E7%AB%AF">后端</a>、<a href="https://github.com/xitu/gold-miner#%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%A7%E5%93%81">产品</a>、<a href="https://github.com/xitu/gold-miner#%E8%AE%BE%E8%AE%A1">设计</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi">知乎专栏</a>。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;TensorFlow 社区创建了一系列用于多平台测试的图像分类模型参考点。在 &lt;a href=&quot;#methodology&quot;&gt;方法&lt;/a&gt; 章节中会详细说明如何执行测试，并给出使用的脚本链接。&lt;/p&gt;</summary>
    
    
    
    <category term="ml" scheme="https://chars.tech/categories/ml/"/>
    
    
    <category term="tensorflow" scheme="https://chars.tech/tags/tensorflow/"/>
    
    <category term="机器学习" scheme="https://chars.tech/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="性能" scheme="https://chars.tech/tags/%E6%80%A7%E8%83%BD/"/>
    
    <category term="掘金翻译计划" scheme="https://chars.tech/tags/%E6%8E%98%E9%87%91%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow 广度和深度学习的教程</title>
    <link href="https://chars.tech/2017-11-30-tensorflow-wide-and-deep/"/>
    <id>https://chars.tech/2017-11-30-tensorflow-wide-and-deep/</id>
    <published>2017-11-30T06:00:10.000Z</published>
    <updated>2018-09-29T12:57:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前文 <a href="https://www.tensorflow.org/tutorials/wide">《TensorFlow Liner Model Tutorial》</a> 中，我们使用 <a href="https://archive.ics.uci.edu/ml/datasets/Census+Income">人口收入普查数据集</a> 训练了一个 logistic 线性回归模型去预测个人年收入超过 5 万美元的概率。TensorFlow 在训练深度神经网络方面效果也很好，那么你可能会考虑该如何取舍它的功能了 – 可是，为什么不选择两者兼得呢？那么，是否可以将两者的优势结合在一个模型中呢？</p><p>在这篇文章中，我们将会介绍如何使用 TF.Learn API 同时训练一个广度线性模型和一个深度前馈神经网络。这种方法结合了记忆和泛化的优势。它在一般的大规模回归和具有稀疏输入特性的分类问题（例如，分类特征存在一个很大的可能值域）上很有效。如果你有兴趣学习更多关于广度和深度学习如何工作的问题，请参考 <a href="http://arxiv.org/abs/1606.07792">研究论文</a></p><p><img src="https://www.tensorflow.org/images/wide_n_deep.svg" alt="Wide &amp; Deep Spectrum of Models" title="Wide &amp; Deep"></p><span id="more"></span><p>现在，我们来看一个简单的例子。</p><p>上图展示了广度模型（具有稀疏特征和转换性质的 logistic 回归模型），深度模型（具有一个嵌入层和多个隐藏层的前馈神经网络），广度和深度模型（两者的联合训练）的区别比较。在高层级里，只需要通过以下三个步骤就能使用 TF.Learn API 配置广度，深度或广度和深度模型。</p><p>1.选择广度部分的特征：选择要使用的稀疏基本列和交叉列。</p><p>2.选择深度部分的特征：选择连续列，每个分类列的嵌入维度和隐藏层大小。</p><p>3.将它们一起放入广度和深度模型（<code>DNNLinearCombinedClassifier</code>）。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>如果想要尝试本教程中的代码：</p><p>1.安装 TensorFlow ，<a href="/blog/tensorflow-pycharm-mac">请前往此处</a>。</p><p>2.下载 <a href="https://www.tensorflow.org/code/tensorflow/examples/learn/wide_n_deep_tutorial.py">教程代码</a>。</p><p>3.安装 pandas 数据分析库。因为本教程中需要使用 pandas 数据。虽然 tf.learn 不要求 pandas，但是它支持 pandas。安装 pandas：</p><p>a. 获取 pip：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Ubuntu/Linux 64-bit</span><br><span class="line">$ sudo apt-get install python-pip python-dev</span><br><span class="line"></span><br><span class="line"># Mac OS X</span><br><span class="line">$ sudo easy_install pip</span><br><span class="line">$ sudo easy_install --upgrade six</span><br></pre></td></tr></table></figure><p>b. 使用 pip 安装 pandas</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install pandas</span><br></pre></td></tr></table></figure><p>如果你在安装过程中遇到问题，请前往 pandas 网站上的 <a href="http://pandas.pydata.org/pandas-docs/stable/install.html">说明</a> 。</p><p>4.执行以下命令来训练教程中描述的线性模型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python wide_n_deep_tutorial.py --model_type=wide_n_deep</span><br></pre></td></tr></table></figure><p>请继续阅读，了解此代码如何构建其线性模型。</p><h2 id="定义基本特征列"><a href="#定义基本特征列" class="headerlink" title="定义基本特征列"></a>定义基本特征列</h2><p>首先，定义我们使用的基本分类和连续特征的列。这些列将被作为模型的广度部分和深度部分的构件块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">gender = tf.feature_column.categorical_column_with_vocabulary_list(</span><br><span class="line">    <span class="string">&quot;gender&quot;</span>, [<span class="string">&quot;Female&quot;</span>, <span class="string">&quot;Male&quot;</span>])</span><br><span class="line">education = tf.feature_column.categorical_column_with_vocabulary_list(</span><br><span class="line">    <span class="string">&quot;education&quot;</span>, [</span><br><span class="line">        <span class="string">&quot;Bachelors&quot;</span>, <span class="string">&quot;HS-grad&quot;</span>, <span class="string">&quot;11th&quot;</span>, <span class="string">&quot;Masters&quot;</span>, <span class="string">&quot;9th&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Some-college&quot;</span>, <span class="string">&quot;Assoc-acdm&quot;</span>, <span class="string">&quot;Assoc-voc&quot;</span>, <span class="string">&quot;7th-8th&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Doctorate&quot;</span>, <span class="string">&quot;Prof-school&quot;</span>, <span class="string">&quot;5th-6th&quot;</span>, <span class="string">&quot;10th&quot;</span>, <span class="string">&quot;1st-4th&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Preschool&quot;</span>, <span class="string">&quot;12th&quot;</span></span><br><span class="line">    ])</span><br><span class="line">marital_status = tf.feature_column.categorical_column_with_vocabulary_list(</span><br><span class="line">    <span class="string">&quot;marital_status&quot;</span>, [</span><br><span class="line">        <span class="string">&quot;Married-civ-spouse&quot;</span>, <span class="string">&quot;Divorced&quot;</span>, <span class="string">&quot;Married-spouse-absent&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Never-married&quot;</span>, <span class="string">&quot;Separated&quot;</span>, <span class="string">&quot;Married-AF-spouse&quot;</span>, <span class="string">&quot;Widowed&quot;</span></span><br><span class="line">    ])</span><br><span class="line">relationship = tf.feature_column.categorical_column_with_vocabulary_list(</span><br><span class="line">    <span class="string">&quot;relationship&quot;</span>, [</span><br><span class="line">        <span class="string">&quot;Husband&quot;</span>, <span class="string">&quot;Not-in-family&quot;</span>, <span class="string">&quot;Wife&quot;</span>, <span class="string">&quot;Own-child&quot;</span>, <span class="string">&quot;Unmarried&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Other-relative&quot;</span></span><br><span class="line">    ])</span><br><span class="line">workclass = tf.feature_column.categorical_column_with_vocabulary_list(</span><br><span class="line">    <span class="string">&quot;workclass&quot;</span>, [</span><br><span class="line">        <span class="string">&quot;Self-emp-not-inc&quot;</span>, <span class="string">&quot;Private&quot;</span>, <span class="string">&quot;State-gov&quot;</span>, <span class="string">&quot;Federal-gov&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Local-gov&quot;</span>, <span class="string">&quot;?&quot;</span>, <span class="string">&quot;Self-emp-inc&quot;</span>, <span class="string">&quot;Without-pay&quot;</span>, <span class="string">&quot;Never-worked&quot;</span></span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示一个哈希的例子：</span></span><br><span class="line">occupation = tf.feature_column.categorical_column_with_hash_bucket(</span><br><span class="line">    <span class="string">&quot;occupation&quot;</span>, hash_bucket_size=<span class="number">1000</span>)</span><br><span class="line">native_country = tf.feature_column.categorical_column_with_hash_bucket(</span><br><span class="line">    <span class="string">&quot;native_country&quot;</span>, hash_bucket_size=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续基列</span></span><br><span class="line">age = tf.feature_column.numeric_column(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">education_num = tf.feature_column.numeric_column(<span class="string">&quot;education_num&quot;</span>)</span><br><span class="line">capital_gain = tf.feature_column.numeric_column(<span class="string">&quot;capital_gain&quot;</span>)</span><br><span class="line">capital_loss = tf.feature_column.numeric_column(<span class="string">&quot;capital_loss&quot;</span>)</span><br><span class="line">hours_per_week = tf.feature_column.numeric_column(<span class="string">&quot;hours_per_week&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换</span></span><br><span class="line">age_buckets = tf.feature_column.bucketized_column(</span><br><span class="line">    age, boundaries=[<span class="number">18</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">60</span>, <span class="number">65</span>])</span><br></pre></td></tr></table></figure><h2 id="广度模型：具有交叉特征列的线性模型"><a href="#广度模型：具有交叉特征列的线性模型" class="headerlink" title="广度模型：具有交叉特征列的线性模型"></a>广度模型：具有交叉特征列的线性模型</h2><p>广度模型是一个具有稀疏和交叉特征列的线性模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">base_columns = [</span><br><span class="line">    gender, native_country, education, occupation, workclass, relationship,</span><br><span class="line">    age_buckets,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">crossed_columns = [</span><br><span class="line">    tf.feature_column.crossed_column(</span><br><span class="line">        [<span class="string">&quot;education&quot;</span>, <span class="string">&quot;occupation&quot;</span>], hash_bucket_size=<span class="number">1000</span>),</span><br><span class="line">    tf.feature_column.crossed_column(</span><br><span class="line">        [age_buckets, <span class="string">&quot;education&quot;</span>, <span class="string">&quot;occupation&quot;</span>], hash_bucket_size=<span class="number">1000</span>),</span><br><span class="line">    tf.feature_column.crossed_column(</span><br><span class="line">        [<span class="string">&quot;native_country&quot;</span>, <span class="string">&quot;occupation&quot;</span>], hash_bucket_size=<span class="number">1000</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>具有交叉特征列的广度模型可以有效地记忆特征之间的稀疏交互。也就是说，交叉特征列不能概括没有在训练数据中出现的特征组合。让我们采用嵌入方式来添加一个深度模型来修复这个问题。</p><h2 id="深度模型：嵌入式神经网络"><a href="#深度模型：嵌入式神经网络" class="headerlink" title="深度模型：嵌入式神经网络"></a>深度模型：嵌入式神经网络</h2><p>深度模型是一个前馈神经网络，如前图所示。每一个稀疏，高维度分类特征首先都会被转换成一个低维度密集的实值矢量，通常被称为嵌入式矢量。这些低维度密集的嵌入式矢量与连续特征相连，然后在正向传递中馈入神经网络的隐藏层。嵌入值随机初始化，并与其他模型参数一起训练，以最大化减少训练损失。如果你有兴趣了解更多关于嵌入的知识，请在查阅教程 <a href="https://www.tensorflow.org/versions/r0.9/tutorials/word2vec/index.html">Vector Representations of Words</a> 或在 Wikipedia 上查阅 <a href="https://en.wikipedia.org/wiki/Word_embedding">Word Embedding</a>。</p><p>我们将使用 <code>embedding_column</code> 配置分类嵌入列，并将它们与连续列连接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deep_columns = [</span><br><span class="line">    tf.feature_column.indicator_column(workclass),</span><br><span class="line">    tf.feature_column.indicator_column(education),</span><br><span class="line">    tf.feature_column.indicator_column(gender),</span><br><span class="line">    tf.feature_column.indicator_column(relationship),</span><br><span class="line">    <span class="comment"># 展示一个嵌入例子</span></span><br><span class="line">    tf.feature_column.embedding_column(native_country, dimension=<span class="number">8</span>),</span><br><span class="line">    tf.feature_column.embedding_column(occupation, dimension=<span class="number">8</span>),</span><br><span class="line">    age,</span><br><span class="line">    education_num,</span><br><span class="line">    capital_gain,</span><br><span class="line">    capital_loss,</span><br><span class="line">    hours_per_week,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>嵌入的 <code>dimension</code> 越高，自由度就越高，模型将不得不学习这些特性的表示。为了简单起见，我们设置所有特征列的维度为 8。从经验上看，关于维度的设定最好是从 \log_{2}(n) 或 k\sqrt[4]{n} 值开始，这里的 n 代表特征列中唯一特征的数量，k 是一个很小的常量（通常小于10）。</p><p>通过密集嵌入，深度模型可以更好的概括，并更好对之前没有在训练数据中遇见的特征进行预测。然而，当两个特征列之间的底层交互矩阵是稀疏和高等级时，很难学习特征列的有效低维度表示。在这种情况下，大多数特征对之间的交互应该为零，除了少数几个，但密集的嵌入将导致所有特征对的非零预测，从而可能过度泛化。另一方面，具有交叉特征的线性模型可以用更少的模型参数有效地记住这些“异常规则”。</p><p>现在，我们来看看如何联合训练广度和深度模型，让它们优势和劣势互补。</p><h2 id="将广度和深度模型结合为一体"><a href="#将广度和深度模型结合为一体" class="headerlink" title="将广度和深度模型结合为一体"></a>将广度和深度模型结合为一体</h2><p>通过将其最终输出的对数几率作为预测结合起来，然后将预测提供给 logistic 损失函数，将广度模型和深度模型相结合。所有的图形定义和变量分配都已经被处理，所以你只需要创建一个 <code>DNNLinearCombinedClassifier</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line">model_dir = tempfile.mkdtemp()</span><br><span class="line">m = tf.contrib.learn.DNNLinearCombinedClassifier(</span><br><span class="line">    model_dir=model_dir,</span><br><span class="line">    linear_feature_columns=wide_columns,</span><br><span class="line">    dnn_feature_columns=deep_columns,</span><br><span class="line">    dnn_hidden_units=[<span class="number">100</span>, <span class="number">50</span>])</span><br></pre></td></tr></table></figure><h2 id="训练和评估模型"><a href="#训练和评估模型" class="headerlink" title="训练和评估模型"></a>训练和评估模型</h2><p>在训练模型之前，请先阅读人口普查数据集，就像在 <a href="https://www.tensorflow.org/tutorials/wide">《TensorFlow Liner Model Tutorial》</a> 中所做的一样。 输入数据处理的代码再次为你提供方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为数据集定义列名</span></span><br><span class="line">CSV_COLUMNS = [</span><br><span class="line">    <span class="string">&quot;age&quot;</span>, <span class="string">&quot;workclass&quot;</span>, <span class="string">&quot;fnlwgt&quot;</span>, <span class="string">&quot;education&quot;</span>, <span class="string">&quot;education_num&quot;</span>,</span><br><span class="line">    <span class="string">&quot;marital_status&quot;</span>, <span class="string">&quot;occupation&quot;</span>, <span class="string">&quot;relationship&quot;</span>, <span class="string">&quot;race&quot;</span>, <span class="string">&quot;gender&quot;</span>,</span><br><span class="line">    <span class="string">&quot;capital_gain&quot;</span>, <span class="string">&quot;capital_loss&quot;</span>, <span class="string">&quot;hours_per_week&quot;</span>, <span class="string">&quot;native_country&quot;</span>,</span><br><span class="line">    <span class="string">&quot;income_bracket&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maybe_download</span>(<span class="params">train_data, test_data</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Maybe downloads training data and returns train and test file names.&quot;&quot;&quot;</span></span><br><span class="line">  <span class="keyword">if</span> train_data:</span><br><span class="line">    train_file_name = train_data</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    train_file = tempfile.NamedTemporaryFile(delete=<span class="literal">False</span>)</span><br><span class="line">    urllib.request.urlretrieve(</span><br><span class="line">        <span class="string">&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data&quot;</span>,</span><br><span class="line">        train_file.name)  <span class="comment"># pylint: disable=line-too-long</span></span><br><span class="line">    train_file_name = train_file.name</span><br><span class="line">    train_file.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Training data is downloaded to %s&quot;</span> % train_file_name)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> test_data:</span><br><span class="line">    test_file_name = test_data</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    test_file = tempfile.NamedTemporaryFile(delete=<span class="literal">False</span>)</span><br><span class="line">    urllib.request.urlretrieve(</span><br><span class="line">        <span class="string">&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.test&quot;</span>,</span><br><span class="line">        test_file.name)  <span class="comment"># pylint: disable=line-too-long</span></span><br><span class="line">    test_file_name = test_file.name</span><br><span class="line">    test_file.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Test data is downloaded to %s&quot;</span>% test_file_name)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> train_file_name, test_file_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">input_fn</span>(<span class="params">data_file, num_epochs, shuffle</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Input builder function.&quot;&quot;&quot;</span></span><br><span class="line">  df_data = pd.read_csv(</span><br><span class="line">      tf.gfile.Open(data_file),</span><br><span class="line">      names=CSV_COLUMNS,</span><br><span class="line">      skipinitialspace=<span class="literal">True</span>,</span><br><span class="line">      engine=<span class="string">&quot;python&quot;</span>,</span><br><span class="line">      skiprows=<span class="number">1</span>)</span><br><span class="line">  <span class="comment"># 移除 NaN 元素</span></span><br><span class="line">  df_data = df_data.dropna(how=<span class="string">&quot;any&quot;</span>, axis=<span class="number">0</span>)</span><br><span class="line">  labels = df_data[<span class="string">&quot;income_bracket&quot;</span>].apply(<span class="keyword">lambda</span> x: <span class="string">&quot;&gt;50K&quot;</span> <span class="keyword">in</span> x).astype(<span class="built_in">int</span>)</span><br><span class="line">  <span class="keyword">return</span> tf.estimator.inputs.pandas_input_fn(</span><br><span class="line">      x=df_data,</span><br><span class="line">      y=labels,</span><br><span class="line">      batch_size=<span class="number">100</span>,</span><br><span class="line">      num_epochs=num_epochs,</span><br><span class="line">      shuffle=shuffle,</span><br><span class="line">      num_threads=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>阅读数据之后，你可以训练并评估模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 num_epochs 设置为 None，以获得无限的数据流</span></span><br><span class="line">m.train(</span><br><span class="line">    input_fn=input_fn(train_file_name, num_epochs=<span class="literal">None</span>, shuffle=<span class="literal">True</span>),</span><br><span class="line">    steps=train_steps)</span><br><span class="line"><span class="comment"># 在所有数据被消耗之前，为了运行评估，设置 steps 为 None</span></span><br><span class="line">results = m.evaluate(</span><br><span class="line">    input_fn=input_fn(test_file_name, num_epochs=<span class="number">1</span>, shuffle=<span class="literal">False</span>),</span><br><span class="line">    steps=<span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;model directory = %s&quot;</span> % model_dir)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">sorted</span>(results):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;%s: %s&quot;</span> % (key, results[key]))</span><br></pre></td></tr></table></figure><p>输出的第一行应该类似 <code>accuracy: 0.84429705</code>。我们可以看到使用广度和深度模型将广度线性模型精度约 83.6% 提高到了约 84.4%。如果你想看端对端的工作示例，你可以下载我们的 <a href="https://www.tensorflow.org/code/tensorflow/examples/learn/wide_n_deep_tutorial.py">示例代码</a>。</p><p>请注意，本教程只是一个小型数据基的简单示例，为了让你快速熟悉 API。如果你有大量具有稀疏特征列和大量可能特征值的数据集，广度和深度学习将会更加强大。此外，请随时关注我们的 <a href="http://arxiv.org/abs/1606.07792">研究论文</a>，以了解更多关于在实际中广度和深度学习在大型机器学习方面如何应用的思考。</p><blockquote><ul><li>原文地址：<a href="https://www.tensorflow.org/tutorials/wide_and_deep">https://www.tensorflow.org/tutorials/wide_and_deep</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li><li>译者：<a href="https://github.com/charsdavy">charsdavy</a></li><li>校对者：<a href="https://github.com/MRNIU">MRNIU</a></li></ul></blockquote><blockquote><p><a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im/">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android">Android</a>、<a href="https://github.com/xitu/gold-miner#ios">iOS</a>、<a href="https://github.com/xitu/gold-miner#%E5%89%8D%E7%AB%AF">前端</a>、<a href="https://github.com/xitu/gold-miner#%E5%90%8E%E7%AB%AF">后端</a>、<a href="https://github.com/xitu/gold-miner#%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%A7%E5%93%81">产品</a>、<a href="https://github.com/xitu/gold-miner#%E8%AE%BE%E8%AE%A1">设计</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi">知乎专栏</a>。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前文 &lt;a href=&quot;https://www.tensorflow.org/tutorials/wide&quot;&gt;《TensorFlow Liner Model Tutorial》&lt;/a&gt; 中，我们使用 &lt;a href=&quot;https://archive.ics.uci.edu/ml/datasets/Census+Income&quot;&gt;人口收入普查数据集&lt;/a&gt; 训练了一个 logistic 线性回归模型去预测个人年收入超过 5 万美元的概率。TensorFlow 在训练深度神经网络方面效果也很好，那么你可能会考虑该如何取舍它的功能了 – 可是，为什么不选择两者兼得呢？那么，是否可以将两者的优势结合在一个模型中呢？&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们将会介绍如何使用 TF.Learn API 同时训练一个广度线性模型和一个深度前馈神经网络。这种方法结合了记忆和泛化的优势。它在一般的大规模回归和具有稀疏输入特性的分类问题（例如，分类特征存在一个很大的可能值域）上很有效。如果你有兴趣学习更多关于广度和深度学习如何工作的问题，请参考 &lt;a href=&quot;http://arxiv.org/abs/1606.07792&quot;&gt;研究论文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.tensorflow.org/images/wide_n_deep.svg&quot; alt=&quot;Wide &amp;amp; Deep Spectrum of Models&quot; title=&quot;Wide &amp;amp; Deep&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ml" scheme="https://chars.tech/categories/ml/"/>
    
    
    <category term="python" scheme="https://chars.tech/tags/python/"/>
    
    <category term="tensorflow" scheme="https://chars.tech/tags/tensorflow/"/>
    
    <category term="机器学习" scheme="https://chars.tech/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="掘金翻译计划" scheme="https://chars.tech/tags/%E6%8E%98%E9%87%91%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>聊聊 iOS 数据保护</title>
    <link href="https://chars.tech/2017-10-17-ios-data-protection/"/>
    <id>https://chars.tech/2017-10-17-ios-data-protection/</id>
    <published>2017-10-17T07:18:19.000Z</published>
    <updated>2018-12-06T14:17:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>文件系统中的文件、keychain中的项，都是加密存储的。当用户解锁设备后，系统通过UDID密钥和用户设定的密码生成一个用于解密的密码密钥，存放在内存中，直到设备再次被锁，开发者可以通过Data Protection API 来设定文件系统中的文件、keychain中的项应该何时被解密。这个就是数据保护的内容。</p><span id="more"></span><h2 id="钥匙串（keychain）"><a href="#钥匙串（keychain）" class="headerlink" title="钥匙串（keychain）"></a>钥匙串（keychain）</h2><p>keychain服务提供了一种安全的保存私密信息（密码，序列号，私钥，证书等）的方式，每个iOS程序都有一个独立的keychain存储。相对于NSUserDefaults、文件保存等一般方式，keychain保存更为安全，而且keychain里保存的信息不会因APP被删除而丢失。</p><p>基于钥匙串的特点，我们在使用时对于新增的数据项目，要注意数据删除的时机。还有一点需要注意的就是，保护属性的指定。如果没有指定保护属性，这将被视为严重的安全漏洞。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><p>当我们备份设备数据时，系统会将用户数据保存在相应的钥匙串中，并依照相应的安全策略保存。主要分成两类：<strong>加密</strong>和<strong>不加密</strong>。</p><p>两者的主要区别在于恢复数据时的范围不同。加密备份的数据可以恢复到任何设备上（ThisDeviceOnly指定的项目除外），而不加密的备份则只能恢复至同一台设备。</p><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p>keychain支持在多个应用之间共享数据。但现实开发中<code>UIPasteboardNameFind</code>的使用代替了keychain。不过好在Apple在iOS11中已经废弃它。看来Apple想规范开发者对于用户敏感数据的共享使用，同时提醒大家使用更加安全的方式存储用户敏感数据。</p><h3 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h3><h4 id="SecItemAdd"><a href="#SecItemAdd" class="headerlink" title="SecItemAdd"></a>SecItemAdd</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *dict = [NSMutableDictionary dictionary];</span><br><span class="line">NSData *passwordData = [@&quot;myPassword&quot; dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];</span><br><span class="line">[dict setObject:@&quot;Conglomco&quot; forKey:(__bridge id)kSecAttrLabel];</span><br><span class="line">[dict setObject:@&quot;This is your password for the Conglomco service.&quot; forKey:(__bridge id)kSecAttrDescription];</span><br><span class="line">[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];</span><br><span class="line">[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];</span><br><span class="line">[dict setObject:passwordData forKey:(__bridge id)kSecValueData];</span><br><span class="line">[dict setObject:(__bridge id)kSecAttrAccessibleWhenUnlocked forKey:(__bridge id)kSecAttrAccessible];</span><br><span class="line"></span><br><span class="line">OSStatus error = SecItemAdd((__bridge CFDictionaryRef)dict, NULL);</span><br><span class="line">if (error == errSecSuccess) &#123;</span><br><span class="line">    NSLog(@&quot;Yay&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SecItemDelete"><a href="#SecItemDelete" class="headerlink" title="SecItemDelete"></a>SecItemDelete</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *dict = [NSMutableDictionary dictionary];</span><br><span class="line"></span><br><span class="line">[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];</span><br><span class="line">[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];</span><br><span class="line">[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];</span><br><span class="line"></span><br><span class="line">OSStatus error = SecItemDelete((__bridge CFDictionaryRef)dict);</span><br><span class="line">if (error == errSecSuccess) &#123;</span><br><span class="line">NSLog(@&quot;Yay&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SecItemUpdate"><a href="#SecItemUpdate" class="headerlink" title="SecItemUpdate"></a>SecItemUpdate</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *dict = [NSMutableDictionary dictionary];</span><br><span class="line">NSData *newPasswordData = [@&quot;newMyPassword&quot; dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];</span><br><span class="line">[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];</span><br><span class="line">[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];</span><br><span class="line"></span><br><span class="line">NSDictionary *updatedAttribute = [NSDictionary dictionaryWithObject:newPasswordData forKey:(__bridge id)kSecValueData];</span><br><span class="line"></span><br><span class="line">OSStatus error = SecItemUpdate((__bridge CFDictionaryRef)dict, (__bridge CFDictionaryRef)updatedAttribute);</span><br><span class="line">if (error == errSecSuccess) &#123;</span><br><span class="line">NSLog(@&quot;Yay&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SecItemCopyMatching"><a href="#SecItemCopyMatching" class="headerlink" title="SecItemCopyMatching"></a>SecItemCopyMatching</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *dict = [NSMutableDictionary dictionary];</span><br><span class="line"></span><br><span class="line">[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];</span><br><span class="line">[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];</span><br><span class="line">[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];</span><br><span class="line">[dict setObject:(id)kCFBooleanTrue forKey:(__bridge id)kSecReturnAttributes];</span><br><span class="line"></span><br><span class="line">NSDictionary *result = nil;</span><br><span class="line">OSStatus error = SecItemCopyMatching((__bridge CFDictionaryRef)dict, (void *)&amp;result);</span><br><span class="line">if (error == errSecSuccess) &#123;</span><br><span class="line">NSLog(@&quot;Yay %@&quot;, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>SecItemAdd</td><td>添加数据</td></tr><tr><td>SecItemDelete</td><td>删除数据</td></tr><tr><td>SecItemUpdate</td><td>修改数据</td></tr><tr><td>SecItemCopyMatching</td><td>查找数据</td></tr></tbody></table><h3 id="保护属性"><a href="#保护属性" class="headerlink" title="保护属性"></a>保护属性</h3><table><thead><tr><th>钥匙串保护属性</th><th>含义</th></tr></thead><tbody><tr><td>kSecAttrAccessibleAfterFirstUnlock</td><td>开机之后密钥不可用，直到用户首次输入密码</td></tr><tr><td>kSecAttrAccessibleAlways</td><td>密钥在设备开机后依旧可用。在iOS9中已经废弃</td></tr><tr><td>kSecAttrAccessibleAlwaysThisDeviceOnly</td><td>密钥始终可用，但无法迁移到其他设备</td></tr><tr><td>kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly</td><td>作用同上</td></tr><tr><td>kSecAttrAccessibleWhenUnlocked</td><td>只要解锁过设备，则密钥保持可用状态</td></tr><tr><td>kSecAttrAccessibleWhenUnlockedThisDeviceOnly</td><td>作用同上</td></tr><tr><td>kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly</td><td>作用同上，只有用户设置密码密钥才可用</td></tr></tbody></table><p><code>kSecAttrAccessibleAlways</code> 将会引入一个很明显的安全问题，因为此种保护属性，只要有人窃取了你的设备，他们就能读取钥匙串的内容。</p><p><code>kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly</code> 这个属性可以完美的解决上述的安全问题。因为越狱时通常需要重启设备。</p><p><code>kSecAttrAccessibleWhenUnlocked</code> 这个属性要求攻击者必须知道用户密码才能提取隐私数据。它很适合做默认属性值。</p><p><code>kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly</code> 是iOS8新增的保护属性。这个属性要求在使用时用户设定了密码，否则使用就失败。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><table><thead><tr><th>项目类</th><th>描述</th></tr></thead><tbody><tr><td>kSecClassGenericPassword</td><td>普通密码</td></tr><tr><td>kSecClassInternetPassword</td><td>专门用于互联网服务的密码</td></tr><tr><td>kSecClassCertificate</td><td>加密证书</td></tr><tr><td>kSecClassKey</td><td>加密密钥</td></tr><tr><td>kSecClassIdentity</td><td>一个密钥对（包括公共证书和私钥）</td></tr></tbody></table><h3 id="iCloud同步"><a href="#iCloud同步" class="headerlink" title="iCloud同步"></a>iCloud同步</h3><p>这是iOS7引入的一种新机制，可以把钥匙串项目同步到iCloud，允许用户在多个设备之间共享钥匙串项目。</p><p>默认情况下，应用程序创建的钥匙串项目会禁用这个机制，但可以把<code>kSecAttrSynchronizable</code>设置为<code>true</code>来启用。</p><p>另外请注意，使用此选项时无法指定不兼容的kSecAttrAccessible属性。例如，指定kSecAttrAccessibleWhenUnlockedThisDeviceOnly不起作用，因为ThisDeviceOnly指定的项目不会备份，也不能同步到iCloud、笔记本电脑、台式机或其他同步位置。</p><h2 id="数据保护"><a href="#数据保护" class="headerlink" title="数据保护"></a>数据保护</h2><p>Apple 推出了数据保护API作为额外的保护层，它允许开发者指定文件解密密钥的生命周期。可以使用这个API控制文件的访问权限，与钥匙串项目中的kSecAttrAccessible 属性类似。</p><p>数据保护API使用用户密码和层级密钥来加密保护文件的密钥，而当这些文件不能被访问时，会从内存中删除这个层级密钥。</p><h3 id="文件保护过程"><a href="#文件保护过程" class="headerlink" title="文件保护过程"></a>文件保护过程</h3><p><img src="/assets/images/tech/ios_data_protection_2.png" alt="文件保护过程"></p><p>1.文件生成一个<code>文件密钥</code>来加密文件的内容。</p><p>2.生成一个额外的密钥对，用于生成<code>文件公钥</code>和<code>文件私钥</code>。</p><p>3.用<code>文件私钥</code>和<code>Protected Unless Open等级公钥</code>计算出一个<code>共享密码</code>。</p><p>4.用<code>共享密码</code> SHA-1散列值加密文件密钥。</p><p>5.加密过的<code>文件密钥</code>会存储在文件的元数据中，元数据中还有文件的公钥。</p><p>6.系统丢弃<code>文件私钥</code>。</p><p>7.关闭文件时从内存中删除未加密的文件密钥。</p><p>8.需要再次打开文件时，用<code>Protected Unless Open等级私钥</code>和<code>文件公钥</code>计算<code>共享密码</code>。</p><p>9.计算<code>共享密码</code>的SHA-1散列值，把它当作解密文件的密钥。</p><h3 id="DataProtectionClass-权限"><a href="#DataProtectionClass-权限" class="headerlink" title="DataProtectionClass 权限"></a>DataProtectionClass 权限</h3><p>如果你的应用在设备进入后台或锁定时不需要写入或读取文件，那你就可以在工程中配置一个<code>NSFileProtectionComplete</code>值来添加权限。这将确保所有受保护的文件数据只能在设备解锁时访问，相当于为所有的应用文件都设置<code>kSecAttrAccessibleWhenUnlocked</code>选项。</p><p>从Xcode5开始，新工程会默认启用数据保护权限，但是一些旧工程并不会自动开启。</p><p>开启方式如下图：</p><p><img src="/assets/images/tech/ios_data_protection_1.png" alt="开启DataProtectionClass权限"></p><h3 id="使用范例-1"><a href="#使用范例-1" class="headerlink" title="使用范例"></a>使用范例</h3><h4 id="NSDataWritingFileProtectionComplete"><a href="#NSDataWritingFileProtectionComplete" class="headerlink" title="NSDataWritingFileProtectionComplete"></a>NSDataWritingFileProtectionComplete</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSData *data = [self generateData];</span><br><span class="line">NSError *error = nil;</span><br><span class="line">NSString *path = [NSString stringWithFormat:@&quot;%@_demo.pdf&quot;, NSTemporaryDirectory()];</span><br><span class="line">[data writeToFile:path options:NSDataWritingFileProtectionComplete error:&amp;error];</span><br><span class="line">if (error) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NSFileProtectionComplete"><a href="#NSFileProtectionComplete" class="headerlink" title="NSFileProtectionComplete"></a>NSFileProtectionComplete</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@&quot;demo.txt&quot;];</span><br><span class="line">NSError *error = nil;</span><br><span class="line">NSDictionary *attr = [NSDictionary dictionaryWithObject:NSFileProtectionComplete forKey:NSFileProtectionKey];</span><br><span class="line">[[NSFileManager defaultManager] setAttributes:attr ofItemAtPath:path error:&amp;error];</span><br><span class="line">if (error) &#123;</span><br><span class="line">NSLog(@&quot;%@&quot;, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SQLITE-OPEN-FILEPROTECTION-COMPLETEUNLESSOPEN"><a href="#SQLITE-OPEN-FILEPROTECTION-COMPLETEUNLESSOPEN" class="headerlink" title="SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN"></a>SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@&quot;demo.sqlite&quot;];</span><br><span class="line">sqlite3 *handle = NULL;</span><br><span class="line">sqlite3_open_v2([path UTF8String],</span><br><span class="line">                &amp;handle,</span><br><span class="line">                SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE | SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN,</span><br><span class="line">                NULL);</span><br></pre></td></tr></table></figure><h3 id="保护等级"><a href="#保护等级" class="headerlink" title="保护等级"></a>保护等级</h3><h4 id="CompleteUntilFirstUserAuthentication"><a href="#CompleteUntilFirstUserAuthentication" class="headerlink" title="CompleteUntilFirstUserAuthentication"></a>CompleteUntilFirstUserAuthentication</h4><p>这个保护等级是iOS5开始使用的默认值。主要用来防御一些需要重启的攻击。</p><h4 id="Complete"><a href="#Complete" class="headerlink" title="Complete"></a>Complete</h4><p>官方称这是目前最安全的文件保护等级。在这种情况下，锁屏之后系统就会删除内存中的层级密钥，并把文件改为不可读。</p><p>具体使用的范例前文可见。</p><p>使用Complete保护之前，考虑是否合适。如果你的应用进程需要持续写&#x2F;读一个文件，那这种保护模式就不合适了。</p><h4 id="CompleteUnlessOpen"><a href="#CompleteUnlessOpen" class="headerlink" title="CompleteUnlessOpen"></a>CompleteUnlessOpen</h4><p>如果一个文件当前被一个应用打开，那会暂时禁用该文件的保护。它会确保打开的文件在设备被锁定时依然能够写入，并且允许新建文件到磁盘。不过这个等级保护的文件在锁屏时无法打开，除非锁屏时就已经提前打开。</p><h2 id="CommonCrypto加密"><a href="#CommonCrypto加密" class="headerlink" title="CommonCrypto加密"></a>CommonCrypto加密</h2><p>CommonCrypto是Apple官方提供的一套加密框架。在使用这套方案时，主要注意以下几个问题即可。</p><h3 id="避免弱算法"><a href="#避免弱算法" class="headerlink" title="避免弱算法"></a>避免弱算法</h3><p>众所周知，DES就是一种很典型的弱算法。如果你使用弱算法，那应用就很容易遭受密码攻击和暴力破解。</p><p>我们在实际使用时，可以考虑使用AES算法、MD5算法或MD5加盐算法等。</p><h3 id="破碎的熵"><a href="#破碎的熵" class="headerlink" title="破碎的熵"></a>破碎的熵</h3><p>我们通常会使用<code>rand</code>方法来产生随机数，但是系统的这个随机函数并不是真正的随机。它产生的随机数符合正态分布，我们可以使用官方提供的方法<code>SecRandomCopyBytes</code>获得。也可以自己使用算法产生随机数。</p><p>这里分享一个笔者以前自己实现的随机数案例。<a href="/blog/uniform-random/">《均匀分布随机函数的实现》</a></p><h3 id="弱密钥"><a href="#弱密钥" class="headerlink" title="弱密钥"></a>弱密钥</h3><p>开发者经常将用户的密码当作加密密钥，尤其在移动设备上，这将导致一个非常脆弱、低熵加密的密钥。</p><p>那么正确的姿势是使用<code>CCKeyDerivationPBKDF</code>方法来生成。</p><h2 id="Touch-ID"><a href="#Touch-ID" class="headerlink" title="Touch ID"></a>Touch ID</h2><h3 id="使用范例-2"><a href="#使用范例-2" class="headerlink" title="使用范例"></a>使用范例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;LocalAuthentication/LocalAuthentication.h&gt;</span><br><span class="line"></span><br><span class="line">LAContext *context = [[LAContext alloc] init];</span><br><span class="line">NSError *error = nil;</span><br><span class="line">NSString *reason = @&quot;We use this to verify your identify&quot;;</span><br><span class="line">if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;error]) &#123;</span><br><span class="line">[context evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:reason reply:^(BOOL success, NSError * _Nullable error) &#123;</span><br><span class="line">if (success) &#123;</span><br><span class="line">NSLog(@&quot;Hello, that&#x27;s your finger!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">NSLog(@&quot;Couldn&#x27;t read your fingerprint. Falling back to PIN or somthing.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">NSLog(@&quot;Error : %@ %@&quot;, error, [error userInfo]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Touch-ID-与普通密码相比的安全性"><a href="#Touch-ID-与普通密码相比的安全性" class="headerlink" title="Touch ID 与普通密码相比的安全性"></a>Touch ID 与普通密码相比的安全性</h3><p>一个人的指纹是世界上最好的密码之一。它独一无二，高度特异，并且无需记忆。它会伴随人终生，所以你可以一直使用同一个指纹密码。</p><p>比起简单的4位数字锁屏密码一万分之一的破解可能性，能找到同样单个指纹的人的概率为五万分之一，这是非常安全的，比起前者我可以不断尝试，Touch ID 指纹的硬性破解几率几乎没有，因为不可能有五万多个人排队来一一解锁你的设备，况且 Touch ID 会拒绝第五次以后的尝试而要求输入密码。所以我们可以添加更加复杂的密码而不是简单的数字密码来进一步提高安全性。</p><h3 id="Touch-ID-指纹识别的原理"><a href="#Touch-ID-指纹识别的原理" class="headerlink" title="Touch ID 指纹识别的原理"></a>Touch ID 指纹识别的原理</h3><p>在如此快速的识别过程中，Home 按钮上的一圈金属环起到了感应手指的功能，通知 Touch ID 来读取指纹。Touch ID 置于该按钮中，传感器的厚度只有 170 微米，拥有 500 ppi 高分辨率，可读取极小的指纹细节。传感器可从皮肤皮下层指纹的一些小部分拍摄高分辨率图像，然后会分析该信息，根据三种基本指纹类型（弧形纹、箕形纹或斗形纹）将指纹分类，它会绘制比人眼不可见的纹路细节，确保指纹读取准确无误。</p><p><img src="/assets/images/tech/ios_data_protection_3.png" alt="touch id sensor"></p><p>Touch ID 可从 360 度方向读取指纹，随后创建指纹的某种数学表达式，并将其与已注册的数据进行比较，以确定是否匹配。如果匹配，便可替代密码来解锁设备或通过某个令牌。</p><p>此外，根据苹果官方的描述，Touch ID 会向以注册的指纹数据里持续的添加新的特征数据，随着时间的推移，这能不断提高匹配准确度，也能进一步的提高安全性。</p><p><img src="/assets/images/tech/ios_data_protection_4.png" alt="touch id ontouch"></p><p>除了上述的内容，苹果还加入可以一些有效的手段来进一步确保安全，例如设备再重新启动或者保持锁定 48 小时后，就只能通过密码而不是指纹来解锁设备。</p><h3 id="Secure-Enclave"><a href="#Secure-Enclave" class="headerlink" title="Secure Enclave"></a>Secure Enclave</h3><p>Apple声明指纹的图案不会被保存，存储于设备中的是指纹特征的数学表达式，而且从这些表达式不可能直接反推出指纹图像。</p><p><img src="/assets/images/tech/ios_data_protection_5.png" alt="touch-id-structure"></p><p>指纹的验证运算独立于主要处理器芯片（例如 A7、A8），芯片内有称为 “Secure Enclave” 的高级安全架构，专用于密码指纹数据，并使用 Secure Enclave 的专用密钥加密，以及每次启动以随机的 UID 进行管理。指纹数据仅能被 Secure Enclave 处理和使用，正因为此架构独立于其它设备部件，仅有 Touch ID 使用它，且不能将它用于匹配其他指纹数据库，所以存储的指纹数据不会由 iOS 或其他应用访问，也不会被存储到 Apple 服务器或备份到 iCloud 等地方。</p><p><img src="/assets/images/tech/ios_data_protection_6.png" alt="A7-Secure-Enclave"></p><p>从硬件上来看指纹特征数据尚不能被 “Secure Enclave” 和 Touch ID 以外的部件访问到，并且两者芯片互相隔离开来，所有软件都没有权利获得指纹数据，仅能得到指纹是否错误的回馈。因为架构的核心秘密仅仅只有苹果公司知道，所以目前几乎没有第三方软件可以访问到这部分敏感信息。</p><p>到此，关于 iOS 数据保护的问题暂时告一段落。欢迎大家评论指正。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;文件系统中的文件、keychain中的项，都是加密存储的。当用户解锁设备后，系统通过UDID密钥和用户设定的密码生成一个用于解密的密码密钥，存放在内存中，直到设备再次被锁，开发者可以通过Data Protection API 来设定文件系统中的文件、keychain中的项应该何时被解密。这个就是数据保护的内容。&lt;/p&gt;</summary>
    
    
    
    <category term="pieces" scheme="https://chars.tech/categories/pieces/"/>
    
    
    <category term="ios" scheme="https://chars.tech/tags/ios/"/>
    
    <category term="存储" scheme="https://chars.tech/tags/%E5%AD%98%E5%82%A8/"/>
    
    <category term="安全" scheme="https://chars.tech/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>MacOS 搭建 Tensorflow PyCharm 环境</title>
    <link href="https://chars.tech/2017-09-26-tensorflow-pycharm-mac/"/>
    <id>https://chars.tech/2017-09-26-tensorflow-pycharm-mac/</id>
    <published>2017-09-26T07:03:16.000Z</published>
    <updated>2018-12-06T14:19:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。目前来说，<a href="https://github.com/tensorflow/tensorflow">Github</a>上star最多的项目就是它了。</p><p>在这之前，笔者写过一篇简单的入门文章<a href="/blog/tensorflow-primer-guide/">《初探 TensorFlow》</a>。当时没能成功搭建环境，加上后期的工作原因，至此搁置了一段时间。今天，终于各种折腾，在自己的Mac上经过多种尝试之后，完美搭建成功。这里就把它分享出来，希望对大家有所帮助。</p><span id="more"></span><h2 id="基于-Anaconda-的安装"><a href="#基于-Anaconda-的安装" class="headerlink" title="基于 Anaconda 的安装"></a>基于 Anaconda 的安装</h2><p><a href="https://www.anaconda.com/">Anaconda</a> 是一个集成许多第三方科学计算库的 <code>Python</code> 科学计算环境,<code>Anaconda</code> 使用 <code>conda</code> 作为自己的包管理工具,同时具有自己的计算环境,类似 <code>Virtualenv</code>.</p><p>和 <code>Virtualenv</code> 一样,不同 <code>Python</code> 工程需要的依赖包,<code>conda</code> 将他们存储在不同的地方。 <code>TensorFlow</code> 上安装的 <code>Anaconda</code> 不会对之前安装的 <code>Python</code> 包进行覆盖.</p><ul><li>安装 <a href="https://www.anaconda.com/download/">Anaconda</a></li><li>建立一个 <code>conda</code> 计算环境</li><li>激活环境,使用 <code>conda</code> 安装 <code>TensorFlow</code></li><li>安装成功后,每次使用 <code>TensorFlow</code> 的时候需要激活 <code>conda</code> 环境</li></ul><h3 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda :"></a>安装 Anaconda :</h3><p>参考 Anaconda 的下载页面的<a href="https://www.anaconda.com/download/">指导</a></p><h3 id="建立环境"><a href="#建立环境" class="headerlink" title="建立环境"></a>建立环境</h3><p>建立一个 conda 计算环境名字叫<code>tensorflow</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Python 2.7</span><br><span class="line">$ conda create -n tensorflow python=2.7</span><br><span class="line"></span><br><span class="line"># Python 3.4</span><br><span class="line">$ conda create -n tensorflow python=3.4</span><br></pre></td></tr></table></figure><h3 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h3><p>激活<code>tensorflow</code>环境,然后使用其中的 <code>pip</code> 安装 <code>TensorFlow</code>. 当使用<code>easy_install</code>使用<code>--ignore-installed</code>标记防止错误的产生。</p><p><a href="https://www.tensorflow.org/install/install_mac#the_url_of_the_tensorflow_python_package">URL of the TensorFlow Python package</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ source activate tensorflow</span><br><span class="line">(tensorflow)$  # Your prompt should change</span><br><span class="line"></span><br><span class="line"># Ubuntu/Linux 64-bit, CPU only, Python 2.7:</span><br><span class="line">(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl</span><br><span class="line"></span><br><span class="line"># Ubuntu/Linux 64-bit, GPU enabled, Python 2.7. Requires CUDA toolkit 7.5 and CuDNN v4.</span><br><span class="line"># For other versions, see &quot;Install from sources&quot; below.</span><br><span class="line">(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl</span><br><span class="line"></span><br><span class="line"># Mac OS X, CPU only:</span><br><span class="line">(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-0.11.0rc0-py2-none-any.whl</span><br></pre></td></tr></table></figure><p>对于 Python 3.x :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ source activate tensorflow</span><br><span class="line">(tensorflow)$  # Your prompt should change</span><br><span class="line"></span><br><span class="line"># Ubuntu/Linux 64-bit, CPU only, Python 3.4:</span><br><span class="line">(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl</span><br><span class="line"></span><br><span class="line"># Ubuntu/Linux 64-bit, GPU enabled, Python 3.4. Requires CUDA toolkit 7.5 and CuDNN v4.</span><br><span class="line"># For other versions, see &quot;Install from sources&quot; below.</span><br><span class="line">(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl</span><br><span class="line"></span><br><span class="line"># Mac OS X, CPU only:</span><br><span class="line">(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0rc0-py3-none-any.whl</span><br></pre></td></tr></table></figure><p>conda 环境激活后,你可以测试:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt; import tensorflow as tf</span><br><span class="line">&gt;&gt;&gt; print(tf.__version__)</span><br><span class="line"># 0.11.0rc0</span><br></pre></td></tr></table></figure><h3 id="开启或关闭环境"><a href="#开启或关闭环境" class="headerlink" title="开启或关闭环境"></a>开启或关闭环境</h3><p>当你不用 TensorFlow 的时候,关闭环境:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(tensorflow)$ source deactivate</span><br><span class="line"></span><br><span class="line">$  # Your prompt should change back</span><br></pre></td></tr></table></figure><p>再次使用的时候再激活 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ source activate tensorflow</span><br><span class="line">(tensorflow)$  # Your prompt should change.</span><br><span class="line"># Run Python programs that use TensorFlow.</span><br><span class="line">...</span><br><span class="line"># When you are done using TensorFlow, deactivate the environment.</span><br><span class="line">(tensorflow)$ source deactivate</span><br></pre></td></tr></table></figure><h2 id="PyCharm-配置"><a href="#PyCharm-配置" class="headerlink" title="PyCharm 配置"></a>PyCharm 配置</h2><p><strong>重点：</strong>正确配置<code>Project</code>的<code>Interpreter</code>即可</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>Preferences</li><li>Project Interpreter</li><li>Click More</li></ul><h3 id="附图"><a href="#附图" class="headerlink" title="附图"></a>附图</h3><ul><li>打开Preferences</li></ul><p><img src="/assets/images/tech/tensorflow_pycharm_config_mac_1.png" alt="打开Preferences"></p><p><img src="/assets/images/tech/tensorflow_pycharm_config_mac_2.png" alt="选择more"></p><ul><li>打开Project Interpreters</li></ul><p><img src="/assets/images/tech/tensorflow_pycharm_config_mac_3.png" alt="选择正确的tensorflow路径"></p><ul><li>Demo运行结果</li></ul><p><img src="/assets/images/tech/tensorflow_pycharm_config_mac_4.png" alt="demo运行结果"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。目前来说，&lt;a href=&quot;https://github.com/tensorflow/tensorflow&quot;&gt;Github&lt;/a&gt;上star最多的项目就是它了。&lt;/p&gt;
&lt;p&gt;在这之前，笔者写过一篇简单的入门文章&lt;a href=&quot;/blog/tensorflow-primer-guide/&quot;&gt;《初探 TensorFlow》&lt;/a&gt;。当时没能成功搭建环境，加上后期的工作原因，至此搁置了一段时间。今天，终于各种折腾，在自己的Mac上经过多种尝试之后，完美搭建成功。这里就把它分享出来，希望对大家有所帮助。&lt;/p&gt;</summary>
    
    
    
    <category term="ml" scheme="https://chars.tech/categories/ml/"/>
    
    
    <category term="python" scheme="https://chars.tech/tags/python/"/>
    
    <category term="tensorflow" scheme="https://chars.tech/tags/tensorflow/"/>
    
    <category term="机器学习" scheme="https://chars.tech/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>iOS App 启动性能优化</title>
    <link href="https://chars.tech/2017-09-22-ios-app-launch-time-optimize/"/>
    <id>https://chars.tech/2017-09-22-ios-app-launch-time-optimize/</id>
    <published>2017-09-22T06:02:16.000Z</published>
    <updated>2019-04-08T01:55:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>应用启动时间，直接影响用户对一款应用的判断和使用体验。<code>ZAKER新闻</code>本身就包含非常多并且复杂度高的业务模块（如新闻、视频等），也接入了很多第三方的插件，这势必会拖慢应用的启动时间，本着精益求精的态度和对用户体验的追求，我们希望在业务扩张的同时最大程度的优化启动时间。</p><span id="more"></span><h2 id="启动时间"><a href="#启动时间" class="headerlink" title="启动时间"></a>启动时间</h2><p>总时间 &#x3D; T1 + T2</p><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>加载<code>系统dylib</code>和<code>可执行文件</code>的时间。</p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>从<code>main</code>到<code>applicationWillFinishLaunching</code>结束的时间。</p><h2 id="App启动过程"><a href="#App启动过程" class="headerlink" title="App启动过程"></a>App启动过程</h2><p><img src="/assets/images/tech/ios-app-launch-time-optimize-1.png" alt="App启动过程"></p><p>1）解析<code>Info.plist</code></p><ul><li>加载相关信息，例如如闪屏</li><li>沙箱建立、权限检查</li></ul><p>2）<code>Mach-O</code>加载</p><ul><li>如果是胖二进制文件，寻找合适当前CPU类别的部分</li><li>加载所有依赖的<code>Mach-O</code>文件（递归调用<code>Mach-O</code>加载的方法）</li><li>定位内部、外部指针引用，例如字符串、函数等</li><li>执行声明为<code>__attribute__((constructor))</code>的C函数</li><li>加载类扩展（Category）中的方法</li><li>C++静态对象加载、调用ObjC的<code>+load</code>函数</li></ul><p>3）程序执行</p><ul><li>调用<code>main()</code></li><li>调用<code>UIApplicationMain()</code></li><li>调用<code>applicationWillFinishLaunching</code></li></ul><h3 id="Mach-O"><a href="#Mach-O" class="headerlink" title="Mach-O"></a>Mach-O</h3><p>Mach-O 是针对不同运行时可执行文件的文件类型。</p><p><img src="/assets/images/tech/ios-app-launch-time-optimize-4.png" alt="Mach-O"></p><h4 id="文件类型："><a href="#文件类型：" class="headerlink" title="文件类型："></a>文件类型：</h4><p>Executable： 应用的主要二进制</p><p>Dylib： 动态链接库（又称 DSO 或 DLL）</p><p>Bundle： 不能被链接的 Dylib，只能在运行时使用 dlopen() 加载，可当做 macOS 的插件。</p><p>Image： executable，dylib 或 bundle</p><p>Framework： 包含 Dylib 以及资源文件和头文件的文件夹</p><h3 id="Mach-O-镜像文件"><a href="#Mach-O-镜像文件" class="headerlink" title="Mach-O 镜像文件"></a>Mach-O 镜像文件</h3><p>Mach-O 被划分成一些 segement，每个 segement 又被划分成一些 section。</p><p>segment 的名字都是大写的，且空间大小为页的整数。页的大小跟硬件有关，在 arm64 架构一页是 16KB，其余为 4KB。</p><p>section 虽然没有整数倍页大小的限制，但是 section 之间不会有重叠。</p><p>几乎所有 Mach-O 都包含这三个段（segment）： <code>__TEXT</code>,<code>__DATA</code> 和 <code>__LINKEDIT</code>：</p><ul><li><p><code>__TEXT</code> 包含 Mach header，被执行的代码和只读常量（如C 字符串）。只读可执行（r-x）。</p></li><li><p><code>__DATA</code> 包含全局变量，静态变量等。可读写（rw-）。</p></li><li><p><code>__LINKEDIT</code> 包含了加载程序的『元数据』，比如函数的名称和地址。只读（r–）。</p></li></ul><h3 id="Mach-O-Universal-文件"><a href="#Mach-O-Universal-文件" class="headerlink" title="Mach-O Universal 文件"></a>Mach-O Universal 文件</h3><p><a href="https://en.wikipedia.org/wiki/Fat_binary">FAT 二进制</a>文件，将多种架构的 Mach-O 文件合并而成。它通过 Fat Header 来记录不同架构在文件中的偏移量，Fat Header 占一页的空间。</p><p>按分页来存储这些 segement 和 header 会浪费空间，但这有利于虚拟内存的实现。</p><h3 id="什么是image"><a href="#什么是image" class="headerlink" title="什么是image"></a>什么是image</h3><p>1.executable可执行文件 比如.o文件。 </p><p>2.dylib 动态链接库 framework就是动态链接库和相应资源包含在一起的一个文件夹结构。 </p><p>3.bundle 资源文件 只能用dlopen加载，不推荐使用这种方式加载。</p><p>除了我们App本身的可行性文件，系统中所有的framework比如UIKit、Foundation等都是以动态链接库的方式集成进App中的。</p><h3 id="什么是ImageLoader"><a href="#什么是ImageLoader" class="headerlink" title="什么是ImageLoader"></a>什么是ImageLoader</h3><p>image 表示一个二进制文件(可执行文件或 so 文件)，里面是被编译过的符号、代码等，所以 ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。 </p><p>两步走：在程序运行时它先将动态链接的 image 递归加载 (也就是上面测试栈中一串的递归调用的时刻)。 再从可执行文件 image 递归加载所有符号。</p><h2 id="冷启动和热启动"><a href="#冷启动和热启动" class="headerlink" title="冷启动和热启动"></a>冷启动和热启动</h2><h3 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h3><p>应用首次启动。即后台线程中未有当前打开的应用，所有的资源都需要加载并初始化。</p><h3 id="热启动"><a href="#热启动" class="headerlink" title="热启动"></a>热启动</h3><p>应用非首次启动。即后台线程中保留有当前应用，应用的资源在内存中有保存。</p><h2 id="启动时间分析"><a href="#启动时间分析" class="headerlink" title="启动时间分析"></a>启动时间分析</h2><p>1）开启时间分析功能</p><p>在Xcode的菜单中选择<code>Project</code>→<code>Scheme</code>→<code>Edit Scheme...</code>，然后找到<code> Run</code> → <code>Environment Variables</code> →<code>+</code>，添加<code>name</code>为<code>DYLD_PRINT_STATISTICS</code> <code>value</code>为<code>1</code>的环境变量。</p><p><img src="/assets/images/tech/ios-app-launch-time-optimize-2.png" alt="开启时间分析功能"></p><p><img src="/assets/images/tech/ios-app-launch-time-optimize-3.png" alt="启动时间"></p><h3 id="load-dylibs-image"><a href="#load-dylibs-image" class="headerlink" title="load dylibs image"></a>load dylibs image</h3><p>在每个动态库的加载过程中， dyld需要：</p><p>1.分析所依赖的动态库</p><p>2.找到动态库的mach-o文件</p><p>3.打开文件</p><p>4.验证文件</p><p>5.在系统核心注册文件签名</p><p>6.对动态库的每一个segment调用mmap()</p><p>通常的，一个App需要加载100到400个dylibs， 但是其中的系统库被优化，可以很快的加载。 针对这一步骤的优化有：</p><p>1.减少非系统库的依赖</p><p>2.合并非系统库</p><p>3.使用静态资源，比如把代码加入主程序</p><h3 id="rebase-x2F-bind"><a href="#rebase-x2F-bind" class="headerlink" title="rebase&#x2F;bind"></a>rebase&#x2F;bind</h3><p>由于ASLR(address space layout randomization)的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这2步来修复镜像中的资源指针，来指向正确的地址。 rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。 </p><p>rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。</p><p>优化该阶段的关键在于减少__DATA segment中的指针数量。我们可以优化的点有：</p><p>1.减少Objc类数量， 减少selector数量</p><p>2.减少C++虚函数数量</p><p>3.转而使用swift stuct（其实本质上就是为了减少符号的数量）</p><h3 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h3><ul><li><code>main()</code>函数之前总共使用了506.48ms</li><li>在506.48ms中，加载动态库用了46.35ms，指针重定位使用了137.72ms，ObjC类初始化使用了95.39ms，各种初始化使用了226.92ms。</li><li>在初始化耗费的226.92ms中，用时最多的几个初始化是<code>libSystem.B.dylib</code>、<code>libBacktraceRecording.dylib</code>、<code>libglInterpose.dylib</code>以及<code>libMTLInterpose.dylib</code>。</li></ul><p>2）使用instruments工作分析具体时间消耗点</p><h2 id="耗时的影响因素"><a href="#耗时的影响因素" class="headerlink" title="耗时的影响因素"></a>耗时的影响因素</h2><p>1） <code>main()</code>函数之前耗时的影响因素</p><ul><li>动态库加载越多，启动越慢。</li><li>ObjC类越多，启动越慢</li><li>C的<code>constructor</code>函数越多，启动越慢</li><li>C++静态对象越多，启动越慢</li><li>ObjC的<code>+load</code>越多，启动越慢</li></ul><p>实验证明，在ObjC类的数目一样多的情况下，需要加载的动态库越多，App启动就越慢。同样的，在动态库一样多的情况下，ObjC的类越多，App的启动也越慢。需要加载的动态库从1个上升到10个的时候，用户几乎感知不到任何分别，但从10个上升到100个的时候就会变得十分明显。同理，100个类和1000个类，可能也很难查察觉得出，但1000个类和10000个类的分别就开始明显起来。</p><p>同样的，尽量不要写<code>__attribute__((constructor))</code>的C函数，也尽量不要用到C++的静态对象；至于ObjC的<code>+load</code>方法，似乎大家已经习惯不用它了。任何情况下，能用<code>dispatch_once()</code>来完成的，就尽量不要用到以上的方法。</p><p>2） <code>main()</code>函数之后耗时的影响因素</p><p>从<code>main()</code>函数开始至<code>applicationWillFinishLaunching</code>结束，我们统一称为<code>main()</code>函数之后的部分。</p><ul><li>执行<code>main()</code>函数的耗时</li><li>执行<code>applicationWillFinishLaunching</code>的耗时</li><li><code>rootViewController</code>及其<code>childViewController</code>的加载、<code>view</code>及其<code>subviews</code>的加载</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="移除不需要用到的类"><a href="#移除不需要用到的类" class="headerlink" title="移除不需要用到的类"></a>移除不需要用到的类</h3><p>为了解决这个历史问题，我使用了一个叫做<a href="https://github.com/dblock/fui">fui（Find Unused Imports）</a>的开源项目，它能很好的分析出不再使用的类，准确率非常高，唯一的问题是它处理不了动态库和静态库里提供的类，也处理不了C++的类模板。</p><p>使用方法是在<code>Terminal</code>中<code>cd</code>到项目所在的目录，然后执行<code>fui find</code>，然后等上那么几分钟（是的你没有看错，真的需要好几分钟甚至需要更长的时间），就可以得到一个列表了。由于这个工具还不是100%靠谱，可根据这个列表，在Xcode中手动检查并删除不再用到的类。</p><h3 id="移除不再使用的图片资源"><a href="#移除不再使用的图片资源" class="headerlink" title="移除不再使用的图片资源"></a>移除不再使用的图片资源</h3><p>通过 <a href="https://github.com/tinymind/LSUnusedResources">LSUnusedResources</a> 工具，扫描出项目中不再使用的图片资源。</p><h3 id="合并功能类似的类和扩展（Category）"><a href="#合并功能类似的类和扩展（Category）" class="headerlink" title="合并功能类似的类和扩展（Category）"></a>合并功能类似的类和扩展（Category）</h3><h3 id="优化application-didFinishLaunchingWithOptions-方法"><a href="#优化application-didFinishLaunchingWithOptions-方法" class="headerlink" title="优化application:didFinishLaunchingWithOptions:方法"></a>优化<code>application:didFinishLaunchingWithOptions:</code>方法</h3><h3 id="优化rootViewController加载"><a href="#优化rootViewController加载" class="headerlink" title="优化rootViewController加载"></a>优化<code>rootViewController</code>加载</h3><h3 id="瘦身-APP"><a href="#瘦身-APP" class="headerlink" title="瘦身 APP"></a>瘦身 APP</h3><h4 id="静态库瘦身"><a href="#静态库瘦身" class="headerlink" title="静态库瘦身"></a>静态库瘦身</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">example 1: </span><br><span class="line">lipo -info libWeChatSDK.a </span><br><span class="line"><span class="comment"># 瘦身静态库支持 arm64 指令集</span></span><br><span class="line">lipo libWeChatSDK.a -thin arm64 -output libWeChatSDK-arm64.a</span><br><span class="line">lipo libWeChatSDK.a -thin armv7s -output libWeChatSDK-armv7s.a</span><br><span class="line"><span class="comment"># 合并</span></span><br><span class="line">lipo -create libWeChatSDK-armv7s.a libWeChatSDK-arm64.a -output libWeChatSDK-device.a</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">example 2:</span><br><span class="line">lipo -info libBaiduMobStat.a</span><br><span class="line"><span class="comment"># 移除特定指令集</span></span><br><span class="line">lipo libBaiduMobStat.a -remove armv7s -output libBaiduMobStat-thin.a </span><br></pre></td></tr></table></figure><h4 id="设定-Xcode-配置"><a href="#设定-Xcode-配置" class="headerlink" title="设定 Xcode 配置"></a>设定 Xcode 配置</h4><ul><li><p>Build Settings-&gt;Optimization Leve Release 版应该选择Fastest, Smalllest</p></li><li><p>开启 BitCode</p></li><li><p>Build Settings-&gt;Valid Architectures中<br>删除 armv7(iphone 4s,3gs),armv7s(iphone 5)</p></li><li><p>Build Settings-&gt;Strip Linked Product &#x2F; Deployment Postprocessing &#x2F; Symbols Hidden by Default<br>在 Release 版本设为 YES</p></li><li><p>Build Settings（Levels选项内）-&gt;Genetate Debug Symbols<br>在 Release 版本设为 NO</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ARMv6：ARM11内核用于iPhone2G和iPhone3G中的架构</span><br><span class="line">ARMv7：modern ARM内核用于iPhone3GS和iPhone4/S中的架构</span><br><span class="line">ARMv7s：A6内核用于iPhone5中的架构</span><br><span class="line">ARM64：A7内核用于iPhone5S/C中的架构</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1）<code>NSUserDefaults</code>是否是瓶颈</p><p>2）还有其他哪些点可以做优化</p><p>参考文档：<a href="http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/">《优化 App 的启动时间》</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;应用启动时间，直接影响用户对一款应用的判断和使用体验。&lt;code&gt;ZAKER新闻&lt;/code&gt;本身就包含非常多并且复杂度高的业务模块（如新闻、视频等），也接入了很多第三方的插件，这势必会拖慢应用的启动时间，本着精益求精的态度和对用户体验的追求，我们希望在业务扩张的同时最大程度的优化启动时间。&lt;/p&gt;</summary>
    
    
    
    <category term="pieces" scheme="https://chars.tech/categories/pieces/"/>
    
    
    <category term="ios" scheme="https://chars.tech/tags/ios/"/>
    
    <category term="优化" scheme="https://chars.tech/tags/%E4%BC%98%E5%8C%96/"/>
    
    <category term="性能" scheme="https://chars.tech/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些设计iOS API需要知道的事</title>
    <link href="https://chars.tech/2017-07-09-ios-design-api-guide/"/>
    <id>https://chars.tech/2017-07-09-ios-design-api-guide/</id>
    <published>2017-07-09T14:32:33.000Z</published>
    <updated>2018-12-06T14:22:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了能够将我们项目中的代码能够在后续开发者使用（重用代码），通常使用的方法是将代码按照功能模块编写成API。那么我们就很有必要了解Objective-C语言中常见的编程范式（paradigm），同时还需了解各种可能碰到的陷阱。</p><span id="more"></span><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h3 id="命名冲突的问题"><a href="#命名冲突的问题" class="headerlink" title="命名冲突的问题"></a>命名冲突的问题</h3><p>Objective-C没有其他语言的那种内置命名空间（namespace）机制。因此，我们只能自己想办法来解决命名冲突问题。最常用的解决方式就是，仿照其他语言（C++）建立自己的namespace，例如，使用前缀。</p><p>所选前缀可以是与公司、应用程序或二者皆有关联之名。例如，ZAKER User Interface可以使用ZUI作为前缀。使用Cocoa创建应用程序时一定要注意，Apple宣称其保留使用所有“两字母前缀”(two-letter prefix)的权利，所以开发者选用的前缀应该是三个字母的。如果开发者使用了两个字母作前缀，那么很有可能开发者自定义的API和Apple的API冲突。</p><p>不仅仅是类名，应用程序中的所有名称都应该加前缀。如果要为既有类新增“分类”(category)，那么一定要给“分类”及“分类”中的方法加上前缀。另外，类的实现文件中所用的纯C函数及全局变量也应该注意添加前缀。</p><p>如果使用了第三方库编写自己的代码，并准备将其发布为程序库供他人开发应用程序所用，则尤其要注意重复符号问题。这种情况下为了避免使用者使用了与你相同的第三方库，应该为第三方库都加上你自己的前缀。</p><p><img src="/assets/images/tech/ios-design-api-guide-1.png" alt="第三方库引入使用前缀"></p><h3 id="命名方式"><a href="#命名方式" class="headerlink" title="命名方式"></a>命名方式</h3><p>类、方法和变量的命名是Objective-C编程的重要环节。如果命名方式好，可以提高代码可读性，减少不必要的注释。<br>初学者通常会觉得Objective-C是门很繁琐的语言，因为其语法结构使得代码读起来和句子一样。命名中一般都带有“in”、“for”、“with”等介词，特别是在命名时还要讲究英文语法。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *text = @&quot;This is a good idea.&quot;;</span><br><span class="line">NSString *newText = [text stringByReplacingOccurrencesOfString:@&quot;idea&quot; withString:@&quot;think&quot;];</span><br></pre></td></tr></table></figure><p>上面的代码虽然用了比较啰嗦的方式描述一个看上去很简单的表达式。对于执行替换的那个方法，代码读起来就像日常语言里的那个句子：“Take text and give me a new string by replacing the occurrences of the string ‘idea’ with the string ‘think’”。<br>这个句子准确描述了开发者想做的事。在命名不像Objective-C这般繁琐的语言中，类似的程序可能会写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string text = &quot;This is a good idea.&quot;;</span><br><span class="line">string new Text = text.replace(&quot;idea&quot;, &quot;think&quot;);</span><br></pre></td></tr></table></figure><p>上面代码这样写，看起来方法名简洁很多，但是带来的代码不可读性却是非常大的。首先，我们不知道 text.replace 方法的两个参数到底按照什么顺序解读（除非查看方法声明）；再者，这两个参数谁替换谁？</p><p>另外，和大多数语言一样，Objective-C也是采用“驼峰式大小写命名法”（camel casing）——以小写字母开头，其后每个单词首字母大写。</p><h4 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h4><p>清晰的方法名从左至右读起来好似一段文章。并不是说非得按照那些命名规则来给方法起名，不过这样做可以令代码变得更好维护，使他人更容易读懂。<br>虽然类似C++或Java中那种函数命名简单，但是，若想知道每个参数的用途，就得查看函数原型，这会令代码难于读懂。<br>NSString这个类展示了一套良好的命名习惯。下面列举几个方法及命名缘由：</p><p>1）<code>+ (instancetype)string;</code><br>工厂方法（factory method），用于创建新的空字符串。方法名清晰地描述了返回值的类型。</p><p>2）<code>+ (instancetype)stringWithString:(NSString *)string;</code><br>工厂方法，根据某字符串创建出与之内容相同的新字符串。与创建空字符串所用的那个工厂方法一样，方法名的第一个单词也指明了返回类型。</p><p>3）<code>+ (instancetype)localizedStringWithFormat:(NSString *)format, ...;</code><br>工厂方法，根据特定格式创建出新的“本地化字符串”（localized string）。返回值类型是方法名的第二个单词（string），因为其前面还有个修饰语（localized）用来描述其逻辑含义。此方法的返回值依然是“字符串”（string），只不过是一种经过本地化处理的特殊字符串。</p><p>4）<code>- (NSUInteger)lengthOfBytesUsingEncoding:(NSStringEncoding)enc;</code><br>若字符串是以给定的编码格式（ASCII、UTF8、UTF16）来编码的，则返回其字节数组长度。此方法与length相似，但该方法还需一个参数，该参数紧跟着方法名中描述其类型的那个名词（encoding）。</p><p>因此，我们可以总结成几条方法命名规则：</p><p>1）如果方法的返回值是新创建的，那么方法名的首个词应该是返回值的类型，除非前面还有修饰语，例如localizedString。属性的存取方法不遵循这种命名方式，因为一般认为这些方法不会创建新对象。即便有时返回内部对象的一份拷贝，我们也认为那相当于原有对象。这些存取方法应该按照其所对应的属性来命名。</p><p>2）应该把表示参数类型的名词放在参数前面。</p><p>3）如果方法要在当前对象上执行操作，那么就应该包含动词；若执行操作时还需要参数，则应该在动词后面加上一个或多个名词。</p><p>4）不要使用str这种简称，应该使用string这样的全称。</p><p>5）boolean属性应加is前缀。如果某方法返回非属性的boolean值，那么应该根据其功能，选用has或is当前缀。</p><p>6）将get这个前缀留给那些借由“输出参数”来保存返回值的方法，比如说，把返回值填充到“C语言式数组”（C-style array）里的那种方法就可以使用这个词做前缀。</p><h4 id="类与协议命名"><a href="#类与协议命名" class="headerlink" title="类与协议命名"></a>类与协议命名</h4><p>不仅仅是方法，类和协议也应该加上前缀，避免命名空间冲突。例如：</p><ul><li>UIView</li><li>UIViewController</li><li>UITableViewDelegate</li></ul><h2 id="错误模型"><a href="#错误模型" class="headerlink" title="错误模型"></a>错误模型</h2><p>目前有很多编程语言都有“异常”(exception)机制，Objective-C也不例外。</p><p>“自动引用计数”(ARC, Automatic Reference Counting)在默认情况下不是“异常安全的”。这意味着：如果抛出异常，那么本应该在作用域末尾释放的对象现在却不会自动释放了。如果想生成“异常安全”的代码，可以通过设置编译器的标志来实现，不过这将引入额外代码，在不抛出异常时，也照样要执行这部分代码。需要打开的编译器标志叫做<code>-fobjc-arc-exception</code>。</p><p>Objective-C现在所采用的办法是：只在极其罕见的情况下抛出异常，异常抛出之后，无须考虑恢复问题，而且应用程序此时也应该退出。这就是说，不用再编写复杂的“异常安全”代码了。</p><p>异常只应该用于极其严重的错误，比如，你编写了某个抽象基类，它的正确用法是先从中继承一个子类，然后使用这个子类。在这种情况下，如果有人直接使用了这个抽象基类，那么可以考虑抛出异常。与其他语言不同，Objective-C中没办法将某个类标识为“抽象类”。要想达成类似效果，最好的办法是在那些子类必须覆写的超类方法里抛出异常。</p><p>异常只用于处理严重错误(fatal error)，对于其他错误，Objective-C语言所用的编程范式为：令方法返回nil&#x2F;0，或使用NSError，以表明有错误发生。</p><p>NSError对象里封装了三条信息：</p><ul><li>Error domain (错误范围，其类型为字符串)</li></ul><p>错误发生的范围，也就是产生错误的根源，通常用一个特有的全局变量来定义。例如，URL-handling-subsystem，在从URL中解析或获取数据时如果出错了，那么就使用NSURLErrorDomain来表示错误范围。</p><ul><li>Error code (错误码，其类型为整数)</li></ul><p>独有的错误码，用以指明在某个范围内具体发生了何种错误。某个特定范围内可能会发生一系列相关错误，这些错误情况通常采用enum来定义。</p><ul><li>User info (用户信息，其类型为字典)</li></ul><p>有关此错误的额外信息，其中或许包含一段“本地化描述”，或许还包含有导致该错误发生的另外一个错误，经由此种信息，可将相关错误串成一条“错误链”。</p><h2 id="使用不可变对象"><a href="#使用不可变对象" class="headerlink" title="使用不可变对象"></a>使用不可变对象</h2><p>设计类的时候，应充分使用属性来封装数据。而在使用属性时，则可将其声明为<code>readonly</code>。默认情况下，属性是<code>readwrite</code>。</p><p>因为如果把可变对象(mutable object)放入collection之后又修改其内容，那么很容易就会破坏set的内部数据结构，使其失去固有的语义。故此，我们应该尽量减少对象中的可变内容。具体到编程实践中，则应该尽量把对外公布出来的属性设为<code>readonly</code>，而且只在有必要时才将属性对外公布。</p><p>定义类的公共API时，需要注意，对象里表示各种collection的那些属性究竟应该设成可变的，还是不可变的。如果某个属性可以为外界所增删，那么这个属性就需要用可变的set来实现。在这种情况下，通常应该提供一个readonly属性供外界使用，该属性将返回不可变的set，而此set则是内部那个可变set的一份拷贝。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">//  ZKRPointOfInterest.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ZKRPointOfInterest : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy, readonly) NSString *identifier;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *title;</span><br><span class="line">@property (nonatomic, assign, readonly) CGFloat latitude;</span><br><span class="line">@property (nonatomic, assign, readonly) CGFloat longitude;</span><br><span class="line">@property (nonatomic, strong, readonly) NSSet *locations;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithIdentifier:(NSString *)identifier</span><br><span class="line">                             title:(NSString *)title</span><br><span class="line">                          latitude:(CGFloat)latitude</span><br><span class="line">                         longitude:(CGFloat)longitude;</span><br><span class="line"></span><br><span class="line">- (void)addLocation:(ZKRPointOfInterest *)location;</span><br><span class="line">- (void)removeLocation:(ZKRPointOfInterest *)location;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  ZKRPointOfInterest.m</span><br><span class="line"></span><br><span class="line">#import &quot;ZKRPointOfInterest.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZKRPointOfInterest</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableSet *_internalLocations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithIdentifier:(NSString *)identifier</span><br><span class="line">                             title:(NSString *)title</span><br><span class="line">                          latitude:(CGFloat)latitude</span><br><span class="line">                         longitude:(CGFloat)longitude</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSSet *)locations</span><br><span class="line">&#123;</span><br><span class="line">    return [_internalLocations copy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addLocation:(ZKRPointOfInterest *)location</span><br><span class="line">&#123;</span><br><span class="line">    if (location) &#123;</span><br><span class="line">        [_internalLocations addObject:location];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeLocation:(ZKRPointOfInterest *)location</span><br><span class="line">&#123;</span><br><span class="line">    [_internalLocations removeObject:location];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>不要在返回的对象上查询类型以确定其是否可变。(即使不用<code>isKindOfClass:</code>方法来判断返回值类型是否可变)</p><h2 id="description方法"><a href="#description方法" class="headerlink" title="description方法"></a>description方法</h2><p>在调试程序时，经常需要打印并查看对象信息。一种办法是编写代码把对象的全部属性都log到日志中。<code>NSLog(@&quot;object=%@&quot;, object);</code></p><p>在构建需要打印到日志的字符串时，object对象会收到description消息，该方法所返回的描述信息将取代“格式字符串”(format string)里的“%@”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *obj = @[@&quot;A string&quot;, @(123)];</span><br><span class="line">NSLog(@&quot;object=%@&quot;, obj);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object=(</span><br><span class="line">&quot;A string&quot;,</span><br><span class="line">123</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果在自定义类上这么做，那么则输出的信息却是如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object=&lt;ZKRSqure: 0x7656d8a90060&gt;</span><br></pre></td></tr></table></figure><p>如果想要像上面NSArray那样打印出有用的信息，那么我们就应该在自己的类中覆写description方法，否则打印信息时就会调用NSObject类所实现的默认方法。此方法定义在NSObject协议里，不过NSObject类也实现了它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)description</span><br><span class="line">&#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;&lt;%@: %p, \&quot;%f %f\&quot;&gt;&quot;, [self class], self, _width, _height];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZKRRectangle *rectangle = [[ZKRRectangle alloc] initWithWidth:5.0 height:7.0];</span><br><span class="line">NSLog(@&quot;%@&quot;, rectangle);</span><br><span class="line"></span><br><span class="line">//Output</span><br><span class="line">&lt;ZKRRectangle: 0x60000002fc20, &quot;5.000000 7.000000&quot;&gt;</span><br></pre></td></tr></table></figure><p>NSObject协议中还有个需要注意的方法，就是<code>debugDescription</code>，此方法用意与<code>description</code>相似。二者区别在于，<code>debugDescription</code>方法是开发者在调试器(debugger)中以控制台命令打印对象时才调用的。在NSObject类的默认实现中，它只是直接调用<code>description</code>。</p><h2 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h2><p>所有对象均要初始化，在初始化时，有些对象可能无须开发者向其提供额外信息，不过一般来说还是需要提供的。通常情况下，对象若不知道必要的信息，则无法完成其工作。例如，UITAbleViewCell类初始化该类对象时，需要指明其样式及标识符，标识符能够区分不同类型的单元格。由于这种对象的创建成本较高，所以绘制表格时可依照标识符来复用，以提升程序效率。这种可为对象提供必要信息以便其能完成工作的初始化方法叫做“全能初始化方法”(designated initializer)。</p><p>如果创建类实例的方式不止一种，那么这个类就会有多个初始化方法。但是，我们仍然需要选定一个作为全能初始化方法，令其他初始化方法都来调用它。例如，NSDate类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init NS_DESIGNATED_INITIALIZER;</span><br><span class="line">- (instancetype)initWithTimeIntervalSinceReferenceDate:(NSTimeInterval)ti NS_DESIGNATED_INITIALIZER;</span><br><span class="line">- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;</span><br><span class="line">- (instancetype)initWithTimeIntervalSinceNow:(NSTimeInterval)secs;</span><br><span class="line">- (instancetype)initWithTimeIntervalSince1970:(NSTimeInterval)secs;</span><br><span class="line">- (instancetype)initWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date;</span><br></pre></td></tr></table></figure><p>在上面几个初始化方法中，<code>initWithTimeIntervalSinceReferenceDate:</code>是全能初始化方法。只有在全能初始化方法中，才会存储内部数据。这样的话，当底层数据存储机制改变时，只需修改此方法的代码就好，无须改动其他初始化方法。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">//  ZKRRectangle.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ZKRRectangle : NSObject&lt;NSCopying&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readonly) CGFloat width;</span><br><span class="line">@property (nonatomic, assign, readonly) CGFloat height;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  ZKRRectangle.m</span><br><span class="line"></span><br><span class="line">#import &quot;ZKRRectangle.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZKRRectangle</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _width = [[aDecoder decodeObjectForKey:@&quot;width&quot;] floatValue];</span><br><span class="line">        _height = [[aDecoder decodeObjectForKey:@&quot;height&quot;] floatValue];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithWidth:height: instad.&quot; userInfo:nil];</span><br><span class="line">    </span><br><span class="line">    return [self initWithWidth:0 height:0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _width = width;</span><br><span class="line">        _height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  ZKRSquare.h</span><br><span class="line"></span><br><span class="line">#import &quot;ZKRRectangle.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ZKRSquare : ZKRRectangle</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithDimension:(CGFloat)dimension;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  ZKRSquare.m</span><br><span class="line"></span><br><span class="line">#import &quot;ZKRSquare.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZKRSquare</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithDimension: instad.&quot; userInfo:nil];</span><br><span class="line">    </span><br><span class="line">    return [self initWithDimension:0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithDimension:(CGFloat)dimension</span><br><span class="line">&#123;</span><br><span class="line">    return [super initWithWidth:dimension height:dimension];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height</span><br><span class="line">&#123;</span><br><span class="line">    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithDimension: instad.&quot; userInfo:nil];</span><br><span class="line">    CGFloat dimension = MIN(width, height);</span><br><span class="line">    return [self initWithDimension:dimension];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均调用此方法。</li><li>若全能方法于超类不同，则需要覆写超类中的对应方法。</li><li>如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。</li></ul><h2 id="NSCopying协议"><a href="#NSCopying协议" class="headerlink" title="NSCopying协议"></a>NSCopying协议</h2><p>使用对象时经常需要拷贝它。在Objective-C中，此操作通过copy方法完成。如果想令自己的类支持拷贝操作，那就要实现NSCopying协议，该协议只有一个方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)copyWithZone:(nullable NSZone *)zone;</span><br></pre></td></tr></table></figure><p>为什么会出现NSZone呢？因为以前开发程序时，会据此把内容分成不同的“区”(zone)，而对象会创建在某个区里面。现在不用了，每个程序只有一个区：“默认区”(default zone)。所以说，尽管必须实现这个方法，但是你不必担心其中的zone参数。</p><p>copy方法由NSObject实现，该方法只是以“默认区”为参数来调用<code>copyWithZone:</code>。我们总是想覆写copy方法，其实真正需要实现的是<code>copyWithZone:</code>方法。若想使某个类支持拷贝功能，只需声明该类遵从NSCopying协议，并实现其中的那个方法即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (id)copyWithZone:(NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    ZKRRectangle *copy = [[[self class] allocWithZone:zone] initWithWidth:_width height:_height];</span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说到copy方法，除了NSString这样的不可变类型的copy，与之类似的还有NSMutableString类的<code>mutableCopy</code>方法。与<code>copyWithZone:</code>方法相对应的可变内容的copy方法<code>mutableCopyWithZone:</code>方法来自于<code>NSMutableCopying</code>协议。如果你的类分为可变版本(mutable)与不可变版本(immutable)，那么就应该实现NSMutableCopying协议。若采用此模式，则在可变类中覆写<code>copyWithZone:</code>方法时，不要返回可变的拷贝，而应该返回一份不可变的版本。无论当前实例是否可变，需要获取其可变版本的拷贝，均应调用mutableCopy方法；获取不可变版本的拷贝，则总应该通过copy方法。</p><p><img src="/assets/images/tech/ios-design-api-guide-2.png" alt="mutableCopy和copy类"></p><p>深拷贝就是在拷贝对象自身时，将其底层数据也一并复制过去。<br>浅拷贝就是在拷贝对象时，只拷贝容器对象本身，而不复制其中数据。</p><p><img src="/assets/images/tech/ios-design-api-guide-3.png" alt="深拷贝和浅拷贝比较"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了能够将我们项目中的代码能够在后续开发者使用（重用代码），通常使用的方法是将代码按照功能模块编写成API。那么我们就很有必要了解Objective-C语言中常见的编程范式（paradigm），同时还需了解各种可能碰到的陷阱。&lt;/p&gt;</summary>
    
    
    
    <category term="pieces" scheme="https://chars.tech/categories/pieces/"/>
    
    
    <category term="objc" scheme="https://chars.tech/tags/objc/"/>
    
    <category term="ios" scheme="https://chars.tech/tags/ios/"/>
    
    <category term="框架" scheme="https://chars.tech/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>从iOS的图片圆角想到渲染</title>
    <link href="https://chars.tech/2017-07-03-ios-corner-radius/"/>
    <id>https://chars.tech/2017-07-03-ios-corner-radius/</id>
    <published>2017-07-03T06:40:56.000Z</published>
    <updated>2018-12-06T14:26:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>圆角是一种很常见的视图效果，相比于直角，它更加柔和优美，易于接受。设置圆角会带来一定的性能损耗，如何提高性能是一个需要重点讨论的话题。</p><p>大家常见的圆角代码<code>x.layer.cornerRadius = xx; x.clipsToBounds = YES;</code>这两行确实实现了圆角视觉效果。其实使用<code>x.layer.cornerRadius = xx;</code>已经实现了圆角，只不过在某些控件是不生效的，因为某些图层在被切割圆角图层之上而被显示出来了。而<code>x.clipsToBounds = YES;</code>带来的后果就是产生<code>离屏渲染</code>。可以使用instruments中的CoreAnimation工具，打开<code>Color Offscren-Rednered Yellow</code>选项，可见黄色区域部分即是离屏渲染部分。</p><p>那么离屏渲染会带来什么？当然后资源损耗，可能产生卡顿。因为在iPhone设备的硬件资源有差异，当离屏渲染不多时，并不是很明显感觉到它的缺点。</p><span id="more"></span><h2 id="什么是像素"><a href="#什么是像素" class="headerlink" title="什么是像素"></a>什么是像素</h2><p>像素，为视频显示的基本单位，译自英文“pixel”，pix是英语单词picture的常用简写，加上英语单词“元素”element，就得到pixel，故“像素”表示“画像元素”之意，有时亦被称为pel（picture element）。每个这样的消息元素不是一个点或者一个方块，而是一个抽象的取样。像素是由红，绿，蓝三种颜色组件构成的。因此，位图数据有时也被叫做 RGB 数据。</p><h2 id="显示机制"><a href="#显示机制" class="headerlink" title="显示机制"></a>显示机制</h2><p>一个像素是如何绘制到屏幕上去的？有很多种方式将一些东西映射到显示屏上，他们需要调用不同的框架、许多功能和方法的结合体。这里我们大概看一下屏幕之后发生的事情。</p><p>图像想显示到屏幕上使人肉眼可见都需借助像素的力量。它们密集的排布在手机屏幕上，将任何图形通过不同的色值表现出来。计算机显示的流程大致可以描述为将图像转化为一系列像素点的排列然后打印在屏幕上，由图像转化为像素点的过程又可以称之为光栅化，就是从矢量的点线面的描述，变成像素的描述。</p><p><img src="/assets/images/tech/ios-corner-radius-display-screen.png" alt="display screen"></p><p>回溯历史，可以从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。</p><h3 id="关于卡顿的简单原理解释"><a href="#关于卡顿的简单原理解释" class="headerlink" title="关于卡顿的简单原理解释"></a>关于卡顿的简单原理解释</h3><p>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p><p>CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p><h2 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h2><p>当像素映射到屏幕上的时候，后台发生了很多事情。但一旦它们显示到屏幕上，每一个像素均由三个颜色组件构成：红，绿，蓝。三个独立的颜色单元会根据给定的颜色显示到一个像素上。在 iPhoneSE 的显示器上有1,136×640&#x3D;727,040个像素，因此有2,181,120个颜色单元。在一些Retina屏幕上，这一数字将达到百万以上。所有的图形堆栈一起工作以确保每次正确的显示。当你滚动整个屏幕的时候，数以百万计的颜色单元必须以每秒60次的速度刷新，这就是一个很大的工作量。</p><p>简单来说，iOS的显示机制大致如此：<br><img src="/assets/images/tech/ios-corner-radius-pixels-software-stack.png" alt="pixels software stack"></p><p>Display 的上一层便是图形处理单元 GPU，GPU 是一个专门为图形高并发计算而量身定做的处理单元。这也是为什么它能同时更新所有的像素，并呈现到显示器上。它的并发本性让它能高效的将不同纹理合成起来。所以，开发中我们应该尽量让CPU负责主线程的UI调动，把图形显示相关的工作交给GPU来处理。</p><p>GPU Driver 是直接和 GPU 交流的代码块。不同的GPU是不同的性能怪兽，但是驱动使它们在下一个层级上显示的更为统一，典型的下一层级有 OpenGL&#x2F;OpenGL ES.</p><p>OpenGL(Open Graphics Library) 是一个提供了 2D 和 3D 图形渲染的 API。GPU 是一块非常特殊的硬件，OpenGL 和 GPU 密切的工作以提高GPU的能力，并实现硬件加速渲染。</p><p>OpenGL 之上扩展出很多东西。在 iOS 上，几乎所有的东西都是通过 Core Animation 绘制出来，然而在 OS X 上，绕过 Core Animation 直接使用 Core Graphics 绘制的情况并不少见。对于一些专门的应用，尤其是游戏，程序可能直接和 OpenGL&#x2F;OpenGL ES 交流。</p><p>需要强调的是，GPU 是一个非常强大的图形硬件，并且在显示像素方面起着核心作用。它连接到 CPU。从硬件上讲两者之间存在某种类型的总线，并且有像 OpenGL，Core Animation 和 Core Graphics 这样的框架来在 GPU 和 CPU 之间精心安排数据的传输。为了将像素显示到屏幕上，一些处理将在 CPU 上进行。然后数据将会传送到 GPU，最终像素显示到屏幕上。</p><p><img src="/assets/images/tech/ios-corner-radius-pixels-hardware.png" alt="pixels hardware"></p><p>正如上图显示，GPU 需要将每一个 frame 的纹理(位图)合成在一起(一秒60次)。每一个纹理会占用 VRAM(video RAM)，所以需要给 GPU 同时保持纹理的数量做一个限制。GPU 在合成方面非常高效，但是某些合成任务却比其他更复杂，并且 GPU在 16.7ms(1&#x2F;60s)内能做的工作也是有限的。</p><p>另外一个问题就是将数据传输到 GPU 上。为了让 GPU 访问数据，需要将数据从 RAM 移动到 VRAM 上。这就是提及到的上传数据到 GPU。这些看起来貌似微不足道，但是一些大型的纹理却会非常耗时。</p><p>最终，CPU 开始运行程序。你可能会让 CPU 从 bundle 加载一张 PNG 的图片并且解压它。这所有的事情都在 CPU 上进行。然后当你需要显示解压缩后的图片时，它需要以某种方式上传到 GPU。一些看似平凡的，比如显示文本，对 CPU 来说却是一件非常复杂的事情，这会促使 Core Text 和 Core Graphics 框架更紧密的集成来根据文本生成一个位图。一旦准备好，它将会被作为一个纹理上传到 GPU 并准备显示出来。当你滚动或者在屏幕上移动文本时，同样的纹理能够被复用，CPU 只需简单的告诉 GPU 新的位置就行了,所以 GPU 就可以重用存在的纹理了。CPU 并不需要重新渲染文本，并且位图也不需要重新上传到 GPU。</p><p>在图形世界中，合成是一个描述不同位图如何放到一起来创建你最终在屏幕上看到图像的过程。屏幕上一切事物皆纹理。一个纹理就是一个包含 RGBA 值的长方形，比如，每一个像素里面都包含红、绿、蓝和透明度的值。在 Core Animation 世界中这就相当于一个 CALayer。</p><p>每一个 layer 是一个纹理，所有的纹理都以某种方式堆叠在彼此的顶部。对于屏幕上的每一个像素，GPU 需要算出怎么混合这些纹理来得到像素 RGB 的值。这就是合成。</p><p>如果我们所拥有的是一个和屏幕大小一样并且和屏幕像素对齐的单一纹理，那么屏幕上每一个像素相当于纹理中的一个像素，纹理的最后一个像素也就是屏幕的最后一个像素。</p><p>如果我们有第二个纹理放在第一个纹理之上，然后GPU将会把第二个纹理合成到第一个纹理中。有很多种不同的合成方法，但是如果我们假定两个纹理的像素对齐，并且使用正常的混合模式，我们便可以用公式来计算每一个像素：<code>R = S + D * ( 1 – Sa )</code><br>结果的颜色是源色彩(顶端纹理)+目标颜色(低一层的纹理)*(1-源颜色的透明度)。在这个公式中所有的颜色都假定已经预先乘以了它们的透明度。</p><p>接着我们进行第二个假定，两个纹理都完全不透明，比如 alpha&#x3D;1。如果目标纹理(低一层的纹理)是蓝色(RGB&#x3D;0,0,1)，并且源纹理(顶层的纹理)颜色是红色(RGB&#x3D;1,0,0)，因为 Sa 为1，所以结果为：<code>R = S</code><br>结果是源颜色的红色。这正是我们所期待的(红色覆盖了蓝色)。如果源颜色层为50%的透明，比如 alpha&#x3D;0.5，既然 alpha 组成部分需要预先乘进 RGB 的值中，那么 S 的 RGB 值为(0.5, 0, 0)，公式看起来便会像这样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                       0.5   0               0.5</span><br><span class="line">R = S + D * (1 - Sa) = 0   + 0 * (1 - 0.5) = 0</span><br><span class="line">                       0     1               0.5</span><br></pre></td></tr></table></figure><p>我们最终得到RGB值为(0.5, 0, 0.5),是一个紫色。这正是我们所期望将透明红色合成到蓝色背景上所得到的。</p><p>记住我们刚刚只是将纹理中的一个像素合成到另一个纹理的像素上。当两个纹理覆盖在一起的时候，GPU需要为所有像素做这种操作。正如你所知道的一样，许多程序都有很多层，因此所有的纹理都需要合成到一起。尽管GPU是一块高度优化的硬件来做这种事情，但这还是会让它非常忙碌。</p><h3 id="为何图片缩放会增加GPU工作量"><a href="#为何图片缩放会增加GPU工作量" class="headerlink" title="为何图片缩放会增加GPU工作量"></a>为何图片缩放会增加GPU工作量</h3><p>当所有的像素是对齐的时候我们得到相对简单的计算公式。每当 GPU 需要计算出屏幕上一个像素是什么颜色的时候，它只需要考虑在这个像素之上的所有 layer 中对应的单个像素，并把这些像素合并到一起。或者，如果最顶层的纹理是不透明的(即图层树的最底层)，这时候 GPU 就可以简单的拷贝它的像素到屏幕上。</p><p>当一个 layer 上所有的像素和屏幕上的像素完美的对应整齐，那这个 layer 就是像素对齐的。主要有两个原因可能会造成不对齐。第一个便是滚动，当一个纹理上下滚动的时候，纹理的像素便不会和屏幕的像素排列对齐。另一个原因便是当纹理的起点不在一个像素的边界上。</p><p>在这两种情况下，GPU 需要再做额外的计算。它需要将源纹理上多个像素混合起来，生成一个用来合成的值。当所有的像素都是对齐的时候，GPU 只剩下很少的工作要做。</p><p>Core Animation 工具和模拟器有一个<code>Color Misaligned Images </code>选项，当这些在你的 CALayer 实例中发生的时候，这个功能便可向你展示。</p><p>关于iOS设备的一些尺寸限制可以看这里：<a href="http://iosres.com/">iOSRes</a></p><h2 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h2><p>On-Screen Rendering意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。<br>Off-Screen Rendering意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p><p>当图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制时，屏幕外渲染就被唤起了。屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。</p><p>离屏渲染可以被 Core Animation 自动触发，或者被应用程序强制触发。屏幕外的渲染会合并&#x2F;渲染图层树的一部分到一个新的缓冲区，然后该缓冲区被渲染到屏幕上。</p><h3 id="特殊的“离屏渲染”：CPU渲染"><a href="#特殊的“离屏渲染”：CPU渲染" class="headerlink" title="特殊的“离屏渲染”：CPU渲染"></a>特殊的“离屏渲染”：CPU渲染</h3><p>如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。<br>整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。</p><h3 id="离屏渲染的体现"><a href="#离屏渲染的体现" class="headerlink" title="离屏渲染的体现"></a>离屏渲染的体现</h3><p>相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：</p><ul><li>1 创建新缓冲区<br>要想进行离屏渲染，首先要创建一个新的缓冲区。</li><li>2 上下文切换<br>离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。</li></ul><h3 id="触发离屏渲染"><a href="#触发离屏渲染" class="headerlink" title="触发离屏渲染"></a>触发离屏渲染</h3><p>1、drawRect<br>2、layer.shouldRasterize &#x3D; true;<br>3、有mask或者是阴影(layer.masksToBounds, layer.shadow*)；<br> 3.1) shouldRasterize（光栅化）<br> 3.2) masks（遮罩）<br> 3.3) shadows（阴影）<br> 3.4) edge antialiasing（抗锯齿）<br> 3.5) group opacity（不透明）<br>4、Text（UILabel, CATextLayer, Core Text, etc）…<br>注：layer.cornerRadius，layer.borderWidth，layer.borderColor并不会Offscreen Render，因为这些不需要加入Mask。</p><h2 id="圆角优化"><a href="#圆角优化" class="headerlink" title="圆角优化"></a>圆角优化</h2><p>前面说了那么多，这里就给上实际可行方案。圆角的优化目前考虑两方面：一是，从图片入手，将图片切割成指定圆角样式。二是，使用贝塞尔曲线，利用CALayer层绘制指定圆角样式的mask遮盖View。</p><p>UIImage切割：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);</span><br><span class="line">CGContextScaleCTM(context, 1, -1);</span><br><span class="line">CGContextTranslateCTM(context, 0, -rect.size.height);</span><br><span class="line"></span><br><span class="line">CGFloat minSize = MIN(self.size.width, self.size.height);</span><br><span class="line">if (borderWidth &lt; minSize / 2.0) &#123;</span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectInset(rect, borderWidth, borderWidth) byRoundingCorners:corners cornerRadii:CGSizeMake(radius, borderWidth)];</span><br><span class="line">    CGContextSaveGState(context);</span><br><span class="line">    [path addClip];</span><br><span class="line">    CGContextDrawImage(context, rect, self.CGImage);</span><br><span class="line">    CGContextRestoreGState(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">image = [image dd_imageByCornerRadius:radius borderedColor:borderColor borderWidth:borderWidth corners:corners];</span><br><span class="line">UIGraphicsEndImageContext();</span><br></pre></td></tr></table></figure><p>图片绘制：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);</span><br><span class="line">[self drawAtPoint:CGPointZero];</span><br><span class="line">CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);</span><br><span class="line">CGFloat strokeInset = borderWidth / 2.0;</span><br><span class="line">CGRect strokeRect = CGRectInset(rect, strokeInset, strokeInset);</span><br><span class="line">UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:strokeRect byRoundingCorners:corners cornerRadii:CGSizeMake(radius, borderWidth)];</span><br><span class="line">path.lineWidth = borderWidth;</span><br><span class="line">[borderColor setStroke];</span><br><span class="line">[path stroke];</span><br><span class="line">UIImage *result = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br></pre></td></tr></table></figure><p>具体源码可以转至github进行star <a href="https://github.com/charsdavy/DDCornerRadius">DDCornerRadius</a> 欢迎issue。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;圆角是一种很常见的视图效果，相比于直角，它更加柔和优美，易于接受。设置圆角会带来一定的性能损耗，如何提高性能是一个需要重点讨论的话题。&lt;/p&gt;
&lt;p&gt;大家常见的圆角代码&lt;code&gt;x.layer.cornerRadius = xx; x.clipsToBounds = YES;&lt;/code&gt;这两行确实实现了圆角视觉效果。其实使用&lt;code&gt;x.layer.cornerRadius = xx;&lt;/code&gt;已经实现了圆角，只不过在某些控件是不生效的，因为某些图层在被切割圆角图层之上而被显示出来了。而&lt;code&gt;x.clipsToBounds = YES;&lt;/code&gt;带来的后果就是产生&lt;code&gt;离屏渲染&lt;/code&gt;。可以使用instruments中的CoreAnimation工具，打开&lt;code&gt;Color Offscren-Rednered Yellow&lt;/code&gt;选项，可见黄色区域部分即是离屏渲染部分。&lt;/p&gt;
&lt;p&gt;那么离屏渲染会带来什么？当然后资源损耗，可能产生卡顿。因为在iPhone设备的硬件资源有差异，当离屏渲染不多时，并不是很明显感觉到它的缺点。&lt;/p&gt;</summary>
    
    
    
    <category term="pieces" scheme="https://chars.tech/categories/pieces/"/>
    
    
    <category term="objc" scheme="https://chars.tech/tags/objc/"/>
    
    <category term="ios" scheme="https://chars.tech/tags/ios/"/>
    
    <category term="ui" scheme="https://chars.tech/tags/ui/"/>
    
    <category term="优化" scheme="https://chars.tech/tags/%E4%BC%98%E5%8C%96/"/>
    
    <category term="渲染" scheme="https://chars.tech/tags/%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
</feed>
