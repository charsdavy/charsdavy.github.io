<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chars&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chars.tech/"/>
  <updated>2017-11-30T06:10:20.915Z</updated>
  <id>http://chars.tech/</id>
  
  <author>
    <name>Chars</name>
    <email>chars.davy@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>（译）TensorFlow 广度和深度学习的教程</title>
    <link href="http://chars.tech/2017/11/30/tensorflow-wide-and-deep/"/>
    <id>http://chars.tech/2017/11/30/tensorflow-wide-and-deep/</id>
    <published>2017-11-30T06:00:10.000Z</published>
    <updated>2017-11-30T06:10:20.915Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>译者：<a href="https://github.com/charsdavy" target="_blank" rel="external">charsdavy</a></li>
<li>校对者：<a href="https://github.com/MRNIU" target="_blank" rel="external">MRNIU</a></li>
</ul>
</blockquote>
<p>在前文 <a href="https://www.tensorflow.org/tutorials/wide" target="_blank" rel="external">《TensorFlow Liner Model Tutorial》</a> 中，我们使用 <a href="https://archive.ics.uci.edu/ml/datasets/Census+Income" target="_blank" rel="external">人口收入普查数据集</a> 训练了一个 logistic 线性回归模型去预测个人年收入超过 5 万美元的概率。TensorFlow 在训练深度神经网络方面效果也很好，那么你可能会考虑该如何取舍它的功能了 – 可是，为什么不选择两者兼得呢？那么，是否可以将两者的优势结合在一个模型中呢？</p>
<p>在这篇文章中，我们将会介绍如何使用 TF.Learn API 同时训练一个广度线性模型和一个深度前馈神经网络。这种方法结合了记忆和泛化的优势。它在一般的大规模回归和具有稀疏输入特性的分类问题（例如，分类特征存在一个很大的可能值域）上很有效。如果你有兴趣学习更多关于广度和深度学习如何工作的问题，请参考 <a href="http://arxiv.org/abs/1606.07792" target="_blank" rel="external">研究论文</a></p>
<p><img src="https://www.tensorflow.org/images/wide_n_deep.svg" alt="Wide &amp; Deep Spectrum of Models" title="Wide &amp; Deep"></p>
<a id="more"></a>
<p>现在，我们来看一个简单的例子。</p>
<p>上图展示了广度模型（具有稀疏特征和转换性质的 logistic 回归模型），深度模型（具有一个嵌入层和多个隐藏层的前馈神经网络），广度和深度模型（两者的联合训练）的区别比较。在高层级里，只需要通过以下三个步骤就能使用 TF.Learn API 配置广度，深度或广度和深度模型。</p>
<p>1.选择广度部分的特征：选择要使用的稀疏基本列和交叉列。</p>
<p>2.选择深度部分的特征：选择连续列，每个分类列的嵌入维度和隐藏层大小。</p>
<p>3.将它们一起放入广度和深度模型（<code>DNNLinearCombinedClassifier</code>）。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>如果想要尝试本教程中的代码：</p>
<p>1.安装 TensorFlow ，<a href="http://chars.tech/2017/09/26/tensorflow-pycharm-mac/">请前往此处</a>。</p>
<p>2.下载 <a href="https://www.tensorflow.org/code/tensorflow/examples/learn/wide_n_deep_tutorial.py" target="_blank" rel="external">教程代码</a>。</p>
<p>3.安装 pandas 数据分析库。因为本教程中需要使用 pandas 数据。虽然 tf.learn 不要求 pandas，但是它支持 pandas。安装 pandas：</p>
<p>a. 获取 pip：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Ubuntu/Linux 64-bit</span><br><span class="line">$ sudo apt-get install python-pip python-dev</span><br><span class="line"></span><br><span class="line"># Mac OS X</span><br><span class="line">$ sudo easy_install pip</span><br><span class="line">$ sudo easy_install --upgrade six</span><br></pre></td></tr></table></figure>
<p>b. 使用 pip 安装 pandas</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install pandas</span><br></pre></td></tr></table></figure>
<p>如果你在安装过程中遇到问题，请前往 pandas 网站上的 <a href="http://pandas.pydata.org/pandas-docs/stable/install.html" target="_blank" rel="external">说明</a> 。</p>
<p>4.执行以下命令来训练教程中描述的线性模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python wide_n_deep_tutorial.py --model_type=wide_n_deep</span><br></pre></td></tr></table></figure>
<p>请继续阅读，了解此代码如何构建其线性模型。</p>
<h2 id="定义基本特征列"><a href="#定义基本特征列" class="headerlink" title="定义基本特征列"></a>定义基本特征列</h2><p>首先，定义我们使用的基本分类和连续特征的列。这些列将被作为模型的广度部分和深度部分的构件块。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">gender = tf.feature_column.categorical_column_with_vocabulary_list(</span><br><span class="line">    <span class="string">"gender"</span>, [<span class="string">"Female"</span>, <span class="string">"Male"</span>])</span><br><span class="line">education = tf.feature_column.categorical_column_with_vocabulary_list(</span><br><span class="line">    <span class="string">"education"</span>, [</span><br><span class="line">        <span class="string">"Bachelors"</span>, <span class="string">"HS-grad"</span>, <span class="string">"11th"</span>, <span class="string">"Masters"</span>, <span class="string">"9th"</span>,</span><br><span class="line">        <span class="string">"Some-college"</span>, <span class="string">"Assoc-acdm"</span>, <span class="string">"Assoc-voc"</span>, <span class="string">"7th-8th"</span>,</span><br><span class="line">        <span class="string">"Doctorate"</span>, <span class="string">"Prof-school"</span>, <span class="string">"5th-6th"</span>, <span class="string">"10th"</span>, <span class="string">"1st-4th"</span>,</span><br><span class="line">        <span class="string">"Preschool"</span>, <span class="string">"12th"</span></span><br><span class="line">    ])</span><br><span class="line">marital_status = tf.feature_column.categorical_column_with_vocabulary_list(</span><br><span class="line">    <span class="string">"marital_status"</span>, [</span><br><span class="line">        <span class="string">"Married-civ-spouse"</span>, <span class="string">"Divorced"</span>, <span class="string">"Married-spouse-absent"</span>,</span><br><span class="line">        <span class="string">"Never-married"</span>, <span class="string">"Separated"</span>, <span class="string">"Married-AF-spouse"</span>, <span class="string">"Widowed"</span></span><br><span class="line">    ])</span><br><span class="line">relationship = tf.feature_column.categorical_column_with_vocabulary_list(</span><br><span class="line">    <span class="string">"relationship"</span>, [</span><br><span class="line">        <span class="string">"Husband"</span>, <span class="string">"Not-in-family"</span>, <span class="string">"Wife"</span>, <span class="string">"Own-child"</span>, <span class="string">"Unmarried"</span>,</span><br><span class="line">        <span class="string">"Other-relative"</span></span><br><span class="line">    ])</span><br><span class="line">workclass = tf.feature_column.categorical_column_with_vocabulary_list(</span><br><span class="line">    <span class="string">"workclass"</span>, [</span><br><span class="line">        <span class="string">"Self-emp-not-inc"</span>, <span class="string">"Private"</span>, <span class="string">"State-gov"</span>, <span class="string">"Federal-gov"</span>,</span><br><span class="line">        <span class="string">"Local-gov"</span>, <span class="string">"?"</span>, <span class="string">"Self-emp-inc"</span>, <span class="string">"Without-pay"</span>, <span class="string">"Never-worked"</span></span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示一个哈希的例子：</span></span><br><span class="line">occupation = tf.feature_column.categorical_column_with_hash_bucket(</span><br><span class="line">    <span class="string">"occupation"</span>, hash_bucket_size=<span class="number">1000</span>)</span><br><span class="line">native_country = tf.feature_column.categorical_column_with_hash_bucket(</span><br><span class="line">    <span class="string">"native_country"</span>, hash_bucket_size=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续基列</span></span><br><span class="line">age = tf.feature_column.numeric_column(<span class="string">"age"</span>)</span><br><span class="line">education_num = tf.feature_column.numeric_column(<span class="string">"education_num"</span>)</span><br><span class="line">capital_gain = tf.feature_column.numeric_column(<span class="string">"capital_gain"</span>)</span><br><span class="line">capital_loss = tf.feature_column.numeric_column(<span class="string">"capital_loss"</span>)</span><br><span class="line">hours_per_week = tf.feature_column.numeric_column(<span class="string">"hours_per_week"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换</span></span><br><span class="line">age_buckets = tf.feature_column.bucketized_column(</span><br><span class="line">    age, boundaries=[<span class="number">18</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">60</span>, <span class="number">65</span>])</span><br></pre></td></tr></table></figure>
<h2 id="广度模型：具有交叉特征列的线性模型"><a href="#广度模型：具有交叉特征列的线性模型" class="headerlink" title="广度模型：具有交叉特征列的线性模型"></a>广度模型：具有交叉特征列的线性模型</h2><p>广度模型是一个具有稀疏和交叉特征列的线性模型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">base_columns = [</span><br><span class="line">    gender, native_country, education, occupation, workclass, relationship,</span><br><span class="line">    age_buckets,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">crossed_columns = [</span><br><span class="line">    tf.feature_column.crossed_column(</span><br><span class="line">        [<span class="string">"education"</span>, <span class="string">"occupation"</span>], hash_bucket_size=<span class="number">1000</span>),</span><br><span class="line">    tf.feature_column.crossed_column(</span><br><span class="line">        [age_buckets, <span class="string">"education"</span>, <span class="string">"occupation"</span>], hash_bucket_size=<span class="number">1000</span>),</span><br><span class="line">    tf.feature_column.crossed_column(</span><br><span class="line">        [<span class="string">"native_country"</span>, <span class="string">"occupation"</span>], hash_bucket_size=<span class="number">1000</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>具有交叉特征列的广度模型可以有效地记忆特征之间的稀疏交互。也就是说，交叉特征列不能概括没有在训练数据中出现的特征组合。让我们采用嵌入方式来添加一个深度模型来修复这个问题。</p>
<h2 id="深度模型：嵌入式神经网络"><a href="#深度模型：嵌入式神经网络" class="headerlink" title="深度模型：嵌入式神经网络"></a>深度模型：嵌入式神经网络</h2><p>深度模型是一个前馈神经网络，如前图所示。每一个稀疏，高维度分类特征首先都会被转换成一个低维度密集的实值矢量，通常被称为嵌入式矢量。这些低维度密集的嵌入式矢量与连续特征相连，然后在正向传递中馈入神经网络的隐藏层。嵌入值随机初始化，并与其他模型参数一起训练，以最大化减少训练损失。如果你有兴趣了解更多关于嵌入的知识，请在查阅教程 <a href="https://www.tensorflow.org/versions/r0.9/tutorials/word2vec/index.html" target="_blank" rel="external">Vector Representations of Words</a> 或在 Wikipedia 上查阅 <a href="https://en.wikipedia.org/wiki/Word_embedding" target="_blank" rel="external">Word Embedding</a>。</p>
<p>我们将使用 <code>embedding_column</code> 配置分类嵌入列，并将它们与连续列连接：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deep_columns = [</span><br><span class="line">    tf.feature_column.indicator_column(workclass),</span><br><span class="line">    tf.feature_column.indicator_column(education),</span><br><span class="line">    tf.feature_column.indicator_column(gender),</span><br><span class="line">    tf.feature_column.indicator_column(relationship),</span><br><span class="line">    <span class="comment"># 展示一个嵌入例子</span></span><br><span class="line">    tf.feature_column.embedding_column(native_country, dimension=<span class="number">8</span>),</span><br><span class="line">    tf.feature_column.embedding_column(occupation, dimension=<span class="number">8</span>),</span><br><span class="line">    age,</span><br><span class="line">    education_num,</span><br><span class="line">    capital_gain,</span><br><span class="line">    capital_loss,</span><br><span class="line">    hours_per_week,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>嵌入的 <code>dimension</code> 越高，自由度就越高，模型将不得不学习这些特性的表示。为了简单起见，我们设置所有特征列的维度为 8。从经验上看，关于维度的设定最好是从 \log_{2}(n) 或 k\sqrt[4]{n} 值开始，这里的 n 代表特征列中唯一特征的数量，k 是一个很小的常量（通常小于10）。</p>
<p>通过密集嵌入，深度模型可以更好的概括，并更好对之前没有在训练数据中遇见的特征进行预测。然而，当两个特征列之间的底层交互矩阵是稀疏和高等级时，很难学习特征列的有效低维度表示。在这种情况下，大多数特征对之间的交互应该为零，除了少数几个，但密集的嵌入将导致所有特征对的非零预测，从而可能过度泛化。另一方面，具有交叉特征的线性模型可以用更少的模型参数有效地记住这些“异常规则”。</p>
<p>现在，我们来看看如何联合训练广度和深度模型，让它们优势和劣势互补。</p>
<h2 id="将广度和深度模型结合为一体"><a href="#将广度和深度模型结合为一体" class="headerlink" title="将广度和深度模型结合为一体"></a>将广度和深度模型结合为一体</h2><p>通过将其最终输出的对数几率作为预测结合起来，然后将预测提供给 logistic 损失函数，将广度模型和深度模型相结合。所有的图形定义和变量分配都已经被处理，所以你只需要创建一个 <code>DNNLinearCombinedClassifier</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line">model_dir = tempfile.mkdtemp()</span><br><span class="line">m = tf.contrib.learn.DNNLinearCombinedClassifier(</span><br><span class="line">    model_dir=model_dir,</span><br><span class="line">    linear_feature_columns=wide_columns,</span><br><span class="line">    dnn_feature_columns=deep_columns,</span><br><span class="line">    dnn_hidden_units=[<span class="number">100</span>, <span class="number">50</span>])</span><br></pre></td></tr></table></figure>
<h2 id="训练和评估模型"><a href="#训练和评估模型" class="headerlink" title="训练和评估模型"></a>训练和评估模型</h2><p>在训练模型之前，请先阅读人口普查数据集，就像在 <a href="https://www.tensorflow.org/tutorials/wide" target="_blank" rel="external">《TensorFlow Liner Model Tutorial》</a> 中所做的一样。 输入数据处理的代码再次为你提供方便：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为数据集定义列名</span></span><br><span class="line">CSV_COLUMNS = [</span><br><span class="line">    <span class="string">"age"</span>, <span class="string">"workclass"</span>, <span class="string">"fnlwgt"</span>, <span class="string">"education"</span>, <span class="string">"education_num"</span>,</span><br><span class="line">    <span class="string">"marital_status"</span>, <span class="string">"occupation"</span>, <span class="string">"relationship"</span>, <span class="string">"race"</span>, <span class="string">"gender"</span>,</span><br><span class="line">    <span class="string">"capital_gain"</span>, <span class="string">"capital_loss"</span>, <span class="string">"hours_per_week"</span>, <span class="string">"native_country"</span>,</span><br><span class="line">    <span class="string">"income_bracket"</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maybe_download</span><span class="params">(train_data, test_data)</span>:</span></span><br><span class="line">  <span class="string">"""Maybe downloads training data and returns train and test file names."""</span></span><br><span class="line">  <span class="keyword">if</span> train_data:</span><br><span class="line">    train_file_name = train_data</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    train_file = tempfile.NamedTemporaryFile(delete=<span class="keyword">False</span>)</span><br><span class="line">    urllib.request.urlretrieve(</span><br><span class="line">        <span class="string">"https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data"</span>,</span><br><span class="line">        train_file.name)  <span class="comment"># pylint: disable=line-too-long</span></span><br><span class="line">    train_file_name = train_file.name</span><br><span class="line">    train_file.close()</span><br><span class="line">    print(<span class="string">"Training data is downloaded to %s"</span> % train_file_name)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> test_data:</span><br><span class="line">    test_file_name = test_data</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    test_file = tempfile.NamedTemporaryFile(delete=<span class="keyword">False</span>)</span><br><span class="line">    urllib.request.urlretrieve(</span><br><span class="line">        <span class="string">"https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.test"</span>,</span><br><span class="line">        test_file.name)  <span class="comment"># pylint: disable=line-too-long</span></span><br><span class="line">    test_file_name = test_file.name</span><br><span class="line">    test_file.close()</span><br><span class="line">    print(<span class="string">"Test data is downloaded to %s"</span>% test_file_name)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> train_file_name, test_file_name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_fn</span><span class="params">(data_file, num_epochs, shuffle)</span>:</span></span><br><span class="line">  <span class="string">"""Input builder function."""</span></span><br><span class="line">  df_data = pd.read_csv(</span><br><span class="line">      tf.gfile.Open(data_file),</span><br><span class="line">      names=CSV_COLUMNS,</span><br><span class="line">      skipinitialspace=<span class="keyword">True</span>,</span><br><span class="line">      engine=<span class="string">"python"</span>,</span><br><span class="line">      skiprows=<span class="number">1</span>)</span><br><span class="line">  <span class="comment"># 移除 NaN 元素</span></span><br><span class="line">  df_data = df_data.dropna(how=<span class="string">"any"</span>, axis=<span class="number">0</span>)</span><br><span class="line">  labels = df_data[<span class="string">"income_bracket"</span>].apply(<span class="keyword">lambda</span> x: <span class="string">"&gt;50K"</span> <span class="keyword">in</span> x).astype(int)</span><br><span class="line">  <span class="keyword">return</span> tf.estimator.inputs.pandas_input_fn(</span><br><span class="line">      x=df_data,</span><br><span class="line">      y=labels,</span><br><span class="line">      batch_size=<span class="number">100</span>,</span><br><span class="line">      num_epochs=num_epochs,</span><br><span class="line">      shuffle=shuffle,</span><br><span class="line">      num_threads=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>阅读数据之后，你可以训练并评估模型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 num_epochs 设置为 None，以获得无限的数据流</span></span><br><span class="line">m.train(</span><br><span class="line">    input_fn=input_fn(train_file_name, num_epochs=<span class="keyword">None</span>, shuffle=<span class="keyword">True</span>),</span><br><span class="line">    steps=train_steps)</span><br><span class="line"><span class="comment"># 在所有数据被消耗之前，为了运行评估，设置 steps 为 None</span></span><br><span class="line">results = m.evaluate(</span><br><span class="line">    input_fn=input_fn(test_file_name, num_epochs=<span class="number">1</span>, shuffle=<span class="keyword">False</span>),</span><br><span class="line">    steps=<span class="keyword">None</span>)</span><br><span class="line">print(<span class="string">"model directory = %s"</span> % model_dir)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> sorted(results):</span><br><span class="line">  print(<span class="string">"%s: %s"</span> % (key, results[key]))</span><br></pre></td></tr></table></figure>
<p>输出的第一行应该类似 <code>accuracy: 0.84429705</code>。我们可以看到使用广度和深度模型将广度线性模型精度约 83.6% 提高到了约 84.4%。如果你想看端对端的工作示例，你可以下载我们的 <a href="https://www.tensorflow.org/code/tensorflow/examples/learn/wide_n_deep_tutorial.py" target="_blank" rel="external">示例代码</a>。</p>
<p>请注意，本教程只是一个小型数据基的简单示例，为了让你快速熟悉 API。如果你有大量具有稀疏特征列和大量可能特征值的数据集，广度和深度学习将会更加强大。此外，请随时关注我们的 <a href="http://arxiv.org/abs/1606.07792" target="_blank" rel="external">研究论文</a>，以了解更多关于在实际中广度和深度学习在大型机器学习方面如何应用的思考。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;译者：&lt;a href=&quot;https://github.com/charsdavy&quot;&gt;charsdavy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;校对者：&lt;a href=&quot;https://github.com/MRNIU&quot;&gt;MRNIU&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;在前文 &lt;a href=&quot;https://www.tensorflow.org/tutorials/wide&quot;&gt;《TensorFlow Liner Model Tutorial》&lt;/a&gt; 中，我们使用 &lt;a href=&quot;https://archive.ics.uci.edu/ml/datasets/Census+Income&quot;&gt;人口收入普查数据集&lt;/a&gt; 训练了一个 logistic 线性回归模型去预测个人年收入超过 5 万美元的概率。TensorFlow 在训练深度神经网络方面效果也很好，那么你可能会考虑该如何取舍它的功能了 – 可是，为什么不选择两者兼得呢？那么，是否可以将两者的优势结合在一个模型中呢？&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们将会介绍如何使用 TF.Learn API 同时训练一个广度线性模型和一个深度前馈神经网络。这种方法结合了记忆和泛化的优势。它在一般的大规模回归和具有稀疏输入特性的分类问题（例如，分类特征存在一个很大的可能值域）上很有效。如果你有兴趣学习更多关于广度和深度学习如何工作的问题，请参考 &lt;a href=&quot;http://arxiv.org/abs/1606.07792&quot;&gt;研究论文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.tensorflow.org/images/wide_n_deep.svg&quot; alt=&quot;Wide &amp;amp; Deep Spectrum of Models&quot; title=&quot;Wide &amp;amp; Deep&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="ml" scheme="http://chars.tech/categories/machine-learning/"/>
    
    
      <category term="python" scheme="http://chars.tech/tags/python/"/>
    
      <category term="tensorflow" scheme="http://chars.tech/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>聊聊 iOS 数据保护</title>
    <link href="http://chars.tech/2017/10/17/ios-data-protection/"/>
    <id>http://chars.tech/2017/10/17/ios-data-protection/</id>
    <published>2017-10-17T07:18:19.000Z</published>
    <updated>2017-10-18T02:35:41.062Z</updated>
    
    <content type="html"><![CDATA[<p>文件系统中的文件、keychain中的项，都是加密存储的。当用户解锁设备后，系统通过UDID密钥和用户设定的密码生成一个用于解密的密码密钥，存放在内存中，直到设备再次被锁，开发者可以通过Data Protection API 来设定文件系统中的文件、keychain中的项应该何时被解密。这个就是数据保护的内容。</p>
<a id="more"></a>
<h2 id="钥匙串（keychain）"><a href="#钥匙串（keychain）" class="headerlink" title="钥匙串（keychain）"></a>钥匙串（keychain）</h2><p>keychain服务提供了一种安全的保存私密信息（密码，序列号，私钥，证书等）的方式，每个iOS程序都有一个独立的keychain存储。相对于NSUserDefaults、文件保存等一般方式，keychain保存更为安全，而且keychain里保存的信息不会因APP被删除而丢失。</p>
<p>基于钥匙串的特点，我们在使用时对于新增的数据项目，要注意数据删除的时机。还有一点需要注意的就是，保护属性的指定。如果没有指定保护属性，这将被视为严重的安全漏洞。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><p>当我们备份设备数据时，系统会将用户数据保存在相应的钥匙串中，并依照相应的安全策略保存。主要分成两类：<strong>加密</strong>和<strong>不加密</strong>。</p>
<p>两者的主要区别在于恢复数据时的范围不同。加密备份的数据可以恢复到任何设备上（ThisDeviceOnly指定的项目除外），而不加密的备份则只能恢复至同一台设备。</p>
<h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p>keychain支持在多个应用之间共享数据。但现实开发中<code>UIPasteboardNameFind</code>的使用代替了keychain。不过好在Apple在iOS11中已经废弃它。看来Apple想规范开发者对于用户敏感数据的共享使用，同时提醒大家使用更加安全的方式存储用户敏感数据。</p>
<h3 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h3><h4 id="SecItemAdd"><a href="#SecItemAdd" class="headerlink" title="SecItemAdd"></a>SecItemAdd</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *dict = [NSMutableDictionary dictionary];</span><br><span class="line">NSData *passwordData = [@&quot;myPassword&quot; dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];</span><br><span class="line">[dict setObject:@&quot;Conglomco&quot; forKey:(__bridge id)kSecAttrLabel];</span><br><span class="line">[dict setObject:@&quot;This is your password for the Conglomco service.&quot; forKey:(__bridge id)kSecAttrDescription];</span><br><span class="line">[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];</span><br><span class="line">[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];</span><br><span class="line">[dict setObject:passwordData forKey:(__bridge id)kSecValueData];</span><br><span class="line">[dict setObject:(__bridge id)kSecAttrAccessibleWhenUnlocked forKey:(__bridge id)kSecAttrAccessible];</span><br><span class="line"></span><br><span class="line">OSStatus error = SecItemAdd((__bridge CFDictionaryRef)dict, NULL);</span><br><span class="line">if (error == errSecSuccess) &#123;</span><br><span class="line">    NSLog(@&quot;Yay&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SecItemDelete"><a href="#SecItemDelete" class="headerlink" title="SecItemDelete"></a>SecItemDelete</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *dict = [NSMutableDictionary dictionary];</span><br><span class="line"></span><br><span class="line">[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];</span><br><span class="line">[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];</span><br><span class="line">[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];</span><br><span class="line"></span><br><span class="line">OSStatus error = SecItemDelete((__bridge CFDictionaryRef)dict);</span><br><span class="line">if (error == errSecSuccess) &#123;</span><br><span class="line">	NSLog(@&quot;Yay&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SecItemUpdate"><a href="#SecItemUpdate" class="headerlink" title="SecItemUpdate"></a>SecItemUpdate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *dict = [NSMutableDictionary dictionary];</span><br><span class="line">NSData *newPasswordData = [@&quot;newMyPassword&quot; dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];</span><br><span class="line">[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];</span><br><span class="line">[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];</span><br><span class="line"></span><br><span class="line">NSDictionary *updatedAttribute = [NSDictionary dictionaryWithObject:newPasswordData forKey:(__bridge id)kSecValueData];</span><br><span class="line"></span><br><span class="line">OSStatus error = SecItemUpdate((__bridge CFDictionaryRef)dict, (__bridge CFDictionaryRef)updatedAttribute);</span><br><span class="line">if (error == errSecSuccess) &#123;</span><br><span class="line">	NSLog(@&quot;Yay&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SecItemCopyMatching"><a href="#SecItemCopyMatching" class="headerlink" title="SecItemCopyMatching"></a>SecItemCopyMatching</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSMutableDictionary *dict = [NSMutableDictionary dictionary];</span><br><span class="line"></span><br><span class="line">[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];</span><br><span class="line">[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];</span><br><span class="line">[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];</span><br><span class="line">[dict setObject:(id)kCFBooleanTrue forKey:(__bridge id)kSecReturnAttributes];</span><br><span class="line"></span><br><span class="line">NSDictionary *result = nil;</span><br><span class="line">OSStatus error = SecItemCopyMatching((__bridge CFDictionaryRef)dict, (void *)&amp;result);</span><br><span class="line">if (error == errSecSuccess) &#123;</span><br><span class="line">	NSLog(@&quot;Yay %@&quot;, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>SecItemAdd</td>
<td>添加数据</td>
</tr>
<tr>
<td>SecItemDelete</td>
<td>删除数据</td>
</tr>
<tr>
<td>SecItemUpdate</td>
<td>修改数据</td>
</tr>
<tr>
<td>SecItemCopyMatching</td>
<td>查找数据</td>
</tr>
</tbody>
</table>
<h3 id="保护属性"><a href="#保护属性" class="headerlink" title="保护属性"></a>保护属性</h3><table>
<thead>
<tr>
<th>钥匙串保护属性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>kSecAttrAccessibleAfterFirstUnlock</td>
<td>开机之后密钥不可用，直到用户首次输入密码</td>
</tr>
<tr>
<td>kSecAttrAccessibleAlways</td>
<td>密钥在设备开机后依旧可用。在iOS9中已经废弃</td>
</tr>
<tr>
<td>kSecAttrAccessibleAlwaysThisDeviceOnly</td>
<td>密钥始终可用，但无法迁移到其他设备</td>
</tr>
<tr>
<td>kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly</td>
<td>作用同上</td>
</tr>
<tr>
<td>kSecAttrAccessibleWhenUnlocked</td>
<td>只要解锁过设备，则密钥保持可用状态</td>
</tr>
<tr>
<td>kSecAttrAccessibleWhenUnlockedThisDeviceOnly</td>
<td>作用同上</td>
</tr>
<tr>
<td>kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly</td>
<td>作用同上，只有用户设置密码密钥才可用</td>
</tr>
</tbody>
</table>
<p><code>kSecAttrAccessibleAlways</code> 将会引入一个很明显的安全问题，因为此种保护属性，只要有人窃取了你的设备，他们就能读取钥匙串的内容。</p>
<p><code>kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly</code> 这个属性可以完美的解决上述的安全问题。因为越狱时通常需要重启设备。</p>
<p><code>kSecAttrAccessibleWhenUnlocked</code> 这个属性要求攻击者必须知道用户密码才能提取隐私数据。它很适合做默认属性值。</p>
<p><code>kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly</code> 是iOS8新增的保护属性。这个属性要求在使用时用户设定了密码，否则使用就失败。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><table>
<thead>
<tr>
<th>项目类</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>kSecClassGenericPassword</td>
<td>普通密码</td>
</tr>
<tr>
<td>kSecClassInternetPassword</td>
<td>专门用于互联网服务的密码</td>
</tr>
<tr>
<td>kSecClassCertificate</td>
<td>加密证书</td>
</tr>
<tr>
<td>kSecClassKey</td>
<td>加密密钥</td>
</tr>
<tr>
<td>kSecClassIdentity</td>
<td>一个密钥对（包括公共证书和私钥）</td>
</tr>
</tbody>
</table>
<h3 id="iCloud同步"><a href="#iCloud同步" class="headerlink" title="iCloud同步"></a>iCloud同步</h3><p>这是iOS7引入的一种新机制，可以把钥匙串项目同步到iCloud，允许用户在多个设备之间共享钥匙串项目。</p>
<p>默认情况下，应用程序创建的钥匙串项目会禁用这个机制，但可以把<code>kSecAttrSynchronizable</code>设置为<code>true</code>来启用。</p>
<p>另外请注意，使用此选项时无法指定不兼容的kSecAttrAccessible属性。例如，指定kSecAttrAccessibleWhenUnlockedThisDeviceOnly不起作用，因为ThisDeviceOnly指定的项目不会备份，也不能同步到iCloud、笔记本电脑、台式机或其他同步位置。</p>
<h2 id="数据保护"><a href="#数据保护" class="headerlink" title="数据保护"></a>数据保护</h2><p>Apple 推出了数据保护API作为额外的保护层，它允许开发者指定文件解密密钥的生命周期。可以使用这个API控制文件的访问权限，与钥匙串项目中的kSecAttrAccessible 属性类似。</p>
<p>数据保护API使用用户密码和层级密钥来加密保护文件的密钥，而当这些文件不能被访问时，会从内存中删除这个层级密钥。</p>
<h3 id="文件保护过程"><a href="#文件保护过程" class="headerlink" title="文件保护过程"></a>文件保护过程</h3><p><img src="http://o88e8any8.bkt.clouddn.com/ios_data_protection_2.png" alt="文件保护过程"></p>
<p>1.文件生成一个<code>文件密钥</code>来加密文件的内容。</p>
<p>2.生成一个额外的密钥对，用于生成<code>文件公钥</code>和<code>文件私钥</code>。</p>
<p>3.用<code>文件私钥</code>和<code>Protected Unless Open等级公钥</code>计算出一个<code>共享密码</code>。</p>
<p>4.用<code>共享密码</code> SHA-1散列值加密文件密钥。</p>
<p>5.加密过的<code>文件密钥</code>会存储在文件的元数据中，元数据中还有文件的公钥。</p>
<p>6.系统丢弃<code>文件私钥</code>。</p>
<p>7.关闭文件时从内存中删除未加密的文件密钥。</p>
<p>8.需要再次打开文件时，用<code>Protected Unless Open等级私钥</code>和<code>文件公钥</code>计算<code>共享密码</code>。</p>
<p>9.计算<code>共享密码</code>的SHA-1散列值，把它当作解密文件的密钥。</p>
<h3 id="DataProtectionClass-权限"><a href="#DataProtectionClass-权限" class="headerlink" title="DataProtectionClass 权限"></a>DataProtectionClass 权限</h3><p>如果你的应用在设备进入后台或锁定时不需要写入或读取文件，那你就可以在工程中配置一个<code>NSFileProtectionComplete</code>值来添加权限。这将确保所有受保护的文件数据只能在设备解锁时访问，相当于为所有的应用文件都设置<code>kSecAttrAccessibleWhenUnlocked</code>选项。</p>
<p>从Xcode5开始，新工程会默认启用数据保护权限，但是一些旧工程并不会自动开启。</p>
<p>开启方式如下图：</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios_data_protection_1.png?imageView2/2/w/800" alt="开启DataProtectionClass权限"></p>
<h3 id="使用范例-1"><a href="#使用范例-1" class="headerlink" title="使用范例"></a>使用范例</h3><h4 id="NSDataWritingFileProtectionComplete"><a href="#NSDataWritingFileProtectionComplete" class="headerlink" title="NSDataWritingFileProtectionComplete"></a>NSDataWritingFileProtectionComplete</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSData *data = [self generateData];</span><br><span class="line">NSError *error = nil;</span><br><span class="line">NSString *path = [NSString stringWithFormat:@&quot;%@_demo.pdf&quot;, NSTemporaryDirectory()];</span><br><span class="line">[data writeToFile:path options:NSDataWritingFileProtectionComplete error:&amp;error];</span><br><span class="line">if (error) &#123;</span><br><span class="line">	NSLog(@&quot;%@&quot;, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NSFileProtectionComplete"><a href="#NSFileProtectionComplete" class="headerlink" title="NSFileProtectionComplete"></a>NSFileProtectionComplete</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@&quot;demo.txt&quot;];</span><br><span class="line">NSError *error = nil;</span><br><span class="line">NSDictionary *attr = [NSDictionary dictionaryWithObject:NSFileProtectionComplete forKey:NSFileProtectionKey];</span><br><span class="line">[[NSFileManager defaultManager] setAttributes:attr ofItemAtPath:path error:&amp;error];</span><br><span class="line">if (error) &#123;</span><br><span class="line">	NSLog(@&quot;%@&quot;, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SQLITE-OPEN-FILEPROTECTION-COMPLETEUNLESSOPEN"><a href="#SQLITE-OPEN-FILEPROTECTION-COMPLETEUNLESSOPEN" class="headerlink" title="SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN"></a>SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@&quot;demo.sqlite&quot;];</span><br><span class="line">sqlite3 *handle = NULL;</span><br><span class="line">sqlite3_open_v2([path UTF8String],</span><br><span class="line">                &amp;handle,</span><br><span class="line">                SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE | SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN,</span><br><span class="line">                NULL);</span><br></pre></td></tr></table></figure>
<h3 id="保护等级"><a href="#保护等级" class="headerlink" title="保护等级"></a>保护等级</h3><h4 id="CompleteUntilFirstUserAuthentication"><a href="#CompleteUntilFirstUserAuthentication" class="headerlink" title="CompleteUntilFirstUserAuthentication"></a>CompleteUntilFirstUserAuthentication</h4><p>这个保护等级是iOS5开始使用的默认值。主要用来防御一些需要重启的攻击。</p>
<h4 id="Complete"><a href="#Complete" class="headerlink" title="Complete"></a>Complete</h4><p>官方称这是目前最安全的文件保护等级。在这种情况下，锁屏之后系统就会删除内存中的层级密钥，并把文件改为不可读。</p>
<p>具体使用的范例前文可见。</p>
<p>使用Complete保护之前，考虑是否合适。如果你的应用进程需要持续写/读一个文件，那这种保护模式就不合适了。</p>
<h4 id="CompleteUnlessOpen"><a href="#CompleteUnlessOpen" class="headerlink" title="CompleteUnlessOpen"></a>CompleteUnlessOpen</h4><p>如果一个文件当前被一个应用打开，那会暂时禁用该文件的保护。它会确保打开的文件在设备被锁定时依然能够写入，并且允许新建文件到磁盘。不过这个等级保护的文件在锁屏时无法打开，除非锁屏时就已经提前打开。</p>
<h2 id="CommonCrypto加密"><a href="#CommonCrypto加密" class="headerlink" title="CommonCrypto加密"></a>CommonCrypto加密</h2><p>CommonCrypto是Apple官方提供的一套加密框架。在使用这套方案时，主要注意以下几个问题即可。</p>
<h3 id="避免弱算法"><a href="#避免弱算法" class="headerlink" title="避免弱算法"></a>避免弱算法</h3><p>众所周知，DES就是一种很典型的弱算法。如果你使用弱算法，那应用就很容易遭受密码攻击和暴力破解。</p>
<p>我们在实际使用时，可以考虑使用AES算法、MD5算法或MD5加盐算法等。</p>
<h3 id="破碎的熵"><a href="#破碎的熵" class="headerlink" title="破碎的熵"></a>破碎的熵</h3><p>我们通常会使用<code>rand</code>方法来产生随机数，但是系统的这个随机函数并不是真正的随机。它产生的随机数符合正态分布，我们可以使用官方提供的方法<code>SecRandomCopyBytes</code>获得。也可以自己使用算法产生随机数。</p>
<p>这里分享一个笔者以前自己实现的随机数案例。<a href="/2016/04/30/uniform-random/">《均匀分布随机函数的实现》</a></p>
<h3 id="弱密钥"><a href="#弱密钥" class="headerlink" title="弱密钥"></a>弱密钥</h3><p>开发者经常将用户的密码当作加密密钥，尤其在移动设备上，这将导致一个非常脆弱、低熵加密的密钥。</p>
<p>那么正确的姿势是使用<code>CCKeyDerivationPBKDF</code>方法来生成。</p>
<h2 id="Touch-ID"><a href="#Touch-ID" class="headerlink" title="Touch ID"></a>Touch ID</h2><h3 id="使用范例-2"><a href="#使用范例-2" class="headerlink" title="使用范例"></a>使用范例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;LocalAuthentication/LocalAuthentication.h&gt;</span><br><span class="line"></span><br><span class="line">LAContext *context = [[LAContext alloc] init];</span><br><span class="line">NSError *error = nil;</span><br><span class="line">NSString *reason = @&quot;We use this to verify your identify&quot;;</span><br><span class="line">if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;error]) &#123;</span><br><span class="line">	[context evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:reason reply:^(BOOL success, NSError * _Nullable error) &#123;</span><br><span class="line">		if (success) &#123;</span><br><span class="line">			NSLog(@&quot;Hello, that&apos;s your finger!&quot;);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			NSLog(@&quot;Couldn&apos;t read your fingerprint. Falling back to PIN or somthing.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	NSLog(@&quot;Error : %@ %@&quot;, error, [error userInfo]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Touch-ID-与普通密码相比的安全性"><a href="#Touch-ID-与普通密码相比的安全性" class="headerlink" title="Touch ID 与普通密码相比的安全性"></a>Touch ID 与普通密码相比的安全性</h3><p>一个人的指纹是世界上最好的密码之一。它独一无二，高度特异，并且无需记忆。它会伴随人终生，所以你可以一直使用同一个指纹密码。</p>
<p>比起简单的4位数字锁屏密码一万分之一的破解可能性，能找到同样单个指纹的人的概率为五万分之一，这是非常安全的，比起前者我可以不断尝试，Touch ID 指纹的硬性破解几率几乎没有，因为不可能有五万多个人排队来一一解锁你的设备，况且 Touch ID 会拒绝第五次以后的尝试而要求输入密码。所以我们可以添加更加复杂的密码而不是简单的数字密码来进一步提高安全性。</p>
<h3 id="Touch-ID-指纹识别的原理"><a href="#Touch-ID-指纹识别的原理" class="headerlink" title="Touch ID 指纹识别的原理"></a>Touch ID 指纹识别的原理</h3><p>在如此快速的识别过程中，Home 按钮上的一圈金属环起到了感应手指的功能，通知 Touch ID 来读取指纹。Touch ID 置于该按钮中，传感器的厚度只有 170 微米，拥有 500 ppi 高分辨率，可读取极小的指纹细节。传感器可从皮肤皮下层指纹的一些小部分拍摄高分辨率图像，然后会分析该信息，根据三种基本指纹类型（弧形纹、箕形纹或斗形纹）将指纹分类，它会绘制比人眼不可见的纹路细节，确保指纹读取准确无误。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios_data_protection_3.png" alt="touch id sensor"></p>
<p>Touch ID 可从 360 度方向读取指纹，随后创建指纹的某种数学表达式，并将其与已注册的数据进行比较，以确定是否匹配。如果匹配，便可替代密码来解锁设备或通过某个令牌。</p>
<p>此外，根据苹果官方的描述，Touch ID 会向以注册的指纹数据里持续的添加新的特征数据，随着时间的推移，这能不断提高匹配准确度，也能进一步的提高安全性。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios_data_protection_4.png" alt="touch id ontouch"></p>
<p>除了上述的内容，苹果还加入可以一些有效的手段来进一步确保安全，例如设备再重新启动或者保持锁定 48 小时后，就只能通过密码而不是指纹来解锁设备。</p>
<h3 id="Secure-Enclave"><a href="#Secure-Enclave" class="headerlink" title="Secure Enclave"></a>Secure Enclave</h3><p>Apple声明指纹的图案不会被保存，存储于设备中的是指纹特征的数学表达式，而且从这些表达式不可能直接反推出指纹图像。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios_data_protection_5.png" alt="touch-id-structure"></p>
<p>指纹的验证运算独立于主要处理器芯片（例如 A7、A8），芯片内有称为 “Secure Enclave” 的高级安全架构，专用于密码指纹数据，并使用 Secure Enclave 的专用密钥加密，以及每次启动以随机的 UID 进行管理。指纹数据仅能被 Secure Enclave 处理和使用，正因为此架构独立于其它设备部件，仅有 Touch ID 使用它，且不能将它用于匹配其他指纹数据库，所以存储的指纹数据不会由 iOS 或其他应用访问，也不会被存储到 Apple 服务器或备份到 iCloud 等地方。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios_data_protection_6.png" alt="A7-Secure-Enclave"></p>
<p>从硬件上来看指纹特征数据尚不能被 “Secure Enclave” 和 Touch ID 以外的部件访问到，并且两者芯片互相隔离开来，所有软件都没有权利获得指纹数据，仅能得到指纹是否错误的回馈。因为架构的核心秘密仅仅只有苹果公司知道，所以目前几乎没有第三方软件可以访问到这部分敏感信息。</p>
<p>到此，关于 iOS 数据保护的问题暂时告一段落。欢迎大家评论指正。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文件系统中的文件、keychain中的项，都是加密存储的。当用户解锁设备后，系统通过UDID密钥和用户设定的密码生成一个用于解密的密码密钥，存放在内存中，直到设备再次被锁，开发者可以通过Data Protection API 来设定文件系统中的文件、keychain中的项应该何时被解密。这个就是数据保护的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="pieces" scheme="http://chars.tech/categories/pieces/"/>
    
    
      <category term="ios" scheme="http://chars.tech/tags/ios/"/>
    
      <category term="存储" scheme="http://chars.tech/tags/persistence/"/>
    
      <category term="安全" scheme="http://chars.tech/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>MacOS 搭建 Tensorflow PyCharm 环境</title>
    <link href="http://chars.tech/2017/09/26/tensorflow-pycharm-mac/"/>
    <id>http://chars.tech/2017/09/26/tensorflow-pycharm-mac/</id>
    <published>2017-09-26T07:03:16.000Z</published>
    <updated>2017-11-20T02:14:48.181Z</updated>
    
    <content type="html"><![CDATA[<p>TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。目前来说，<a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">Github</a>上star最多的项目就是它了。</p>
<p>在这之前，笔者写过一篇简单的入门文章<a href="/2017/06/07/tensorflow-primer-guide/">《初探 TensorFlow》</a>。当时没能成功搭建环境，加上后期的工作原因，至此搁置了一段时间。今天，终于各种折腾，在自己的Mac上经过多种尝试之后，完美搭建成功。这里就把它分享出来，希望对大家有所帮助。</p>
<a id="more"></a>
<h2 id="基于-Anaconda-的安装"><a href="#基于-Anaconda-的安装" class="headerlink" title="基于 Anaconda 的安装"></a>基于 Anaconda 的安装</h2><p><a href="https://www.anaconda.com/" target="_blank" rel="external">Anaconda</a> 是一个集成许多第三方科学计算库的 <code>Python</code> 科学计算环境,<code>Anaconda</code> 使用 <code>conda</code> 作为自己的包管理工具,同时具有自己的计算环境,类似 <code>Virtualenv</code>.</p>
<p>和 <code>Virtualenv</code> 一样,不同 <code>Python</code> 工程需要的依赖包,<code>conda</code> 将他们存储在不同的地方。 <code>TensorFlow</code> 上安装的 <code>Anaconda</code> 不会对之前安装的 <code>Python</code> 包进行覆盖.</p>
<ul>
<li>安装 <a href="https://www.anaconda.com/download/" target="_blank" rel="external">Anaconda</a></li>
<li>建立一个 <code>conda</code> 计算环境</li>
<li>激活环境,使用 <code>conda</code> 安装 <code>TensorFlow</code></li>
<li>安装成功后,每次使用 <code>TensorFlow</code> 的时候需要激活 <code>conda</code> 环境</li>
</ul>
<h3 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda :"></a>安装 Anaconda :</h3><p>参考 Anaconda 的下载页面的<a href="https://www.anaconda.com/download/" target="_blank" rel="external">指导</a></p>
<h3 id="建立环境"><a href="#建立环境" class="headerlink" title="建立环境"></a>建立环境</h3><p>建立一个 conda 计算环境名字叫<code>tensorflow</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Python 2.7</span><br><span class="line">$ conda create -n tensorflow python=2.7</span><br><span class="line"></span><br><span class="line"># Python 3.4</span><br><span class="line">$ conda create -n tensorflow python=3.4</span><br></pre></td></tr></table></figure>
<h3 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h3><p>激活<code>tensorflow</code>环境,然后使用其中的 <code>pip</code> 安装 <code>TensorFlow</code>. 当使用<code>easy_install</code>使用<code>--ignore-installed</code>标记防止错误的产生。</p>
<p><a href="https://www.tensorflow.org/install/install_mac#the_url_of_the_tensorflow_python_package" target="_blank" rel="external">URL of the TensorFlow Python package</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ source activate tensorflow</span><br><span class="line">(tensorflow)$  # Your prompt should change</span><br><span class="line"></span><br><span class="line"># Ubuntu/Linux 64-bit, CPU only, Python 2.7:</span><br><span class="line">(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl</span><br><span class="line"></span><br><span class="line"># Ubuntu/Linux 64-bit, GPU enabled, Python 2.7. Requires CUDA toolkit 7.5 and CuDNN v4.</span><br><span class="line"># For other versions, see &quot;Install from sources&quot; below.</span><br><span class="line">(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl</span><br><span class="line"></span><br><span class="line"># Mac OS X, CPU only:</span><br><span class="line">(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-0.11.0rc0-py2-none-any.whl</span><br></pre></td></tr></table></figure>
<p>对于 Python 3.x :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ source activate tensorflow</span><br><span class="line">(tensorflow)$  # Your prompt should change</span><br><span class="line"></span><br><span class="line"># Ubuntu/Linux 64-bit, CPU only, Python 3.4:</span><br><span class="line">(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl</span><br><span class="line"></span><br><span class="line"># Ubuntu/Linux 64-bit, GPU enabled, Python 3.4. Requires CUDA toolkit 7.5 and CuDNN v4.</span><br><span class="line"># For other versions, see &quot;Install from sources&quot; below.</span><br><span class="line">(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl</span><br><span class="line"></span><br><span class="line"># Mac OS X, CPU only:</span><br><span class="line">(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0rc0-py3-none-any.whl</span><br></pre></td></tr></table></figure>
<p>conda 环境激活后,你可以测试:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt; import tensorflow as tf</span><br><span class="line">&gt;&gt;&gt; print(tf.__version__)</span><br><span class="line"># 0.11.0rc0</span><br></pre></td></tr></table></figure>
<h3 id="开启或关闭环境"><a href="#开启或关闭环境" class="headerlink" title="开启或关闭环境"></a>开启或关闭环境</h3><p>当你不用 TensorFlow 的时候,关闭环境:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(tensorflow)$ source deactivate</span><br><span class="line"></span><br><span class="line">$  # Your prompt should change back</span><br></pre></td></tr></table></figure>
<p>再次使用的时候再激活 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ source activate tensorflow</span><br><span class="line">(tensorflow)$  # Your prompt should change.</span><br><span class="line"># Run Python programs that use TensorFlow.</span><br><span class="line">...</span><br><span class="line"># When you are done using TensorFlow, deactivate the environment.</span><br><span class="line">(tensorflow)$ source deactivate</span><br></pre></td></tr></table></figure>
<h2 id="PyCharm-配置"><a href="#PyCharm-配置" class="headerlink" title="PyCharm 配置"></a>PyCharm 配置</h2><p><strong>重点：</strong>正确配置<code>Project</code>的<code>Interpreter</code>即可</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>Preferences</li>
<li>Project Interpreter</li>
<li>Click More</li>
</ul>
<h3 id="附图"><a href="#附图" class="headerlink" title="附图"></a>附图</h3><ul>
<li>打开Preferences</li>
</ul>
<p><img src="http://o88e8any8.bkt.clouddn.com/tensorflow_pycharm_config_mac_1.png" alt="打开Preferences"></p>
<p><img src="http://o88e8any8.bkt.clouddn.com/tensorflow_pycharm_config_mac_2.png" alt="选择more"></p>
<ul>
<li>打开Project Interpreters</li>
</ul>
<p><img src="http://o88e8any8.bkt.clouddn.com/tensorflow_pycharm_config_mac_3.png" alt="选择正确的tensorflow路径"></p>
<ul>
<li>Demo运行结果</li>
</ul>
<p><img src="http://o88e8any8.bkt.clouddn.com/tensorflow_pycharm_config_mac_4.png" alt="demo运行结果"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。目前来说，&lt;a href=&quot;https://github.com/tensorflow/tensorflow&quot;&gt;Github&lt;/a&gt;上star最多的项目就是它了。&lt;/p&gt;
&lt;p&gt;在这之前，笔者写过一篇简单的入门文章&lt;a href=&quot;/2017/06/07/tensorflow-primer-guide/&quot;&gt;《初探 TensorFlow》&lt;/a&gt;。当时没能成功搭建环境，加上后期的工作原因，至此搁置了一段时间。今天，终于各种折腾，在自己的Mac上经过多种尝试之后，完美搭建成功。这里就把它分享出来，希望对大家有所帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="ml" scheme="http://chars.tech/categories/machine-learning/"/>
    
    
      <category term="python" scheme="http://chars.tech/tags/python/"/>
    
      <category term="tensorflow" scheme="http://chars.tech/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>iOS App 启动性能优化</title>
    <link href="http://chars.tech/2017/09/22/ios-app-launch-time-optimize/"/>
    <id>http://chars.tech/2017/09/22/ios-app-launch-time-optimize/</id>
    <published>2017-09-22T06:02:16.000Z</published>
    <updated>2017-10-18T06:51:27.145Z</updated>
    
    <content type="html"><![CDATA[<p>应用启动时间，直接影响用户对一款应用的判断和使用体验。<code>ZAKER新闻</code>本身就包含非常多并且复杂度高的业务模块（如新闻、视频等），也接入了很多第三方的插件，这势必会拖慢应用的启动时间，本着精益求精的态度和对用户体验的追求，我们希望在业务扩张的同时最大程度的优化启动时间。</p>
<a id="more"></a>
<h2 id="启动时间"><a href="#启动时间" class="headerlink" title="启动时间"></a>启动时间</h2><p>总时间 = T1 + T2</p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>加载<code>系统dylib</code>和<code>可执行文件</code>的时间。</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>从<code>main</code>到<code>applicationWillFinishLaunching</code>结束的时间。</p>
<h2 id="App启动过程"><a href="#App启动过程" class="headerlink" title="App启动过程"></a>App启动过程</h2><p><img src="http://o88e8any8.bkt.clouddn.com/ios-app-launch-time-optimize-1.png" alt="App启动过程"></p>
<p>1）解析<code>Info.plist</code></p>
<ul>
<li>加载相关信息，例如如闪屏</li>
<li>沙箱建立、权限检查</li>
</ul>
<p>2）<code>Mach-O</code>加载</p>
<ul>
<li>如果是胖二进制文件，寻找合适当前CPU类别的部分</li>
<li>加载所有依赖的<code>Mach-O</code>文件（递归调用<code>Mach-O</code>加载的方法）</li>
<li>定位内部、外部指针引用，例如字符串、函数等</li>
<li>执行声明为<code>__attribute__((constructor))</code>的C函数</li>
<li>加载类扩展（Category）中的方法</li>
<li>C++静态对象加载、调用ObjC的<code>+load</code>函数</li>
</ul>
<p>3）程序执行</p>
<ul>
<li>调用<code>main()</code></li>
<li>调用<code>UIApplicationMain()</code></li>
<li>调用<code>applicationWillFinishLaunching</code></li>
</ul>
<h3 id="Mach-O"><a href="#Mach-O" class="headerlink" title="Mach-O"></a>Mach-O</h3><p>Mach-O 是针对不同运行时可执行文件的文件类型。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-app-launch-time-optimize-4.png" alt="Mach-O"></p>
<h4 id="文件类型："><a href="#文件类型：" class="headerlink" title="文件类型："></a>文件类型：</h4><p>Executable： 应用的主要二进制</p>
<p>Dylib： 动态链接库（又称 DSO 或 DLL）</p>
<p>Bundle： 不能被链接的 Dylib，只能在运行时使用 dlopen() 加载，可当做 macOS 的插件。</p>
<p>Image： executable，dylib 或 bundle</p>
<p>Framework： 包含 Dylib 以及资源文件和头文件的文件夹</p>
<h3 id="Mach-O-镜像文件"><a href="#Mach-O-镜像文件" class="headerlink" title="Mach-O 镜像文件"></a>Mach-O 镜像文件</h3><p>Mach-O 被划分成一些 segement，每个 segement 又被划分成一些 section。</p>
<p>segment 的名字都是大写的，且空间大小为页的整数。页的大小跟硬件有关，在 arm64 架构一页是 16KB，其余为 4KB。</p>
<p>section 虽然没有整数倍页大小的限制，但是 section 之间不会有重叠。</p>
<p>几乎所有 Mach-O 都包含这三个段（segment）： <code>__TEXT</code>,<code>__DATA</code> 和 <code>__LINKEDIT</code>：</p>
<ul>
<li><p><code>__TEXT</code> 包含 Mach header，被执行的代码和只读常量（如C 字符串）。只读可执行（r-x）。</p>
</li>
<li><p><code>__DATA</code> 包含全局变量，静态变量等。可读写（rw-）。</p>
</li>
<li><p><code>__LINKEDIT</code> 包含了加载程序的『元数据』，比如函数的名称和地址。只读（r–）。</p>
</li>
</ul>
<h3 id="Mach-O-Universal-文件"><a href="#Mach-O-Universal-文件" class="headerlink" title="Mach-O Universal 文件"></a>Mach-O Universal 文件</h3><p><a href="https://en.wikipedia.org/wiki/Fat_binary" target="_blank" rel="external">FAT 二进制</a>文件，将多种架构的 Mach-O 文件合并而成。它通过 Fat Header 来记录不同架构在文件中的偏移量，Fat Header 占一页的空间。</p>
<p>按分页来存储这些 segement 和 header 会浪费空间，但这有利于虚拟内存的实现。</p>
<h3 id="什么是image"><a href="#什么是image" class="headerlink" title="什么是image"></a>什么是image</h3><p>1.executable可执行文件 比如.o文件。 </p>
<p>2.dylib 动态链接库 framework就是动态链接库和相应资源包含在一起的一个文件夹结构。 </p>
<p>3.bundle 资源文件 只能用dlopen加载，不推荐使用这种方式加载。</p>
<p>除了我们App本身的可行性文件，系统中所有的framework比如UIKit、Foundation等都是以动态链接库的方式集成进App中的。</p>
<h3 id="什么是ImageLoader"><a href="#什么是ImageLoader" class="headerlink" title="什么是ImageLoader"></a>什么是ImageLoader</h3><p>image 表示一个二进制文件(可执行文件或 so 文件)，里面是被编译过的符号、代码等，所以 ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。 </p>
<p>两步走：在程序运行时它先将动态链接的 image 递归加载 (也就是上面测试栈中一串的递归调用的时刻)。 再从可执行文件 image 递归加载所有符号。</p>
<h2 id="冷启动和热启动"><a href="#冷启动和热启动" class="headerlink" title="冷启动和热启动"></a>冷启动和热启动</h2><h3 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h3><p>应用首次启动。即后台线程中未有当前打开的应用，所有的资源都需要加载并初始化。</p>
<h3 id="热启动"><a href="#热启动" class="headerlink" title="热启动"></a>热启动</h3><p>应用非首次启动。即后台线程中保留有当前应用，应用的资源在内存中有保存。</p>
<h2 id="启动时间分析"><a href="#启动时间分析" class="headerlink" title="启动时间分析"></a>启动时间分析</h2><p>1）开启时间分析功能</p>
<p>在Xcode的菜单中选择<code>Project</code>→<code>Scheme</code>→<code>Edit Scheme...</code>，然后找到<code>Run</code> → <code>Environment Variables</code> →<code>+</code>，添加<code>name</code>为<code>DYLD_PRINT_STATISTICSvalue</code>为<code>1</code>的环境变量。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-app-launch-time-optimize-2.png" alt="开启时间分析功能"></p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-app-launch-time-optimize-3.png" alt="启动时间"></p>
<h3 id="load-dylibs-image"><a href="#load-dylibs-image" class="headerlink" title="load dylibs image"></a>load dylibs image</h3><p>在每个动态库的加载过程中， dyld需要：</p>
<p>1.分析所依赖的动态库</p>
<p>2.找到动态库的mach-o文件</p>
<p>3.打开文件</p>
<p>4.验证文件</p>
<p>5.在系统核心注册文件签名</p>
<p>6.对动态库的每一个segment调用mmap()</p>
<p>通常的，一个App需要加载100到400个dylibs， 但是其中的系统库被优化，可以很快的加载。 针对这一步骤的优化有：</p>
<p>1.减少非系统库的依赖</p>
<p>2.合并非系统库</p>
<p>3.使用静态资源，比如把代码加入主程序</p>
<h3 id="rebase-bind"><a href="#rebase-bind" class="headerlink" title="rebase/bind"></a>rebase/bind</h3><p>由于ASLR(address space layout randomization)的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这2步来修复镜像中的资源指针，来指向正确的地址。 rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。 </p>
<p>rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。</p>
<p>优化该阶段的关键在于减少__DATA segment中的指针数量。我们可以优化的点有：</p>
<p>1.减少Objc类数量， 减少selector数量</p>
<p>2.减少C++虚函数数量</p>
<p>3.转而使用swift stuct（其实本质上就是为了减少符号的数量）</p>
<h3 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h3><ul>
<li><code>main()</code>函数之前总共使用了506.48ms</li>
<li>在506.48ms中，加载动态库用了46.35ms，指针重定位使用了137.72ms，ObjC类初始化使用了95.39ms，各种初始化使用了226.92ms。</li>
<li>在初始化耗费的226.92ms中，用时最多的几个初始化是<code>libSystem.B.dylib</code>、<code>libBacktraceRecording.dylib</code>、<code>libglInterpose.dylib</code>以及<code>libMTLInterpose.dylib</code>。</li>
</ul>
<p>2）使用instruments工作分析具体时间消耗点</p>
<h2 id="耗时的影响因素"><a href="#耗时的影响因素" class="headerlink" title="耗时的影响因素"></a>耗时的影响因素</h2><p>1） <code>main()</code>函数之前耗时的影响因素</p>
<ul>
<li>动态库加载越多，启动越慢。</li>
<li>ObjC类越多，启动越慢</li>
<li>C的<code>constructor</code>函数越多，启动越慢</li>
<li>C++静态对象越多，启动越慢</li>
<li>ObjC的<code>+load</code>越多，启动越慢</li>
</ul>
<p>实验证明，在ObjC类的数目一样多的情况下，需要加载的动态库越多，App启动就越慢。同样的，在动态库一样多的情况下，ObjC的类越多，App的启动也越慢。需要加载的动态库从1个上升到10个的时候，用户几乎感知不到任何分别，但从10个上升到100个的时候就会变得十分明显。同理，100个类和1000个类，可能也很难查察觉得出，但1000个类和10000个类的分别就开始明显起来。</p>
<p>同样的，尽量不要写<code>__attribute__((constructor))</code>的C函数，也尽量不要用到C++的静态对象；至于ObjC的<code>+load</code>方法，似乎大家已经习惯不用它了。任何情况下，能用<code>dispatch_once()</code>来完成的，就尽量不要用到以上的方法。</p>
<p>2） <code>main()</code>函数之后耗时的影响因素</p>
<p>从<code>main()</code>函数开始至<code>applicationWillFinishLaunching</code>结束，我们统一称为<code>main()</code>函数之后的部分。</p>
<ul>
<li>执行<code>main()</code>函数的耗时</li>
<li>执行<code>applicationWillFinishLaunching</code>的耗时</li>
<li><code>rootViewController</code>及其<code>childViewController</code>的加载、<code>view</code>及其<code>subviews</code>的加载</li>
</ul>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="移除不需要用到的类"><a href="#移除不需要用到的类" class="headerlink" title="移除不需要用到的类"></a>移除不需要用到的类</h3><p>为了解决这个历史问题，我使用了一个叫做<a href="https://github.com/dblock/fui" target="_blank" rel="external">fui（Find Unused Imports）</a>的开源项目，它能很好的分析出不再使用的类，准确率非常高，唯一的问题是它处理不了动态库和静态库里提供的类，也处理不了C++的类模板。</p>
<p>使用方法是在<code>Terminal</code>中<code>cd</code>到项目所在的目录，然后执行<code>fui find</code>，然后等上那么几分钟（是的你没有看错，真的需要好几分钟甚至需要更长的时间），就可以得到一个列表了。由于这个工具还不是100%靠谱，可根据这个列表，在Xcode中手动检查并删除不再用到的类。</p>
<h3 id="合并功能类似的类和扩展（Category）"><a href="#合并功能类似的类和扩展（Category）" class="headerlink" title="合并功能类似的类和扩展（Category）"></a>合并功能类似的类和扩展（Category）</h3><h3 id="优化application-didFinishLaunchingWithOptions-方法"><a href="#优化application-didFinishLaunchingWithOptions-方法" class="headerlink" title="优化application:didFinishLaunchingWithOptions:方法"></a>优化<code>application:didFinishLaunchingWithOptions:</code>方法</h3><h3 id="优化rootViewController加载"><a href="#优化rootViewController加载" class="headerlink" title="优化rootViewController加载"></a>优化<code>rootViewController</code>加载</h3><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1）<code>NSUserDefaults</code>是否是瓶颈</p>
<p>2）还有其他哪些点可以做优化</p>
<p>参考文档：<a href="http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/" target="_blank" rel="external">《优化 App 的启动时间》</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应用启动时间，直接影响用户对一款应用的判断和使用体验。&lt;code&gt;ZAKER新闻&lt;/code&gt;本身就包含非常多并且复杂度高的业务模块（如新闻、视频等），也接入了很多第三方的插件，这势必会拖慢应用的启动时间，本着精益求精的态度和对用户体验的追求，我们希望在业务扩张的同时最大程度的优化启动时间。&lt;/p&gt;
    
    </summary>
    
      <category term="pieces" scheme="http://chars.tech/categories/pieces/"/>
    
    
      <category term="ios" scheme="http://chars.tech/tags/ios/"/>
    
      <category term="性能" scheme="http://chars.tech/tags/performance/"/>
    
      <category term="优化" scheme="http://chars.tech/tags/optimization/"/>
    
  </entry>
  
  <entry>
    <title>那些设计iOS API需要知道的事</title>
    <link href="http://chars.tech/2017/07/09/ios-design-api-guide/"/>
    <id>http://chars.tech/2017/07/09/ios-design-api-guide/</id>
    <published>2017-07-09T14:32:33.000Z</published>
    <updated>2017-07-28T11:03:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了能够将我们项目中的代码能够在后续开发者使用（重用代码），通常使用的方法是将代码按照功能模块编写成API。那么我们就很有必要了解Objective-C语言中常见的编程范式（paradigm），同时还需了解各种可能碰到的陷阱。</p>
<a id="more"></a>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h3 id="命名冲突的问题"><a href="#命名冲突的问题" class="headerlink" title="命名冲突的问题"></a>命名冲突的问题</h3><p>Objective-C没有其他语言的那种内置命名空间（namespace）机制。因此，我们只能自己想办法来解决命名冲突问题。最常用的解决方式就是，仿照其他语言（C++）建立自己的namespace，例如，使用前缀。</p>
<p>所选前缀可以是与公司、应用程序或二者皆有关联之名。例如，ZAKER User Interface可以使用ZUI作为前缀。使用Cocoa创建应用程序时一定要注意，Apple宣称其保留使用所有“两字母前缀”(two-letter prefix)的权利，所以开发者选用的前缀应该是三个字母的。如果开发者使用了两个字母作前缀，那么很有可能开发者自定义的API和Apple的API冲突。</p>
<p>不仅仅是类名，应用程序中的所有名称都应该加前缀。如果要为既有类新增“分类”(category)，那么一定要给“分类”及“分类”中的方法加上前缀。另外，类的实现文件中所用的纯C函数及全局变量也应该注意添加前缀。</p>
<p>如果使用了第三方库编写自己的代码，并准备将其发布为程序库供他人开发应用程序所用，则尤其要注意重复符号问题。这种情况下为了避免使用者使用了与你相同的第三方库，应该为第三方库都加上你自己的前缀。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-design-api-guide-1.png?imageView/2/w/400" alt="第三方库引入使用前缀"></p>
<h3 id="命名方式"><a href="#命名方式" class="headerlink" title="命名方式"></a>命名方式</h3><p>类、方法和变量的命名是Objective-C编程的重要环节。如果命名方式好，可以提高代码可读性，减少不必要的注释。<br>初学者通常会觉得Objective-C是门很繁琐的语言，因为其语法结构使得代码读起来和句子一样。命名中一般都带有“in”、“for”、“with”等介词，特别是在命名时还要讲究英文语法。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *text = @&quot;This is a good idea.&quot;;</span><br><span class="line">NSString *newText = [text stringByReplacingOccurrencesOfString:@&quot;idea&quot; withString:@&quot;think&quot;];</span><br></pre></td></tr></table></figure>
<p>上面的代码虽然用了比较啰嗦的方式描述一个看上去很简单的表达式。对于执行替换的那个方法，代码读起来就像日常语言里的那个句子：“Take text and give me a new string by replacing the occurrences of the string ‘idea’ with the string ‘think’”。<br>这个句子准确描述了开发者想做的事。在命名不像Objective-C这般繁琐的语言中，类似的程序可能会写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string text = &quot;This is a good idea.&quot;;</span><br><span class="line">string new Text = text.replace(&quot;idea&quot;, &quot;think&quot;);</span><br></pre></td></tr></table></figure>
<p>上面代码这样写，看起来方法名简洁很多，但是带来的代码不可读性却是非常大的。首先，我们不知道 text.replace 方法的两个参数到底按照什么顺序解读（除非查看方法声明）；再者，这两个参数谁替换谁？</p>
<p>另外，和大多数语言一样，Objective-C也是采用“驼峰式大小写命名法”（camel casing）——以小写字母开头，其后每个单词首字母大写。</p>
<h4 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h4><p>清晰的方法名从左至右读起来好似一段文章。并不是说非得按照那些命名规则来给方法起名，不过这样做可以令代码变得更好维护，使他人更容易读懂。<br>虽然类似C++或Java中那种函数命名简单，但是，若想知道每个参数的用途，就得查看函数原型，这会令代码难于读懂。<br>NSString这个类展示了一套良好的命名习惯。下面列举几个方法及命名缘由：</p>
<p>1）<code>+ (instancetype)string;</code><br>工厂方法（factory method），用于创建新的空字符串。方法名清晰地描述了返回值的类型。</p>
<p>2）<code>+ (instancetype)stringWithString:(NSString *)string;</code><br>工厂方法，根据某字符串创建出与之内容相同的新字符串。与创建空字符串所用的那个工厂方法一样，方法名的第一个单词也指明了返回类型。</p>
<p>3）<code>+ (instancetype)localizedStringWithFormat:(NSString *)format, ...;</code><br>工厂方法，根据特定格式创建出新的“本地化字符串”（localized string）。返回值类型是方法名的第二个单词（string），因为其前面还有个修饰语（localized）用来描述其逻辑含义。此方法的返回值依然是“字符串”（string），只不过是一种经过本地化处理的特殊字符串。</p>
<p>4）<code>- (NSUInteger)lengthOfBytesUsingEncoding:(NSStringEncoding)enc;</code><br>若字符串是以给定的编码格式（ASCII、UTF8、UTF16）来编码的，则返回其字节数组长度。此方法与length相似，但该方法还需一个参数，该参数紧跟着方法名中描述其类型的那个名词（encoding）。</p>
<p>因此，我们可以总结成几条方法命名规则：</p>
<p>1）如果方法的返回值是新创建的，那么方法名的首个词应该是返回值的类型，除非前面还有修饰语，例如localizedString。属性的存取方法不遵循这种命名方式，因为一般认为这些方法不会创建新对象。即便有时返回内部对象的一份拷贝，我们也认为那相当于原有对象。这些存取方法应该按照其所对应的属性来命名。</p>
<p>2）应该把表示参数类型的名词放在参数前面。</p>
<p>3）如果方法要在当前对象上执行操作，那么就应该包含动词；若执行操作时还需要参数，则应该在动词后面加上一个或多个名词。</p>
<p>4）不要使用str这种简称，应该使用string这样的全称。</p>
<p>5）boolean属性应加is前缀。如果某方法返回非属性的boolean值，那么应该根据其功能，选用has或is当前缀。</p>
<p>6）将get这个前缀留给那些借由“输出参数”来保存返回值的方法，比如说，把返回值填充到“C语言式数组”（C-style array）里的那种方法就可以使用这个词做前缀。</p>
<h4 id="类与协议命名"><a href="#类与协议命名" class="headerlink" title="类与协议命名"></a>类与协议命名</h4><p>不仅仅是方法，类和协议也应该加上前缀，避免命名空间冲突。例如：</p>
<ul>
<li>UIView</li>
<li>UIViewController</li>
<li>UITableViewDelegate</li>
</ul>
<h2 id="错误模型"><a href="#错误模型" class="headerlink" title="错误模型"></a>错误模型</h2><p>目前有很多编程语言都有“异常”(exception)机制，Objective-C也不例外。</p>
<p>“自动引用计数”(ARC, Automatic Reference Counting)在默认情况下不是“异常安全的”。这意味着：如果抛出异常，那么本应该在作用域末尾释放的对象现在却不会自动释放了。如果想生成“异常安全”的代码，可以通过设置编译器的标志来实现，不过这将引入额外代码，在不抛出异常时，也照样要执行这部分代码。需要打开的编译器标志叫做<code>-fobjc-arc-exception</code>。</p>
<p>Objective-C现在所采用的办法是：只在极其罕见的情况下抛出异常，异常抛出之后，无须考虑恢复问题，而且应用程序此时也应该退出。这就是说，不用再编写复杂的“异常安全”代码了。</p>
<p>异常只应该用于极其严重的错误，比如，你编写了某个抽象基类，它的正确用法是先从中继承一个子类，然后使用这个子类。在这种情况下，如果有人直接使用了这个抽象基类，那么可以考虑抛出异常。与其他语言不同，Objective-C中没办法将某个类标识为“抽象类”。要想达成类似效果，最好的办法是在那些子类必须覆写的超类方法里抛出异常。</p>
<p>异常只用于处理严重错误(fatal error)，对于其他错误，Objective-C语言所用的编程范式为：令方法返回nil/0，或使用NSError，以表明有错误发生。</p>
<p>NSError对象里封装了三条信息：</p>
<ul>
<li>Error domain (错误范围，其类型为字符串)</li>
</ul>
<p>错误发生的范围，也就是产生错误的根源，通常用一个特有的全局变量来定义。例如，URL-handling-subsystem，在从URL中解析或获取数据时如果出错了，那么就使用NSURLErrorDomain来表示错误范围。</p>
<ul>
<li>Error code (错误码，其类型为整数)</li>
</ul>
<p>独有的错误码，用以指明在某个范围内具体发生了何种错误。某个特定范围内可能会发生一系列相关错误，这些错误情况通常采用enum来定义。</p>
<ul>
<li>User info (用户信息，其类型为字典)</li>
</ul>
<p>有关此错误的额外信息，其中或许包含一段“本地化描述”，或许还包含有导致该错误发生的另外一个错误，经由此种信息，可将相关错误串成一条“错误链”。</p>
<h2 id="使用不可变对象"><a href="#使用不可变对象" class="headerlink" title="使用不可变对象"></a>使用不可变对象</h2><p>设计类的时候，应充分使用属性来封装数据。而在使用属性时，则可将其声明为<code>readonly</code>。默认情况下，属性是<code>readwrite</code>。</p>
<p>因为如果把可变对象(mutable object)放入collection之后又修改其内容，那么很容易就会破坏set的内部数据结构，使其失去固有的语义。故此，我们应该尽量减少对象中的可变内容。具体到编程实践中，则应该尽量把对外公布出来的属性设为<code>readonly</code>，而且只在有必要时才将属性对外公布。</p>
<p>定义类的公共API时，需要注意，对象里表示各种collection的那些属性究竟应该设成可变的，还是不可变的。如果某个属性可以为外界所增删，那么这个属性就需要用可变的set来实现。在这种情况下，通常应该提供一个readonly属性供外界使用，该属性将返回不可变的set，而此set则是内部那个可变set的一份拷贝。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">//  ZKRPointOfInterest.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ZKRPointOfInterest : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy, readonly) NSString *identifier;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *title;</span><br><span class="line">@property (nonatomic, assign, readonly) CGFloat latitude;</span><br><span class="line">@property (nonatomic, assign, readonly) CGFloat longitude;</span><br><span class="line">@property (nonatomic, strong, readonly) NSSet *locations;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithIdentifier:(NSString *)identifier</span><br><span class="line">                             title:(NSString *)title</span><br><span class="line">                          latitude:(CGFloat)latitude</span><br><span class="line">                         longitude:(CGFloat)longitude;</span><br><span class="line"></span><br><span class="line">- (void)addLocation:(ZKRPointOfInterest *)location;</span><br><span class="line">- (void)removeLocation:(ZKRPointOfInterest *)location;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  ZKRPointOfInterest.m</span><br><span class="line"></span><br><span class="line">#import &quot;ZKRPointOfInterest.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZKRPointOfInterest</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableSet *_internalLocations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithIdentifier:(NSString *)identifier</span><br><span class="line">                             title:(NSString *)title</span><br><span class="line">                          latitude:(CGFloat)latitude</span><br><span class="line">                         longitude:(CGFloat)longitude</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSSet *)locations</span><br><span class="line">&#123;</span><br><span class="line">    return [_internalLocations copy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addLocation:(ZKRPointOfInterest *)location</span><br><span class="line">&#123;</span><br><span class="line">    if (location) &#123;</span><br><span class="line">        [_internalLocations addObject:location];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeLocation:(ZKRPointOfInterest *)location</span><br><span class="line">&#123;</span><br><span class="line">    [_internalLocations removeObject:location];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>不要在返回的对象上查询类型以确定其是否可变。(即使不用<code>isKindOfClass:</code>方法来判断返回值类型是否可变)</p>
<h2 id="description方法"><a href="#description方法" class="headerlink" title="description方法"></a>description方法</h2><p>在调试程序时，经常需要打印并查看对象信息。一种办法是编写代码把对象的全部属性都log到日志中。<code>NSLog(@&quot;object=%@&quot;, object);</code></p>
<p>在构建需要打印到日志的字符串时，object对象会收到description消息，该方法所返回的描述信息将取代“格式字符串”(format string)里的“%@”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *obj = @[@&quot;A string&quot;, @(123)];</span><br><span class="line">NSLog(@&quot;object=%@&quot;, obj);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object=(</span><br><span class="line">	&quot;A string&quot;,</span><br><span class="line">	123</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果在自定义类上这么做，那么则输出的信息却是如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object=&lt;ZKRSqure: 0x7656d8a90060&gt;</span><br></pre></td></tr></table></figure>
<p>如果想要像上面NSArray那样打印出有用的信息，那么我们就应该在自己的类中覆写description方法，否则打印信息时就会调用NSObject类所实现的默认方法。此方法定义在NSObject协议里，不过NSObject类也实现了它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)description</span><br><span class="line">&#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;&lt;%@: %p, \&quot;%f %f\&quot;&gt;&quot;, [self class], self, _width, _height];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ZKRRectangle *rectangle = [[ZKRRectangle alloc] initWithWidth:5.0 height:7.0];</span><br><span class="line">NSLog(@&quot;%@&quot;, rectangle);</span><br><span class="line"></span><br><span class="line">//Output</span><br><span class="line">&lt;ZKRRectangle: 0x60000002fc20, &quot;5.000000 7.000000&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>NSObject协议中还有个需要注意的方法，就是<code>debugDescription</code>，此方法用意与<code>description</code>相似。二者区别在于，<code>debugDescription</code>方法是开发者在调试器(debugger)中以控制台命令打印对象时才调用的。在NSObject类的默认实现中，它只是直接调用<code>description</code>。</p>
<h2 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h2><p>所有对象均要初始化，在初始化时，有些对象可能无须开发者向其提供额外信息，不过一般来说还是需要提供的。通常情况下，对象若不知道必要的信息，则无法完成其工作。例如，UITAbleViewCell类初始化该类对象时，需要指明其样式及标识符，标识符能够区分不同类型的单元格。由于这种对象的创建成本较高，所以绘制表格时可依照标识符来复用，以提升程序效率。这种可为对象提供必要信息以便其能完成工作的初始化方法叫做“全能初始化方法”(designated initializer)。</p>
<p>如果创建类实例的方式不止一种，那么这个类就会有多个初始化方法。但是，我们仍然需要选定一个作为全能初始化方法，令其他初始化方法都来调用它。例如，NSDate类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init NS_DESIGNATED_INITIALIZER;</span><br><span class="line">- (instancetype)initWithTimeIntervalSinceReferenceDate:(NSTimeInterval)ti NS_DESIGNATED_INITIALIZER;</span><br><span class="line">- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;</span><br><span class="line">- (instancetype)initWithTimeIntervalSinceNow:(NSTimeInterval)secs;</span><br><span class="line">- (instancetype)initWithTimeIntervalSince1970:(NSTimeInterval)secs;</span><br><span class="line">- (instancetype)initWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date;</span><br></pre></td></tr></table></figure>
<p>在上面几个初始化方法中，<code>initWithTimeIntervalSinceReferenceDate:</code>是全能初始化方法。只有在全能初始化方法中，才会存储内部数据。这样的话，当底层数据存储机制改变时，只需修改此方法的代码就好，无须改动其他初始化方法。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">//  ZKRRectangle.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ZKRRectangle : NSObject&lt;NSCopying&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readonly) CGFloat width;</span><br><span class="line">@property (nonatomic, assign, readonly) CGFloat height;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  ZKRRectangle.m</span><br><span class="line"></span><br><span class="line">#import &quot;ZKRRectangle.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZKRRectangle</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _width = [[aDecoder decodeObjectForKey:@&quot;width&quot;] floatValue];</span><br><span class="line">        _height = [[aDecoder decodeObjectForKey:@&quot;height&quot;] floatValue];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithWidth:height: instad.&quot; userInfo:nil];</span><br><span class="line">    </span><br><span class="line">    return [self initWithWidth:0 height:0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _width = width;</span><br><span class="line">        _height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  ZKRSquare.h</span><br><span class="line"></span><br><span class="line">#import &quot;ZKRRectangle.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ZKRSquare : ZKRRectangle</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithDimension:(CGFloat)dimension;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  ZKRSquare.m</span><br><span class="line"></span><br><span class="line">#import &quot;ZKRSquare.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZKRSquare</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithDimension: instad.&quot; userInfo:nil];</span><br><span class="line">    </span><br><span class="line">    return [self initWithDimension:0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithDimension:(CGFloat)dimension</span><br><span class="line">&#123;</span><br><span class="line">    return [super initWithWidth:dimension height:dimension];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height</span><br><span class="line">&#123;</span><br><span class="line">    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithDimension: instad.&quot; userInfo:nil];</span><br><span class="line">    CGFloat dimension = MIN(width, height);</span><br><span class="line">    return [self initWithDimension:dimension];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均调用此方法。</li>
<li>若全能方法于超类不同，则需要覆写超类中的对应方法。</li>
<li>如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。</li>
</ul>
<h2 id="NSCopying协议"><a href="#NSCopying协议" class="headerlink" title="NSCopying协议"></a>NSCopying协议</h2><p>使用对象时经常需要拷贝它。在Objective-C中，此操作通过copy方法完成。如果想令自己的类支持拷贝操作，那就要实现NSCopying协议，该协议只有一个方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)copyWithZone:(nullable NSZone *)zone;</span><br></pre></td></tr></table></figure>
<p>为什么会出现NSZone呢？因为以前开发程序时，会据此把内容分成不同的“区”(zone)，而对象会创建在某个区里面。现在不用了，每个程序只有一个区：“默认区”(default zone)。所以说，尽管必须实现这个方法，但是你不必担心其中的zone参数。</p>
<p>copy方法由NSObject实现，该方法只是以“默认区”为参数来调用<code>copyWithZone:</code>。我们总是想覆写copy方法，其实真正需要实现的是<code>copyWithZone:</code>方法。若想使某个类支持拷贝功能，只需声明该类遵从NSCopying协议，并实现其中的那个方法即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (id)copyWithZone:(NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    ZKRRectangle *copy = [[[self class] allocWithZone:zone] initWithWidth:_width height:_height];</span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说到copy方法，除了NSString这样的不可变类型的copy，与之类似的还有NSMutableString类的<code>mutableCopy</code>方法。与<code>copyWithZone:</code>方法相对应的可变内容的copy方法<code>mutableCopyWithZone:</code>方法来自于<code>NSMutableCopying</code>协议。如果你的类分为可变版本(mutable)与不可变版本(immutable)，那么就应该实现NSMutableCopying协议。若采用此模式，则在可变类中覆写<code>copyWithZone:</code>方法时，不要返回可变的拷贝，而应该返回一份不可变的版本。无论当前实例是否可变，需要获取其可变版本的拷贝，均应调用mutableCopy方法；获取不可变版本的拷贝，则总应该通过copy方法。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-design-api-guide-2.png?imageView/2/w/500" alt="mutableCopy和copy类"></p>
<p>深拷贝就是在拷贝对象自身时，将其底层数据也一并复制过去。<br>浅拷贝就是在拷贝对象时，只拷贝容器对象本身，而不复制其中数据。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-design-api-guide-3.png?imageView/2/w/400" alt="深拷贝和浅拷贝比较"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了能够将我们项目中的代码能够在后续开发者使用（重用代码），通常使用的方法是将代码按照功能模块编写成API。那么我们就很有必要了解Objective-C语言中常见的编程范式（paradigm），同时还需了解各种可能碰到的陷阱。&lt;/p&gt;
    
    </summary>
    
      <category term="pieces" scheme="http://chars.tech/categories/pieces/"/>
    
    
      <category term="ios" scheme="http://chars.tech/tags/ios/"/>
    
      <category term="objc" scheme="http://chars.tech/tags/objc/"/>
    
      <category term="框架" scheme="http://chars.tech/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>从iOS的图片圆角想到渲染</title>
    <link href="http://chars.tech/2017/07/03/ios-corner-radius/"/>
    <id>http://chars.tech/2017/07/03/ios-corner-radius/</id>
    <published>2017-07-03T06:40:56.000Z</published>
    <updated>2017-07-05T08:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>圆角是一种很常见的视图效果，相比于直角，它更加柔和优美，易于接受。设置圆角会带来一定的性能损耗，如何提高性能是一个需要重点讨论的话题。</p>
<p>大家常见的圆角代码<code>x.layer.cornerRadius = xx; x.clipsToBounds = YES;</code>这两行确实实现了圆角视觉效果。其实使用<code>x.layer.cornerRadius = xx;</code>已经实现了圆角，只不过在某些控件是不生效的，因为某些图层在被切割圆角图层之上而被显示出来了。而<code>x.clipsToBounds = YES;</code>带来的后果就是产生<code>离屏渲染</code>。可以使用instruments中的CoreAnimation工具，打开<code>Color Offscren-Rednered Yellow</code>选项，可见黄色区域部分即是离屏渲染部分。</p>
<p>那么离屏渲染会带来什么？当然后资源损耗，可能产生卡顿。因为在iPhone设备的硬件资源有差异，当离屏渲染不多时，并不是很明显感觉到它的缺点。</p>
<a id="more"></a>
<h2 id="什么是像素"><a href="#什么是像素" class="headerlink" title="什么是像素"></a>什么是像素</h2><p>像素，为视频显示的基本单位，译自英文“pixel”，pix是英语单词picture的常用简写，加上英语单词“元素”element，就得到pixel，故“像素”表示“画像元素”之意，有时亦被称为pel（picture element）。每个这样的消息元素不是一个点或者一个方块，而是一个抽象的取样。像素是由红，绿，蓝三种颜色组件构成的。因此，位图数据有时也被叫做 RGB 数据。</p>
<h2 id="显示机制"><a href="#显示机制" class="headerlink" title="显示机制"></a>显示机制</h2><p>一个像素是如何绘制到屏幕上去的？有很多种方式将一些东西映射到显示屏上，他们需要调用不同的框架、许多功能和方法的结合体。这里我们大概看一下屏幕之后发生的事情。</p>
<p>图像想显示到屏幕上使人肉眼可见都需借助像素的力量。它们密集的排布在手机屏幕上，将任何图形通过不同的色值表现出来。计算机显示的流程大致可以描述为将图像转化为一系列像素点的排列然后打印在屏幕上，由图像转化为像素点的过程又可以称之为光栅化，就是从矢量的点线面的描述，变成像素的描述。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/display-screen.png?imageView/2/w/300" alt="display screen"></p>
<p>回溯历史，可以从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。</p>
<h3 id="关于卡顿的简单原理解释"><a href="#关于卡顿的简单原理解释" class="headerlink" title="关于卡顿的简单原理解释"></a>关于卡顿的简单原理解释</h3><p>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p>
<p>CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p>
<h2 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h2><p>当像素映射到屏幕上的时候，后台发生了很多事情。但一旦它们显示到屏幕上，每一个像素均由三个颜色组件构成：红，绿，蓝。三个独立的颜色单元会根据给定的颜色显示到一个像素上。在 iPhoneSE 的显示器上有1,136×640=727,040个像素，因此有2,181,120个颜色单元。在一些Retina屏幕上，这一数字将达到百万以上。所有的图形堆栈一起工作以确保每次正确的显示。当你滚动整个屏幕的时候，数以百万计的颜色单元必须以每秒60次的速度刷新，这就是一个很大的工作量。</p>
<p>简单来说，iOS的显示机制大致如此：<br><img src="http://o88e8any8.bkt.clouddn.com/pixels-software-stack.png" alt="pixels software stack"></p>
<p>Display 的上一层便是图形处理单元 GPU，GPU 是一个专门为图形高并发计算而量身定做的处理单元。这也是为什么它能同时更新所有的像素，并呈现到显示器上。它的并发本性让它能高效的将不同纹理合成起来。所以，开发中我们应该尽量让CPU负责主线程的UI调动，把图形显示相关的工作交给GPU来处理。</p>
<p>GPU Driver 是直接和 GPU 交流的代码块。不同的GPU是不同的性能怪兽，但是驱动使它们在下一个层级上显示的更为统一，典型的下一层级有 OpenGL/OpenGL ES.</p>
<p>OpenGL(Open Graphics Library) 是一个提供了 2D 和 3D 图形渲染的 API。GPU 是一块非常特殊的硬件，OpenGL 和 GPU 密切的工作以提高GPU的能力，并实现硬件加速渲染。</p>
<p>OpenGL 之上扩展出很多东西。在 iOS 上，几乎所有的东西都是通过 Core Animation 绘制出来，然而在 OS X 上，绕过 Core Animation 直接使用 Core Graphics 绘制的情况并不少见。对于一些专门的应用，尤其是游戏，程序可能直接和 OpenGL/OpenGL ES 交流。</p>
<p>需要强调的是，GPU 是一个非常强大的图形硬件，并且在显示像素方面起着核心作用。它连接到 CPU。从硬件上讲两者之间存在某种类型的总线，并且有像 OpenGL，Core Animation 和 Core Graphics 这样的框架来在 GPU 和 CPU 之间精心安排数据的传输。为了将像素显示到屏幕上，一些处理将在 CPU 上进行。然后数据将会传送到 GPU，最终像素显示到屏幕上。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/pixels-hardware.png" alt="pixels hardware"></p>
<p>正如上图显示，GPU 需要将每一个 frame 的纹理(位图)合成在一起(一秒60次)。每一个纹理会占用 VRAM(video RAM)，所以需要给 GPU 同时保持纹理的数量做一个限制。GPU 在合成方面非常高效，但是某些合成任务却比其他更复杂，并且 GPU在 16.7ms(1/60s)内能做的工作也是有限的。</p>
<p>另外一个问题就是将数据传输到 GPU 上。为了让 GPU 访问数据，需要将数据从 RAM 移动到 VRAM 上。这就是提及到的上传数据到 GPU。这些看起来貌似微不足道，但是一些大型的纹理却会非常耗时。</p>
<p>最终，CPU 开始运行程序。你可能会让 CPU 从 bundle 加载一张 PNG 的图片并且解压它。这所有的事情都在 CPU 上进行。然后当你需要显示解压缩后的图片时，它需要以某种方式上传到 GPU。一些看似平凡的，比如显示文本，对 CPU 来说却是一件非常复杂的事情，这会促使 Core Text 和 Core Graphics 框架更紧密的集成来根据文本生成一个位图。一旦准备好，它将会被作为一个纹理上传到 GPU 并准备显示出来。当你滚动或者在屏幕上移动文本时，同样的纹理能够被复用，CPU 只需简单的告诉 GPU 新的位置就行了,所以 GPU 就可以重用存在的纹理了。CPU 并不需要重新渲染文本，并且位图也不需要重新上传到 GPU。</p>
<p>在图形世界中，合成是一个描述不同位图如何放到一起来创建你最终在屏幕上看到图像的过程。屏幕上一切事物皆纹理。一个纹理就是一个包含 RGBA 值的长方形，比如，每一个像素里面都包含红、绿、蓝和透明度的值。在 Core Animation 世界中这就相当于一个 CALayer。</p>
<p>每一个 layer 是一个纹理，所有的纹理都以某种方式堆叠在彼此的顶部。对于屏幕上的每一个像素，GPU 需要算出怎么混合这些纹理来得到像素 RGB 的值。这就是合成。</p>
<p>如果我们所拥有的是一个和屏幕大小一样并且和屏幕像素对齐的单一纹理，那么屏幕上每一个像素相当于纹理中的一个像素，纹理的最后一个像素也就是屏幕的最后一个像素。</p>
<p>如果我们有第二个纹理放在第一个纹理之上，然后GPU将会把第二个纹理合成到第一个纹理中。有很多种不同的合成方法，但是如果我们假定两个纹理的像素对齐，并且使用正常的混合模式，我们便可以用公式来计算每一个像素：<code>R = S + D * ( 1 – Sa )</code><br>结果的颜色是源色彩(顶端纹理)+目标颜色(低一层的纹理)*(1-源颜色的透明度)。在这个公式中所有的颜色都假定已经预先乘以了它们的透明度。</p>
<p>接着我们进行第二个假定，两个纹理都完全不透明，比如 alpha=1。如果目标纹理(低一层的纹理)是蓝色(RGB=0,0,1)，并且源纹理(顶层的纹理)颜色是红色(RGB=1,0,0)，因为 Sa 为1，所以结果为：<code>R = S</code><br>结果是源颜色的红色。这正是我们所期待的(红色覆盖了蓝色)。如果源颜色层为50%的透明，比如 alpha=0.5，既然 alpha 组成部分需要预先乘进 RGB 的值中，那么 S 的 RGB 值为(0.5, 0, 0)，公式看起来便会像这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                       0.5   0               0.5</span><br><span class="line">R = S + D * (1 - Sa) = 0   + 0 * (1 - 0.5) = 0</span><br><span class="line">                       0     1               0.5</span><br></pre></td></tr></table></figure>
<p>我们最终得到RGB值为(0.5, 0, 0.5),是一个紫色。这正是我们所期望将透明红色合成到蓝色背景上所得到的。</p>
<p>记住我们刚刚只是将纹理中的一个像素合成到另一个纹理的像素上。当两个纹理覆盖在一起的时候，GPU需要为所有像素做这种操作。正如你所知道的一样，许多程序都有很多层，因此所有的纹理都需要合成到一起。尽管GPU是一块高度优化的硬件来做这种事情，但这还是会让它非常忙碌。</p>
<h3 id="为何图片缩放会增加GPU工作量"><a href="#为何图片缩放会增加GPU工作量" class="headerlink" title="为何图片缩放会增加GPU工作量"></a>为何图片缩放会增加GPU工作量</h3><p>当所有的像素是对齐的时候我们得到相对简单的计算公式。每当 GPU 需要计算出屏幕上一个像素是什么颜色的时候，它只需要考虑在这个像素之上的所有 layer 中对应的单个像素，并把这些像素合并到一起。或者，如果最顶层的纹理是不透明的(即图层树的最底层)，这时候 GPU 就可以简单的拷贝它的像素到屏幕上。</p>
<p>当一个 layer 上所有的像素和屏幕上的像素完美的对应整齐，那这个 layer 就是像素对齐的。主要有两个原因可能会造成不对齐。第一个便是滚动，当一个纹理上下滚动的时候，纹理的像素便不会和屏幕的像素排列对齐。另一个原因便是当纹理的起点不在一个像素的边界上。</p>
<p>在这两种情况下，GPU 需要再做额外的计算。它需要将源纹理上多个像素混合起来，生成一个用来合成的值。当所有的像素都是对齐的时候，GPU 只剩下很少的工作要做。</p>
<p>Core Animation 工具和模拟器有一个<code>Color Misaligned Images</code>选项，当这些在你的 CALayer 实例中发生的时候，这个功能便可向你展示。</p>
<p>关于iOS设备的一些尺寸限制可以看这里：<a href="http://iosres.com/" target="_blank" rel="external">iOSRes</a></p>
<h2 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h2><p>On-Screen Rendering意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。<br>Off-Screen Rendering意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p>
<p>当图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制时，屏幕外渲染就被唤起了。屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。</p>
<p>离屏渲染可以被 Core Animation 自动触发，或者被应用程序强制触发。屏幕外的渲染会合并/渲染图层树的一部分到一个新的缓冲区，然后该缓冲区被渲染到屏幕上。</p>
<h3 id="特殊的“离屏渲染”：CPU渲染"><a href="#特殊的“离屏渲染”：CPU渲染" class="headerlink" title="特殊的“离屏渲染”：CPU渲染"></a>特殊的“离屏渲染”：CPU渲染</h3><p>如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。<br>整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。</p>
<h3 id="离屏渲染的体现"><a href="#离屏渲染的体现" class="headerlink" title="离屏渲染的体现"></a>离屏渲染的体现</h3><p>相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：</p>
<ul>
<li>1 创建新缓冲区<br>要想进行离屏渲染，首先要创建一个新的缓冲区。</li>
<li>2 上下文切换<br>离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。</li>
</ul>
<h3 id="触发离屏渲染"><a href="#触发离屏渲染" class="headerlink" title="触发离屏渲染"></a>触发离屏渲染</h3><p>1、drawRect<br>2、layer.shouldRasterize = true;<br>3、有mask或者是阴影(layer.masksToBounds, layer.shadow*)；<br> 3.1) shouldRasterize（光栅化）<br> 3.2) masks（遮罩）<br> 3.3) shadows（阴影）<br> 3.4) edge antialiasing（抗锯齿）<br> 3.5) group opacity（不透明）<br>4、Text（UILabel, CATextLayer, Core Text, etc）…<br>注：layer.cornerRadius，layer.borderWidth，layer.borderColor并不会Offscreen Render，因为这些不需要加入Mask。</p>
<h2 id="圆角优化"><a href="#圆角优化" class="headerlink" title="圆角优化"></a>圆角优化</h2><p>前面说了那么多，这里就给上实际可行方案。圆角的优化目前考虑两方面：一是，从图片入手，将图片切割成指定圆角样式。二是，使用贝塞尔曲线，利用CALayer层绘制指定圆角样式的mask遮盖View。</p>
<p>UIImage切割：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);</span><br><span class="line">CGContextScaleCTM(context, 1, -1);</span><br><span class="line">CGContextTranslateCTM(context, 0, -rect.size.height);</span><br><span class="line"></span><br><span class="line">CGFloat minSize = MIN(self.size.width, self.size.height);</span><br><span class="line">if (borderWidth &lt; minSize / 2.0) &#123;</span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectInset(rect, borderWidth, borderWidth) byRoundingCorners:corners cornerRadii:CGSizeMake(radius, borderWidth)];</span><br><span class="line">    CGContextSaveGState(context);</span><br><span class="line">    [path addClip];</span><br><span class="line">    CGContextDrawImage(context, rect, self.CGImage);</span><br><span class="line">    CGContextRestoreGState(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">image = [image dd_imageByCornerRadius:radius borderedColor:borderColor borderWidth:borderWidth corners:corners];</span><br><span class="line">UIGraphicsEndImageContext();</span><br></pre></td></tr></table></figure>
<p>图片绘制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);</span><br><span class="line">[self drawAtPoint:CGPointZero];</span><br><span class="line">CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);</span><br><span class="line">CGFloat strokeInset = borderWidth / 2.0;</span><br><span class="line">CGRect strokeRect = CGRectInset(rect, strokeInset, strokeInset);</span><br><span class="line">UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:strokeRect byRoundingCorners:corners cornerRadii:CGSizeMake(radius, borderWidth)];</span><br><span class="line">path.lineWidth = borderWidth;</span><br><span class="line">[borderColor setStroke];</span><br><span class="line">[path stroke];</span><br><span class="line">UIImage *result = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br></pre></td></tr></table></figure>
<p>具体源码可以转至github进行star <a href="https://github.com/charsdavy/DDCornerRadius" target="_blank" rel="external">DDCornerRadius</a> 欢迎issue。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;圆角是一种很常见的视图效果，相比于直角，它更加柔和优美，易于接受。设置圆角会带来一定的性能损耗，如何提高性能是一个需要重点讨论的话题。&lt;/p&gt;
&lt;p&gt;大家常见的圆角代码&lt;code&gt;x.layer.cornerRadius = xx; x.clipsToBounds = YES;&lt;/code&gt;这两行确实实现了圆角视觉效果。其实使用&lt;code&gt;x.layer.cornerRadius = xx;&lt;/code&gt;已经实现了圆角，只不过在某些控件是不生效的，因为某些图层在被切割圆角图层之上而被显示出来了。而&lt;code&gt;x.clipsToBounds = YES;&lt;/code&gt;带来的后果就是产生&lt;code&gt;离屏渲染&lt;/code&gt;。可以使用instruments中的CoreAnimation工具，打开&lt;code&gt;Color Offscren-Rednered Yellow&lt;/code&gt;选项，可见黄色区域部分即是离屏渲染部分。&lt;/p&gt;
&lt;p&gt;那么离屏渲染会带来什么？当然后资源损耗，可能产生卡顿。因为在iPhone设备的硬件资源有差异，当离屏渲染不多时，并不是很明显感觉到它的缺点。&lt;/p&gt;
    
    </summary>
    
      <category term="pieces" scheme="http://chars.tech/categories/pieces/"/>
    
    
      <category term="ios" scheme="http://chars.tech/tags/ios/"/>
    
      <category term="objc" scheme="http://chars.tech/tags/objc/"/>
    
      <category term="优化" scheme="http://chars.tech/tags/optimization/"/>
    
      <category term="ui" scheme="http://chars.tech/tags/ui/"/>
    
      <category term="渲染" scheme="http://chars.tech/tags/render/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的那些使用</title>
    <link href="http://chars.tech/2017/06/13/binary-tree-guide/"/>
    <id>http://chars.tech/2017/06/13/binary-tree-guide/</id>
    <published>2017-06-13T15:30:22.000Z</published>
    <updated>2017-07-05T08:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支(不存在分支度大于2的节点)的树结构。通常分支被称作“左子树”和“右子树”。二叉树的分支具有左右次序，不能颠倒。</p>
<p>二叉树的第i层至多拥有 2^(i-1) 个节点数；深度为k的二叉树至多总共有 2^(k+1) - 1 个节点数，而总计拥有节点数匹配的，称为“满二叉树”；深度为k有n个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度k的满二叉树，序号为1到n的节点一对一对应时，称为“完全二叉树”。对任何一棵非空的二叉树T，如果其叶片(终端节点)数为n0，分支度为2的节点数为n2，则n0 = n2 + 1。</p>
<p>与普通树不同，普通树的节点个数至少为1，而二叉树的节点个数可以为0；普通树节点的最大分支度没有限制，而二叉树节点的最大分支度为2；普通树的节点无左、右次序之分，而二叉树的节点有左、右次序之分。</p>
<p>二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉查找树和二元堆积，并应用于高效率的搜索和排序。</p>
<a id="more"></a>
<p>相对于普通二叉树，还有一些特殊二叉树，它们诞生于特殊的场景需求。例如，二叉搜索树就是因搜索需求而诞生的一种特殊的树。</p>
<p>具体可以参见<br><a href="/2017/06/10/binary-search-tree/">《聊聊「二叉搜索树」的那些事儿》</a></p>
<p>本文初衷是因为Homebrew 的作者<a href="https://twitter.com/mxcl/status/608682016205344768" target="_blank" rel="external">@Max Howell</a>的一条twitter</p>
<blockquote>
<p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.</p>
</blockquote>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="1-完全二叉树"><a href="#1-完全二叉树" class="headerlink" title="(1)完全二叉树"></a>(1)完全二叉树</h3><p>若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的节点数都达到最大个数，第h层有叶子节点，并且叶子节点都是从左到右依次排布，这就是完全二叉树。</p>
<h3 id="2-满二叉树"><a href="#2-满二叉树" class="headerlink" title="(2)满二叉树"></a>(2)满二叉树</h3><p>除了叶节点外每一个节点都有左右子叶且叶子节点都处在最底层的二叉树。</p>
<h3 id="3-平衡二叉树"><a href="#3-平衡二叉树" class="headerlink" title="(3)平衡二叉树"></a>(3)平衡二叉树</h3><p>平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><p>树的节点：包含一个数据元素及若干指向子树的分支。</p>
<p>孩子节点：节点的子树的根称为该节点的孩子。</p>
<p>双亲节点：B 节点是A 节点的孩子，则A节点是B 节点的双亲。</p>
<p>兄弟节点：同一双亲的孩子节点； </p>
<p>堂兄节点：同一层上节点。</p>
<p>祖先节点: 从根到该节点的所经分支上的所有节点。</p>
<p>子孙节点：以某节点为根的子树中任一节点都称为该节点的子孙。</p>
<p>节点层：根节点的层定义为1；根的孩子为第二层节点，依此类推。</p>
<p>树的深度：树中最大的节点层。</p>
<p>节点的度：节点子树的个数。</p>
<p>树的度： 树中最大的节点度。</p>
<p>叶子节点：也叫终端节点，是度为 0 的节点。</p>
<p>分支节点：度不为0的节点。</p>
<p>有序树：子树有序的树，如：家族树。</p>
<p>无序树：不考虑子树的顺序。</p>
<h2 id="树的结构"><a href="#树的结构" class="headerlink" title="树的结构"></a>树的结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">/** 二叉树节点 */</span><br><span class="line">@interface DDBinaryTreeNode : NSObject</span><br><span class="line"></span><br><span class="line">/** 值 */</span><br><span class="line">@property (nonatomic, assign) NSInteger value;</span><br><span class="line">/** 左节点 */</span><br><span class="line">@property (nonatomic, strong) DDBinaryTreeNode *leftNode;</span><br><span class="line">/** 右节点 */</span><br><span class="line">@property (nonatomic, strong) DDBinaryTreeNode *rightNode;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有节点，使每一个节点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个节点转换成为一个线性序列来表示。</p>
<p>设L、D、R分别表示遍历左子树、访问根节点和遍历右子树， 则对一棵二叉树的遍历有三种情况：DLR（称为先序遍历），LDR（称为中序遍历），LRD （称为后序遍历）。</p>
<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (void)preOrderTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (handler) &#123;</span><br><span class="line">        handler(rootNode);</span><br><span class="line">    &#125;</span><br><span class="line">    [self preOrderTraverseTree:rootNode.leftNode handler:handler];</span><br><span class="line">    [self preOrderTraverseTree:rootNode.rightNode handler:handler];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (void)inOrderTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void (^)(DDBinaryTreeNode *treeNode))handler</span><br><span class="line">&#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [self inOrderTraverseTree:rootNode.leftNode handler:handler];</span><br><span class="line">    if (handler) &#123;</span><br><span class="line">        handler(rootNode);</span><br><span class="line">    &#125;</span><br><span class="line">    [self inOrderTraverseTree:rootNode.rightNode handler:handler];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (void)postOrderTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [self postOrderTraverseTree:rootNode.leftNode handler:handler];</span><br><span class="line">    [self postOrderTraverseTree:rootNode.rightNode handler:handler];</span><br><span class="line">    if (handler) &#123;</span><br><span class="line">        handler(rootNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="广度优先遍历-Breadth-First-Search"><a href="#广度优先遍历-Breadth-First-Search" class="headerlink" title="广度优先遍历(Breadth First Search)"></a>广度优先遍历(Breadth First Search)</h3><p>从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。<br>按照从上到下、从左到右的次序进行遍历。先遍历完一层，再遍历下一层。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ (void)levelTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列</span><br><span class="line">    [queueArray addObject:rootNode]; //压入根节点</span><br><span class="line">    while (queueArray.count &gt; 0) &#123;</span><br><span class="line">        DDBinaryTreeNode *node = [queueArray firstObject];</span><br><span class="line">        if (handler) &#123;</span><br><span class="line">            handler(node);</span><br><span class="line">        &#125;</span><br><span class="line">        [queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先出原则</span><br><span class="line">        if (node.leftNode) &#123;</span><br><span class="line">            [queueArray addObject:node.leftNode]; //压入左节点</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.rightNode) &#123;</span><br><span class="line">            [queueArray addObject:node.rightNode]; //压入右节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="深度优先遍历-Depth-First-Search"><a href="#深度优先遍历-Depth-First-Search" class="headerlink" title="深度优先遍历(Depth First Search)"></a>深度优先遍历(Depth First Search)</h3><p>DFS是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。<br>当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。<br>如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (void)depthTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler</span><br><span class="line">&#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (handler) &#123;</span><br><span class="line">        handler(rootNode);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self depthTraverseTree:rootNode.leftNode handler:handler];</span><br><span class="line">    [self depthTraverseTree:rootNode.rightNode handler:handler];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树的翻转"><a href="#树的翻转" class="headerlink" title="树的翻转"></a>树的翻转</h2><p>翻转二叉树，又叫求二叉树的镜像，就是把二叉树的左右子树对调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (DDBinaryTreeNode *)invertBinaryTree:(DDBinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123;</span><br><span class="line">        return rootNode;</span><br><span class="line">    &#125;</span><br><span class="line">    [self invertBinaryTree:rootNode.leftNode];</span><br><span class="line">    [self invertBinaryTree:rootNode.rightNode];</span><br><span class="line">    DDBinaryTreeNode *tempNode = rootNode.leftNode;</span><br><span class="line">    rootNode.leftNode = rootNode.rightNode;</span><br><span class="line">    rootNode.rightNode = tempNode;</span><br><span class="line">    return rootNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树的查找"><a href="#树的查找" class="headerlink" title="树的查找"></a>树的查找</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ (DDBinaryTreeNode *)searchTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode</span><br><span class="line">&#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (rootNode.value == value) &#123;</span><br><span class="line">        return rootNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (value &lt; rootNode.value) &#123;</span><br><span class="line">        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.leftNode];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.rightNode];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关链接：<br><a href="http://www.cocoachina.com/programmer/20151015/13687.html" target="_blank" rel="external">《百度的校园招聘面试经历》</a></p>
<p><a href="http://blog.devtang.com/2015/06/16/talk-about-tech-interview/" target="_blank" rel="external">《你会翻转二叉树吗》</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支(不存在分支度大于2的节点)的树结构。通常分支被称作“左子树”和“右子树”。二叉树的分支具有左右次序，不能颠倒。&lt;/p&gt;
&lt;p&gt;二叉树的第i层至多拥有 2^(i-1) 个节点数；深度为k的二叉树至多总共有 2^(k+1) - 1 个节点数，而总计拥有节点数匹配的，称为“满二叉树”；深度为k有n个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度k的满二叉树，序号为1到n的节点一对一对应时，称为“完全二叉树”。对任何一棵非空的二叉树T，如果其叶片(终端节点)数为n0，分支度为2的节点数为n2，则n0 = n2 + 1。&lt;/p&gt;
&lt;p&gt;与普通树不同，普通树的节点个数至少为1，而二叉树的节点个数可以为0；普通树节点的最大分支度没有限制，而二叉树节点的最大分支度为2；普通树的节点无左、右次序之分，而二叉树的节点有左、右次序之分。&lt;/p&gt;
&lt;p&gt;二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉查找树和二元堆积，并应用于高效率的搜索和排序。&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://chars.tech/categories/algorithm/"/>
    
    
      <category term="objc" scheme="http://chars.tech/tags/objc/"/>
    
      <category term="tree" scheme="http://chars.tech/tags/tree/"/>
    
      <category term="二叉树" scheme="http://chars.tech/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>聊聊「二叉搜索树」的那些事儿</title>
    <link href="http://chars.tech/2017/06/10/binary-search-tree/"/>
    <id>http://chars.tech/2017/06/10/binary-search-tree/</id>
    <published>2017-06-10T01:05:21.000Z</published>
    <updated>2017-07-05T08:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 它的左、右子树也分别为二叉排序树。“中序遍历”可以让节点有序。</p>
<a id="more"></a>
<p><img src="http://o88e8any8.bkt.clouddn.com/binary-search-tree.png" alt="binary search tree"></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>二叉排序树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉排序树的存储结构。中序遍历二叉排序树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉排序树变成一个有序序列，构造树的过程即为对无序序列进行排序的过程。每次插入的新的节点都是二叉排序树上新的叶子节点，在进行插入操作时，不必移动其它节点，只需改动某个节点的指针，由空变为非空即可。搜索，插入，删除的复杂度等于树高，O(log(n))。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="树节点"><a href="#树节点" class="headerlink" title="树节点"></a>树节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">/** 二叉树节点 */</span><br><span class="line">@interface DDBinaryTreeNode : NSObject</span><br><span class="line"></span><br><span class="line">/** 值 */</span><br><span class="line">@property (nonatomic, assign) NSInteger value;</span><br><span class="line">/** 左节点 */</span><br><span class="line">@property (nonatomic, strong) DDBinaryTreeNode *leftNode;</span><br><span class="line">/** 右节点 */</span><br><span class="line">@property (nonatomic, strong) DDBinaryTreeNode *rightNode;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>二叉排序树的创建无非就是不断查找和插入的过程，当我们查找某个值没有找到时，我们就会将该值插入到二叉排序树中。因为在查找的过程中可以确定该结点要插入的合适位置，所以插入就显得比较简单了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@class DDBinaryTreeNode;</span><br><span class="line"></span><br><span class="line">@interface DDBinarySearchTreeHandler : NSObject</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  创建二叉排序树</span><br><span class="line"> *  二叉排序树：左节点值全部小于根节点值，右节点值全部大于根节点值</span><br><span class="line"> *</span><br><span class="line"> *  @param values 数组</span><br><span class="line"> *</span><br><span class="line"> *  @return 二叉树根节点</span><br><span class="line"> */</span><br><span class="line">+ (DDBinaryTreeNode *)createTreeWithValues:(NSArray *)values;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  向二叉排序树节点添加一个节点</span><br><span class="line"> *</span><br><span class="line"> *  @param treeNode 根节点</span><br><span class="line"> *  @param value	值</span><br><span class="line"> *</span><br><span class="line"> *  @return 根节点</span><br><span class="line"> */</span><br><span class="line">+ (DDBinaryTreeNode *)addTreeNode:(DDBinaryTreeNode *)treeNode value:(NSInteger)value;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  二叉搜索树中某个值的节点</span><br><span class="line"> *</span><br><span class="line"> *  @param value	值</span><br><span class="line"> *  @param rootNode 树根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 节点</span><br><span class="line"> */</span><br><span class="line">+ (DDBinaryTreeNode *)searchTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (DDBinaryTreeNode *)createTreeWithValues:(NSArray *)values</span><br><span class="line">&#123;</span><br><span class="line">    DDBinaryTreeNode *root = nil;</span><br><span class="line">    for (NSInteger i = 0; i &lt; values.count; i++) &#123;</span><br><span class="line">        NSInteger value = [(NSNumber *)[values objectAtIndex:i] integerValue];</span><br><span class="line">        root = [DDBinarySearchTreeHandler addTreeNode:root value:value];</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>根据查找树的性质我们可以很简单的写出添加的代码，一个一个的比较，注意每插入的一个总是叶子节点。再进行调整。最终形成的效果图如下：</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/binary-search-tree-01.png" alt="添加节点"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (DDBinaryTreeNode *)addTreeNode:(DDBinaryTreeNode *)treeNode value:(NSInteger)value</span><br><span class="line">&#123;</span><br><span class="line">    if (!treeNode) &#123;</span><br><span class="line">        treeNode = [[DDBinaryTreeNode alloc] init];</span><br><span class="line">        treeNode.value = value;</span><br><span class="line">        NSLog(@&quot;node:%td&quot;, value);</span><br><span class="line">    &#125; else if (value &lt;= treeNode.value) &#123;</span><br><span class="line">        NSLog(@&quot;to left&quot;);</span><br><span class="line">        //值小于根节点，则插入到左子树</span><br><span class="line">        treeNode.leftNode = [DDBinarySearchTreeHandler addTreeNode:treeNode.leftNode value:value];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;to right&quot;);</span><br><span class="line">        //值大于根节点，则插入到右子树</span><br><span class="line">        treeNode.rightNode = [DDBinarySearchTreeHandler addTreeNode:treeNode.rightNode value:value];</span><br><span class="line">    &#125;</span><br><span class="line">    return treeNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ (DDBinaryTreeNode *)searchTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode</span><br><span class="line">&#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (rootNode.value == value) &#123;</span><br><span class="line">        return rootNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (value &lt; rootNode.value) &#123;</span><br><span class="line">        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.leftNode];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.rightNode];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>对于树来说，删除是最复杂的，主要需要考虑4种情况：叶子节点，只有左子树，只有右子树和左右子树都有。</p>
<h4 id="叶子节点"><a href="#叶子节点" class="headerlink" title="叶子节点"></a>叶子节点</h4><p>删除的节点没有左子树也没有右子树，也就是删除的节点为叶子节点。这种情况下我们有可以细分为两类，一种是该叶子节点就是二叉排序树的根节点，也就是二叉排序树中只有一个节点的情况。只需要将root指针置为空即可。再一种情况是删除的叶子节点有父节点，直接将父节点连接该删除节点的指针置空即可。</p>
<h4 id="只有一个子节点"><a href="#只有一个子节点" class="headerlink" title="只有一个子节点"></a>只有一个子节点</h4><p>如果删除的节点有左子树那就把左子树顶上去，如果有右子树就把右子树顶上去即可。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/binary-search-tree-03.png?v=20170612" alt="左子树节点"></p>
<h4 id="左右子树都有"><a href="#左右子树都有" class="headerlink" title="左右子树都有"></a>左右子树都有</h4><p>首先可以这么想象，如果我们要删除一个数组的元素，那么我们在删除后会将其后面的一个元素顶到被删除的位置。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/binary-search-tree-04.png?v=20170612" alt="双孩子节点1"></p>
<p>那么二叉树操作同样也是一样，我们根据”中序遍历“找到要删除节点的后一个节点，然后顶上去就行了，原理跟”数组”一样一样的。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/binary-search-tree-05.png?v=20170612.png" alt="双孩子节点2"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">+ (void)deleteTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode</span><br><span class="line">&#123;</span><br><span class="line">    DDBinaryTreeNode *parent = rootNode;</span><br><span class="line">    DDBinaryTreeNode *current = rootNode;</span><br><span class="line">    // 记录被找到的节点是父节点的左子节点还是右子节点</span><br><span class="line">    BOOL isLeftChild = false;</span><br><span class="line">    // 循环直到找到目标节点的位置,否则返回</span><br><span class="line">    while (current.value != value) &#123;</span><br><span class="line">        parent = current;</span><br><span class="line">        if (current.value &gt; value) &#123;</span><br><span class="line">            isLeftChild = true;</span><br><span class="line">            current = current.leftNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            isLeftChild = false;</span><br><span class="line">            current = current.rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        if (current == nil) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果待删除的节点没有任何子节点</span><br><span class="line">    // 直接将该节点的原本指向该节点的指针设置为nil</span><br><span class="line">    if (current.leftNode == nil &amp;&amp; current.rightNode == nil) &#123;</span><br><span class="line">        if (current == rootNode) &#123;</span><br><span class="line">            rootNode = nil;</span><br><span class="line">        &#125;</span><br><span class="line">        if (isLeftChild == true) &#123;</span><br><span class="line">            parent.leftNode = nil;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parent.rightNode = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果待删除的节点有一个子节点,且其为左子节点</span><br><span class="line">    else if (current.rightNode == nil) &#123;</span><br><span class="line">        // 判断当前节点是否为根节点</span><br><span class="line">        if (current == rootNode) &#123;</span><br><span class="line">            rootNode = current.leftNode;</span><br><span class="line">        &#125; else if (isLeftChild) &#123;</span><br><span class="line">            // 挂载到父节点的左子树</span><br><span class="line">            parent.leftNode = current.leftNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 挂载到父节点的右子树</span><br><span class="line">            parent.rightNode = current.leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (current.leftNode == nil) &#123;</span><br><span class="line">        if (current == rootNode) &#123;</span><br><span class="line">            rootNode = current.rightNode;</span><br><span class="line">        &#125; else if (isLeftChild) &#123;</span><br><span class="line">            parent.leftNode = current.rightNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parent.rightNode = current.rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果待删除的节点有两个子节点</span><br><span class="line">    else if (current.leftNode != nil &amp;&amp; current.rightNode != nil) &#123;</span><br><span class="line">        // 寻找右子树中的最小值</span><br><span class="line">        DDBinaryTreeNode *successor = [DDBinarySearchTreeHandler successor:current];</span><br><span class="line">        if (current == rootNode) &#123;</span><br><span class="line">            rootNode = successor;</span><br><span class="line">        &#125; else if (isLeftChild) &#123;</span><br><span class="line">            parent.leftNode = successor;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parent.rightNode = successor;</span><br><span class="line">        &#125;</span><br><span class="line">        successor.leftNode = current.leftNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 在树中查找最合适的节点</span><br><span class="line"> */</span><br><span class="line">+ (DDBinaryTreeNode *)successor:(DDBinaryTreeNode *)node &#123;</span><br><span class="line">    DDBinaryTreeNode *successsor = nil;</span><br><span class="line">    DDBinaryTreeNode *successsorParent = nil;</span><br><span class="line">    DDBinaryTreeNode *current = node.rightNode;</span><br><span class="line">    while (current != nil) &#123;</span><br><span class="line">        successsorParent = successsor;</span><br><span class="line">        successsor = current;</span><br><span class="line">        current = current.leftNode;</span><br><span class="line">    &#125;</span><br><span class="line">    if (successsor != node.rightNode) &#123;</span><br><span class="line">        successsorParent.leftNode = successsor.rightNode;</span><br><span class="line">        successsor.rightNode = node.rightNode;</span><br><span class="line">    &#125;</span><br><span class="line">    return successsor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 它的左、右子树也分别为二叉排序树。“中序遍历”可以让节点有序。&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://chars.tech/categories/algorithm/"/>
    
    
      <category term="objc" scheme="http://chars.tech/tags/objc/"/>
    
      <category term="tree" scheme="http://chars.tech/tags/tree/"/>
    
      <category term="二叉搜索树" scheme="http://chars.tech/tags/binary-search-tree/"/>
    
  </entry>
  
  <entry>
    <title>初探 TensorFlow</title>
    <link href="http://chars.tech/2017/06/07/tensorflow-primer-guide/"/>
    <id>http://chars.tech/2017/06/07/tensorflow-primer-guide/</id>
    <published>2017-06-07T15:45:11.000Z</published>
    <updated>2017-07-05T08:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>TensorFlow 是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。</p>
<a id="more"></a>
<p><img src="http://o88e8any8.bkt.clouddn.com/tensors_flowing.gif" alt="tensors_flowing"></p>
<h2 id="什么是数据流图（Data-Flow-Graph）"><a href="#什么是数据流图（Data-Flow-Graph）" class="headerlink" title="什么是数据流图（Data Flow Graph）"></a>什么是数据流图（Data Flow Graph）</h2><p>数据流图用“结点”(nodes)和“线”(edges)的有向图来描述数学计算。“节点” 一般用来表示施加的数学操作，但也可以表示数据输入(feed in)的起点/输出(push out)的终点，或者是读取/写入持久变量(persistent variable)的终点。“线”表示“节点”之间的输入/输出关系。这些数据“线”可以输运“size可动态调整”的多维数据数组，即“张量”(tensor)。张量从图中流过的直观图像是这个工具取名为“Tensorflow”的原因。一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。</p>
<h2 id="TensorFlow的特征"><a href="#TensorFlow的特征" class="headerlink" title="TensorFlow的特征"></a>TensorFlow的特征</h2><ul>
<li>高度的灵活性</li>
<li>真正的可移植性（Portability）</li>
<li>将科研和产品联系在一起</li>
<li>自动求微分</li>
<li>多语言支持</li>
<li>性能最优化</li>
</ul>
<h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># --recurse-submodules 参数是必须的, 用于获取 TesorFlow 依赖的 protobuf 库</span><br><span class="line">$ git clone --recurse-submodules https://github.com/tensorflow/tensorflow</span><br></pre></td></tr></table></figure>
<h4 id="Linux-安装"><a href="#Linux-安装" class="headerlink" title="Linux 安装"></a>Linux 安装</h4><h5 id="安装-Bazel"><a href="#安装-Bazel" class="headerlink" title="安装 Bazel"></a>安装 Bazel</h5><p>首先依照 <a href="https://bazel.build/versions/master/docs/install.html" target="_blank" rel="external">教程</a> 安装 Bazel 的依赖. 然后使用下列命令下载和编译 Bazel 的源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/bazelbuild/bazel.git</span><br><span class="line">$ cd bazel</span><br><span class="line">$ git checkout tags/0.1.0</span><br><span class="line">$ ./compile.sh</span><br></pre></td></tr></table></figure>
<p>上面命令中拉取的代码标签为 0.1.0, 兼容 Tensorflow 目前版本. bazel 的HEAD 版本 (即最新版本) 在这里可能不稳定.</p>
<p>将执行路径 <code>output/bazel</code> 添加到 <code>$PATH</code> 环境变量中.</p>
<h5 id="安装其他依赖"><a href="#安装其他依赖" class="headerlink" title="安装其他依赖"></a>安装其他依赖</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install python-numpy swig python-dev</span><br></pre></td></tr></table></figure>
<h4 id="Mac-OS-X-安装"><a href="#Mac-OS-X-安装" class="headerlink" title="Mac OS X 安装"></a>Mac OS X 安装</h4><p>Mac 和 Linux 需要的软件依赖完全一样, 但是安装过程区别很大. 以下链接用于帮助你 在 Mac OS X 上安装这些依赖:</p>
<h5 id="Bazel"><a href="#Bazel" class="headerlink" title="Bazel"></a>Bazel</h5><p>参见<a href="https://bazel.build/versions/master/docs/install.html" target="_blank" rel="external">网页</a>的 Mac OS X 安装指南.</p>
<h5 id="SWIG"><a href="#SWIG" class="headerlink" title="SWIG"></a>SWIG</h5><p><a href="http://www.swig.org/Doc3.0/Preface.html#Preface_osx_installation" target="_blank" rel="external">Mac OS X 安装教程</a></p>
<p>注意: 你需要安装<a href="ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/" target="_blank" rel="external">PCRE</a>, 而不是 PCRE2.</p>
<h5 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h5><p>参见<a href="https://docs.scipy.org/doc/numpy/user/install.html" target="_blank" rel="external">安装教程</a>.</p>
<h5 id="创建-pip-包并安装"><a href="#创建-pip-包并安装" class="headerlink" title="创建 pip 包并安装"></a>创建 pip 包并安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ bazel build -c opt //tensorflow/tools/pip_package:build_pip_package</span><br><span class="line"></span><br><span class="line">$ bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg</span><br><span class="line"></span><br><span class="line"># .whl 文件的实际名字与你所使用的平台有关</span><br><span class="line">$ pip install /tmp/tensorflow_pkg/tensorflow-0.5.0-cp27-none-linux_x86_64.whl</span><br></pre></td></tr></table></figure>
<h3 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h3><p>TensorFlow Python API 依赖 Python 2.7 版本.</p>
<p>在 Linux 和 Mac 下最简单的安装方式, 是使用 <a href="https://pypi.python.org/pypi/pip" target="_blank" rel="external">pip</a> 安装.</p>
<p>为了简化安装步骤, 建议使用 virtualenv, 具体安装方法在后文具体说明.</p>
<h4 id="Ubuntu-Linux"><a href="#Ubuntu-Linux" class="headerlink" title="Ubuntu/Linux"></a>Ubuntu/Linux</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 仅使用 CPU 的版本</span><br><span class="line">$ pip install https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.5.0-cp27-none-linux_x86_64.whl</span><br><span class="line"></span><br><span class="line"># 开启 GPU 支持的版本 (安装该版本的前提是已经安装了 CUDA sdk)</span><br><span class="line">$ pip install https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.5.0-cp27-none-linux_x86_64.whl</span><br></pre></td></tr></table></figure>
<h4 id="Mac-OS-X"><a href="#Mac-OS-X" class="headerlink" title="Mac OS X"></a>Mac OS X</h4><p>在 OS X 系统上, 推荐先安装 <a href="https://brew.sh/" target="_blank" rel="external">homebrew</a>, 然后执行 <code>brew install python</code>, 以便能够使用 homebrew 中的 Python 安装 TensorFlow. 另外一种推荐的方式是在 virtualenv 中安装 TensorFlow.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 当前版本只支持 CPU</span><br><span class="line">$ pip install https://storage.googleapis.com/tensorflow/mac/tensorflow-0.5.0-py2-none-any.whl</span><br></pre></td></tr></table></figure>
<h4 id="基于-VirtualEnv-的安装"><a href="#基于-VirtualEnv-的安装" class="headerlink" title="基于 VirtualEnv 的安装"></a>基于 VirtualEnv 的安装</h4><p>推荐使用 <a href="https://pypi.python.org/pypi/virtualenv" target="_blank" rel="external">virtualenv</a> 创建一个隔离的容器, 来安装 TensorFlow. 这是可选的, 但是这样做能使排查安装问题变得更容易.</p>
<p>首先, 安装所有必备工具:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 在 Linux 上:</span><br><span class="line">$ sudo apt-get install python-pip python-dev python-virtualenv</span><br><span class="line"></span><br><span class="line"># 在 Mac 上:</span><br><span class="line">$ sudo easy_install pip  # 如果还没有安装 pip</span><br><span class="line">$ sudo pip install --upgrade virtualenv</span><br></pre></td></tr></table></figure>
<p>接下来, 建立一个全新的 virtualenv 环境. 为了将环境建在 ~/tensorflow 目录下, 执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv --system-site-packages ~/tensorflow</span><br><span class="line">$ cd ~/tensorflow</span><br></pre></td></tr></table></figure>
<p>然后, 激活 virtualenv:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ source bin/activate  # 如果使用 bash</span><br><span class="line">$ source bin/activate.csh  # 如果使用 csh</span><br><span class="line">(tensorflow)$  # 终端提示符应该发生变化</span><br></pre></td></tr></table></figure>
<p>在 virtualenv 内, 安装 TensorFlow:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tensorflow)$ pip install --upgrade &lt;$url_to_binary.whl&gt;</span><br></pre></td></tr></table></figure>
<p>接下来, 使用类似命令运行 TensorFlow 程序:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(tensorflow)$ cd tensorflow/models/image/mnist</span><br><span class="line">(tensorflow)$ python convolutional.py</span><br><span class="line"></span><br><span class="line"># 当使用完 TensorFlow</span><br><span class="line">(tensorflow)$ deactivate  # 停用 virtualenv</span><br><span class="line"></span><br><span class="line">$  # 你的命令提示符会恢复原样</span><br></pre></td></tr></table></figure>
<h2 id="运行-TensorFlow"><a href="#运行-TensorFlow" class="headerlink" title="运行 TensorFlow"></a>运行 TensorFlow</h2><p>打开一个 python 终端:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; import tensorflow as tf</span><br><span class="line">&gt;&gt;&gt; hello = tf.constant(&apos;Hello, TensorFlow!&apos;)</span><br><span class="line">&gt;&gt;&gt; sess = tf.Session()</span><br><span class="line">&gt;&gt;&gt; print sess.run(hello)</span><br><span class="line">Hello, TensorFlow!</span><br><span class="line">&gt;&gt;&gt; a = tf.constant(10)</span><br><span class="line">&gt;&gt;&gt; b = tf.constant(32)</span><br><span class="line">&gt;&gt;&gt; print sess.run(a+b)</span><br><span class="line">42</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TensorFlow 是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。&lt;/p&gt;
    
    </summary>
    
      <category term="ml" scheme="http://chars.tech/categories/machine-learning/"/>
    
    
      <category term="python" scheme="http://chars.tech/tags/python/"/>
    
      <category term="tensorflow" scheme="http://chars.tech/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>拆解 MySQL 的高阶使用与概念</title>
    <link href="http://chars.tech/2017/05/29/mysql-advanced-study/"/>
    <id>http://chars.tech/2017/05/29/mysql-advanced-study/</id>
    <published>2017-05-29T07:31:40.000Z</published>
    <updated>2017-07-05T08:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们主要分享了MySQL中的常见知识与使用。这里我们主要分享一下MySQL中的高阶使用，主要包括：函数、存储过程和存储引擎。</p>
<p>对于MySQL中的基础知识，可以参见</p>
<p><a href="/2017/05/16/mysql-study/">《与 MySQL 的零距离接触》</a></p>
<a id="more"></a>
<h1 id="1-函数"><a href="#1-函数" class="headerlink" title="1 函数"></a>1 函数</h1><p>函数可以返回任意类型的值，也可以接收这些类型的参数。</p>
<h2 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h2><table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONCAT()</td>
<td>字符连接</td>
</tr>
<tr>
<td>CONCAT_WS()</td>
<td>使用指定的分隔符进行字符连接</td>
</tr>
<tr>
<td>FORMAT()</td>
<td>数字格式化</td>
</tr>
<tr>
<td>LOWER()</td>
<td>转换成小写字母</td>
</tr>
<tr>
<td>UPPER()</td>
<td>转换成大写字母</td>
</tr>
<tr>
<td>LEFT()</td>
<td>获取左侧字符</td>
</tr>
<tr>
<td>RIGHT()</td>
<td>获取右侧字符</td>
</tr>
<tr>
<td>LENGTH()</td>
<td>获取字符串长度</td>
</tr>
<tr>
<td>LTRIM()</td>
<td>删除前导空格</td>
</tr>
<tr>
<td>RTRIM()</td>
<td>删除后续空格</td>
</tr>
<tr>
<td>TRIM()</td>
<td>删除前导和后续空格</td>
</tr>
<tr>
<td>SUBSTRING()</td>
<td>字符串截取</td>
</tr>
<tr>
<td>[NOT] LIKE</td>
<td>模式匹配</td>
</tr>
<tr>
<td>REPLACE()</td>
<td>字符串替换</td>
</tr>
</tbody>
</table>
<p>函数可以嵌套使用。<br><code>%</code>（百分号）：代表任意个字符。<br><code>_</code>（下划线）：代表任意一个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 删除前导&apos;?&apos;符号</span><br><span class="line">SELECT TRIM(LEADING &apos;?&apos; FROM &apos;??MySQL???&apos;);</span><br><span class="line"># 删除后续&apos;?&apos;符号</span><br><span class="line">SELECT TRIM(TRAILING &apos;?&apos; FROM &apos;??MySQL???&apos;);</span><br><span class="line"># 删除前后&apos;?&apos;符号</span><br><span class="line">SELECT TRIM(BOTH &apos;?&apos; FROM &apos;??My??SQL???&apos;);</span><br><span class="line"># 将&apos;?&apos;符号替换成&apos;!&apos;符号</span><br><span class="line">SELECT REPLACE(&apos;??My??SQL???&apos;, &apos;?&apos;, &apos;!&apos;);</span><br><span class="line"># 从中&apos;MySQL&apos;第1个开始，截取2个字符</span><br><span class="line">SELECT SUBSTRING(&apos;MySQL&apos;, 1, 2);</span><br><span class="line"># 从中&apos;MySQL&apos;截取最后1个字符</span><br><span class="line">SELECT SUBSTRING(&apos;MySQL&apos;, -1);</span><br><span class="line"># 从中&apos;MySQL&apos;第2个开始，截取至结尾</span><br><span class="line">SELECT SUBSTRING(&apos;MySQL&apos;, 2);</span><br></pre></td></tr></table></figure>
<h2 id="数值运算符函数"><a href="#数值运算符函数" class="headerlink" title="数值运算符函数"></a>数值运算符函数</h2><table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CEIL()</td>
<td>进一取整</td>
</tr>
<tr>
<td>DIV</td>
<td>整数除法</td>
</tr>
<tr>
<td>FLOOR()</td>
<td>舍一取整</td>
</tr>
<tr>
<td>MOD</td>
<td>取余数（取模）</td>
</tr>
<tr>
<td>POWER()</td>
<td>幂运算</td>
</tr>
<tr>
<td>ROUND()</td>
<td>四舍五入</td>
</tr>
<tr>
<td>TRUNCATE()</td>
<td>数字截取</td>
</tr>
</tbody>
</table>
<h2 id="比较运算符函数"><a href="#比较运算符函数" class="headerlink" title="比较运算符函数"></a>比较运算符函数</h2><table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[NOT]BETWEEN…AND..</td>
<td>[不]在范围之内</td>
</tr>
<tr>
<td>[NOT]IN()</td>
<td>[不]在列出值范围内</td>
</tr>
<tr>
<td>IS[NOT]NULL</td>
<td>[不]为空</td>
</tr>
</tbody>
</table>
<h2 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数"></a>日期时间函数</h2><table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NOW()</td>
<td>当前日期和时间</td>
</tr>
<tr>
<td>CURDATE()</td>
<td>当前日期</td>
</tr>
<tr>
<td>CURTIME()</td>
<td>当前时间</td>
</tr>
<tr>
<td>DATE_ADD()</td>
<td>日期变化</td>
</tr>
<tr>
<td>DATEDIFF()</td>
<td>日期差值</td>
</tr>
<tr>
<td>DATE_FORMAT()</td>
<td>日期格式化</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 时间增加1年</span><br><span class="line">SELECT DATE_ADD(&apos;2016-05-28&apos;, INTERVAL 365 DAY);</span><br><span class="line"># 时间减少1年</span><br><span class="line">SELECT DATE_ADD(&apos;2016-05-28&apos;, INTERVAL -365 DAY);</span><br><span class="line"># 时间增加3周</span><br><span class="line">SELECT DATE_ADD(&apos;2016-05-28&apos;, INTERVAL 3 WEEK);</span><br><span class="line"># 日期格式化</span><br><span class="line">SELECT DATE_FORMAT(&apos;2016-05-28&apos;, &apos;%m/%d/%Y&apos;);</span><br><span class="line"># 更多时间格式可以前往MySQL官网查看手册</span><br></pre></td></tr></table></figure>
<h2 id="信息函数"><a href="#信息函数" class="headerlink" title="信息函数"></a>信息函数</h2><table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONNECTION_ID()</td>
<td>连接ID</td>
</tr>
<tr>
<td>DATEBASE()</td>
<td>当前数据库</td>
</tr>
<tr>
<td>LAST_INSERT_ID()</td>
<td>最后插入记录的ID号</td>
</tr>
<tr>
<td>USER()</td>
<td>当前用户</td>
</tr>
<tr>
<td>VERSION()</td>
<td>版本信息</td>
</tr>
</tbody>
</table>
<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVG()</td>
<td>平均值</td>
</tr>
<tr>
<td>COUNT()</td>
<td>计数</td>
</tr>
<tr>
<td>MAX()</td>
<td>最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>最小值</td>
</tr>
<tr>
<td>SUM()</td>
<td>求和</td>
</tr>
</tbody>
</table>
<h2 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h2><table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>MD5()</td>
<td>信息摘要算法</td>
</tr>
<tr>
<td>PASSWORD()</td>
<td>密码算法</td>
</tr>
</tbody>
</table>
<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>用户自定义函数（user-defined function，UDF）是一种对MySQL扩展的途径，其用法与内置函数相同。UDF是对MySQL扩展的一种途径。</p>
<h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ul>
<li>参数：可以有零个或多个</li>
<li>返回值：只能有一个</li>
</ul>
<p>参数和返回值没有必然的联系。</p>
<h3 id="创建自定义函数"><a href="#创建自定义函数" class="headerlink" title="创建自定义函数"></a>创建自定义函数</h3><p><code>CREATE FUNCTION function_name RETURNS {STRING|INTEGER|REAL|DECIMAL} routine_body</code></p>
<h4 id="函数体（routine-body）"><a href="#函数体（routine-body）" class="headerlink" title="函数体（routine_body）"></a>函数体（routine_body）</h4><ul>
<li>函数体由合法的SQL语句构成；</li>
<li>函数体可以是简单的SELECT或INSERT语句；</li>
<li>函数体如果为复合结构则使用BEGIN…END语句；</li>
<li>复合结构可以包含声明，循环，控制结构。</li>
</ul>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 不带参数</span><br><span class="line">CREATE FUNCTION f1() RETURNS VARCHAR(30) RETURN DATE_FORMAT(NOW(), &apos;%Y-%m-%d %H:%i:%s&apos;);</span><br><span class="line"></span><br><span class="line"># 带参数</span><br><span class="line">CREATE FUNCTION f2(num1 SMALLINT UNSIGNED, num2 SMALLINT UNSIGNED) RETURNS FLOAT(10, 2) UNSIGNED RETURN (num1 + num2) / 2;</span><br><span class="line"></span><br><span class="line"># 具有复合结构函数体</span><br><span class="line"># 可能需要使用DELIMITER命令修改分隔符</span><br><span class="line">CREATE FUNCTION f3(username VARCHAR(20)) RETURNS INT UNSIGNED </span><br><span class="line">BEGIN </span><br><span class="line">INSERT test(username) VALUES(username);</span><br><span class="line">RETURN LAST_INSERT_ID();</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<h1 id="2-存储过程"><a href="#2-存储过程" class="headerlink" title="2 存储过程"></a>2 存储过程</h1><p><img src="http://o88e8any8.bkt.clouddn.com/mysql-study-22.png" alt="命令执行流程"><br>存储过程是SQL语句和控制语句的预编译集合，以一个名称存储作为一个单元处理。可以由用户调用执行，允许用户声明变量以及进行流程控制。存储过程可以接收输入类型的参数，也可以接收输出类型的参数，并可以存在多个返回值。执行效率比单一的SQL语句高。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>增强SQL语句的功能和灵活性</li>
</ul>
<p>在存储过程中可以写控制语句具有很强的灵活性，可以完成复杂的判断及较复杂的运算。</p>
<ul>
<li>实现较快的执行速度</li>
</ul>
<p>如果某一操作包含了大量的SQL语句，那么这些SQL语句都将被MySQL引擎执行语法分析、编译、执行，所以效率相对过低。而存储过程是预编译的，当客户端第一次调用存储过程时，MySQL的引擎将对它进行语法分析、编译等操作，然后把这个编译的结果存储到内存中，所以说第一次使用的时候效率和以前是相同的。但是以后客户端再次调用这个存储过程时，直接从内存中执行，所以说效率比较高，速度比较快。</p>
<ul>
<li>减少网络流量</li>
</ul>
<p>如果通过客户端每一个单独发送SQL语句让服务器来执行，那么通过http协议来提交的数据量相对来说较大。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE [DEFINER = &#123;user|CURRENT_USER&#125;] PROCEDURE sp_name ([proc_parameter[, ...]]) [characteristic ...] routine_body</span><br></pre></td></tr></table></figure>
<p><code>proc_parameter</code>:<br><code>[IN | OUT | INOUT] param_name type</code></p>
<p>参数：<br><code>IN</code>，表示该参数的值必须在调用存储过程时指定。<br><code>OUT</code>，表示该参数值可以被存储过程改变，并且可以返回。<br><code>INOUT</code>，表示该参数的调用时指定，并且可以被改变和返回。</p>
<p>特性：<br><code>COMMENT</code>注释<br><code>CONTAINS SQL</code>包含SQL语句，但不包含读或写数据的语句。<br><code>NO SQL</code>不包含SQL语句。<br><code>READS SQL DATA</code>包含读写数据的语句。<br><code>MODIFIES SQL DATA</code>包含写数据的语句。<br><code>SQL SECURITY {DEFINER | INVOKER}</code>指明谁有权限来执行。</p>
<h2 id="过程体"><a href="#过程体" class="headerlink" title="过程体"></a>过程体</h2><ul>
<li>过程体由合法的SQL语句构成；</li>
<li>过程体可以是任意SQL语句；<br>不能通过存储过程来创建数据表、数据库。可以通过存储过程对数据进行增、删、改、查和多表连接操作。</li>
<li>过程体如果为复合结构则使用BEGIN…END语句；</li>
<li>复合结构中可以包含声明、循环、控制结构。</li>
</ul>
<h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CALL sp_name ([parameter[, ...]])</span><br><span class="line">CALL sp_name[()]</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE [IF EXISTS] sp_name</span><br></pre></td></tr></table></figure>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER PROCEDURE sp_name [characteristic ...] COMMENT &apos;string&apos;</span><br><span class="line">| &#123;CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA&#125;</span><br><span class="line">| SQL SECURITY &#123;DEFINER | INVOKER&#125;</span><br></pre></td></tr></table></figure>
<h2 id="存储过程与自定义函数的区别"><a href="#存储过程与自定义函数的区别" class="headerlink" title="存储过程与自定义函数的区别"></a>存储过程与自定义函数的区别</h2><ul>
<li>存储过程实现的功能要复杂一些，而函数的针对性更强。</li>
<li>存储过程可以返回多个值，函数只能有一个返回值。</li>
<li>存储过程一般独立执行，函数可以作为其他SQL语句的组成部分来实现。</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 创建不带参数的存储过程</span><br><span class="line">CREATE PROCEDURE sp1() SELECT VERSION();</span><br><span class="line"></span><br><span class="line"># 创建带有IN类型参数的存储过程(users为数据表名)</span><br><span class="line"># 参数的名字不能和数据表中的记录名字一样</span><br><span class="line">CREATE PROCEDURE removeUserById(IN p_id INT UNSIGNED)</span><br><span class="line">BEGIN</span><br><span class="line">DELETE FROM users WHERE id = p_id;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"># 创建带有IN和OUT类型参数的存储过程(users为数据表名)</span><br><span class="line">CREATE PROCEDURE removeUserAndReturnUserNumsById(IN p_id INT UNSIGNED, OUT userNums INT UNSIGNED)</span><br><span class="line">BEGIN</span><br><span class="line">DELETE FROM users WHERE id = p_id;</span><br><span class="line">SELECT COUNT(id) FROM users INTO userNums;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"># 创建带有多个OUT类型参数的存储过程(users为数据表名)</span><br><span class="line">CREATE PROCEDURE removeUserAndReturnInfosByAge(IN p_age SMALLINT UNSIGNED, OUT delUser SMALLINT UNSIGNED,  OUT userNums SMALLINT UNSIGNED)</span><br><span class="line">BEGIN</span><br><span class="line">DELETE FROM users WHERE age = p_age;</span><br><span class="line">SELECT ROW_COUNT INTO delUser;</span><br><span class="line">SELECT COUNT(id) FROM users INTO userNums;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<h1 id="3-存储引擎"><a href="#3-存储引擎" class="headerlink" title="3 存储引擎"></a>3 存储引擎</h1><p>MySQL可以将数据以不同的技术存储在文件（内存）中，这种技术就称为存储引擎。<br>每一种存储引擎使用不同的存储机制、索引技巧、锁定水平，最终提供广泛且不同的功能。</p>
<ul>
<li><p>锁<br>共享锁（读锁）：在同一时间段内，多个用户可以读取同一个资源，读取过程中数据不会发生任何变化。<br>排他锁（写锁）：在任何时候只能有一个用户写入资源，当进行写锁时会阻塞其他的读锁或者写锁操作。</p>
</li>
<li><p>锁颗粒<br>表锁：是一种开销最小的锁策略。<br>行锁：是一种开销最大的锁策略。</p>
</li>
<li><p>并发控制<br>当多个连接记录进行修改时保证数据的一致性和完整性。</p>
</li>
<li><p>事务<br>事务用于保证数据库的完整性。</p>
</li>
</ul>
<p>举例：用户银行转账<br><code>用户A</code> 转账200元 <code>用户B</code><br>实现步骤：<br>1）从当前账户减掉200元（账户余额大于等于200元）。<br>2）在对方账户增加200元。</p>
<p><strong>事务特性：</strong><br>1）原子性（atomicity）<br>2）一致性（consistency）<br>3）隔离性（isolation）<br>4）持久性（durability）</p>
<ul>
<li><p>外键<br>是保证数据一致性的策略。</p>
</li>
<li><p>索引<br>是对数据表中一列或多列的值进行排序的一种结构。</p>
</li>
</ul>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>MySQL主要支持以下几种引擎类型：</p>
<ul>
<li>MyISAM</li>
<li>InnoDB</li>
<li>Memory</li>
<li>CSV</li>
<li>Archive</li>
</ul>
<p>各类存储引擎特点</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
<th>Archive</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储限制</td>
<td>256TB</td>
<td>64TB</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>事务安全</td>
<td>-</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>支持索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>锁颗粒</td>
<td>表锁</td>
<td>行锁</td>
<td>表锁</td>
<td>行锁</td>
</tr>
<tr>
<td>数据压缩</td>
<td>支持</td>
<td>-</td>
<td>-</td>
<td>支持</td>
</tr>
<tr>
<td>支持外键</td>
<td>-</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>CSV:实际上是由逗号分隔的数据引擎，在数据库子目录为每一个表创建一个<code>.csv</code>的文件，这是一种普通的文本文件，每一个数据行占用一个文本行。不支持索引。</p>
<p>BlackHole：黑洞引擎，写入的数据都会消失，一般用于做数据复制的中继。</p>
<p>MyISAM：适用于事务的处理不多的情况。</p>
<p>InnoDB：适用于事务处理比较多，需要有外键支持的情况。</p>
<p>索引分类：普通索引、唯一索引、全文索引、btree索引、hash索引…</p>
<h2 id="修改存储引擎"><a href="#修改存储引擎" class="headerlink" title="修改存储引擎"></a>修改存储引擎</h2><ul>
<li>通过修改MySQL配置文件<br><code>default-storage-engine=engine_name</code></li>
<li>通过创建数据表命令实现<br><code>CREATE TABLE table_name(...)ENGINE=engine_name</code></li>
<li>通过修改数据表命令实现<br><code>ALTER TABLE table_name ENGINE[=]engine_name</code></li>
</ul>
<h1 id="4-管理工具"><a href="#4-管理工具" class="headerlink" title="4 管理工具"></a>4 管理工具</h1><ul>
<li><p>phpMyAdmin<br>需要有PHP环境</p>
</li>
<li><p>Navicat</p>
</li>
<li>MySQL Workbench</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面我们主要分享了MySQL中的常见知识与使用。这里我们主要分享一下MySQL中的高阶使用，主要包括：函数、存储过程和存储引擎。&lt;/p&gt;
&lt;p&gt;对于MySQL中的基础知识，可以参见&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/2017/05/16/mysql-study/&quot;&gt;《与 MySQL 的零距离接触》&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://chars.tech/categories/web/"/>
    
    
      <category term="database" scheme="http://chars.tech/tags/database/"/>
    
      <category term="读书笔记" scheme="http://chars.tech/tags/notes/"/>
    
      <category term="mysql" scheme="http://chars.tech/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 中的SQL</title>
    <link href="http://chars.tech/2017/05/19/mysql-sql-study/"/>
    <id>http://chars.tech/2017/05/19/mysql-sql-study/</id>
    <published>2017-05-19T07:43:18.000Z</published>
    <updated>2017-07-05T08:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>结构化查询语言（英语：Structured Query Language，缩写：SQL），是一种特殊目的之编程语言，用于数据库中的标准数据查询语言，IBM公司最早使用在其开发的数据库系统中。</p>
<p>不过各种通行的数据库系统在其实践过程中都对SQL规范作了某些编改和扩充。所以，实际上不同数据库系统之间的SQL不能完全相互通用。</p>
<p>文章以MySQL数据库为演示环境，主要分享MySQL中的SQL使用。</p>
<a id="more"></a>
<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] character_name</span><br></pre></td></tr></table></figure>
<p><code>{}</code>表示为必选项，即必填参数。<code>|</code>表示选项，即其中选取一项即可。<code>[]</code>表示为可选项。</p>
<p><code>character_name</code>参数为指定数据库的编码方式，不填则使用MySQL配置的字符集编码。</p>
<h3 id="查看当前服务器下的数据表列表"><a href="#查看当前服务器下的数据表列表" class="headerlink" title="查看当前服务器下的数据表列表"></a>查看当前服务器下的数据表列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW &#123;DATABASES | SCHEMAS&#125; [LIKE &apos;pattern&apos; | WHERE expr]</span><br></pre></td></tr></table></figure>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name</span><br></pre></td></tr></table></figure>
<h2 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h2><p>自动编号，且必须与主键组合使用。</p>
<p>数值型数据。</p>
<p>默认情况下，起始值为1，每次的增量为1。</p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>1.保证数据的完整性和一致性。</p>
<p>2.分为表级约束（针对两个或两个以上的字段进行约束）和列级约束（针对某一个字段进行约束）。</p>
<p>3.类型包括：</p>
<ul>
<li>NOT NULL 非空约束</li>
<li>PRIMARY KEY 主键约束</li>
<li>UNIQUE KEY 唯一约束</li>
<li>DEFAULT 默认约束</li>
<li>FOREIGN KEY 外键约束</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t6(id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY, username VARCHAR(20) NOT NULL UNIQUE KEY, sex ENUM(&apos;1&apos;, &apos;2&apos;, &apos;3&apos;) DEFAULT &apos;3&apos;);</span><br></pre></td></tr></table></figure>
<p><img src="http://o88e8any8.bkt.clouddn.com/mysql-study-05.png" alt="t6表结构"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT t6 (username) VALUES (&apos;Chars&apos;);</span><br></pre></td></tr></table></figure>
<p><img src="http://o88e8any8.bkt.clouddn.com/mysql-study-06.png" alt="t6表插入值"></p>
<h3 id="空值与非空值"><a href="#空值与非空值" class="headerlink" title="空值与非空值"></a>空值与非空值</h3><p>NULL，字段值可以为空。</p>
<p>NOT NULL，字段值禁止为空。不存在表级约束。</p>
<h3 id="PRIMARY-KEY"><a href="#PRIMARY-KEY" class="headerlink" title="PRIMARY KEY"></a>PRIMARY KEY</h3><p>主键约束。</p>
<p>每张数据表只能存在一个主键。</p>
<p>主键保证记录的唯一性。</p>
<p>主键自动为NOT NULL。</p>
<p><strong>注意：</strong></p>
<p><code>AUTO_INCREMENT</code>必须与<code>PRIMARY KEY</code>一起使用。但是，<code>PRIMARY KEY</code>不一定与<code>AUTO_INCREMENT</code>一起使用。</p>
<h3 id="UNIQUE-KEY"><a href="#UNIQUE-KEY" class="headerlink" title="UNIQUE KEY"></a>UNIQUE KEY</h3><p>唯一约束。</p>
<p>唯一约束可以保证记录的唯一性。</p>
<p>唯一约束的字段可以为空值（NULL）。</p>
<p>每张数据表可以存在多个唯一约束。</p>
<p><strong>注意：UNIQUE KEY与PRIMARY KEY区别</strong></p>
<p>PRIMARY KEY每张数据表只能有一个，且不能为空。</p>
<p>UNIQUE KEY每张数据表可以有多个，且可以为空。</p>
<h3 id="DEFAULT"><a href="#DEFAULT" class="headerlink" title="DEFAULT"></a>DEFAULT</h3><p>默认值。</p>
<p>当插入记录时，如果没有明确为字段赋值，则自动赋予默认值。</p>
<p>不存在表级约束。</p>
<h3 id="FOREIGN-KEY"><a href="#FOREIGN-KEY" class="headerlink" title="FOREIGN KEY"></a>FOREIGN KEY</h3><p>保持数据一致性，完整性。</p>
<p>实现一对一或一对多关系。</p>
<p>关系型数据库名称的来源。</p>
<h4 id="外键约束的要求"><a href="#外键约束的要求" class="headerlink" title="外键约束的要求"></a>外键约束的要求</h4><p>1.父表和子表必须使用相同的存储引擎，而且禁止使用临时表。</p>
<p>2.数据表的存储引擎只能为InnoDB。</p>
<p>3.外键列和参照列必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度则可以不同。</p>
<p>4.外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL将自动创建索引。</p>
<h4 id="外键约束的参照操作"><a href="#外键约束的参照操作" class="headerlink" title="外键约束的参照操作"></a>外键约束的参照操作</h4><p>1.CASCADE：从父表删除或更新且自动删除或更新子表中匹配的行。</p>
<p>2.SET NULL：从父表删除或更新行，并设置子表中的外键列为NULL。如果使用该选项，必须保证子表列没有指定NOT NULL。</p>
<p>3.RESTRICT：拒绝对父表的删除或更新操作。</p>
<p>4.NO ACTION：标准SQL的关键字，在MySQL中与RESTRICT相同。</p>
<p><strong>注意：</strong>物理外键即使用FOREIGN KEY关键字定义表。逻辑外键即定义表的时候按照某种联系，但是不使用FOREIGN KEY关键字修饰。</p>
<h4 id="编辑数据表的默认存储引擎"><a href="#编辑数据表的默认存储引擎" class="headerlink" title="编辑数据表的默认存储引擎"></a>编辑数据表的默认存储引擎</h4><p>MySQL配置文件</p>
<p><code>default-storage-engine=INNODB</code></p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table provinces(id smallint unsigned primary key auto_increment, pname varchar(20) not null);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table users(id smallint unsigned primary key auto_increment, username varchar(10) not null, pid bigint, foreign key(pid) references provinces(id));</span><br><span class="line"></span><br><span class="line"># 报错</span><br><span class="line"># ERROR 1215 (HY000): Cannot add foreign key constraint</span><br><span class="line"># 因为类型不匹配</span><br><span class="line"></span><br><span class="line"># 正确命令应该是：</span><br><span class="line">create table users(id smallint unsigned primary key auto_increment, username varchar(10) not null, pid smallint unsigned, foreign key(pid) references provinces(id));</span><br></pre></td></tr></table></figure>
<p><img src="http://o88e8any8.bkt.clouddn.com/mysql-study-07.png" alt="provinces表索引结构"></p>
<p><img src="http://o88e8any8.bkt.clouddn.com/mysql-study-08.png" alt="users表索引结构"></p>
<h3 id="表级约束和列级约束"><a href="#表级约束和列级约束" class="headerlink" title="表级约束和列级约束"></a>表级约束和列级约束</h3><p>对一个数据列建立的约束，称为列级约束。</p>
<p>对多个数据列建立的约束，称为表级约束。</p>
<p>列级约束既可以在列定义时声明，也可以在列定义后声明。</p>
<p>表级约束只能在列定义后声明。</p>
<h2 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h2><p>数据表（或称表）是数据库最重要的组成部分之一，是其它对象的基础。数据表即二维表，行称为记录，列称为字段。</p>
<h3 id="USE"><a href="#USE" class="headerlink" title="USE"></a>USE</h3><p>打开数据库</p>
<p><code>USE 数据库名称;</code></p>
<h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE [IF NOT EXISTS] table_name (column_name data_type, ...)</span><br></pre></td></tr></table></figure>
<h3 id="查看数据表列表"><a href="#查看数据表列表" class="headerlink" title="查看数据表列表"></a>查看数据表列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES [FROM db_name] [LIKE &apos;pattern&apos; | WHERE expr]</span><br></pre></td></tr></table></figure>
<h3 id="查看数据表结构"><a href="#查看数据表结构" class="headerlink" title="查看数据表结构"></a>查看数据表结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW COLUMNS FROM tbl_name</span><br></pre></td></tr></table></figure>
<h3 id="插入表记录"><a href="#插入表记录" class="headerlink" title="插入表记录"></a>插入表记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT [INTO] tbl_name [(col_name,...)] VALUES(val,...)</span><br></pre></td></tr></table></figure>
<p>如果省略col_name就需要写全数据表所有的值。</p>
<h3 id="记录查找"><a href="#记录查找" class="headerlink" title="记录查找"></a>记录查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT expr,... FROM tbl_name</span><br></pre></td></tr></table></figure>
<h3 id="添加单列（数据表字段）"><a href="#添加单列（数据表字段）" class="headerlink" title="添加单列（数据表字段）"></a>添加单列（数据表字段）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name ADD [COLUMN] col_name column_definition [FIRST|AFTER col_name]</span><br></pre></td></tr></table></figure>
<p>省略[FIRST|AFTER col_name]参数将位于所有列的最后面。</p>
<h3 id="添加多列（数据表字段）"><a href="#添加多列（数据表字段）" class="headerlink" title="添加多列（数据表字段）"></a>添加多列（数据表字段）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name ADD [COLUMN] (col_name column_definition, ...)</span><br></pre></td></tr></table></figure>
<h3 id="删除列（数据表字段）"><a href="#删除列（数据表字段）" class="headerlink" title="删除列（数据表字段）"></a>删除列（数据表字段）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name DROP [COLUMN] col_name</span><br></pre></td></tr></table></figure>
<h3 id="添加主键约束"><a href="#添加主键约束" class="headerlink" title="添加主键约束"></a>添加主键约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_col_name, ...)</span><br></pre></td></tr></table></figure>
<h3 id="添加唯一约束"><a href="#添加唯一约束" class="headerlink" title="添加唯一约束"></a>添加唯一约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] UNIQUE [INDEX|KEY] [index_name] [index_type] (index_col_name, ...)</span><br></pre></td></tr></table></figure>
<h3 id="添加外键约束"><a href="#添加外键约束" class="headerlink" title="添加外键约束"></a>添加外键约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] FOREIGN KEY [index_name] (index_col_name, ...) reference_definition</span><br></pre></td></tr></table></figure>
<h3 id="添加／删除默认约束"><a href="#添加／删除默认约束" class="headerlink" title="添加／删除默认约束"></a>添加／删除默认约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name ALTER [COLUMN] col_name &#123;SET DEFAULT literal | DROP DEFAULT&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除主键约束"><a href="#删除主键约束" class="headerlink" title="删除主键约束"></a>删除主键约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name DROP PRIMARY KEY</span><br></pre></td></tr></table></figure>
<h3 id="删除唯一约束"><a href="#删除唯一约束" class="headerlink" title="删除唯一约束"></a>删除唯一约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name DROP &#123;INDEX | KEY&#125; index_name</span><br></pre></td></tr></table></figure>
<h3 id="删除外键约束"><a href="#删除外键约束" class="headerlink" title="删除外键约束"></a>删除外键约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol</span><br></pre></td></tr></table></figure>
<h3 id="修改列定义"><a href="#修改列定义" class="headerlink" title="修改列定义"></a>修改列定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name MODIFY [COLUMN] col_name column_definition [FIRST | AFTER col_name]</span><br></pre></td></tr></table></figure>
<h3 id="修改列名称"><a href="#修改列名称" class="headerlink" title="修改列名称"></a>修改列名称</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_name CHANGE [COLUMN] old_col_name new_col_name column_definition [FIRST | AFTER col_name]</span><br></pre></td></tr></table></figure>
<h3 id="数据表更名"><a href="#数据表更名" class="headerlink" title="数据表更名"></a>数据表更名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 方法1</span><br><span class="line">ALTER TABLE tbl_name RENAME [TO|AS] new_tbl_name</span><br><span class="line"></span><br><span class="line"># 方法2</span><br><span class="line">RENAME TABLE tbl_name TO new_tbl_name [, tbl_name2 TO new_tbl_name2] ...</span><br></pre></td></tr></table></figure>
<h2 id="数据表数据操作"><a href="#数据表数据操作" class="headerlink" title="数据表数据操作"></a>数据表数据操作</h2><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 插入记录（可以插入多条记录）</span><br><span class="line">INSERT [INTO] tbl_name [(col_name, ...)] &#123;VALUES|VALUE&#125; (&#123;expr|DEFAULT&#125;, ...), (...), ...</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 插入记录（不可以插入多条记录）</span><br><span class="line">INSERT [INTO] tbl_name SET col_name = &#123;expr|DEFAULT&#125;, ...</span><br><span class="line"></span><br><span class="line"># 说明：与前一种方式的区别在于，此方法可以使用子查询（SubQuery）。由比较运算引发子查询（SubQuery）。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 插入记录</span><br><span class="line">INSERT [INTO] tbl_name [(col_name, ...)] SELECT ...</span><br><span class="line"></span><br><span class="line"># 说明：此方法可以将查询结果插入到指定数据表。</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.创建“商品分类”表</span><br><span class="line">CREATE TABLE IF NOT EXISTS tdb_goods_cates(cate_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,cate_name VARCHAR(40));</span><br><span class="line"></span><br><span class="line">2.查询tdb_goods表的所有记录，并且按&quot;类别&quot;分组</span><br><span class="line">SELECT goods_cate FROM tdb_goods GROUP BY goods_cate;</span><br><span class="line"></span><br><span class="line">3.将分组结果写入到tdb_goods_cates数据表</span><br><span class="line">INSERT tdb_goods_cates (cate_name) SELECT goods_cate FROM tdb_goods GROUP BY goods_cate;</span><br></pre></td></tr></table></figure>
<h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 更新记录（单表更新）</span><br><span class="line">UPDATE [LOW_PRIORITY] [IGNORE] table_reference SET col_name1 = &#123;expr|DEFAULT&#125; [, col_name2 = &#123;expr|DEFAULT&#125;] ... [WHERE where_condition]</span><br></pre></td></tr></table></figure>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除记录（单表删除）</span><br><span class="line">DELETE FROM tbl_name [WHERE where_condition]</span><br></pre></td></tr></table></figure>
<h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查找记录</span><br><span class="line">SELECT select_expr [, select_expr ...] </span><br><span class="line">[</span><br><span class="line">	FROM table_references</span><br><span class="line">	[WHERE where_condition]</span><br><span class="line">	[GROUP BY &#123;col_name|position&#125; [ASC|DESC], ... ]</span><br><span class="line">	[HAVING where_condition]</span><br><span class="line">	[ORDER BY &#123;col_name|expr|position&#125; [ASC|DESC], ...]</span><br><span class="line">	[LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="select-expr-查询表达式"><a href="#select-expr-查询表达式" class="headerlink" title="select_expr 查询表达式"></a>select_expr 查询表达式</h4><p>每一个表达式表示想要的一列，必须至少有一个。</p>
<p>多个列之间以英文逗号分隔。</p>
<p>星号（<code>*</code>）表示多有列。<code>tbl_name.*</code>可以表示命名表的所有列。</p>
<p>查询表达式可以使用[AS] alias_name为其赋予别名。</p>
<p>别名可用于GROUP BY，ORDER BY或HAVING子句。</p>
<h4 id="WHERE-条件表达式"><a href="#WHERE-条件表达式" class="headerlink" title="WHERE 条件表达式"></a>WHERE 条件表达式</h4><p>对记录进行过滤，如果没有指定WHERE子句，则显示所有记录。</p>
<p>在WHERE表达式中，可以使用MySQL支持的函数或运算符。</p>
<h4 id="GROUP-BY-查询结果分组"><a href="#GROUP-BY-查询结果分组" class="headerlink" title="GROUP BY 查询结果分组"></a>GROUP BY 查询结果分组</h4><p><code>[GROUP BY {col_name|position} [ASC|DESC], ... ]</code><br>ASC：生序，默认值。<br>DESC：降序。</p>
<h4 id="HAVING-分组条件"><a href="#HAVING-分组条件" class="headerlink" title="HAVING 分组条件"></a>HAVING 分组条件</h4><p><code>[HAVING where_condition]</code><br><code>where_condition</code>中要么使用聚合函数，要么出现的字段一定要在SELECT中出现。</p>
<p>聚合函数：count() …</p>
<h4 id="ORDER-BY-对查询结果进行排序"><a href="#ORDER-BY-对查询结果进行排序" class="headerlink" title="ORDER BY 对查询结果进行排序"></a>ORDER BY 对查询结果进行排序</h4><p><code>[ORDER BY {col_name|expr|position} [ASC|DESC], ...]</code></p>
<h4 id="LIMIT-限制查询返回的数量"><a href="#LIMIT-限制查询返回的数量" class="headerlink" title="LIMIT 限制查询返回的数量"></a>LIMIT 限制查询返回的数量</h4><p><code>[LIMIT {[offset,] row_count | row_count OFFSET offset}]</code><br>offset是从0开始的。</p>
<h3 id="CREATE-…-SELECT"><a href="#CREATE-…-SELECT" class="headerlink" title="CREATE … SELECT"></a>CREATE … SELECT</h3><p>创建数据表同时将查询结果写入到数据表<br><code>CREATE TABLE [IF NOT EXISTS] tbl_name [(create_definition, ...)] select_statement</code></p>
<p>示例：</p>
<ul>
<li>通过CREATE…SELECT来创建数据表并且同时写入记录<br><code>CREATE TABLE tdb_goods_brands (brand_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,brand_name VARCHAR(40) NOT NULL) SELECT brand_name FROM tdb_goods GROUP BY brand_name;</code></li>
</ul>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询（Subquery）是指出现在其他SQL语句内的SELECT子句。例如：<br><code>SELECT * FROM t1 WHERE col1=(SELECT col2 FROM t2);</code><br>其中<code>SELECT * FROM t1</code>称为Outer Query/Outer Statement。<code>SELECT col2 FROM t2</code>称为SubQuery。</p>
<p>子查询指嵌套在查询内部，且必须始终出现在圆括号内。子查询可以包含多个关键字或条件，如DISTINCT、GROUP BY、ORDER BY、LIMIT函数等。子查询外层的查询可以是：SELECT、INSERT、UPDATE、SET或DO。</p>
<p>子查询可以返回标量、一行、一列或子查询。</p>
<h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>1.创建表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table tdb_goods (</span><br><span class="line">	goods_id smallint unsigned primary key auto_increment,</span><br><span class="line">	goods_name varchar(150) not null, </span><br><span class="line">	goods_cate varchar(40) not null, </span><br><span class="line">	brand_name varchar(40) not null,</span><br><span class="line">	goods_price decimal(15,3) unsigned default 0 not null, </span><br><span class="line">	is_show boolean default 1 not null, </span><br><span class="line">	is_saleoff boolean default 0 not null);</span><br></pre></td></tr></table></figure></p>
<p>2.添加数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES(&apos;Mac Pro MD878CH/A 专业级台式电脑&apos;,&apos;服务器/工作站&apos;,&apos;苹果&apos;,&apos;28888&apos;,DEFAULT,DEFAULT);</span><br><span class="line"> </span><br><span class="line">INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES(&apos; HMZ-T3W 头戴显示设备&apos;,&apos;笔记本配件&apos;,&apos;索尼&apos;,&apos;6999&apos;,DEFAULT,DEFAULT);</span><br><span class="line"></span><br><span class="line">INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES(&apos;商务双肩背包&apos;,&apos;笔记本配件&apos;,&apos;索尼&apos;,&apos;99&apos;,DEFAULT,DEFAULT);</span><br><span class="line"></span><br><span class="line">INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES(&apos;X3250 M4机架式服务器 2583i14&apos;,&apos;服务器/工作站&apos;,&apos;IBM&apos;,&apos;6888&apos;,DEFAULT,DEFAULT);</span><br></pre></td></tr></table></figure></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="使用比较运算符的子查询"><a href="#使用比较运算符的子查询" class="headerlink" title="使用比较运算符的子查询"></a>使用比较运算符的子查询</h4><p><code>=、&gt;、&lt;、&gt;=、&lt;=、&lt;&gt;、!=、&lt;=&gt; ...</code></p>
<p>语法结构<br><code>operand comparison_operator subquery</code></p>
<p>示例：</p>
<ul>
<li><p>求所有电脑产品的平均价格,并且保留两位小数，AVG,MAX,MIN、COUNT、SUM为聚合函数<br><code>SELECT ROUND(AVG(goods_price),2) AS avg_price FROM tdb_goods;</code></p>
</li>
<li><p>查询所有价格大于平均价格的商品，并且按价格降序排序<br><code>SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price &gt; 5845.10 ORDER BY goods_price DESC;</code></p>
</li>
<li><p>使用子查询来实现<br><code>SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price &gt; (SELECT ROUND(AVG(goods_price),2) AS avg_price FROM tdb_goods) ORDER BY goods_price DESC;</code></p>
</li>
</ul>
<h5 id="用ANY、SOME或ALL修饰的比较运算符"><a href="#用ANY、SOME或ALL修饰的比较运算符" class="headerlink" title="用ANY、SOME或ALL修饰的比较运算符"></a>用ANY、SOME或ALL修饰的比较运算符</h5><p><code>operand comparison_operator ANY(subquery)</code><br><code>operand comparison_operator SOME(subquery)</code><br><code>operand comparison_operator ALL(subquery)</code></p>
<p>ANY、SOME、ALL关键字</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/mysql-study-10.png" alt=""></p>
<p>示例：</p>
<ul>
<li>查询价格大于或等于”超级本”价格的商品，并且按价格降序排列<br><code>SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price = ANY(SELECT goods_price FROM tdb_goods WHERE goods_cate = &#39;超级本&#39;) ORDER BY goods_price DESC;</code></li>
</ul>
<h4 id="使用-NOT-IN的子查询"><a href="#使用-NOT-IN的子查询" class="headerlink" title="使用[NOT]IN的子查询"></a>使用[NOT]IN的子查询</h4><p>语法结构<br><code>operand comparison_operator [NOT]IN(subquery)</code><br>=ANY运算符与IN等效。<br>!=ALL或&lt;&gt;ALL运算符与NOT IN等效。</p>
<p>示例：</p>
<ul>
<li>= ANY 或 = SOME 等价于 IN<br><code>SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price IN (SELECT goods_price FROM tdb_goods WHERE goods_cate = &#39;超级本&#39;) ORDER BY goods_price DESC;</code></li>
</ul>
<h4 id="使用-NOT-EXISTS的子查询"><a href="#使用-NOT-EXISTS的子查询" class="headerlink" title="使用[NOT]EXISTS的子查询"></a>使用[NOT]EXISTS的子查询</h4><p>如果子查询返回任何行，EXISTS将返回TRUE；否则为FALSE。</p>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>MySQL在SELECT语句、多表更新、多表删除语句中支持JOIN操作。</p>
<h3 id="多表更新"><a href="#多表更新" class="headerlink" title="多表更新"></a>多表更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_references SET col_name1 = &#123;expr1|DEFAULT&#125; [, col_name2 = &#123;expr2|DEFAULT&#125;] ... [WHERE where_condition]</span><br></pre></td></tr></table></figure>
<p><code>table_references</code>的语法结构：<br><code>{[INNER|CROSS] JOIN | {LEFT|RIGHT} [OUTER] JOIN} table_reference ON conditional_expr</code></p>
<h4 id="数据表参照"><a href="#数据表参照" class="headerlink" title="数据表参照"></a>数据表参照</h4><p>table_references<br><code>tbl_name [[AS] alias]|table_subquery [AS] alias</code><br>数据表可以使用<code>tbl_name AS alias_name</code>或<code>tbl_name alias_name</code>赋予别名。<br><code>table_subquery</code>可以作为子查询使用在FROM子句中，这样的子查询必须为其赋予别名。</p>
<h4 id="连接类型"><a href="#连接类型" class="headerlink" title="连接类型"></a>连接类型</h4><p>INNER JOIN，内连接。在MySQL中，JOIN，CROSS JOIN和INNER JOIN是等价的。<br>LEFT [OUTER] JOIN，左外连接。<br>RIGHT [OUTER] JOIN，右外连接。</p>
<p>示例：</p>
<ul>
<li>通过tdb_goods_cates数据表来更新tdb_goods表<br><code>UPDATE tdb_goods INNER JOIN tdb_goods_cates ON goods_cate = cate_name SET goods_cate = cate_id ;</code></li>
</ul>
<h3 id="多表删除"><a href="#多表删除" class="headerlink" title="多表删除"></a>多表删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE tbl_name [.*] [, tbl_name [.*]] ... FROM table_references [WHERE where_condition]</span><br></pre></td></tr></table></figure>
<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>显示左表及右表符合连接条件的记录。即仅显示符合连接条件的内容。<br><img src="http://o88e8any8.bkt.clouddn.com/mysql-study-11.png?imageView/2/w/150" alt="内连接"></p>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>A LEFT JOIN B join_condition.<br>数据表B的结果集依赖数据表A。<br>数据表A的结果集根据左连接条件依赖所有数据表（B表除外）。<br>左外连接条件决定如何检索数据表B（在没有指定WHERE条件的情况下）。<br>如果数据表A的某条记录符合WHERE条件，但是在数据表B不存在符合连接条件的记录，将生成一个所有列为空的额外的B行。<br>如果使用内连接查找的记录在连接数据表中不存在，并且在WHERE子句中尝试以下操作：col_name IS NULL时，如果col_name被定义为NOT NULL，MySQL将在找到符合连接条件的记录后停止搜索更多的行。</p>
<ul>
<li>左外连接<br>显示左表的全部记录及右表符合连接条件的记录。<br><img src="http://o88e8any8.bkt.clouddn.com/mysql-study-12.png?imageView/2/w/150" alt="左外连接"></li>
<li>右外连接<br>显示右表的全部记录及左表符合连接条件的记录。<br><img src="http://o88e8any8.bkt.clouddn.com/mysql-study-13.png?imageView/2/w/150" alt="右外连接"></li>
</ul>
<h3 id="连接条件"><a href="#连接条件" class="headerlink" title="连接条件"></a>连接条件</h3><p>使用ON关键字来设定连接条件，也可以使用WHERE来代替。<br>通常使用ON关键字来设定连接条件，使用WHERE关键字进行结果集记录的过滤。</p>
<h3 id="无限级分类表设计"><a href="#无限级分类表设计" class="headerlink" title="无限级分类表设计"></a>无限级分类表设计</h3><ul>
<li><p>无限分类的数据表设计<br><code>CREATE TABLE tdb_goods_types(
   type_id   SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
   type_name VARCHAR(20) NOT NULL,
   parent_id SMALLINT UNSIGNED NOT NULL DEFAULT 0
);</code></p>
</li>
<li><p>插入数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&apos;家用电器&apos;,DEFAULT);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&apos;电脑、办公&apos;,DEFAULT);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&apos;大家电&apos;,1);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&apos;生活电器&apos;,1);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&apos;平板电视&apos;,3);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&apos;空调&apos;,3);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&apos;电风扇&apos;,4);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&apos;饮水机&apos;,4);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&apos;电脑整机&apos;,2);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&apos;电脑配件&apos;,2);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&apos;笔记本&apos;,9);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&apos;超级本&apos;,9);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&apos;游戏本&apos;,9);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&apos;CPU&apos;,10);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&apos;主机&apos;,10);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h3><p>同一个数据表对其自身进行连接。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;结构化查询语言（英语：Structured Query Language，缩写：SQL），是一种特殊目的之编程语言，用于数据库中的标准数据查询语言，IBM公司最早使用在其开发的数据库系统中。&lt;/p&gt;
&lt;p&gt;不过各种通行的数据库系统在其实践过程中都对SQL规范作了某些编改和扩充。所以，实际上不同数据库系统之间的SQL不能完全相互通用。&lt;/p&gt;
&lt;p&gt;文章以MySQL数据库为演示环境，主要分享MySQL中的SQL使用。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://chars.tech/categories/web/"/>
    
    
      <category term="database" scheme="http://chars.tech/tags/database/"/>
    
      <category term="读书笔记" scheme="http://chars.tech/tags/notes/"/>
    
      <category term="mysql" scheme="http://chars.tech/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>与 MySQL 的零距离接触</title>
    <link href="http://chars.tech/2017/05/16/mysql-study/"/>
    <id>http://chars.tech/2017/05/16/mysql-study/</id>
    <published>2017-05-16T15:05:12.000Z</published>
    <updated>2017-07-05T08:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.mysql.com/" target="_blank" rel="external">MySQL</a>是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。</p>
<p>MySQL是一个开源的关系型数据库管理系统，分为社区版和企业版。</p>
<a id="more"></a>
<h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h1><p>直接前往官网 <a href="https://www.mysql.com/" target="_blank" rel="external">https://www.mysql.com/</a> ，进入download页面下载所需对应安装版本。默认配置安装即可。</p>
<h1 id="2-配置"><a href="#2-配置" class="headerlink" title="2 配置"></a>2 配置</h1><p>安装成功之后，需要修改密码。详看<a href="/2017/03/22/mysql-install-config/">《MySQL 安装配置》</a></p>
<p>修改编码方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">character-set-server=utf8</span><br></pre></td></tr></table></figure>
<h1 id="3-目录结构"><a href="#3-目录结构" class="headerlink" title="3 目录结构"></a>3 目录结构</h1><p>bin目录，存储可执行文件。</p>
<p>data目录，存储数据文件。</p>
<p>docs，文档。</p>
<p>include目录，存储包含的头文件。</p>
<p>lib目录，存储库文件。</p>
<p>share，错误消息和字符集文件。</p>
<h1 id="4-命令参数说明"><a href="#4-命令参数说明" class="headerlink" title="4 命令参数说明"></a>4 命令参数说明</h1><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-D,–database=name</td>
<td>打开指定数据库</td>
</tr>
<tr>
<td>–delimiter=name</td>
<td>指定分隔符</td>
</tr>
<tr>
<td>-h,–host=name</td>
<td>服务器名称</td>
</tr>
<tr>
<td>-p,–password[=name]</td>
<td>密码</td>
</tr>
<tr>
<td>-P,–port=#</td>
<td>端口号</td>
</tr>
<tr>
<td>–prompt=name</td>
<td>设置提示符</td>
</tr>
<tr>
<td>-u,–user=name</td>
<td>用户名</td>
</tr>
<tr>
<td>-V,–version</td>
<td>输出版本信息并退出</td>
</tr>
</tbody>
</table>
<h2 id="MySQL提示符"><a href="#MySQL提示符" class="headerlink" title="MySQL提示符"></a>MySQL提示符</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\D</td>
<td>完整的日期</td>
</tr>
<tr>
<td>\d</td>
<td>当前数据库</td>
</tr>
<tr>
<td>\h</td>
<td>服务器名称</td>
</tr>
<tr>
<td>\u</td>
<td>当前用户</td>
</tr>
</tbody>
</table>
<h2 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h2><h3 id="修改MySQL提示符"><a href="#修改MySQL提示符" class="headerlink" title="修改MySQL提示符"></a>修改MySQL提示符</h3><p>1.连接客户端时通过参数指定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -proot --prompt 提示符</span><br></pre></td></tr></table></figure>
<p>2.连接上客户端后，通过prompt命令修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;prompt 提示符</span><br></pre></td></tr></table></figure>
<h3 id="MySQL常用命令"><a href="#MySQL常用命令" class="headerlink" title="MySQL常用命令"></a>MySQL常用命令</h3><p>1.显示当前服务器版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT VERSION();</span><br></pre></td></tr></table></figure>
<p>2.显示当前日期时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT NOW();</span><br></pre></td></tr></table></figure>
<p>3.显示当前用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT USER();</span><br></pre></td></tr></table></figure>
<h3 id="MySQL语句规范"><a href="#MySQL语句规范" class="headerlink" title="MySQL语句规范"></a>MySQL语句规范</h3><p>1.关键字与函数名称全部大写。</p>
<p>2.数据库名称、表名称、字段名称全部小写。</p>
<p>3.SQL语句必须以”;”符号结尾。</p>
<h1 id="5-SQL"><a href="#5-SQL" class="headerlink" title="5 SQL"></a>5 SQL</h1><p>结构化查询语言（英语：Structured Query Language，缩写：SQL），是一种特殊目的之编程语言，用于数据库中的标准数据查询语言。<br>不过各种通行的数据库系统在其实践过程中都对SQL规范作了某些编改和扩充。所以，实际上不同数据库系统之间的SQL不能完全相互通用。</p>
<p>具体参看文章<br><a href="/2017/05/19/mysql-sql-study/">《MySQL 中的SQL》</a></p>
<h1 id="6-数据类型"><a href="#6-数据类型" class="headerlink" title="6 数据类型"></a>6 数据类型</h1><p>数据类型是指列、存储过程参数、表达式和局部变量的数据特征，它决定了数据的存储格式，代表了不同信息的类型。</p>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p><img src="http://o88e8any8.bkt.clouddn.com/mysql-study-01.png" alt="整型表"></p>
<h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>存储范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>FLOAT[(M,D)]</td>
<td>-3.402823466E+38到-1.175494351E-38、0和1.175494351E-38到3.402823466E+38。M是数字总位数，D是小数点后面的位数。如果M和D被省略，根据硬件允许的限制来保存值。单精度浮点数精确到大约7位小数点。</td>
</tr>
<tr>
<td>DOUBLE[(M,D)]</td>
<td>-1.7976931348623157E+308到-2.2250738585072014E-308、0和2.2250738585072014E-308到1.7976931348623157E+308。</td>
</tr>
</tbody>
</table>
<h2 id="日期和时间型"><a href="#日期和时间型" class="headerlink" title="日期和时间型"></a>日期和时间型</h2><table>
<thead>
<tr>
<th>列类型</th>
<th>存储需求</th>
</tr>
</thead>
<tbody>
<tr>
<td>YEAR</td>
<td>1</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
</tr>
<tr>
<td>DATE</td>
<td>3</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4</td>
</tr>
</tbody>
</table>
<h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><table>
<thead>
<tr>
<th>列类型</th>
<th>存储需求</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR(M)</td>
<td>M个字节，0&lt;=M&lt;=255</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>L+1个字节，其中L&lt;=M且0&lt;=M&lt;=65535</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>L+1个字节，其中L&lt;2^8</td>
</tr>
<tr>
<td>TEXT</td>
<td>L+2个字节，其中L&lt;2^16</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>L+3个字节，其中L&lt;2^24</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>L+4个字节，其中L&lt;2^32</td>
</tr>
<tr>
<td>ENUM(‘VALUE1’,’VALUE2’,…)</td>
<td>1或2个字节，取决于枚举值的个数（最多65,535个值）</td>
</tr>
<tr>
<td>SET(‘VALUE1’,’VALUE2’,…)</td>
<td>1、2、3、4或者8个字节，取决于set成员的数目（最多64个成员）</td>
</tr>
</tbody>
</table>
<p>更多其他MySQL使用与知识可以参见<a href="/2017/05/29/mysql-advanced-study/">《拆解 MySQL 的高阶使用与概念》</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.mysql.com/&quot;&gt;MySQL&lt;/a&gt;是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。&lt;/p&gt;
&lt;p&gt;MySQL是一个开源的关系型数据库管理系统，分为社区版和企业版。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://chars.tech/categories/web/"/>
    
    
      <category term="database" scheme="http://chars.tech/tags/database/"/>
    
      <category term="读书笔记" scheme="http://chars.tech/tags/notes/"/>
    
      <category term="mysql" scheme="http://chars.tech/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Objective-C的Runtime</title>
    <link href="http://chars.tech/2017/05/09/objc-runtime/"/>
    <id>http://chars.tech/2017/05/09/objc-runtime/</id>
    <published>2017-05-09T00:36:49.000Z</published>
    <updated>2017-07-05T08:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。</p>
<p>对于Objective-C来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。Runtime基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。</p>
<p>在Runtime中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。这些结构体和函数被runtime函数封装后，让Objective-C的面向对象编程变为可能。</p>
<p>找出方法的最终执行代码：当程序执行<code>[object doSomething]</code>时，会向消息接收者(object)发送一条消息(doSomething)，runtime会根据消息接收者是否能响应该消息而做出不同的反应。</p>
<a id="more"></a>
<h1 id="1-消息机制"><a href="#1-消息机制" class="headerlink" title="1 消息机制"></a>1 消息机制</h1><p>与古老的C语言不同，Objective-C虽然源自C语言，但是它却是面向对象的，在这之中，消息机制发挥着重大作用。</p>
<p><strong>C语言和Objective-C编译时的区别：</strong></p>
<p>C语言在编译的时候，已经知道调用哪一个函数。</p>
<p>Objective-C不一样，只有在运行时才知道需要调用的方法和函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT void objc_msgSend(void /* id self, SEL op, ... */ )</span><br><span class="line">    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0);</span><br></pre></td></tr></table></figure>
<p>使用这个方法要<code>#import &lt;objc/message.h&gt;</code>，另外，Apple在Xcode5开始，不建议使用底层方法，而恰巧以上方法就是底层方法。此时，Xcode就会报错，那么，如何解决呢？</p>
<p>解决方案如下：</p>
<ul>
<li>1）打开Project的<code>Build Settings</code>，搜索“msg”。</li>
<li>2）将<code>Enable Strict Checking of objc_msgSend Calls</code>的值设置为NO。</li>
</ul>
<h2 id="发送无参消息"><a href="#发送无参消息" class="headerlink" title="发送无参消息"></a>发送无参消息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface Sample : NSObject</span><br><span class="line">+ (void)run;</span><br><span class="line">- (void)run;</span><br><span class="line">- (void)eatWithFood:(NSString *)food;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Sample</span><br><span class="line">+ (void)run</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;类方法 run&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;实例方法 run&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)eatWithFood:(NSString *)food</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;实例方法 eat：%@&quot;, food);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">- (void)test &#123;</span><br><span class="line">	Sample *t = [[Sample alloc] init];</span><br><span class="line">	objc_msgSend(t, @selector(run));</span><br><span class="line"></span><br><span class="line">	objc_msgSend([Sample class], @selector(run));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发送带参消息"><a href="#发送带参消息" class="headerlink" title="发送带参消息"></a>发送带参消息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)test &#123;</span><br><span class="line">	Sample *t = [[Sample alloc] init];</span><br><span class="line">	objc_msgSend(t, @selector(eatWithFood:), @&quot;apple&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>附加：将Objective-C转换出Runtime代码方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc xxxx.m</span><br></pre></td></tr></table></figure>
<h2 id="交换方法的实现"><a href="#交换方法的实现" class="headerlink" title="交换方法的实现"></a>交换方法的实现</h2><p><code>class_getInstanceMethod(__unsafe_unretained Class cls, SEL name)</code>获取对象方法。</p>
<p><code>class_getClassMethod(__unsafe_unretained Class cls, SEL name)</code>获取类方法。</p>
<p><code>method_exchangeImplementations(Method m1, Method m2)</code>交换方法的实现方式。</p>
<p>常见示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSURL *url = [NSURL URLWithString:@&quot;https://charsdavy.github.io&quot;];</span><br><span class="line">[NSURLRequest requestWithURL:url];</span><br></pre></td></tr></table></figure>
<p>但<code>url</code>可能返回nil，而此段代码未能对返回值<code>url</code>进行合法判断。但每次使用以上类似代码都需要进行合法性判断，那么有什么更好的方法使<code>URLWithString:</code>能够做合法性判断呢？这个时候就需要使用Runtime的特有方法了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@interface NSURL (DD)</span><br><span class="line">+ (instancetype)dd_URLWithString:(NSString *)URLString;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSURL (DD)</span><br><span class="line">// 加载此分类时调用</span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    //获取方法名称</span><br><span class="line">    Method urlMethod = class_getClassMethod([NSURL class], @selector(URLWithString:));</span><br><span class="line">    Method ddUrlMethod = class_getClassMethod([NSURL class], @selector(dd_URLWithString:));</span><br><span class="line">    //交换方法的实现</span><br><span class="line">    method_exchangeImplementations(urlMethod, ddUrlMethod);</span><br><span class="line">&#125;</span><br><span class="line">//此方法与URLWithString:交换了实现方式</span><br><span class="line">+ (instancetype)dd_URLWithString:(NSString *)URLString</span><br><span class="line">&#123;</span><br><span class="line">//    NSURL *url = [NSURL URLWithString:URLString]; 此处不能再调用此方法，否则会死循环</span><br><span class="line">    NSURL *url = [NSURL dd_URLWithString:URLString];</span><br><span class="line">    if (!url) &#123;</span><br><span class="line">        NSLog(@&quot;url is nil&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return url;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h2 id="归档和解档"><a href="#归档和解档" class="headerlink" title="归档和解档"></a>归档和解档</h2><p>先来理解几个Objective-C中的概念：</p>
<p>序列化：将自定义的Objective-C的对象转化成二进制文件数据。</p>
<p>反序列化：将二进制文件数据转化成自定义的Objective-C的对象。</p>
<p>归档：将自定义的Objective-C的对象存储到本地磁盘。</p>
<p>解档：将存储在本地磁盘的数据转换成自定义的Objective-C的对象。</p>
<p>Ivar类型：成员属性。</p>
<p>Method类型：成员方法。</p>
<p>通常我们使用归档和解档的方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@interface Sample : NSObject&lt;NSCoding&gt;</span><br><span class="line">@property (nonatomic) NSString *name;</span><br><span class="line">@property (nonatomic) NSString *age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Sample</span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder</span><br><span class="line">&#123;</span><br><span class="line">    [aCoder encodeObject:self.name forKey:@&quot;name&quot;];</span><br><span class="line">    [aCoder encodeObject:self.age forKey:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;];</span><br><span class="line">        self.age = [aDecoder decodeObjectForKey:@&quot;age&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">- (void)saveObject</span><br><span class="line">&#123;</span><br><span class="line">    Sample *p = [[Sample alloc] init];</span><br><span class="line">    p.name = @&quot;Chars&quot;;</span><br><span class="line">    p.age = @&quot;18&quot;;</span><br><span class="line">    </span><br><span class="line">    NSString *path = [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;chars.dat&quot;];</span><br><span class="line">    </span><br><span class="line">    BOOL flag = [NSKeyedArchiver archiveRootObject:p toFile:path];</span><br><span class="line">    if (flag) &#123;</span><br><span class="line">        NSLog(@&quot;success&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;falied&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;, path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)readObject</span><br><span class="line">&#123;</span><br><span class="line">    NSString *path = [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;chars.dat&quot;];</span><br><span class="line">    </span><br><span class="line">    Sample *p = [NSKeyedUnarchiver unarchiveObjectWithFile:path];</span><br><span class="line">    if (p) &#123;</span><br><span class="line">        NSLog(@&quot;name:%@,age:%@&quot;, p.name, p.age);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;falied&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;, path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Objective-C中归档底层实现方式：将对象拆分为字典（键值对），然后变成二进制存入磁盘。</p>
<p>但是，当model中成员属性数量很多的时候，就沦为了体力劳动。那么，此时我们又能使用Runtime来简化工作。</p>
<p><code>class_copyIvarList(__unsafe_unretained Class cls, unsigned int *outCount)</code>获取Class中成员变量的个数。</p>
<p>以下就是使用Runtime消息机制编写的归档与解档方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder</span><br><span class="line">&#123;   </span><br><span class="line">    unsigned int count = 0;</span><br><span class="line">    Ivar *ivars = class_copyIvarList([Sample class], &amp;count);</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        const char *name = ivar_getName(ivar);</span><br><span class="line">        NSString *key = [NSString stringWithUTF8String:name];</span><br><span class="line">        [aCoder encodeObject:[self valueForKey:key] forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        unsigned int count = 0;</span><br><span class="line">        Ivar *ivars = class_copyIvarList([Sample class], &amp;count);</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            Ivar ivar = ivars[i];</span><br><span class="line">            const char *name = ivar_getName(ivar);</span><br><span class="line">            NSString *key = [NSString stringWithUTF8String:name];</span><br><span class="line">            id value = [aDecoder decodeObjectForKey:key];</span><br><span class="line">            [self setValue:value forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        free(ivars);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-KVO"><a href="#2-KVO" class="headerlink" title="2 KVO"></a>2 KVO</h1><p>利用Runtime，在运行时动态创建一个对象。</p>
<p>实现原理：</p>
<ol>
<li>创建<code>NSKVONotifying_XXX:XXX</code>类(XXX为被监听者)。</li>
<li>重写属性set方法，调用<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>方法，进而触发调用观察者的<code>observeValueForKeyPath:ofObject:change:context:</code></li>
</ol>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@interface Viewer : NSObject</span><br><span class="line">@property (nonatomic) NSString *name;</span><br><span class="line">@property (nonatomic) NSString *age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Observer : NSObject</span><br><span class="line">@property (nonatomic) NSString *name;</span><br><span class="line">@property (nonatomic) NSString *age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Observer</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;object:%@, keyPath:%@, change:%@&quot;, object, keyPath, change);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">Observer *observer = [[Observer alloc] init];</span><br><span class="line">Viewr *viewer = [[Viewer alloc] init];</span><br><span class="line">//注册监听,viewer为被监听者，observer为观察者</span><br><span class="line">[viewr addObserver:observer forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br><span class="line">//触发KVO</span><br><span class="line">viewer.age = @&quot;99&quot;;</span><br></pre></td></tr></table></figure>
<h1 id="3-动态添加方法"><a href="#3-动态添加方法" class="headerlink" title="3 动态添加方法"></a>3 动态添加方法</h1><p>当方法被调用时，才被加载。</p>
<p><code>+ (BOOL)resolveClassMethod:(SEL)sel;</code>当一个类被调用了一个没有实现的方法时，则会调用此方法。</p>
<p><code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>当一个类被调用了一个没有实现的实例方法时，则会调用此方法。</p>
<p><code>class_addMethod(__unsafe_unretained Class cls, SEL name, IMP imp, const char *types)</code>动态添加方法。</p>
<p>参数<code>cls</code>：类类型。参数<code>name</code>：方法编号。参数<code>imp</code>：方法实现，就是一个函数的指针。参数<code>* types</code>：方法类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@implementation Sample</span><br><span class="line">//一个类被调用了一个没有实现的实例方法时，则会调用此方法。</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    if (sel == @selector(eat)) &#123;</span><br><span class="line">        //添加一个实例方法</span><br><span class="line">        class_addMethod([Sample class], sel, (IMP)eat, &quot;v@:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//隐式参数,self和_cmd是系统传过来的参数</span><br><span class="line">void eat(id self, SEL _cmd) &#123;</span><br><span class="line">    NSLog(@&quot;调用了%@的%@方法&quot;, self, NSStringFromSelector(_cmd));</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">[[[Sample alloc] init] performSelector:@selector(eat)];</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。&lt;/p&gt;
&lt;p&gt;对于Objective-C来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。Runtime基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。&lt;/p&gt;
&lt;p&gt;在Runtime中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。这些结构体和函数被runtime函数封装后，让Objective-C的面向对象编程变为可能。&lt;/p&gt;
&lt;p&gt;找出方法的最终执行代码：当程序执行&lt;code&gt;[object doSomething]&lt;/code&gt;时，会向消息接收者(object)发送一条消息(doSomething)，runtime会根据消息接收者是否能响应该消息而做出不同的反应。&lt;/p&gt;
    
    </summary>
    
      <category term="pieces" scheme="http://chars.tech/categories/pieces/"/>
    
    
      <category term="ios" scheme="http://chars.tech/tags/ios/"/>
    
      <category term="objc" scheme="http://chars.tech/tags/objc/"/>
    
      <category term="读书笔记" scheme="http://chars.tech/tags/notes/"/>
    
      <category term="runtime" scheme="http://chars.tech/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>日语-敬体和简体</title>
    <link href="http://chars.tech/2017/04/23/japanese-honorific-tongue/"/>
    <id>http://chars.tech/2017/04/23/japanese-honorific-tongue/</id>
    <published>2017-04-23T13:17:27.000Z</published>
    <updated>2017-09-30T06:26:04.055Z</updated>
    
    <content type="html"><![CDATA[<p>在口语里，日语的谓语形式根据说话人之间的上下级关系、亲疏关系的不同而不同。“～ます”、“～です”是对长辈或关系不太亲密的人使用的形式。这种形式我们称为“敬体形”。与此相反，如对方是自己的同辈或晚辈，或者关系比较密切时则使用“简体形”。“简体形”是不使用“ます”、“です”的形式。</p>
<p>动词本身即具有“敬体形”和“简体形”，“～ます”、“～ません”、“～ました”、“～ませんでした”等四种礼貌的表达形式即是“敬体形”，而动词的“基本形”、“ない形”、“た形”都属于简体形。但一类形容词、二类形容词和名词本身没有“敬体形”和“简体形”之分，只有在做谓语时，其谓语形式才具有“敬体形”和“简体形”。</p>
<a id="more"></a>
<h2 id="1-动词"><a href="#1-动词" class="headerlink" title="1 动词"></a>1 动词</h2><table>
<thead>
<tr>
<th>时态</th>
<th>敬体</th>
<th>简体</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>现在时</td>
<td>〜ます</td>
<td>原形</td>
<td>あります-&gt;ある</td>
</tr>
<tr>
<td>过去时</td>
<td>〜ました</td>
<td>〜た</td>
<td>ありました-&gt;あった</td>
</tr>
<tr>
<td>否定式</td>
<td>〜ません</td>
<td>〜ない</td>
<td>ありません-&gt;<del>あらない</del>ない</td>
</tr>
<tr>
<td>过去否定式</td>
<td>〜ませんでした</td>
<td>〜なかった</td>
<td>ありませんでした-&gt;なかった</td>
</tr>
</tbody>
</table>
<h2 id="2-形容词"><a href="#2-形容词" class="headerlink" title="2 形容词"></a>2 形容词</h2><p>具体变形规则可以参看<a href="/2016/12/26/japanese-adjective">《日语-形容词》</a></p>
<h3 id="2-1-一类形容词"><a href="#2-1-一类形容词" class="headerlink" title="2.1 一类形容词"></a>2.1 一类形容词</h3><table>
<thead>
<tr>
<th>时态</th>
<th>敬体</th>
<th>简体</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>现在时</td>
<td>〜です</td>
<td>〜<del>です</del></td>
<td>おいしいです-&gt;おいしい</td>
</tr>
<tr>
<td>过去时</td>
<td>〜かったです</td>
<td>〜かった<del>です</del></td>
<td>おいし<del>い</del>かったです-&gt;おいし<del>い</del>かった</td>
</tr>
<tr>
<td>否定式</td>
<td>〜くないです</td>
<td>〜くない<del>です</del></td>
<td>おいし<del>い</del>くないです-&gt;おいし<del>い</del>くない</td>
</tr>
<tr>
<td>过去否定式</td>
<td>〜くなかったです</td>
<td>〜くなかった<del>です</del></td>
<td>おいし<del>い</del>くなかったです-&gt;おいし<del>い</del>くなかった</td>
</tr>
</tbody>
</table>
<p>おいしい（美味しい）</p>
<h3 id="2-2-二类形容词"><a href="#2-2-二类形容词" class="headerlink" title="2.2 二类形容词"></a>2.2 二类形容词</h3><table>
<thead>
<tr>
<th>时态</th>
<th>敬体</th>
<th>简体</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>现在时</td>
<td>〜です</td>
<td>〜だ</td>
<td>元気です-&gt;元気だ</td>
</tr>
<tr>
<td>过去时</td>
<td>〜でした</td>
<td>〜だった</td>
<td>元気でした-&gt;元気だった</td>
</tr>
<tr>
<td>否定式</td>
<td>〜ではありません</td>
<td>〜ではない/〜じゃない</td>
<td>元気ではありません-&gt;元気ではない/元気じゃない</td>
</tr>
<tr>
<td>过去否定式</td>
<td>〜ではありませんでした</td>
<td>〜ではなかった/〜じゃなかった</td>
<td>元気ではありませんでした-&gt;元気ではなかった/元気じゃなかった</td>
</tr>
</tbody>
</table>
<p>昨日、暑かった？ううん、全然暑くなかった。</p>
<p>この着物、派手（はで）？ううん、全然派手じゃないわ（此处男性使用时不加わ）。</p>
<h2 id="3-名词"><a href="#3-名词" class="headerlink" title="3 名词"></a>3 名词</h2><p>形式规则与二类形容词一致。</p>
<h2 id="4-敬语的基本型"><a href="#4-敬语的基本型" class="headerlink" title="4 敬语的基本型"></a>4 敬语的基本型</h2><h3 id="尊他语（尊敬語）"><a href="#尊他语（尊敬語）" class="headerlink" title="尊他语（尊敬語）"></a>尊他语（尊敬語）</h3><table>
<thead>
<tr>
<th>基本型</th>
<th>尊敬语</th>
</tr>
</thead>
<tbody>
<tr>
<td>　お〜になら　</td>
<td>　お待ちになる　<br>　お読みになる　<br>　お書きになる　<br>　お聴きになる　</td>
</tr>
<tr>
<td>　ご〜になら　</td>
<td>　ご入学になる　<br>　ご視察になる　<br>　ご說明になる　</td>
</tr>
<tr>
<td>　〜れる　<br>　〜られる　</td>
<td>　行かれる　<br>　聞かれる　<br>　話される <br>　来られる　</td>
</tr>
</tbody>
</table>
<h3 id="自谦语（謙譲語）"><a href="#自谦语（謙譲語）" class="headerlink" title="自谦语（謙譲語）"></a>自谦语（謙譲語）</h3><table>
<thead>
<tr>
<th>基本型</th>
<th>自谦语</th>
</tr>
</thead>
<tbody>
<tr>
<td>　お〜する　</td>
<td>　お待ちする　<br>　お書きする　<br>　お聴きする　</td>
</tr>
<tr>
<td>　ご〜する　</td>
<td>　ご案內する　<br>　ご返事する　<br>　ご說明する　</td>
</tr>
<tr>
<td>　〜いただく(相手の動作)　</td>
<td>　お越しいただく　<br>　ご覽いただく　</td>
</tr>
<tr>
<td>　〜させていただく(自分の動作)　</td>
<td>　聞かせていただく　<br>　読ませていただく　<br>　出席させていただく　</td>
</tr>
<tr>
<td>　〜いたす　</td>
<td>　出席いただく　<br>　連絡させていただく　</td>
</tr>
</tbody>
</table>
<h3 id="礼貌语（丁寧語）"><a href="#礼貌语（丁寧語）" class="headerlink" title="礼貌语（丁寧語）"></a>礼貌语（丁寧語）</h3><table>
<thead>
<tr>
<th>基本型</th>
<th>礼貌语</th>
</tr>
</thead>
<tbody>
<tr>
<td>　〜です　</td>
<td>　〜です　<br>　〜ます　<br>　〜ございます　</td>
</tr>
<tr>
<td>　〜ます　</td>
<td>　　</td>
</tr>
<tr>
<td>　〜ございます　</td>
<td>　　</td>
</tr>
</tbody>
</table>
<h3 id="混合表"><a href="#混合表" class="headerlink" title="混合表"></a>混合表</h3><table>
<thead>
<tr>
<th>基本型</th>
<th>尊他语</th>
<th>自谦语</th>
</tr>
</thead>
<tbody>
<tr>
<td>　いる　</td>
<td>　いらっしゃいます　<br>　おいでになります　</td>
<td>　おります　</td>
</tr>
<tr>
<td>　する　</td>
<td>　なさいます　</td>
<td>　いたします　</td>
</tr>
<tr>
<td>　行く　</td>
<td>　いらっしゃいます　</td>
<td>　参ります　</td>
</tr>
<tr>
<td>　来る　</td>
<td>　いらっしゃいます　<br>　お見えになります <br> お越しになります　</td>
<td>　参ります　</td>
</tr>
<tr>
<td>言う</td>
<td>おっしゃいます　</td>
<td>申します　<br> 申し上げます　</td>
</tr>
<tr>
<td>会う　</td>
<td>お会いになる　</td>
<td>お目にかかる　</td>
</tr>
<tr>
<td>聞く　</td>
<td>お聞きになります　</td>
<td>うかがいます　<br> 承ります　</td>
</tr>
<tr>
<td>見る　</td>
<td>ご覧になります　</td>
<td>拝見いたします　</td>
</tr>
<tr>
<td>見せる　</td>
<td>お見せになります　</td>
<td>お目にかける　<br> お見せする　</td>
</tr>
<tr>
<td>与える</td>
<td>くださいます</td>
<td>差し上げます　<br> 上げます　</td>
</tr>
<tr>
<td>知っている　</td>
<td>ご存知です　</td>
<td>存じ上げております　<br> 存じております</td>
</tr>
<tr>
<td>持って行く　</td>
<td>お持ちになら　</td>
<td>持参います　</td>
</tr>
<tr>
<td>食べる・飲む　</td>
<td>召し上がります　</td>
<td>いただきます　</td>
</tr>
<tr>
<td>もらう　</td>
<td></td>
<td>いただきます　<br>　頂戴いたします　</td>
</tr>
<tr>
<td>着る　</td>
<td>召す　<br> お召しになら　</td>
<td>着る　</td>
</tr>
<tr>
<td>ほめる　</td>
<td>お褒めになる　</td>
<td>お褒めにあずかる　</td>
</tr>
<tr>
<td>借りる　</td>
<td>お借りになる　</td>
<td>拝借する　</td>
</tr>
<tr>
<td>思う　</td>
<td>おぼしめす　</td>
<td>存じます　</td>
</tr>
</tbody>
</table>
<h3 id="礼貌语的使用方法"><a href="#礼貌语的使用方法" class="headerlink" title="礼貌语的使用方法"></a>礼貌语的使用方法</h3><table>
<thead>
<tr>
<th>丁寧語の程度による使い分け</th>
<th>同僚との会話</th>
<th>普通の丁寧語</th>
</tr>
</thead>
<tbody>
<tr>
<td>どうする　</td>
<td>どうします　</td>
<td>いかがなさいますか　</td>
</tr>
<tr>
<td>いいか　</td>
<td>いいですか　</td>
<td>いかがでございましょう　</td>
</tr>
<tr>
<td>そうだ　</td>
<td>そうです　</td>
<td>さようでございます　</td>
</tr>
<tr>
<td>これを見て　</td>
<td>これを見てください　</td>
<td>これをご覧くださyい　</td>
</tr>
<tr>
<td>わかったか　</td>
<td>わかりますか　</td>
<td>お分かりいただけましたでしょうか　</td>
</tr>
<tr>
<td>聞いた　</td>
<td>ききました　</td>
<td>うかがいました　</td>
</tr>
<tr>
<td>ある　</td>
<td>あります　</td>
<td>ございます　</td>
</tr>
<tr>
<td>いってみろ　</td>
<td>話してください　</td>
<td>おっしゃってください　</td>
</tr>
</tbody>
</table>
<h3 id="そのほか-其他"><a href="#そのほか-其他" class="headerlink" title="そのほか/其他"></a>そのほか/其他</h3><table>
<thead>
<tr>
<th>普通語</th>
<th>丁寧語</th>
</tr>
</thead>
<tbody>
<tr>
<td>あっち　</td>
<td>あちら　</td>
</tr>
<tr>
<td>こっち　</td>
<td>こちら　</td>
</tr>
<tr>
<td>きょう（今日）</td>
<td>ほんじつ（本日）</td>
</tr>
<tr>
<td>きのう（昨日）</td>
<td>さくじつ（昨日）</td>
</tr>
<tr>
<td>あした（明日）</td>
<td>みょうにち（明日）</td>
</tr>
<tr>
<td>おととい（一昨日）</td>
<td>いっさくじつ（一昨日）</td>
</tr>
<tr>
<td>あさって（明後日）</td>
<td>みょうごにち（明後日）</td>
</tr>
<tr>
<td>少し　</td>
<td>少少</td>
</tr>
<tr>
<td>どう　</td>
<td>いかが　</td>
</tr>
<tr>
<td>いくら　</td>
<td>いかほど　</td>
</tr>
<tr>
<td>すみません　</td>
<td>相すみません　</td>
</tr>
<tr>
<td>けさ（今朝）</td>
<td>こんちょう（今朝）</td>
</tr>
<tr>
<td>ゆうべ（昨夜）</td>
<td>さくや（昨夜）</td>
</tr>
<tr>
<td>ことし（今年）</td>
<td>ほんねん（本年）</td>
</tr>
<tr>
<td>きょねん（去年）</td>
<td>さくねん（昨年）</td>
</tr>
<tr>
<td>おととし（一昨年）</td>
<td>いっさくねん（一昨年）</td>
</tr>
<tr>
<td>今</td>
<td>只今</td>
</tr>
<tr>
<td>今度</td>
<td>この度</td>
</tr>
<tr>
<td>この間</td>
<td>せんじつ（先日）</td>
</tr>
<tr>
<td>どんな　</td>
<td>どの樣な　</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在口语里，日语的谓语形式根据说话人之间的上下级关系、亲疏关系的不同而不同。“～ます”、“～です”是对长辈或关系不太亲密的人使用的形式。这种形式我们称为“敬体形”。与此相反，如对方是自己的同辈或晚辈，或者关系比较密切时则使用“简体形”。“简体形”是不使用“ます”、“です”的形式。&lt;/p&gt;
&lt;p&gt;动词本身即具有“敬体形”和“简体形”，“～ます”、“～ません”、“～ました”、“～ませんでした”等四种礼貌的表达形式即是“敬体形”，而动词的“基本形”、“ない形”、“た形”都属于简体形。但一类形容词、二类形容词和名词本身没有“敬体形”和“简体形”之分，只有在做谓语时，其谓语形式才具有“敬体形”和“简体形”。&lt;/p&gt;
    
    </summary>
    
      <category term="talk" scheme="http://chars.tech/categories/talk/"/>
    
    
      <category term="碎碎念" scheme="http://chars.tech/tags/text/"/>
    
      <category term="日语" scheme="http://chars.tech/tags/japan-language/"/>
    
  </entry>
  
  <entry>
    <title>Python 学习 基础篇</title>
    <link href="http://chars.tech/2017/04/22/python-basic-knowledge/"/>
    <id>http://chars.tech/2017/04/22/python-basic-knowledge/</id>
    <published>2017-04-22T05:48:41.000Z</published>
    <updated>2017-07-05T08:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>全世界大概有几百种编程语言，而其中著名的只有十几种。Python就是著名编程语言之一。它起源于“龟叔”（Guido van Rossum，荷兰人）在1989年圣诞节间的无聊，而为了打发时间所创造。</p>
<p>可见业余时间比工作时间创造出来的东西更容易出名哈，当然，这是开玩笑的。“龟叔”赋予Python“优雅、明确、简单”的特点。</p>
<p>那么，Python适合做什么呢？它主要适用领域：Web网站和各种网络服务（YouTube、Instagram、douban、openstack）；系统工具和脚本；作为“胶水”语言把其它语言开发的模块包装起来方便使用。</p>
<p>优点是显著的，但是也少不了缺点。Python不适用的领域：贴近硬件的代码（首选C）；移动开发（iOS／Android都有各自的开发语言）；因为不能做到告诉渲染，所以不适合游戏开发（首选C／C++）。</p>
<a id="more"></a>
<h2 id="Python和其它语言对比"><a href="#Python和其它语言对比" class="headerlink" title="Python和其它语言对比"></a>Python和其它语言对比</h2><table>
<thead>
<tr>
<th>语言</th>
<th>类型</th>
<th>运行速度</th>
<th>代码量</th>
</tr>
</thead>
<tbody>
<tr>
<td>C</td>
<td>编译为机器码</td>
<td>非常快</td>
<td>非常多</td>
</tr>
<tr>
<td>Java</td>
<td>编译为字节码</td>
<td>快</td>
<td>多</td>
</tr>
<tr>
<td>Python</td>
<td>解释执行</td>
<td>慢</td>
<td>少</td>
</tr>
</tbody>
</table>
<p>CPU越来越快，程序的运行速度瓶颈往往不在Python的执行，更多受到网络速度和硬盘速度的制约。</p>
<p>另外，Python发布程序即发布源代码。</p>
<h2 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h2><p>前往<a href="http://www.python.org" target="_blank" rel="external">官网下载</a>对应平台对应工具。另外Python2.7版本和3.3版本并不兼容，所以开发时请注意使用Python的版本。</p>
<p>作为Mac OS X使用者，其实更推荐<a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="external">PyCharm IDE</a>。安装之后直接使用即可。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：</p>
<h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>Python可以处理任意大小的整数，当然包括负整数，在Python程序中，整数的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。</p>
<p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10^9 和 12.3x10^8 是相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9 就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。</p>
<p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是以’’或””括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来。</p>
<p>布尔值可以用and、or和not运算。</p>
<p>and运算是与运算，只有所有都为 True，and运算结果才是 True。</p>
<p>or运算是或运算，只要其中有一个为 True，or 运算结果就是 True。</p>
<p>not运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。</p>
<h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p>
<p>此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型。</p>
<h2 id="print-语句"><a href="#print-语句" class="headerlink" title="print 语句"></a>print 语句</h2><p>print语句可以向屏幕上输出指定的文字。比如输出’hello, world’，用代码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print &apos;hello, world&apos;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>1.当我们在Python交互式环境下编写代码时，&gt;&gt;&gt;是Python解释器的提示符，不是代码的一部分。</p>
<p>2.当我们在文本编辑器中编写代码时，千万不要自己添加 &gt;&gt;&gt;。</p>
<p>print语句也可以跟上多个字符串，用逗号“,”隔开，就可以连成一串输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print &apos;The quick brown fox&apos;, &apos;jumps over&apos;, &apos;the lazy dog&apos;</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br></pre></td></tr></table></figure>
<p>print会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的：</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/python-basic-knowledge-1.jpg" alt="print解释图"></p>
<p>print也可以打印整数，或者计算结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print 300</span><br><span class="line">300    #运行结果</span><br><span class="line">&gt;&gt;&gt; print 100 + 200</span><br><span class="line">300    #运行结果</span><br></pre></td></tr></table></figure>
<p>因此，我们可以把计算100 + 200的结果打印得更漂亮一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print &apos;100 + 200 =&apos;, 100 + 200</span><br><span class="line">100 + 200 = 300     #运行结果</span><br></pre></td></tr></table></figure>
<p>注意: 对于100 + 200，Python解释器自动计算出结果300，但是，’100 + 200 =’是字符串而非数学公式，Python把它视为字符串，请自行解释上述打印结果。</p>
<h2 id="Python的注释"><a href="#Python的注释" class="headerlink" title="Python的注释"></a>Python的注释</h2><p>任何时候，我们都可以给程序加上注释。注释是用来说明代码的，给自己或别人看，而程序运行的时候，Python解释器会直接忽略掉注释，所以，有没有注释不影响程序的执行结果，但是影响到别人能不能看懂你的代码。</p>
<p>Python的注释以<code>#</code>开头，后面的文字直到行尾都算注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这一行全部都是注释...</span><br><span class="line">print &apos;hello&apos; # 这也是注释</span><br></pre></td></tr></table></figure>
<p>注释还有一个巧妙的用途，就是一些代码我们不想运行，但又不想删除，就可以用注释暂时屏蔽掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 暂时不想运行下面一行代码:</span><br><span class="line"># print &apos;hello, python.&apos;</span><br></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在Python中，变量的概念基本上和初中代数的方程变量是一致的。</p>
<p>例如，对于方程式<code>y=x*x</code>，x就是变量。当<code>x=2</code>时，计算结果是4，当<code>x=5</code>时，计算结果是25。</p>
<p>只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p>
<p>在Python程序中，变量是用一个变量名表示，变量名必须是<strong>大小写英文、数字和下划线（_）的组合，且不能用数字开头</strong>，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 1</span><br></pre></td></tr></table></figure>
<p>变量<code>a</code>是一个整数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_007 = &apos;T007&apos;</span><br></pre></td></tr></table></figure>
<p>变量<code>t_007</code>是一个字符串。</p>
<p>在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 123    # a是整数</span><br><span class="line">print a</span><br><span class="line">a = &apos;Chars&apos;   # a变为字符串</span><br><span class="line">print a</span><br></pre></td></tr></table></figure>
<p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。</p>
<p>静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 123; // a是整数类型变量</span><br><span class="line">a = &quot;Chars&quot;; // 错误：不能把字符串赋给整型变量</span><br></pre></td></tr></table></figure>
<p>和静态语言相比，动态语言更灵活，就是这个原因。</p>
<p>请不要把赋值语句的等号等同于数学的等号。比如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = 10</span><br><span class="line">x = x + 2</span><br></pre></td></tr></table></figure>
<p>如果从数学上理解<code>x = x + 2</code>那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式<code>x + 2</code>，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。</p>
<p>最后，理解变量在计算机内存中的表示也非常重要。当我们写：<code>a = &#39;ABC&#39;</code>时，Python解释器干了两件事情：</p>
<ol>
<li><p>在内存中创建了一个’ABC’的字符串；</p>
</li>
<li><p>在内存中创建了一个名为a的变量，并把它指向’ABC’。</p>
</li>
</ol>
<p>也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &apos;ABC&apos;</span><br><span class="line">b = a</span><br><span class="line">a = &apos;XYZ&apos;</span><br><span class="line">print b</span><br></pre></td></tr></table></figure>
<p>最后一行打印出变量b的内容到底是<code>&#39;ABC&#39;</code>呢还是<code>&#39;XYZ&#39;</code>？如果从数学意义上理解，就会错误地得出b和a相同，也应该是<code>&#39;XYZ&#39;</code>，但实际上b的值是<code>&#39;ABC&#39;</code>，让我们一行一行地执行代码，就可以看到到底发生了什么事：</p>
<p>执行<code>a = &#39;ABC&#39;</code>，解释器创建了字符串<code>&#39;ABC&#39;</code>和变量<code>a</code>，并把a指向<code>&#39;ABC&#39;</code>：</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/python-basic-knowledge-2.jpg" alt="变量图1"></p>
<p>执行<code>b = a</code>，解释器创建了变量 b，并把b指向 a 指向的字符串<code>&#39;ABC&#39;</code>：</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/python-basic-knowledge-3.jpg" alt="变量图2"></p>
<p>执行<code>a = &#39;XYZ&#39;</code>，解释器创建了字符串<code>&#39;XYZ&#39;</code>，并把a的指向改为<code>&#39;XYZ&#39;</code>，但b并没有更改：</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/python-basic-knowledge-4.jpg" alt="变量图3"></p>
<p>所以，最后打印变量b的结果自然是<code>&#39;ABC&#39;</code>了。</p>
<h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><h3 id="定义字符串"><a href="#定义字符串" class="headerlink" title="定义字符串"></a>定义字符串</h3><p>前面我们讲解了什么是字符串。字符串可以用<code>&#39;&#39;</code>或者<code>&quot;&quot;</code>括起来表示。</p>
<p>如果字符串本身包含’怎么办？比如我们要表示字符串 <code>I&#39;m OK</code>，这时，可以用<code>&quot; &quot;</code>括起来表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;I&apos;m OK&quot;</span><br></pre></td></tr></table></figure>
<p>类似的，如果字符串包含”，我们就可以用’ ‘括起来表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;Learn &quot;Python&quot; in Chars&apos;s Blog&apos;</span><br></pre></td></tr></table></figure>
<p>如果字符串既包含’又包含”怎么办？</p>
<p>这个时候，就需要对字符串的某些特殊字符进行“转义”，Python字符串用<code>\</code>进行转义。</p>
<p>要表示字符串 <code>Bob said &quot;I&#39;m OK&quot;</code>.<br>由于 ‘ 和 “ 会引起歧义，因此，我们在它前面插入一个<code>\</code>表示这是一个普通字符，不代表字符串的起始，因此，这个字符串又可以表示为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;Bob said \&quot;I\&apos;m OK\&quot;.&apos;</span><br></pre></td></tr></table></figure>
<p>注意：转义字符 \ 不计入字符串的内容中。</p>
<p>常用的转义字符还有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\n 表示换行</span><br><span class="line">\t 表示一个制表符</span><br><span class="line">\\ 表示 \ 字符本身</span><br></pre></td></tr></table></figure>
<h3 id="raw字符串与多行字符串"><a href="#raw字符串与多行字符串" class="headerlink" title="raw字符串与多行字符串"></a>raw字符串与多行字符串</h3><p>如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀<code>r</code>，表示这是一个 raw 字符串，里面的字符就不需要转义了。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r&apos;\(~_~)/ \(~_~)/&apos;</span><br></pre></td></tr></table></figure>
<p>但是<code>r&#39;...&#39;</code>表示法不能表示多行字符串，也不能表示包含<code>&#39;</code>和 <code>&quot;</code>的字符串（为什么？）</p>
<p>如果要表示多行字符串，可以用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;&apos;Line 1</span><br><span class="line">Line 2</span><br><span class="line">Line 3&apos;&apos;&apos;</span><br></pre></td></tr></table></figure>
<p>上面这个字符串的表示方法和下面的是完全一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;Line 1\nLine 2\nLine 3&apos;</span><br></pre></td></tr></table></figure>
<p>还可以在多行字符串前面添加<code>r</code>，把这个多行字符串也变成一个raw字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r&apos;&apos;&apos;Python is created by &quot;Guido&quot;.</span><br><span class="line">It is free and easy to learn.</span><br><span class="line">Let&apos;s start learn Python in Chars&apos;s Blog!&apos;&apos;&apos;</span><br></pre></td></tr></table></figure>
<h3 id="Unicode字符串"><a href="#Unicode字符串" class="headerlink" title="Unicode字符串"></a>Unicode字符串</h3><p>字符串还有一个编码问题。</p>
<p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），0 - 255被用来表示大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母 A 的编码是65，小写字母 z 的编码是122。</p>
<p>如果要表示中文，显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。</p>
<p>类似的，日文和韩文等其他语言也有这个问题。为了统一所有文字的编码，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p>
<p>Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。</p>
<p>因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码，普通的字符串’ABC’在Python内部都是ASCII编码的。</p>
<p>Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u’…’表示，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print u&apos;中文&apos;</span><br><span class="line">中文</span><br></pre></td></tr></table></figure>
<p>注意: 不加 u ，中文就不能正常显示。</p>
<p>Unicode字符串除了多了一个 u 之外，与普通字符串没啥区别，转义字符和多行表示法仍然有效：</p>
<p>转义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u&apos;中文\n日文\n韩文&apos;</span><br></pre></td></tr></table></figure>
<p>多行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u&apos;&apos;&apos;第一行</span><br><span class="line">第二行&apos;&apos;&apos;</span><br></pre></td></tr></table></figure>
<p>raw+多行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ur&apos;&apos;&apos;Python的Unicode字符串支持&quot;中文&quot;,</span><br><span class="line">&quot;日文&quot;,</span><br><span class="line">&quot;韩文&quot;等多种语言&apos;&apos;&apos;</span><br></pre></td></tr></table></figure>
<p>如果中文字符串在Python环境下遇到<code>UnicodeDecodeError</code>，这是因为.py文件保存的格式有问题。可以在第一行添加注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure>
<p>目的是告诉Python解释器，用UTF-8编码读取源代码。然后用Notepad++ 另存为… 并选择UTF-8格式保存。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="创建list"><a href="#创建list" class="headerlink" title="创建list"></a>创建list</h3><p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</p>
<p>比如，列出班里所有同学的名字，就可以用一个list表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure>
<p>list是数学意义上的有序集合，也就是说，list中的元素是按照顺序排列的。</p>
<p>构造list非常简单，按照上面的代码，直接用 [ ] 把list的所有元素都括起来，就是一个list对象。通常，我们会把list赋值给一个变量，这样，就可以通过变量来引用list：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line">&gt;&gt;&gt; classmates # 打印classmates变量的内容</span><br><span class="line">[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure>
<p>由于Python是动态语言，所以list中包含的元素并不要求都必须是同一种数据类型，我们完全可以在list中包含各种数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Michael&apos;, 100, True]</span><br></pre></td></tr></table></figure>
<p>一个元素也没有的list，就是空list：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; empty_list = []</span><br></pre></td></tr></table></figure>
<h3 id="按照索引访问list"><a href="#按照索引访问list" class="headerlink" title="按照索引访问list"></a>按照索引访问list</h3><p>由于list是一个有序集合，所以，我们可以用一个list按分数从高到低表示出班里的3个同学：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</span><br></pre></td></tr></table></figure>
<p>那我们如何从list中获取指定第 N 名的同学呢？方法是通过索引来获取list中的指定元素。</p>
<p>需要特别注意的是，索引从 0 开始，也就是说，第一个元素的索引是0，第二个元素的索引是1，以此类推。</p>
<p>因此，要打印第一名同学的名字，用 L[0]:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print L[0]</span><br><span class="line">Adam</span><br></pre></td></tr></table></figure>
<p>要打印第二名同学的名字，用 L[1]:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print L[1]</span><br><span class="line">Lisa</span><br></pre></td></tr></table></figure>
<p>要打印第三名同学的名字，用 L[2]:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print L[2]</span><br><span class="line">Bart</span><br></pre></td></tr></table></figure>
<p>要打印第四名同学的名字，用 L[3]:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print L[3]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure>
<p>报错了！IndexError意思就是索引超出了范围，因为上面的list只有3个元素，有效的索引是 0，1，2。</p>
<p>所以，使用索引时，<strong>千万注意不要越界</strong>。</p>
<h3 id="倒序访问list"><a href="#倒序访问list" class="headerlink" title="倒序访问list"></a>倒序访问list</h3><p>我们还是用一个list按分数从高到低表示出班里的3个同学：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</span><br></pre></td></tr></table></figure>
<p>这时，老师说，请分数最低的同学站出来。</p>
<p>要写代码完成这个任务，我们可以先数一数这个 list，发现它包含3个元素，因此，最后一个元素的索引是2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print L[2]</span><br><span class="line">Bart</span><br></pre></td></tr></table></figure>
<p>有没有更简单的方法？有！</p>
<p>Bart同学是最后一名，俗称倒数第一，所以，我们可以用 -1 这个索引来表示最后一个元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print L[-1]</span><br><span class="line">Bart</span><br></pre></td></tr></table></figure>
<p>Bart同学表示躺枪。</p>
<p>类似的，倒数第二用 -2 表示，倒数第三用 -3 表示，倒数第四用 -4 表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print L[-2]</span><br><span class="line">Lisa</span><br><span class="line">&gt;&gt;&gt; print L[-3]</span><br><span class="line">Adam</span><br><span class="line">&gt;&gt;&gt; print L[-4]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure>
<p>L[-4] 报错了，因为倒数第四不存在，一共只有3个元素。</p>
<p>使用倒序索引时，也要<strong>注意不要越界</strong>。</p>
<h3 id="添加新元素"><a href="#添加新元素" class="headerlink" title="添加新元素"></a>添加新元素</h3><p>现在，班里有3名同学：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</span><br></pre></td></tr></table></figure>
<p>今天，班里转来一名新同学 Paul，如何把新同学添加到现有的 list 中呢？</p>
<p>第一个办法是用 list 的 append() 方法，把新同学追加到 list 的末尾：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</span><br><span class="line">&gt;&gt;&gt; L.append(&apos;Paul&apos;)</span><br><span class="line">&gt;&gt;&gt; print L</span><br><span class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]</span><br></pre></td></tr></table></figure>
<p>append()总是把新的元素添加到 list 的尾部。</p>
<p>如果 Paul 同学表示自己总是考满分，要求添加到第一的位置，怎么办？</p>
<p>方法是用list的 insert()方法，它接受两个参数，第一个参数是索引号，第二个参数是待添加的新元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</span><br><span class="line">&gt;&gt;&gt; L.insert(0, &apos;Paul&apos;)</span><br><span class="line">&gt;&gt;&gt; print L</span><br><span class="line">[&apos;Paul&apos;, &apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</span><br></pre></td></tr></table></figure>
<p>L.insert(0, ‘Paul’) 的意思是，’Paul’将被添加到索引为 0 的位置上（也就是第一个），而原来索引为 0 的Adam同学，以及后面的所有同学，都自动向后移动一位。</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>Paul同学刚来几天又要转走了，那么我们怎么把Paul 从现有的list中删除呢？</p>
<p>如果Paul同学排在最后一个，我们可以用list的pop()方法删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]</span><br><span class="line">&gt;&gt;&gt; L.pop()</span><br><span class="line">&apos;Paul&apos;</span><br><span class="line">&gt;&gt;&gt; print L</span><br><span class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</span><br></pre></td></tr></table></figure>
<p>pop()方法总是删掉list的最后一个元素，并且它还返回这个元素，所以我们执行 L.pop() 后，会打印出 ‘Paul’。</p>
<p>如果Paul同学不是排在最后一个怎么办？比如Paul同学排在第三：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;, &apos;Bart&apos;]</span><br></pre></td></tr></table></figure>
<p>要把Paul踢出list，我们就必须先定位Paul的位置。由于Paul的索引是2，因此，用 pop(2)把Paul删掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L.pop(2)</span><br><span class="line">&apos;Paul&apos;</span><br><span class="line">&gt;&gt;&gt; print L</span><br><span class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</span><br></pre></td></tr></table></figure>
<h3 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h3><p>假设现在班里仍然是3名同学：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</span><br></pre></td></tr></table></figure>
<p>现在，Bart同学要转学走了，碰巧来了一个Paul同学，要更新班级成员名单，我们可以先把Bart删掉，再把Paul添加进来。</p>
<p>另一个办法是直接用Paul把Bart给替换掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[2] = &apos;Paul&apos;</span><br><span class="line">&gt;&gt;&gt; print L</span><br><span class="line">L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;]</span><br></pre></td></tr></table></figure>
<p>对list中的某一个索引赋值，就可以直接用新的元素替换掉原来的元素，list包含的元素个数保持不变。</p>
<p>由于Bart还可以用 -1 做索引，因此，下面的代码也可以完成同样的替换工作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[-1] = &apos;Paul&apos;</span><br></pre></td></tr></table></figure>
<h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><h3 id="创建tuple"><a href="#创建tuple" class="headerlink" title="创建tuple"></a>创建tuple</h3><p>tuple是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，但是，tuple一旦创建完毕，就不能修改了。</p>
<p>同样是表示班里同学的名称，用tuple表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;)</span><br></pre></td></tr></table></figure>
<p>创建tuple和创建list唯一不同之处是用( )替代了[ ]。</p>
<p>现在，这个 t 就不能改变了，tuple没有 append()方法，也没有insert()和pop()方法。所以，新同学没法直接往 tuple 中添加，老同学想退出 tuple 也不行。</p>
<p>获取 tuple 元素的方式和 list 是一模一样的，我们可以正常使用 t[0]，t[-1]等索引方式访问元素，但是不能赋值成别的元素，不信可以试试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t[0] = &apos;Paul&apos;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &apos;tuple&apos; object does not support item assignment</span><br></pre></td></tr></table></figure>
<h3 id="创建单元素tuple"><a href="#创建单元素tuple" class="headerlink" title="创建单元素tuple"></a>创建单元素tuple</h3><p>tuple和list一样，可以包含 0 个、1个和任意多个元素。</p>
<p>包含多个元素的 tuple，前面我们已经创建过了。</p>
<p>包含 0 个元素的 tuple，也就是空tuple，直接用 ()表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = ()</span><br><span class="line">&gt;&gt;&gt; print t</span><br><span class="line">()</span><br></pre></td></tr></table></figure>
<p>创建包含1个元素的 tuple 呢？来试试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1)</span><br><span class="line">&gt;&gt;&gt; print t</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>好像哪里不对！t 不是 tuple ，而是整数1。为什么呢？</p>
<p>因为()既可以表示tuple，又可以作为括号表示运算时的优先级，结果 (1) 被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。</p>
<p>正是因为用()定义单元素的tuple有歧义，所以 Python 规定，单元素 tuple 要多加一个逗号“,”，这样就避免了歧义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1,)</span><br><span class="line">&gt;&gt;&gt; print t</span><br><span class="line">(1,)</span><br></pre></td></tr></table></figure>
<h3 id="可变的tuple"><a href="#可变的tuple" class="headerlink" title="可变的tuple"></a>可变的tuple</h3><p>前面我们看到了tuple一旦创建就不能修改。现在，我们来看一个“可变”的tuple：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;, [&apos;A&apos;, &apos;B&apos;])</span><br></pre></td></tr></table></figure>
<p>注意到 t 有 3 个元素：’a’，’b’和一个list：[‘A’, ‘B’]。list作为一个整体是tuple的第3个元素。list对象可以通过 t[2] 拿到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = t[2]</span><br></pre></td></tr></table></figure>
<p>然后，我们把list的两个元素改一改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[0] = &apos;X&apos;</span><br><span class="line">&gt;&gt;&gt; L[1] = &apos;Y&apos;</span><br></pre></td></tr></table></figure>
<p>再看看tuple的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print t</span><br><span class="line">(&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;])</span><br></pre></td></tr></table></figure>
<p>不是说tuple一旦定义后就不可变了吗？怎么现在又变了？</p>
<p>别急，我们先看看定义的时候tuple包含的3个元素：</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/python-basic-knowledge-5.jpg" alt="tuple图1"></p>
<p>当我们把list的元素’A’和’B’修改为’X’和’Y’后，tuple变为：</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/python-basic-knowledge-6.jpg" alt="tuple图2"></p>
<p>表面上看，tuple的元素确实变了，但其实变的不是 tuple 的元素，而是list的元素。</p>
<p>tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p>
<p>理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。</p>
<h2 id="条件判断和循环"><a href="#条件判断和循环" class="headerlink" title="条件判断和循环"></a>条件判断和循环</h2><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。</p>
<h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，可以用if语句实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age = 20</span><br><span class="line">if age &gt;= 18:</span><br><span class="line">    print &apos;your age is&apos;, age</span><br><span class="line">    print &apos;adult&apos;</span><br><span class="line">print &apos;END&apos;</span><br></pre></td></tr></table></figure>
<p>注意: Python代码的缩进规则。具有相同缩进的代码被视为代码块，上面的3，4行 print 语句就构成一个代码块（但不包括第5行的print）。如果 if 语句判断为 True，就会执行这个代码块。</p>
<p>缩进请严格按照Python的习惯写法：4个空格，不要使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。</p>
<p>注意: if 语句后接表达式，然后用:表示代码块开始。</p>
<p>如果你在Python交互环境下敲代码，还要特别留意缩进，并且退出缩进需要多敲一行回车：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; age = 20</span><br><span class="line">&gt;&gt;&gt; if age &gt;= 18:</span><br><span class="line">...     print &apos;your age is&apos;, age</span><br><span class="line">...     print &apos;adult&apos;</span><br><span class="line">...</span><br><span class="line">your age is 20</span><br><span class="line">adult</span><br></pre></td></tr></table></figure>
<h4 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h4><p>当 if 语句判断表达式的结果为 True 时，就会执行 if 包含的代码块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if age &gt;= 18:</span><br><span class="line">    print &apos;adult&apos;</span><br></pre></td></tr></table></figure>
<p>如果我们想判断年龄在18岁以下时，打印出 ‘teenager’，怎么办？</p>
<p>方法是再写一个 if:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if age &lt; 18:</span><br><span class="line">    print &apos;teenager&apos;</span><br></pre></td></tr></table></figure>
<p>或者用 not 运算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if not age &gt;= 18:</span><br><span class="line">    print &apos;teenager&apos;</span><br></pre></td></tr></table></figure>
<p>细心的读者可以发现，这两种条件判断是“非此即彼”的，要么符合条件1，要么符合条件2，因此，完全可以用一个 <code>if ... else ...</code>语句把它们统一起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if age &gt;= 18:</span><br><span class="line">    print &apos;adult&apos;</span><br><span class="line">else:</span><br><span class="line">    print &apos;teenager&apos;</span><br></pre></td></tr></table></figure>
<p>利用<code>if ... else ...</code>语句，我们可以根据条件表达式的值为 True 或者 False ，分别执行 if 代码块或者 else 代码块。</p>
<p>注意: else 后面有个“:”。</p>
<h4 id="if-elif-else语句"><a href="#if-elif-else语句" class="headerlink" title="if-elif-else语句"></a>if-elif-else语句</h4><p>有的时候，一个<code>if ... else ...</code>还不够用。比如，根据年龄的划分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">条件1：18岁或以上：adult</span><br><span class="line">条件2：6岁或以上：teenager</span><br><span class="line">条件3：6岁以下：kid</span><br></pre></td></tr></table></figure>
<p>我们可以用一个 if age &gt;= 18 判断是否符合条件1，如果不符合，再通过一个 if 判断 age &gt;= 6 来判断是否符合条件2，否则，执行条件3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if age &gt;= 18:</span><br><span class="line">    print &apos;adult&apos;</span><br><span class="line">else:</span><br><span class="line">    if age &gt;= 6:</span><br><span class="line">        print &apos;teenager&apos;</span><br><span class="line">    else:</span><br><span class="line">        print &apos;kid&apos;</span><br></pre></td></tr></table></figure>
<p>这样写出来，我们就得到了一个两层嵌套的<code>if ... else ...</code>语句。这个逻辑没有问题，但是，如果继续增加条件，比如3岁以下是 baby：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if age &gt;= 18:</span><br><span class="line">    print &apos;adult&apos;</span><br><span class="line">else:</span><br><span class="line">    if age &gt;= 6:</span><br><span class="line">        print &apos;teenager&apos;</span><br><span class="line">    else:</span><br><span class="line">        if age &gt;= 3:</span><br><span class="line">            print &apos;kid&apos;</span><br><span class="line">        else:</span><br><span class="line">            print &apos;baby&apos;</span><br></pre></td></tr></table></figure>
<p>这种缩进只会越来越多，代码也会越来越难看。</p>
<p>要避免嵌套结构的<code>if ... else ...</code>，我们可以用<code>if ...</code>多个<code>elif ... else ...</code>的结构，一次写完所有的规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if age &gt;= 18:</span><br><span class="line">    print &apos;adult&apos;</span><br><span class="line">elif age &gt;= 6:</span><br><span class="line">    print &apos;teenager&apos;</span><br><span class="line">elif age &gt;= 3:</span><br><span class="line">    print &apos;kid&apos;</span><br><span class="line">else:</span><br><span class="line">    print &apos;baby&apos;</span><br></pre></td></tr></table></figure>
<p>elif 意思就是 else if。这样一来，我们就写出了结构非常清晰的一系列条件判断。</p>
<p>特别注意: 这一系列条件判断会从上到下依次判断，如果某个判断为 True，执行完对应的代码块，后面的条件判断就直接忽略，不再执行了。</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>list或tuple可以表示一个有序集合。如果我们想依次访问一个list中的每一个元素呢？比如 list：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</span><br><span class="line">print L[0]</span><br><span class="line">print L[1]</span><br><span class="line">print L[2]</span><br></pre></td></tr></table></figure>
<p>如果list只包含几个元素，这样写还行，如果list包含1万个元素，我们就不可能写1万行print。</p>
<p>这时，循环就派上用场了。</p>
<p>Python的 for 循环就可以依次把list或tuple的每个元素迭代出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</span><br><span class="line">for name in L:</span><br><span class="line">    print name</span><br></pre></td></tr></table></figure>
<p>注意:  name 这个变量是在 for 循环中定义的，意思是，依次取出list中的每一个元素，并把元素赋值给 name，然后执行for循环体（就是缩进的代码块）。</p>
<p>这样一来，遍历一个list或tuple就非常容易了。</p>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>和 for 循环不同的另一种循环是 while 循环，while 循环不会迭代 list 或 tuple 的元素，而是根据表达式判断循环是否结束。</p>
<p>比如要从 0 开始打印不大于 N 的整数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">N = 10</span><br><span class="line">x = 0</span><br><span class="line">while x &lt; N:</span><br><span class="line">    print x</span><br><span class="line">    x = x + 1</span><br></pre></td></tr></table></figure>
<p>while循环每次先判断 x &lt; N，如果为True，则执行循环体的代码块，否则，退出循环。</p>
<p>在循环体内，x = x + 1 会让 x 不断增加，最终因为 x &lt; N 不成立而退出循环。</p>
<p>如果没有这一个语句，while循环在判断 x &lt; N 时总是为True，就会无限循环下去，变成死循环，所以要特别留意while循环的退出条件。</p>
<h4 id="break退出循环"><a href="#break退出循环" class="headerlink" title="break退出循环"></a>break退出循环</h4><p>用 for 循环或者 while 循环时，如果要在循环体内直接退出循环，可以使用 break 语句。</p>
<p>比如计算1至100的整数和，我们用while来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">x = 1</span><br><span class="line">while True:</span><br><span class="line">    sum = sum + x</span><br><span class="line">    x = x + 1</span><br><span class="line">    if x &gt; 100:</span><br><span class="line">        break</span><br><span class="line">print sum</span><br></pre></td></tr></table></figure>
<p>咋一看， while True 就是一个死循环，但是在循环体内，我们还判断了 x &gt; 100 条件成立时，用break语句退出循环，这样也可以实现循环的结束。</p>
<h4 id="continue继续循环"><a href="#continue继续循环" class="headerlink" title="continue继续循环"></a>continue继续循环</h4><p>在循环过程中，可以用break退出当前循环，还可以用continue跳过后续循环代码，继续下一次循环。</p>
<p>假设我们已经写好了利用for循环计算平均分的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">L = [75, 98, 59, 81, 66, 43, 69, 85]</span><br><span class="line">sum = 0.0</span><br><span class="line">n = 0</span><br><span class="line">for x in L:</span><br><span class="line">    sum = sum + x</span><br><span class="line">    n = n + 1</span><br><span class="line">print sum / n</span><br></pre></td></tr></table></figure>
<p>现在老师只想统计及格分数的平均分，就要把 x &lt; 60 的分数剔除掉，这时，利用 continue，可以做到当 x &lt; 60的时候，不继续执行循环体的后续代码，直接进入下一次循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for x in L:</span><br><span class="line">    if x &lt; 60:</span><br><span class="line">        continue</span><br><span class="line">    sum = sum + x</span><br><span class="line">    n = n + 1</span><br></pre></td></tr></table></figure>
<h4 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h4><p>在循环内部，还可以嵌套循环，我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for x in [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]:</span><br><span class="line">    for y in [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]:</span><br><span class="line">        print x + y</span><br></pre></td></tr></table></figure>
<p>x 每循环一次，y 就会循环 3 次。</p>
<h2 id="Dict类型"><a href="#Dict类型" class="headerlink" title="Dict类型"></a>Dict类型</h2><p>我们已经知道，list 和 tuple 可以用来表示顺序集合，例如，班里同学的名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</span><br></pre></td></tr></table></figure>
<p>或者考试的成绩列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[95, 85, 59]</span><br></pre></td></tr></table></figure>
<p>但是，要根据名字找到对应的成绩，用两个 list 表示就不方便。</p>
<p>如果把名字和分数关联起来，组成类似的查找表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;Adam&apos; ==&gt; 95</span><br><span class="line">&apos;Lisa&apos; ==&gt; 85</span><br><span class="line">&apos;Bart&apos; ==&gt; 59</span><br></pre></td></tr></table></figure>
<p>给定一个名字，就可以直接查到分数。</p>
<p>Python的 dict 就是专门干这件事的。用 dict 表示“名字”-“成绩”的查找表如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    &apos;Adam&apos;: 95,</span><br><span class="line">    &apos;Lisa&apos;: 85,</span><br><span class="line">    &apos;Bart&apos;: 59</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把名字称为key，对应的成绩称为value，dict就是通过 key 来查找 value。</p>
<p>花括号 {} 表示这是一个dict，然后按照 key: value, 写出来即可。最后一个 key: value 的逗号可以省略。</p>
<p>由于dict也是集合，len() 函数可以计算任意集合的大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(d)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>注意: 一个 key-value 算一个，因此，dict大小为3。</p>
<h3 id="访问Dict"><a href="#访问Dict" class="headerlink" title="访问Dict"></a>访问Dict</h3><p>我们已经能创建一个dict，用于表示名字和成绩的对应关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    &apos;Adam&apos;: 95,</span><br><span class="line">    &apos;Lisa&apos;: 85,</span><br><span class="line">    &apos;Bart&apos;: 59</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，如何根据名字来查找对应的成绩呢？</p>
<p>可以简单地使用 d[key] 的形式来查找对应的 value，这和 list 很像，不同之处是，list 必须使用索引返回对应的元素，而dict使用key：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print d[&apos;Adam&apos;]</span><br><span class="line">95</span><br><span class="line">&gt;&gt;&gt; print d[&apos;Paul&apos;]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;index.py&quot;, line 11, in &lt;module&gt;</span><br><span class="line">    print d[&apos;Paul&apos;]</span><br><span class="line">KeyError: &apos;Paul&apos;</span><br></pre></td></tr></table></figure>
<p>注意: 通过 key 访问 dict 的value，只要 key 存在，dict就返回对应的value。如果key不存在，会直接报错：KeyError。</p>
<p>要避免 KeyError 发生，有两个办法：</p>
<p>一是先判断一下 key 是否存在，用 in 操作符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if &apos;Paul&apos; in d:</span><br><span class="line">    print d[&apos;Paul&apos;]</span><br></pre></td></tr></table></figure>
<p>如果 ‘Paul’ 不存在，if语句判断为False，自然不会执行 print d[‘Paul’] ，从而避免了错误。</p>
<p>二是使用dict本身提供的一个 get 方法，在Key不存在的时候，返回None：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print d.get(&apos;Bart&apos;)</span><br><span class="line">59</span><br><span class="line">&gt;&gt;&gt; print d.get(&apos;Paul&apos;)</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<h3 id="Dict特点"><a href="#Dict特点" class="headerlink" title="Dict特点"></a>Dict特点</h3><p>dict的第一个特点是查找速度快，无论dict有10个元素还是10万个元素，查找速度都一样。而list的查找速度随着元素增加而逐渐下降。</p>
<p>不过dict的查找速度快不是没有代价的，dict的缺点是占用内存大，还会浪费很多内容，list正好相反，占用内存小，但是查找速度慢。</p>
<p>由于dict是按 key 查找，所以，在一个dict中，key不能重复。</p>
<p>dict的第二个特点就是存储的key-value序对是没有顺序的！这和list不一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    &apos;Adam&apos;: 95,</span><br><span class="line">    &apos;Lisa&apos;: 85,</span><br><span class="line">    &apos;Bart&apos;: 59</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们试图打印这个dict时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print d</span><br><span class="line">&#123;&apos;Lisa&apos;: 85, &apos;Adam&apos;: 95, &apos;Bart&apos;: 59&#125;</span><br></pre></td></tr></table></figure>
<p>打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同，这说明dict内部是无序的，不能用dict存储有序的集合。</p>
<p>dict的第三个特点是作为 key 的元素必须不可变，Python的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。但是list是可变的，就不能作为 key。</p>
<p>可以试试用list作为key时会报什么样的错误。</p>
<p>不可变这个限制仅作用于key，value是否可变无所谓：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &apos;123&apos;: [1, 2, 3],  # key 是 str，value是list</span><br><span class="line">    123: &apos;123&apos;,  # key 是 int，value 是 str</span><br><span class="line">    (&apos;a&apos;, &apos;b&apos;): True  # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最常用的key还是字符串，因为用起来最方便。</p>
<h3 id="更新Dict"><a href="#更新Dict" class="headerlink" title="更新Dict"></a>更新Dict</h3><p>dict是可变的，也就是说，我们可以随时往dict中添加新的 key-value。比如已有dict：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    &apos;Adam&apos;: 95,</span><br><span class="line">    &apos;Lisa&apos;: 85,</span><br><span class="line">    &apos;Bart&apos;: 59</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要把新同学’Paul’的成绩 72 加进去，用赋值语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&apos;Paul&apos;] = 72</span><br></pre></td></tr></table></figure>
<p>再看看dict的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print d</span><br><span class="line">&#123;&apos;Lisa&apos;: 85, &apos;Paul&apos;: 72, &apos;Adam&apos;: 95, &apos;Bart&apos;: 59&#125;</span><br></pre></td></tr></table></figure>
<p>如果 key 已经存在，则赋值会用新的 value 替换掉原来的 value：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&apos;Bart&apos;] = 60</span><br><span class="line">&gt;&gt;&gt; print d</span><br><span class="line">&#123;&apos;Lisa&apos;: 85, &apos;Paul&apos;: 72, &apos;Adam&apos;: 95, &apos;Bart&apos;: 60&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历Dict"><a href="#遍历Dict" class="headerlink" title="遍历Dict"></a>遍历Dict</h3><p>由于dict也是一个集合，所以，遍历dict和遍历list类似，都可以通过 for 循环实现。</p>
<p>直接使用for循环可以遍历 dict 的 key：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;</span><br><span class="line">&gt;&gt;&gt; for key in d:</span><br><span class="line">...     print key</span><br><span class="line">... </span><br><span class="line">Lisa</span><br><span class="line">Adam</span><br><span class="line">Bart</span><br></pre></td></tr></table></figure>
<p>由于通过 key 可以获取对应的 value，因此，在循环体内，可以获取到value的值。</p>
<h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><p>dict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。</p>
<p>有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set就派上用场了。</p>
<p>set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。</p>
<p>创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;])</span><br></pre></td></tr></table></figure>
<p>可以查看 set 的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print s</span><br><span class="line">set([&apos;A&apos;, &apos;C&apos;, &apos;B&apos;])</span><br></pre></td></tr></table></figure>
<p>请注意，上述打印的形式类似 list， 但它不是 list，仔细看还可以发现，打印的顺序和原始 list 的顺序有可能是不同的，因为set内部存储的元素是无序的。</p>
<p>因为set不能包含重复的元素，所以，当我们传入包含重复元素的 list 会怎么样呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;C&apos;])</span><br><span class="line">&gt;&gt;&gt; print s</span><br><span class="line">set([&apos;A&apos;, &apos;C&apos;, &apos;B&apos;])</span><br><span class="line">&gt;&gt;&gt; len(s)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>结果显示，set会自动去掉重复的元素，原来的list有4个元素，但set只有3个元素。</p>
<h3 id="访问Set"><a href="#访问Set" class="headerlink" title="访问Set"></a>访问Set</h3><p>由于set存储的是无序集合，所以我们没法通过索引来访问。</p>
<p>访问 set中的某个元素实际上就是判断一个元素是否在set中。</p>
<p>例如，存储了班里同学名字的set：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;])</span><br></pre></td></tr></table></figure>
<p>我们可以用 in 操作符判断：</p>
<p>Bart是该班的同学吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Bart&apos; in s</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>Bill是该班的同学吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;Bill&apos; in s</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>bart是该班的同学吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;bart&apos; in s</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>看来大小写很重要，’Bart’ 和 ‘bart’被认为是两个不同的元素。</p>
<h3 id="Set的特点"><a href="#Set的特点" class="headerlink" title="Set的特点"></a>Set的特点</h3><p>set的内部结构和dict很像，唯一区别是不存储value，因此，判断一个元素是否在set中速度很快。</p>
<p>set存储的元素和dict的key类似，必须是不变对象，因此，任何可变对象是不能放入set中的。</p>
<p>最后，set存储的元素也是没有顺序的。</p>
<p>set的这些特点，可以应用在哪些地方呢？</p>
<p>星期一到星期日可以用字符串’MON’, ‘TUE’, … ‘SUN’表示。</p>
<p>假设我们让用户输入星期一至星期日的某天，如何判断用户的输入是否是一个有效的星期呢？</p>
<p>可以用 if 语句判断，但这样做非常繁琐：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = &apos;???&apos; # 用户输入的字符串</span><br><span class="line">if x!= &apos;MON&apos; and x!= &apos;TUE&apos; and x!= &apos;WED&apos; ... and x!= &apos;SUN&apos;:</span><br><span class="line">    print &apos;input error&apos;</span><br><span class="line">else:</span><br><span class="line">    print &apos;input ok&apos;</span><br></pre></td></tr></table></figure>
<p>注意：if 语句中的…表示没有列出的其它星期名称，测试时，请输入完整。</p>
<p>如果事先创建好一个set，包含’MON’ ~ ‘SUN’：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weekdays = set([&apos;MON&apos;, &apos;TUE&apos;, &apos;WED&apos;, &apos;THU&apos;, &apos;FRI&apos;, &apos;SAT&apos;, &apos;SUN&apos;])</span><br></pre></td></tr></table></figure>
<p>再判断输入是否有效，只需要判断该字符串是否在set中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = &apos;???&apos; # 用户输入的字符串</span><br><span class="line">if x in weekdays:</span><br><span class="line">    print &apos;input ok&apos;</span><br><span class="line">else:</span><br><span class="line">    print &apos;input error&apos;</span><br></pre></td></tr></table></figure>
<p>这样一来，代码就简单多了。</p>
<h3 id="遍历Set"><a href="#遍历Set" class="headerlink" title="遍历Set"></a>遍历Set</h3><p>由于 set 也是一个集合，所以，遍历 set 和遍历 list 类似，都可以通过 for 循环实现。</p>
<p>直接使用 for 循环可以遍历 set 的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;])</span><br><span class="line">&gt;&gt;&gt; for name in s:</span><br><span class="line">...     print name</span><br><span class="line">... </span><br><span class="line">Lisa</span><br><span class="line">Adam</span><br><span class="line">Bart</span><br></pre></td></tr></table></figure>
<p>注意: 观察 for 循环在遍历set时，元素的顺序和list的顺序很可能是不同的，而且不同的机器上运行的结果也可能不同。</p>
<h3 id="更新Set"><a href="#更新Set" class="headerlink" title="更新Set"></a>更新Set</h3><p>由于set存储的是一组不重复的无序元素，因此，更新set主要做两件事：</p>
<p>一是把新的元素添加到set中，二是把已有元素从set中删除。</p>
<p>添加元素时，用set的add()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s.add(4)</span><br><span class="line">&gt;&gt;&gt; print s</span><br><span class="line">set([1, 2, 3, 4])</span><br></pre></td></tr></table></figure>
<p>如果添加的元素已经存在于set中，add()不会报错，但是不会加进去了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s.add(3)</span><br><span class="line">&gt;&gt;&gt; print s</span><br><span class="line">set([1, 2, 3])</span><br></pre></td></tr></table></figure>
<p>删除set中的元素时，用set的remove()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; s.remove(4)</span><br><span class="line">&gt;&gt;&gt; print s</span><br><span class="line">set([1, 2, 3])</span><br></pre></td></tr></table></figure>
<p>如果删除的元素不存在set中，remove()会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s.remove(4)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">KeyError: 4</span><br></pre></td></tr></table></figure>
<p>所以用add()可以直接添加，而remove()前需要判断。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>我们知道圆的面积计算公式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S = πr²</span><br></pre></td></tr></table></figure>
<p>当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r1 = 12.34</span><br><span class="line">r2 = 9.08</span><br><span class="line">r3 = 73.1</span><br><span class="line">s1 = 3.14 * r1 * r1</span><br><span class="line">s2 = 3.14 * r2 * r2</span><br><span class="line">s3 = 3.14 * r3 * r3</span><br></pre></td></tr></table></figure>
<p>当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 <em> x </em> x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。</p>
<p>有了函数，我们就不再每次写s = 3.14 <em> x </em> x，而是写成更有意义的函数调用 s = area_of_circle(x)，而函数 area_of_circle 本身只需要写一次，就可以多次调用。</p>
<p>抽象是数学中非常常见的概念。举个例子：</p>
<p>计算数列的和，比如：1 + 2 + 3 + … + 100，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + … + 100记作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">∑n</span><br><span class="line">n=1</span><br></pre></td></tr></table></figure>
<p>这种抽象记法非常强大，因为我们看到∑就可以理解成求和，而不是还原成低级的加法运算。</p>
<p>而且，这种抽象记法是可扩展的，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">∑(n²+1)</span><br><span class="line">n=1</span><br></pre></td></tr></table></figure>
<p>还原成加法运算就变成了：</p>
<p>(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + … + (100 x 100 + 1)<br>可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。</p>
<p>写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。</p>
<p>Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。</p>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>Python内置了很多有用的函数，我们可以直接调用。</p>
<p>要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数 abs，它接收一个参数。</p>
<p>可以直接从Python的官方网站查看文档：<br><a href="http://docs.python.org/2/library/functions.html#abs" target="_blank" rel="external">http://docs.python.org/2/library/functions.html#abs</a><br>也可以在交互式命令行通过 help(abs) 查看abs函数的帮助信息。</p>
<p>调用 abs 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(100)</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; abs(-20)</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; abs(12.34)</span><br><span class="line">12.34</span><br></pre></td></tr></table></figure>
<p>调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(1, 2)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: abs() takes exactly one argument (2 given)</span><br></pre></td></tr></table></figure>
<p>如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(&apos;a&apos;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: bad operand type for abs(): &apos;str&apos;</span><br></pre></td></tr></table></figure>
<p>而比较函数 cmp(x, y) 就需要两个参数，如果 x<y，返回 -1，如果="" x="=y，返回" 0，如果="">y，返回 1：</y，返回></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; cmp(1, 2)</span><br><span class="line">-1</span><br><span class="line">&gt;&gt;&gt; cmp(2, 1)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; cmp(3, 3)</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>Python内置的常用函数还包括数据类型转换函数，比如   int()函数可以把其他数据类型转换为整数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int(&apos;123&apos;)</span><br><span class="line">123</span><br><span class="line">&gt;&gt;&gt; int(12.34)</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<p>str()函数把其他类型转换成 str：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str(123)</span><br><span class="line">&apos;123&apos;</span><br><span class="line">&gt;&gt;&gt; str(1.23)</span><br><span class="line">&apos;1.23&apos;</span><br></pre></td></tr></table></figure>
<h3 id="编写函数"><a href="#编写函数" class="headerlink" title="编写函数"></a>编写函数</h3><p>在Python中，定义一个函数要使用 def 语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用 return 语句返回。</p>
<p>我们以自定义一个求绝对值的 my_abs 函数为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure>
<p>请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。</p>
<p>如果没有return语句，函数执行完毕后也会返回结果，只是结果为 None。</p>
<p>return None可以简写为return。</p>
<h3 id="返回多值"><a href="#返回多值" class="headerlink" title="返回多值"></a>返回多值</h3><p>函数可以返回多个值吗？答案是肯定的。</p>
<p>比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：</p>
<p><code># math</code>包提供了sin()和 cos()函数，我们先用<code>import</code>引用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">def move(x, y, step, angle):</span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    return nx, ny</span><br></pre></td></tr></table></figure>
<p>这样我们就可以同时获得返回值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)</span><br><span class="line">&gt;&gt;&gt; print x, y</span><br><span class="line">151.961524227 70.0</span><br></pre></td></tr></table></figure>
<p>但其实这只是一种假象，Python函数返回的仍然是单一值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)</span><br><span class="line">&gt;&gt;&gt; print r</span><br><span class="line">(151.96152422706632, 70.0)</span><br></pre></td></tr></table></figure>
<p>用print打印返回结果，原来返回值是一个tuple！</p>
<p>但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>
<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>
<p>举个例子，我们来计算阶乘 n! = 1 <em> 2 </em> 3 <em> … </em> n，用函数 fact(n)表示，可以看出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fact(n) = n! = 1 * 2 * 3 * ... * (n-1) * n = (n-1)! * n = fact(n-1) * n</span><br></pre></td></tr></table></figure>
<p>所以，fact(n)可以表示为 n * fact(n-1)，只有n=1时需要特殊处理。</p>
<p>于是，fact(n)用递归的方式写出来就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def fact(n):</span><br><span class="line">    if n==1:</span><br><span class="line">        return 1</span><br><span class="line">    return n * fact(n - 1)</span><br></pre></td></tr></table></figure>
<p>上面就是一个递归函数。可以试试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fact(1)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; fact(5)</span><br><span class="line">120</span><br><span class="line">&gt;&gt;&gt; fact(100)</span><br><span class="line">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000L</span><br></pre></td></tr></table></figure>
<p>如果我们计算fact(5)，可以根据函数定义看到计算过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">===&gt; fact(5)</span><br><span class="line">===&gt; 5 * fact(4)</span><br><span class="line">===&gt; 5 * (4 * fact(3))</span><br><span class="line">===&gt; 5 * (4 * (3 * fact(2)))</span><br><span class="line">===&gt; 5 * (4 * (3 * (2 * fact(1))))</span><br><span class="line">===&gt; 5 * (4 * (3 * (2 * 1)))</span><br><span class="line">===&gt; 5 * (4 * (3 * 2))</span><br><span class="line">===&gt; 5 * (4 * 6)</span><br><span class="line">===&gt; 5 * 24</span><br><span class="line">===&gt; 120</span><br></pre></td></tr></table></figure>
<p>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p>
<p><strong>使用递归函数需要注意防止栈溢出。</strong>在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试计算 fact(10000)。</p>
<h3 id="定义默认参数"><a href="#定义默认参数" class="headerlink" title="定义默认参数"></a>定义默认参数</h3><p>定义函数的时候，还可以有默认参数。</p>
<p>例如Python自带的 int() 函数，其实就有两个参数，我们既可以传一个参数，又可以传两个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int(&apos;123&apos;)</span><br><span class="line">123</span><br><span class="line">&gt;&gt;&gt; int(&apos;123&apos;, 8)</span><br><span class="line">83</span><br></pre></td></tr></table></figure>
<p>int()函数的第二个参数是转换进制，如果不传，默认是十进制 (base=10)，如果传了，就用传入的参数。</p>
<p>可见，函数的默认参数的作用是简化调用，你只需要把必须的参数传进去。但是在需要的时候，又可以传入额外的参数来覆盖默认参数值。</p>
<p>我们来定义一个计算 x 的N次方的函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def power(x, n):</span><br><span class="line">    s = 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n = n - 1</span><br><span class="line">        s = s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure>
<p>假设计算平方的次数最多，我们就可以把 n 的默认值设定为 2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def power(x, n=2):</span><br><span class="line">    s = 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n = n - 1</span><br><span class="line">        s = s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure>
<p>这样一来，计算平方就不需要传入两个参数了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5)</span><br><span class="line">25</span><br></pre></td></tr></table></figure>
<p>由于函数的参数按从左到右的顺序匹配，所以默认参数只能定义在必需参数的后面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># OK:</span><br><span class="line">def fn1(a, b=1, c=2):</span><br><span class="line">    pass</span><br><span class="line"># Error:</span><br><span class="line">def fn2(a=1, b):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<h3 id="定义可变参数"><a href="#定义可变参数" class="headerlink" title="定义可变参数"></a>定义可变参数</h3><p>如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def fn(*args):</span><br><span class="line">    print args</span><br></pre></td></tr></table></figure>
<p>可变参数的名字前面有个 * 号，我们可以传入0个、1个或多个参数给可变参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fn()</span><br><span class="line">()</span><br><span class="line">&gt;&gt;&gt; fn(&apos;a&apos;)</span><br><span class="line">(&apos;a&apos;,)</span><br><span class="line">&gt;&gt;&gt; fn(&apos;a&apos;, &apos;b&apos;)</span><br><span class="line">(&apos;a&apos;, &apos;b&apos;)</span><br><span class="line">&gt;&gt;&gt; fn(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)</span><br><span class="line">(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)</span><br></pre></td></tr></table></figure>
<p>可变参数也不是很神秘，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。</p>
<p>定义可变参数的目的也是为了简化调用。假设我们要计算任意个数的平均值，就可以定义一个可变参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def average(*args):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>这样，在调用的时候，可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; average()</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; average(1, 2)</span><br><span class="line">1.5</span><br><span class="line">&gt;&gt;&gt; average(1, 2, 2, 3, 4)</span><br><span class="line">2.4</span><br></pre></td></tr></table></figure>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="对list进行切片"><a href="#对list进行切片" class="headerlink" title="对list进行切片"></a>对list进行切片</h3><p>取一个list的部分元素是非常常见的操作。比如，一个list如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]</span><br></pre></td></tr></table></figure>
<p>取前3个元素，应该怎么做？</p>
<p>笨办法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [L[0], L[1], L[2]]</span><br><span class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</span><br></pre></td></tr></table></figure>
<p>之所以是笨办法是因为扩展一下，取前N个元素就没辙了。</p>
<p>取前N个元素，也就是索引为0-(N-1)的元素，可以用循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = []</span><br><span class="line">&gt;&gt;&gt; n = 3</span><br><span class="line">&gt;&gt;&gt; for i in range(n):</span><br><span class="line">...     r.append(L[i])</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; r</span><br><span class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</span><br></pre></td></tr></table></figure>
<p>对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。</p>
<p>对应上面的问题，取前3个元素，用一行代码就可以完成切片：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[0:3]</span><br><span class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</span><br></pre></td></tr></table></figure>
<p>L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</p>
<p>如果第一个索引是0，还可以省略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:3]</span><br><span class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]</span><br></pre></td></tr></table></figure>
<p>也可以从索引1开始，取出2个元素出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[1:3]</span><br><span class="line">[&apos;Lisa&apos;, &apos;Bart&apos;]</span><br></pre></td></tr></table></figure>
<p>只用一个 : ，表示从头到尾：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:]</span><br><span class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]</span><br></pre></td></tr></table></figure>
<p>因此，L[:]实际上复制出了一个新list。</p>
<p>切片操作还可以指定第三个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[::2]</span><br><span class="line">[&apos;Adam&apos;, &apos;Bart&apos;]</span><br></pre></td></tr></table></figure>
<p>第三个参数表示每N个取一个，上面的 L[::2] 会每两个元素取出一个来，也就是隔一个取一个。</p>
<p>把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。</p>
<h3 id="倒序切片"><a href="#倒序切片" class="headerlink" title="倒序切片"></a>倒序切片</h3><p>对于list，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; L[-2:]</span><br><span class="line">[&apos;Bart&apos;, &apos;Paul&apos;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; L[:-2]</span><br><span class="line">[&apos;Adam&apos;, &apos;Lisa&apos;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; L[-3:-1]</span><br><span class="line">[&apos;Lisa&apos;, &apos;Bart&apos;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; L[-4:-1:2]</span><br><span class="line">[&apos;Adam&apos;, &apos;Bart&apos;]</span><br></pre></td></tr></table></figure>
<p>记住倒数第一个元素的索引是-1。倒序切片包含起始索引，不包含结束索引。</p>
<h3 id="对字符串切片"><a href="#对字符串切片" class="headerlink" title="对字符串切片"></a>对字符串切片</h3><p>字符串 ‘xxx’和 Unicode字符串 u’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]</span><br><span class="line">&apos;ABC&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;ABCDEFG&apos;[-3:]</span><br><span class="line">&apos;EFG&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]</span><br><span class="line">&apos;ACEG&apos;</span><br></pre></td></tr></table></figure>
<p>在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>在Python中，如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们成为迭代（Iteration）。</p>
<p>在Python中，迭代是通过 for … in 来完成的，而很多语言比如C或者Java，迭代list是通过下标完成的，比如Java代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (i=0; i&lt;list.length; i++) &#123;</span><br><span class="line">    n = list[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，Python的for循环抽象程度要高于Java的for循环。</p>
<p>因为 Python 的 for循环不仅可以用在list或tuple上，还可以作用在其他任何可迭代对象上。</p>
<p>因此，迭代操作就是对于一个集合，无论该集合是有序还是无序，我们用 for 循环总是可以依次取出集合的每一个元素。</p>
<p>注意: 集合是指包含一组元素的数据结构，我们已经介绍的包括：</p>
<ol>
<li>有序集合：list，tuple，str和unicode；</li>
<li>无序集合：set</li>
<li>无序集合并且具有 key-value 对：dict<br>而迭代是一个动词，它指的是一种操作，在Python中，就是 for 循环。</li>
</ol>
<p>迭代与按下标访问数组最大的不同是，后者是一种具体的迭代实现方式，而前者只关心迭代结果，根本不关心迭代内部是如何实现的。</p>
<h3 id="索引迭代"><a href="#索引迭代" class="headerlink" title="索引迭代"></a>索引迭代</h3><p>Python中，迭代永远是取出元素本身，而非元素的索引。</p>
<p>对于有序集合，元素确实是有索引的。有的时候，我们确实想在 for 循环中拿到索引，怎么办？</p>
<p>方法是使用 enumerate() 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]</span><br><span class="line">&gt;&gt;&gt; for index, name in enumerate(L):</span><br><span class="line">...     print index, &apos;-&apos;, name</span><br><span class="line">... </span><br><span class="line">0 - Adam</span><br><span class="line">1 - Lisa</span><br><span class="line">2 - Bart</span><br><span class="line">3 - Paul</span><br></pre></td></tr></table></figure>
<p>使用 enumerate() 函数，我们可以在for循环中同时绑定索引index和元素name。但是，这不是 enumerate() 的特殊语法。实际上，enumerate() 函数把：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]</span><br></pre></td></tr></table></figure>
<p>变成了类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(0, &apos;Adam&apos;), (1, &apos;Lisa&apos;), (2, &apos;Bart&apos;), (3, &apos;Paul&apos;)]</span><br></pre></td></tr></table></figure>
<p>因此，迭代的每一个元素实际上是一个tuple：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for t in enumerate(L):</span><br><span class="line">    index = t[0]</span><br><span class="line">    name = t[1]</span><br><span class="line">    print index, &apos;-&apos;, name</span><br></pre></td></tr></table></figure>
<p>如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for index, name in enumerate(L):</span><br><span class="line">    print index, &apos;-&apos;, name</span><br></pre></td></tr></table></figure>
<p>这样不但代码更简单，而且还少了两条赋值语句。</p>
<p>可见，索引迭代也不是真的按索引访问，而是由 enumerate() 函数自动把每个元素变成 (index, element) 这样的tuple，再迭代，就同时获得了索引和元素本身。</p>
<h3 id="迭代Dict的value"><a href="#迭代Dict的value" class="headerlink" title="迭代Dict的value"></a>迭代Dict的value</h3><p>我们已经了解了dict对象本身就是可迭代对象，用 for 循环直接迭代 dict，可以每次拿到dict的一个key。</p>
<p>如果我们希望迭代 dict 对象的value，应该怎么做？</p>
<p>dict 对象有一个 values() 方法，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;</span><br><span class="line">print d.values()</span><br><span class="line"># [85, 95, 59]</span><br><span class="line">for v in d.values():</span><br><span class="line">    print v</span><br><span class="line"># 85</span><br><span class="line"># 95</span><br><span class="line"># 59</span><br></pre></td></tr></table></figure>
<p>如果仔细阅读Python的文档，还可以发现，dict除了values()方法外，还有一个 itervalues() 方法，用 itervalues() 方法替代 values() 方法，迭代效果完全一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;</span><br><span class="line">print d.itervalues()</span><br><span class="line"># &lt;dictionary-valueiterator object at 0x106adbb50&gt;</span><br><span class="line">for v in d.itervalues():</span><br><span class="line">    print v</span><br><span class="line"># 85</span><br><span class="line"># 95</span><br><span class="line"># 59</span><br></pre></td></tr></table></figure>
<p>那这两个方法有何不同之处呢？</p>
<ol>
<li><p>values() 方法实际上把一个 dict 转换成了包含 value 的list。</p>
</li>
<li><p>但是 itervalues() 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。</p>
</li>
<li><p>打印 itervalues() 发现它返回一个 <dictionary-valueiterator> 对象，这说明在Python中，for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。</dictionary-valueiterator></p>
</li>
</ol>
<p>如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。</p>
<h3 id="迭代Dict的key和value"><a href="#迭代Dict的key和value" class="headerlink" title="迭代Dict的key和value"></a>迭代Dict的key和value</h3><p>我们了解了如何迭代 dict 的key和value，那么，在一个 for 循环中，能否同时迭代 key和value？答案是肯定的。</p>
<p>首先，我们看看 dict 对象的 items() 方法返回的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;</span><br><span class="line">&gt;&gt;&gt; print d.items()</span><br><span class="line">[(&apos;Lisa&apos;, 85), (&apos;Adam&apos;, 95), (&apos;Bart&apos;, 59)]</span><br></pre></td></tr></table></figure>
<p>可以看到，items() 方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for key, value in d.items():</span><br><span class="line">...     print key, &apos;:&apos;, value</span><br><span class="line">... </span><br><span class="line">Lisa : 85</span><br><span class="line">Adam : 95</span><br><span class="line">Bart : 59</span><br></pre></td></tr></table></figure>
<p>和 values() 有一个 itervalues() 类似， items() 也有一个对应的 iteritems()，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="列表生成"><a href="#列表生成" class="headerlink" title="列表生成"></a>列表生成</h3><p>要生成<code>list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>，我们可以用<code>range(1, 11)</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; range(1, 11)</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure>
<p>但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L = []</span><br><span class="line">&gt;&gt;&gt; for x in range(1, 11):</span><br><span class="line">...    L.append(x * x)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure>
<p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11)]</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure>
<p>这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。</p>
<p>写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p>
<h3 id="复杂表达式"><a href="#复杂表达式" class="headerlink" title="复杂表达式"></a>复杂表达式</h3><p>使用for循环的迭代不仅可以迭代普通的list，还可以迭代dict。</p>
<p>假设有如下的dict：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;</span><br></pre></td></tr></table></figure>
<p>完全可以通过一个复杂的列表生成式把它变成一个 HTML 表格：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tds = [&apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) for name, score in d.iteritems()]</span><br><span class="line">print &apos;&lt;table&gt;&apos;</span><br><span class="line">print &apos;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&apos;</span><br><span class="line">print &apos;\n&apos;.join(tds)</span><br><span class="line">print &apos;&lt;/table&gt;&apos;</span><br></pre></td></tr></table></figure>
<p>注：字符串可以通过 % 进行格式化，用指定的参数替代 %s。字符串的join()方法可以把一个 list 拼接成一个字符串。</p>
<p>把打印出来的结果保存为一个html文件，就可以在浏览器中看到效果了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot;&gt;</span><br><span class="line">&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;Lisa&lt;/td&gt;&lt;td&gt;85&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;Adam&lt;/td&gt;&lt;td&gt;95&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;Bart&lt;/td&gt;&lt;td&gt;59&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Name</th>
<th>Score</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lisa</td>
<td>85</td>
</tr>
<tr>
<td>Adam</td>
<td>95</td>
</tr>
<tr>
<td>Bart</td>
<td>59</td>
</tr>
</tbody>
</table>
<h3 id="条件过滤"><a href="#条件过滤" class="headerlink" title="条件过滤"></a>条件过滤</h3><p>列表生成式的 for 循环后面还可以加上 if 判断。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11)]</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure>
<p>如果我们只想要偶数的平方，不改动 range()的情况下，可以加上 if 来筛选：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]</span><br><span class="line">[4, 16, 36, 64, 100]</span><br></pre></td></tr></table></figure>
<p>有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。</p>
<h3 id="多层表达式"><a href="#多层表达式" class="headerlink" title="多层表达式"></a>多层表达式</h3><p>for循环可以嵌套，因此，在列表生成式中，也可以用多层 for 循环来生成列表。</p>
<p>对于字符串 ‘ABC’ 和 ‘123’，可以使用两层循环，生成全排列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [m + n for m in &apos;ABC&apos; for n in &apos;123&apos;]</span><br><span class="line">[&apos;A1&apos;, &apos;A2&apos;, &apos;A3&apos;, &apos;B1&apos;, &apos;B2&apos;, &apos;B3&apos;, &apos;C1&apos;, &apos;C2&apos;, &apos;C3&apos;]</span><br></pre></td></tr></table></figure>
<p>翻译成循环代码就像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line">for m in &apos;ABC&apos;:</span><br><span class="line">    for n in &apos;123&apos;:</span><br><span class="line">        L.append(m + n)</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全世界大概有几百种编程语言，而其中著名的只有十几种。Python就是著名编程语言之一。它起源于“龟叔”（Guido van Rossum，荷兰人）在1989年圣诞节间的无聊，而为了打发时间所创造。&lt;/p&gt;
&lt;p&gt;可见业余时间比工作时间创造出来的东西更容易出名哈，当然，这是开玩笑的。“龟叔”赋予Python“优雅、明确、简单”的特点。&lt;/p&gt;
&lt;p&gt;那么，Python适合做什么呢？它主要适用领域：Web网站和各种网络服务（YouTube、Instagram、douban、openstack）；系统工具和脚本；作为“胶水”语言把其它语言开发的模块包装起来方便使用。&lt;/p&gt;
&lt;p&gt;优点是显著的，但是也少不了缺点。Python不适用的领域：贴近硬件的代码（首选C）；移动开发（iOS／Android都有各自的开发语言）；因为不能做到告诉渲染，所以不适合游戏开发（首选C／C++）。&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://chars.tech/categories/web/"/>
    
    
      <category term="碎碎念" scheme="http://chars.tech/tags/text/"/>
    
      <category term="读书笔记" scheme="http://chars.tech/tags/notes/"/>
    
      <category term="python" scheme="http://chars.tech/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>什么是iOS的安全模式</title>
    <link href="http://chars.tech/2017/04/19/ios-security-pattern/"/>
    <id>http://chars.tech/2017/04/19/ios-security-pattern/</id>
    <published>2017-04-19T15:18:42.000Z</published>
    <updated>2017-07-05T08:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为iOS开发，作品App肯定需要提交到App Store审核。平心而论，App Store确实成功地将许多恶意软件拒之门外。但是，对开发者而言，应用程序的审核流程是令人沮丧的黑箱操作。</p>
<p>当然，什么是恶意程序是由Apple来定义。因为App Store的存在，所以，如果想要实现某些特定的功能，唯一的手段就是将设备越狱或者骗过App Store的审查。</p>
<p>官方的App审查永远无法抓到那些钻空子的恶意程序，所以需要另外一套高效的机制，来阻止恶意程序破坏整个操作系统的安全。</p>
<a id="more"></a>
<h2 id="安全启动"><a href="#安全启动" class="headerlink" title="安全启动"></a>安全启动</h2><p>当启动一台iOS设备时，系统首先会从只读的引导ROM中读取初始化指令，即系统引导程序。这个引导ROM包含Apple官方权威认证的公钥，它会验证底层启动加载器（LLB）的签名，一旦通过验证就启动它。</p>
<p>然后验证第二级引导程序iBoot，iBoot启动后设备就可以进入恢复模式或启动内核。在iBoot验证完成内核签名的合法性之后，整个启动程序开始步入正轨：加载驱动程序、检测设备、启动系统守护进程。</p>
<p>这个信任链确保所有的系统组件都由Apple写入、签名、分发，不能来自第三方机构，特别是那些恶意的攻击者以及企图越狱设备的黑客。App启动时也会用信任链去审查签名。所有的App都必须直接或间接由Apple签名。</p>
<p>越狱工作的原理正是攻击这一信任链。越狱工具的作者需要找到这一信任链条上的漏洞，从而禁掉链条中负责验证的组件。破解引导ROM通常是最可取的方法，因为该组件不会因Apple今后的软件更新而改变。</p>
<p>有关更多签名知识可以参看：</p>
<p><a href="http://wereadteam.github.io/2017/03/13/Signature/" target="_blank" rel="external">《iOS App 签名的原理》</a></p>
<h2 id="沙盒机制"><a href="#沙盒机制" class="headerlink" title="沙盒机制"></a>沙盒机制</h2><p>App的沙盒机制是一种基于FreeBSD系统TrustedBSD框架的强制访问控制（MAC）机制，它采用一种类似于Lisp的配置语言来描述哪些资源系统可以访问，哪些禁止访问。这些资源主要包括文件、系统服务、网络连接、内存资源等。</p>
<p>MAC机制不同于传统的访问控制机制（比如自主访问控制（DAC）），它不允许主体（比如用户进程）操作对象（文件、套接字等）。DAC最常见的形式就是UNIX系统上的用户、组和其它权限，所有这些都可以被授予读、写或执行的权限。在DAC系统中，用户如果拥有一个对象的所有权，也就拥有该对象的修改权限。</p>
<p>MAC在沙盒中意味着App被关进了一个虚拟的容器。该容器遵循一系列的特定规则，即哪些系统资源可以访问。</p>
<p>在文件访问方面，一般只能访问App的包目录；App可以读写存储在该位置的文件。</p>
<p>Android的访问控制机制与MAC不同。Android实现了一个更加传统的DAC模型，App都有自己的用户ID和属于该ID的文件夹，其权限管理严格按照传统的UNIX文件权限管理运作。虽然这两项机制工作起来都没有问题，但MAC的扩展性总体来说还是更强一些。比如，除了App目录隔离，MAC机制还可以限制网络访问或系统守护进程的操作。</p>
<h2 id="数据保护和全盘加密"><a href="#数据保护和全盘加密" class="headerlink" title="数据保护和全盘加密"></a>数据保护和全盘加密</h2><p>数据保护和全盘加密两机制可以实现远程抹除设备数据，在设备丢失的情况下保护用户数据免于泄漏。</p>
<p>文件系统加密并不能防止从一个正在运行的设备上窃取数据的行为。如果一个App可以从磁盘中读取一个文件，那文件系统加密并没有任何用武之处，因为内核对于任何尝试读取这些文件的进程都是透明解密的。换句话说，相比那些读取文件的调用行为，文件系统加密工作都是更底层。一旦攻破者攻破了系统验证，那就能无障碍地读取任意文件。</p>
<p>全盘加密对于以下两个安全特性是必要的：安全删除文件、远程设备擦出。iOS中使用的加密密钥是分层级的，只需要简单丢弃一个加密密钥就能彻底销毁整层的数据，甚至是销毁整个文件系统。</p>
<h2 id="加密密钥的层级"><a href="#加密密钥的层级" class="headerlink" title="加密密钥的层级"></a>加密密钥的层级</h2><p>iOS文件系统中用于数据加密的密钥是分等级的，即用密钥来加密其它密钥，这样Apple就能更精确的控制数据什么时候可用。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-security-pattarn-01.png" alt="加密密钥层级图"></p>
<p>文件密钥（File Key）针对每个文件独立生成，存储在文件的元数据中。</p>
<p>层级密钥（Class Key）为数据提供不同级别的保护。</p>
<p>文件系统密钥（Filesystem Key）是一种全局加密密钥，当元数据被层级密钥加密后，使用文件系统密钥来加密涉及文件安全的元数据。</p>
<p>设备密钥（Device Key）通常被称为UID密钥，每台设备唯一，只能通过硬件的AES引擎访问，操作系统无法直接获取。它是系统的主密钥，用来加密文件系统密钥和层级密钥。</p>
<p>用户密码（User Passcode），可与设备密钥结合起来加密层级密钥。</p>
<p>一旦设置密码，这个密钥等级也允许开发者自己决定本地存储的数据该如何保护，包括在设备锁定时是否能被访问、数据能否备份到其它设备等。</p>
<h2 id="ASLR和XN及其它机制"><a href="#ASLR和XN及其它机制" class="headerlink" title="ASLR和XN及其它机制"></a>ASLR和XN及其它机制</h2><p>iOS用两套标准机制来预防代码执行攻击：地址空间结构随机化（ASLR）和XN bit（eXecute Never，标记该段内存区域不包含可执行代码）。</p>
<p>每次执行程序时，ASLR都会随机分配程序、数据、堆和栈的内存位置。而共享库的内存地址只在每次系统重启时随机设置，因为共享库需要在多个进程中使用。ALSR机制可以预防缓存区移除攻击（return-to-libc），因为函数和库的内存地址随机，而这种攻击依赖于基本库和函数的已知地址。</p>
<p>XN bit，一般对应非ARM平台的NX（No-eXecute）bit，允许操作系统将某段内存标记为不可执行，这由CPU来控制。在iOS中，这个机制默认应用在程序的栈和堆上。</p>
<p>每个程序都有一段可写可执行的内存，但是它必须是经过Apple官方签名授权系统的签名。Safari浏览器中的JavaScript即时（JIT, Just-in-time）编译器会用到这段内存。而WebView并不具备JIT功能，这样虽然可以避免代码执行攻击，但是也使得iOS平台上的Chrome无法做到像Safari那样好用。</p>
<h2 id="越狱检测"><a href="#越狱检测" class="headerlink" title="越狱检测"></a>越狱检测</h2><p>越狱的本质就是通过一系列步骤来禁掉签名机制，从而允许设备运行未经Apple官方审核的应用。黑箱测试应用程序是越狱的重要能力。</p>
<p>其实，越狱不一定要禁掉iOS的沙盒机制，它只是允许你在沙盒外安装App。安装在移动用户主目录下的App（即通过App Store安装）仍然受到沙盒限制。第三方的App需要安装在越狱设备中权限更高的<code>/Applications</code>目录下，与Apple股票应用安装在一起。</p>
<h2 id="动态修复"><a href="#动态修复" class="headerlink" title="动态修复"></a>动态修复</h2><p>一般来说，如果一段原生代码没有经过Apple发布的密钥签名认证，App则无法运行它。如果Apple的签名验证逻辑中存在bug或漏洞，可能会允许下载和执行原生代码。</p>
<p>iOS有一个特性，可以让程序分配一段没有NX保护的内存区块（该内存区块可读、可写，甚至可执行），里面运行的代码也不需要经过签名认证。这个机制在Safari上的JIT编译器上使用。这个运用场景中，就可能会产生漏洞，业界著名的例子就是Charlie Miller。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为iOS开发，作品App肯定需要提交到App Store审核。平心而论，App Store确实成功地将许多恶意软件拒之门外。但是，对开发者而言，应用程序的审核流程是令人沮丧的黑箱操作。&lt;/p&gt;
&lt;p&gt;当然，什么是恶意程序是由Apple来定义。因为App Store的存在，所以，如果想要实现某些特定的功能，唯一的手段就是将设备越狱或者骗过App Store的审查。&lt;/p&gt;
&lt;p&gt;官方的App审查永远无法抓到那些钻空子的恶意程序，所以需要另外一套高效的机制，来阻止恶意程序破坏整个操作系统的安全。&lt;/p&gt;
    
    </summary>
    
      <category term="pieces" scheme="http://chars.tech/categories/pieces/"/>
    
    
      <category term="ios" scheme="http://chars.tech/tags/ios/"/>
    
      <category term="安全" scheme="http://chars.tech/tags/security/"/>
    
      <category term="读书笔记" scheme="http://chars.tech/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊iOS的那些生命周期</title>
    <link href="http://chars.tech/2017/04/11/ios-lifecycle/"/>
    <id>http://chars.tech/2017/04/11/ios-lifecycle/</id>
    <published>2017-04-11T09:07:18.000Z</published>
    <updated>2017-07-05T08:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS应用程序的生命周期，还有程序是运行在前台还是后台，应用程序各个状态的变换，这些对于开发者来说都是很重要的。iOS系统的资源是有限的，应用程序在前台和在后台的状态是不一样的。在后台时，程序会受到系统的很多限制，这样可以提高电池的使用和用户体验。</p>
<p>本文所要说到的生命周期，也不仅仅只是应用生命周期；还包括，视图生命周期。</p>
<a id="more"></a>
<h2 id="应用生命周期"><a href="#应用生命周期" class="headerlink" title="应用生命周期"></a>应用生命周期</h2><p>iOS的应用程序一共有5种状态:</p>
<ul>
<li>Not Running(非运行状态)</li>
</ul>
<p>应用没有运行或被系统终止。</p>
<ul>
<li>Inactive(前台非活动状态)</li>
</ul>
<p>应用正在进入前台状态，但是还不能接受事件处理。</p>
<ul>
<li>Active(前台活动状态)</li>
</ul>
<p>应用进入前台状态，能接受事件处理。</p>
<ul>
<li>Background(后台状态)</li>
</ul>
<p>应用进入后台后，依然能够执行代码。如果有可执行的代码，就会执行代码，如果没有可执行的代码或者将可执行的代码执行完毕，应用会马上进入挂起状态。有的程序经过特殊的请求后可以长期处于Backgroud状态。</p>
<ul>
<li>Suspended(挂起状态)</li>
</ul>
<p>处于挂起的应用进入一种“冷冻”状态,不能执行代码。如果系统内存不够,系统就把挂起的程序清除掉，为前台程序提供更多的内存，应用会被终止。</p>
<p>作为应用程序的委托对象，AppDelegate类在应用生命周期的不同阶段会回调不同的方法。首先，让我们先了解一下iOS 应用的不同状态及它们彼此间的关系，如下图所示 ：</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-app-lifecycle-1.png" alt=""></p>
<p>在应用状态跃迁的过程中，iOS 系统会回调AppDelegate中的一些方法，并且发送一些通知。实际上，在应用的生命周期中用到的方法和通知很多，我们选取了几个主要的方法和通知进行详细介绍，具体如下表所述：</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-app-lifecycle-2.jpeg" alt=""></p>
<p>为了便于观察应用程序的运行状态，为AppDelegate.m中的方法添加一些日志输出，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@implementation AppDelegate </span><br><span class="line">  </span><br><span class="line">- (BOOL)application:(UIApplication *)application </span><br><span class="line">    didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;application:didFinishLaunchingWithOptions:&quot;);</span><br><span class="line"> </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">- (void)applicationWillResignActive:(UIApplication *)application&#123;    </span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;applicationWillResignActive:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application&#123;    </span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;applicationDidEnterBackground:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)applicationWillEnterForeground:(UIApplication *)application&#123;    </span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;applicationWillEnterForeground:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)applicationDidBecomeActive:(UIApplication *)application&#123;    </span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;applicationDidBecomeActive:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)applicationWillTerminate:(UIApplication *)application&#123;    </span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;applicationWillTerminate:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>为了让大家更直观地了解各状态与其相应的方法、通知间的关系，下面以几个应用场景为切入点进行系统的分析。</p>
<h3 id="（一）非运行状态——应用启动场景"><a href="#（一）非运行状态——应用启动场景" class="headerlink" title="（一）非运行状态——应用启动场景"></a>（一）非运行状态——应用启动场景</h3><p>场景描述：用户点击应用图标的时候，可能是第一次启动这个应用，也可能是应用终止后再次启动。该场景的状态跃迁过程见下图，共经历两个阶段3个状态：Not running →Inactive→Active。 </p>
<ul>
<li>1)在Not running→Inactive 阶段。</li>
</ul>
<p>调用<code>application:didFinishLaunchingWithOptions:</code>方法，发出<code>UIApplicationDidFinishLaunchingNotification</code> 通知。 </p>
<ul>
<li>2)在Inactive →Active 阶段。</li>
</ul>
<p>调用 <code>applicationDidBecomeActive:</code>方法，发出<code>UIApplicationDidBecomeActiveNotification</code> 通知。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-app-lifecycle-3.png" alt=""></p>
<h3 id="（二）点击Home键——应用退出场景"><a href="#（二）点击Home键——应用退出场景" class="headerlink" title="（二）点击Home键——应用退出场景"></a>（二）点击Home键——应用退出场景</h3><p>场景描述：应用处于运行状态（即Active状态）时，点击Home键或者有其他的应用导致当前应用中断。该场景的状态跃迁过程可以分成两种情况：可以在后台运行或者挂起，不可以在后台运行或者挂起。根据产品属性文件（如HelloWorld-Info.plist）中的相关属性Application does not run in background 是与否可以控制这两种状态。如果采用文本编辑器打开HelloWorldInfo.plist文件该设置项对应的键是UIApplicationExitsOnSuspend。　</p>
<p>状态跃迁的第一种情况：应用可以在后台运行或者挂起，该场景的状态跃迁过程见下图 ，共经历3 个阶段4个状态：Active → Inactive → Background→Suspended。 </p>
<ul>
<li>1)在Active→Inactive 阶段。</li>
</ul>
<p>调用 <code>applicationWillResignActive:</code>方法，发出<code>UIApplicationWillResignActiveNotification</code> 通知。 </p>
<ul>
<li>2)在Inactive →Background阶段。</li>
</ul>
<p>应用从非活动状态进入到后台（不涉及我们要重点说明的方法和通知）。 </p>
<ul>
<li>3)在Background→Suspended 阶段。</li>
</ul>
<p>调用<code>applicationDidEnterBackground:</code>方法，发出<code>UIApplicationDidEnterBackgroundNotification</code> 通知。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-app-lifecycle-4.png" alt=""></p>
<p>状态跃迁的第二种情况：应用不可以在后台运行或者挂起，其状态跃迁情况见下图 ，共经历4个阶段5 个状态：Active  → Inactive  → Background→Suspended→Not running 。</p>
<ul>
<li>1)在Active →Inactivd 阶段。</li>
</ul>
<p>应用由活动状态转为非活动状态（不涉及我们要重点说明的方法和通知）。 </p>
<ul>
<li>2)在Inactive →Background阶段。</li>
</ul>
<p>应用从非活动状态进入到后台（不涉及我们要重点说明的方法和通知）。 </p>
<ul>
<li>3)在Background→Suspended 阶段。</li>
</ul>
<p>调用<code>applicationDidEnterBackground:</code>方法， 发出<code>UIApplicationDidEnterBackgroundNotification</code>通知。</p>
<ul>
<li>4)在Suspended →Not running阶段。</li>
</ul>
<p>调用<code>applicationWillTerminate:</code>方法，发出<code>UIApplicationWillTerminateNotification</code>通知。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-app-lifecycle-5.png" alt=""></p>
<p>iOS 在iOS 4之前不支持多任务，点击Home键时，应用会退出并中断；而在iOS 4之后（包括iOS 4），操作系统能够支持多任务处理，点击Home键应用会进入后台但不会中断（内存不够的情况除外）。 </p>
<p>应用在后台也可以进行部分处理工作，处理完成则进入挂起状态。</p>
<h3 id="（三）挂起重新运行场景"><a href="#（三）挂起重新运行场景" class="headerlink" title="（三）挂起重新运行场景"></a>（三）挂起重新运行场景</h3><p>场景描述：挂起状态的应用重新运行。该场景的状态跃迁过程如下图所示，共经历3 个阶段4 个状态：Suspended  → Background  → Inactive  → Active 。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-app-lifecycle-6.png" alt=""></p>
<ul>
<li>1)Suspended→Background阶段。</li>
</ul>
<p>应用从挂起状态进入后台（不涉及我们讲述的这几个方法和通知）。 </p>
<ul>
<li>2)Background→Inactive 阶段。</li>
</ul>
<p>调用<code>applicationWillEnterForeground:</code>方法，发出<code>UIApplicationWillEnterForegroundNotification</code>通知。 </p>
<ul>
<li>3)Inactive →Active 阶段。</li>
</ul>
<p>调用<code>applicationDidBecomeActive:</code>方法，发出<code>UIApplicationDidBecomeActiveNotification</code> 通知。</p>
<h3 id="（四）内存清除——应用终止场景"><a href="#（四）内存清除——应用终止场景" class="headerlink" title="（四）内存清除——应用终止场景"></a>（四）内存清除——应用终止场景</h3><p>场景描述：应用在后台处理完成时进入挂起状态（这是一种休眠状态），如果这时发出低内存警告，为了满足其他应用对内存的需要，该应用就会被清除内存从而终止运行，该场景的状态跃迁见下图 。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-app-lifecycle-7.png" alt=""></p>
<p>内存清除的时候应用终止运行。内存清除有两种情况，可能是系统强制清除内存，也可能是由使用者从任务栏中手动清除（即删掉应用）。内存清除后如果应用再次运行，上一次的运行状态不会被保存，相当于应用第一次运行。</p>
<p>在内存清除场景下，应用不会调用任何方法，也不会发出任何通知。</p>
<h2 id="视图生命周期"><a href="#视图生命周期" class="headerlink" title="视图生命周期"></a>视图生命周期</h2><p>视图是应用的一个重要组成部分，功能的实现与其息息相关，而视图控制器控制着视图，其重要性在整个应用中不言而喻。</p>
<h3 id="视图生命周期与视图控制器关系"><a href="#视图生命周期与视图控制器关系" class="headerlink" title="视图生命周期与视图控制器关系"></a>视图生命周期与视图控制器关系</h3><p>以视图的4 种状态为基础，我们来系统了解一下视图控制器的生命周期。在视图不同的生命周期中，视图控制器会回调不同的方法，具体如下图所示。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-ui-lifecycle-1.png" alt=""></p>
<p>在视图控制器已被实例化，视图被加载到内存中时调用viewDidLoad方法，这个时候视图并未出现。在该方法中，通常进行的是对所控制的视图进行初始化处理。 </p>
<p>视图可见前后会调用<code>viewWillAppear:</code>方法和<code>viewDidAppear:</code> 方法；视图不可见前后会调用<code>viewWillDisappear:</code> 方法和<code>viewDidDisappear:</code>方法。4个方法调用父类相应的方法以实现其功能，编码时该方法的位置可根据实际情况做以调整，参见如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(void)viewWillAppear:(BOOL)animated&#123;</span><br><span class="line">    [super viewWillAppear:YES];</span><br><span class="line">    //something code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>viewDidLoad</code> 方法在应用运行的时候只调用一次，而这上述4 个方法可以被反复调用多次，它们的使用很广泛但同时也具有很强的技巧性。例如，有的应用会使用重力加速计，重力加速计会不断轮询设备以实时获得设备在z 轴、x 轴和y轴方向的重力加速度。不断的轮询必然会耗费大量电能进而影响电池使用寿命，我们通过利用这4个方法适时地打开或者关闭重力加速计来达到节约电能的目的。怎么使用这4 个方法才能做到“适时”是一个值得思考的问题。 </p>
<p>在低内存情况下，iOS 会调用<code>didReceiveMemoryWarning:</code> 和<code>viewDidUnload:</code>方法。在iOS 6 之后，就不再使用<code>viewDidUnload:</code>，而仅支持<code>didReceiveMemoryWarning：</code>。</p>
<p><code>didReceiveMemoryWarning:</code>方法的主要职能是释放内存，包括视图控制器中的一些成员变量和视图的释放。现举例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    self.button = nil;</span><br><span class="line">    self.myStringD = nil; </span><br><span class="line">    [myStringC release];    //ARC内存管理情况下不用</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了上述5 个方法视图控制器外，还有很多其他方法。</p>
<h3 id="iOS-UI-状态保持和恢复"><a href="#iOS-UI-状态保持和恢复" class="headerlink" title="iOS  UI 状态保持和恢复"></a>iOS  UI 状态保持和恢复</h3><p>iOS 设计规范中要求，当应用退出的时候（包括被终止运行的时候），需要保持界面中UI元素的状态，当再次进来的时候看到的状态与退出时是一样的。在iOS 之后，苹果提供以下API使得UI状态保持和恢复变得很容易。 </p>
<p>在iOS 中，我们可以在以下3种地方实现状态保持和恢复：</p>
<ul>
<li><p>应用程序委托对象 </p>
</li>
<li><p>视图控制器 </p>
</li>
<li><p>自定义视图</p>
</li>
</ul>
<p>恢复标识是iOS为了实现UI状态保持和恢复添加的设置项目。我们还需要在应用程序委托对象AppDelegate代码部分做一些修改，添加的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL) application:(UIApplication *)application shouldSaveApplicationState:(NSCoder *)coder&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">-(BOOL) application:(UIApplication *)application shouldRestoreApplicationState:(NSCoder *)coder&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">- (void)application:(UIApplication *)application willEncodeRestorableStateWithCoder:(NSCoder *)coder&#123;</span><br><span class="line">    [coder encodeFloat:2.0 forKey:@&quot;Version&quot;];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">- (void)application:(UIApplication *)application didDecodeRestorableStateWithCoder:(NSCoder *)coder&#123;</span><br><span class="line">    float lastVer = [coder decodeFloatForKey:@&quot;Version&quot;];</span><br><span class="line">    NSLog(@&quot;lastVer = %f&quot;,lastVer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中application:shouldSaveApplicationState:方法在应用退出时调用，负责控制是否允许保存状态，返回YES 情况是可以保存，NO是不保存。 </p>
<p><code>application:shouldRestoreApplicationState:</code>方法在应用启动时调用，负责控制是否恢复上次退出时的状态，返回YES 表示可以恢复，返回NO表示不可以恢复。 </p>
<p><code>application:willEncodeRestorableStateWithCoder:</code>方法在保存时调用，在这个方法中实现UI状态或数据的保存，其中<code>[coder encodeFloat:2.0 forKey:@&quot;Version&quot;]</code> 语句是保存简单数据。 </p>
<p><code>application:didDecodeRestorableStateWithCoder:</code>方法在恢复时调用，在这个方法中实现UI状态或数据的恢复，其中<code>[coder decodeFloatForKey:@&quot;Version&quot;]</code> 语句用于恢复上次保存的数据。 </p>
<p>想要实现具体界面中控件的保持和恢复，还需要在它的视图控制器中添加一些代码。我们在ViewController.m中添加的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(void)encodeRestorableStateWithCoder:(NSCoder *)coder&#123;</span><br><span class="line">    [super encodeRestorableStateWithCoder:coder];</span><br><span class="line">    [coder encodeObject:self.txtField.text forKey:kSaveKey];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">-(void)decodeRestorableStateWithCoder:(NSCoder *)coder&#123;</span><br><span class="line">    [super decodeRestorableStateWithCoder:coder];</span><br><span class="line">    self.txtField.text = [coder decodeObjectForKey:kSaveKey];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在iOS 6之后，视图控制器都添加了两个方法——<code>encodeRestorableStateWithCoder:</code> 和<code>decodeRestorableStateWithCoder:</code> ，用来实现该控制器中的控件或数据的保存和恢复。</p>
<p>其中<code>encodeRestorableStateWithCoder:</code>方法在保存时候调用，<code>[coder encodeObject:self. txtField.textforKey:kSaveKey]</code>语句是按照指定的键保存文本框的内容。</p>
<p><code>decodeRestorableStateWithCoder:</code>方法在恢复时调用，<code>[coder decodeObjectForKey:kSaveKey]</code>在恢复文本框内容时调用，保存和恢复事实上就是向一个归档文件中编码和解码的过程。</p>
<h2 id="移除Main-storyboard"><a href="#移除Main-storyboard" class="headerlink" title="移除Main.storyboard"></a>移除Main.storyboard</h2><p>每次使用Single View Application模板创建工程之后，总是会有一个Main.storyboard文件，那么，当我们使用代码布局的时候，很显然是不需要它的。那么，如何将它从工程中移除呢？只要进行如下几步即可。</p>
<h3 id="在工程配置中移除关联"><a href="#在工程配置中移除关联" class="headerlink" title="在工程配置中移除关联"></a>在工程配置中移除关联</h3><p><img src="http://o88e8any8.bkt.clouddn.com/ios-remove-storyboard-1.jpeg" alt=""></p>
<p>在TARGETS中，将Main InInterface选项中的值清空并保存设置。</p>
<h3 id="移除Main-storyboard中的关联文件"><a href="#移除Main-storyboard中的关联文件" class="headerlink" title="移除Main.storyboard中的关联文件"></a>移除Main.storyboard中的关联文件</h3><p><img src="http://o88e8any8.bkt.clouddn.com/ios-remove-storyboard-2.png" alt=""></p>
<p>选择storyboard文件。将类关联文件项清空并保存设置。</p>
<h3 id="移除Main-storyboard文件"><a href="#移除Main-storyboard文件" class="headerlink" title="移除Main.storyboard文件"></a>移除Main.storyboard文件</h3><p><img src="http://o88e8any8.bkt.clouddn.com/ios-remove-storyboard-3.jpeg" alt=""></p>
<p>从工程中移除文件。</p>
<h3 id="在AppDelegate中添加代码"><a href="#在AppDelegate中添加代码" class="headerlink" title="在AppDelegate中添加代码"></a>在AppDelegate中添加代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    // Override point for customization after application launch.   </span><br><span class="line">    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];</span><br><span class="line">    </span><br><span class="line">    ViewController *viewController = [[ViewController alloc] init];</span><br><span class="line">    self.window.rootViewController = viewController;  </span><br><span class="line">    self.window.backgroundColor = [UIColor purpleColor];</span><br><span class="line">　[self.window makeKeyAndVisible];    </span><br><span class="line">   return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成以上几步，运行工程即可，顺利运行，没有出现任何error或waring。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS应用程序的生命周期，还有程序是运行在前台还是后台，应用程序各个状态的变换，这些对于开发者来说都是很重要的。iOS系统的资源是有限的，应用程序在前台和在后台的状态是不一样的。在后台时，程序会受到系统的很多限制，这样可以提高电池的使用和用户体验。&lt;/p&gt;
&lt;p&gt;本文所要说到的生命周期，也不仅仅只是应用生命周期；还包括，视图生命周期。&lt;/p&gt;
    
    </summary>
    
      <category term="pieces" scheme="http://chars.tech/categories/pieces/"/>
    
    
      <category term="ios" scheme="http://chars.tech/tags/ios/"/>
    
      <category term="objc" scheme="http://chars.tech/tags/objc/"/>
    
      <category term="application" scheme="http://chars.tech/tags/application/"/>
    
      <category term="ui" scheme="http://chars.tech/tags/ui/"/>
    
      <category term="生命周期" scheme="http://chars.tech/tags/lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>日语-发音</title>
    <link href="http://chars.tech/2017/04/10/japanese-pronounce/"/>
    <id>http://chars.tech/2017/04/10/japanese-pronounce/</id>
    <published>2017-04-10T14:05:00.000Z</published>
    <updated>2017-09-26T07:02:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>日语以东京音为标准音，其声调可以分为如下几种：0型，①型，②型，③型，④型，⑤型，⑥型和⑦型等。高声调表示重音，低声调表示轻音。</p>
<p>0型：表示只有第一拍低，其它各拍都高。</p>
<p>①型：表示只有第一拍高，以下其它各拍都低。</p>
<p>②型：表示只有第二拍高，第一拍和以下其它各拍都低。</p>
<p>③型：表示第二拍，第三拍高，第一拍和以下其它各拍都低。</p>
<p>④型：表示第二拍，第三拍，第四拍高，第一拍和以下其它各拍都低。</p>
<p>依此类推其它型。</p>
<a id="more"></a>
<h2 id="1-五十音图"><a href="#1-五十音图" class="headerlink" title="1 五十音图"></a>1 五十音图</h2><h3 id="1-1-清音"><a href="#1-1-清音" class="headerlink" title="1.1 清音"></a>1.1 清音</h3><table>
<thead>
<tr>
<th></th>
<th>あ段</th>
<th>い段</th>
<th>う段</th>
<th>え段</th>
<th>お段</th>
</tr>
</thead>
<tbody>
<tr>
<td>　あ行 　</td>
<td>　あ　ア a　</td>
<td>　い　イ i　</td>
<td>　う　ウ u　</td>
<td>　え　エ e　</td>
<td>　お　オ　o</td>
</tr>
<tr>
<td>　か行 k　</td>
<td>　か　カ ka　</td>
<td>　き　キ ki　</td>
<td>　く　ク ku　</td>
<td>　け　ケ ke　</td>
<td>　こ　コ　ko</td>
</tr>
<tr>
<td>　さ行 s　</td>
<td>　さ　サ sa　</td>
<td>　し　シ shi　</td>
<td>　す　ス su　</td>
<td>　せ セ　se　</td>
<td>　そ　ソ so　</td>
</tr>
<tr>
<td>　た行 t　</td>
<td>　た タ　ta　</td>
<td>　ち　チ chi　</td>
<td>　つ ツ　tsu　</td>
<td>　て　テ　te</td>
<td>　と　ト to　</td>
</tr>
<tr>
<td>　な行 n　</td>
<td>　な　ナ na　</td>
<td>　に　ニ ni　</td>
<td>　ぬ ヌ　nu　</td>
<td>　ね ネ　ne　</td>
<td>　の　ノ no　</td>
</tr>
<tr>
<td>　は行 h　</td>
<td>　は ハ　ha　</td>
<td>　ひ　ヒ hi　</td>
<td>　ふ フ　fu　</td>
<td>　へ　ヘ　he</td>
<td>　ほ　ホ ho　</td>
</tr>
<tr>
<td>　ま行 m　</td>
<td>　ま　マ ma　</td>
<td>　み　ミ　mi</td>
<td>　む　ム mu　</td>
<td>　め　メ　me　</td>
<td>　も　モ　mo</td>
</tr>
<tr>
<td>　や行 y　</td>
<td>　や　ヤ ya　</td>
<td>　</td>
<td>　ゆ　ユ yu　</td>
<td>　</td>
<td>　よ　ヨ yo　</td>
</tr>
<tr>
<td>　ら行 r　</td>
<td>　ら　ラ ra　</td>
<td>　り　リ ri　</td>
<td>　る　ル ru　</td>
<td>　れ　レ re　</td>
<td>　ろ　ロ ro　</td>
</tr>
<tr>
<td>　わ行 w　</td>
<td>　わ　ワ wa　</td>
<td>　</td>
<td>　</td>
<td>　</td>
<td>　を　ヲ wo　</td>
</tr>
<tr>
<td>　</td>
<td>　ん　ン n　</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="1-2-拨音-ん"><a href="#1-2-拨音-ん" class="headerlink" title="1.2 拨音 (ん)"></a>1.2 拨音 (ん)</h3><table>
<thead>
<tr>
<th>后续音节</th>
<th>实际发音</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>ぱ、ば、ま行</td>
<td>/m/</td>
<td>　さんぽ、しんぶん、うんめい、こんぶ、かんぶ　</td>
</tr>
<tr>
<td>た、だ、ら、な行</td>
<td>/n/</td>
<td>　ほんとう、もんだい、ほんらい、しんねん、こんど、すんな　</td>
</tr>
<tr>
<td>其它或词尾</td>
<td>/ng/</td>
<td>　へんか、あんしん、れんあい、まんが、バン、おんせん　</td>
</tr>
</tbody>
</table>
<h3 id="1-3-浊音"><a href="#1-3-浊音" class="headerlink" title="1.3 浊音"></a>1.3 浊音</h3><table>
<thead>
<tr>
<th>が行 g</th>
<th>　が　ガ ga　</th>
<th>　ぎ　ギ　gi</th>
<th>　ぐ　グ gu　</th>
<th>　げ　ゲ ge　</th>
<th>　ご　ゴ go　</th>
</tr>
</thead>
<tbody>
<tr>
<td>ざ行 z</td>
<td>　ざ　ザ za　</td>
<td>　じ　ジ zi　</td>
<td>　ず　ズ zu　</td>
<td>　ぜ　ゼ ze　</td>
<td>　ぞ　ゾ zo　</td>
</tr>
<tr>
<td>だ行 d</td>
<td>　だ　ダ da　</td>
<td>　ぢ　ヂ zi　</td>
<td>　づ　ヅ zu　</td>
<td>　で　デ de　</td>
<td>　ど　ド do　</td>
</tr>
<tr>
<td>ば行 b</td>
<td>　ば　バ ba　</td>
<td>　び　ビ bi　</td>
<td>　ぶ　ブ bu　</td>
<td>　べ　ベ be　</td>
<td>　ぼ　ボ bo　</td>
</tr>
</tbody>
</table>
<h3 id="1-4-半浊音"><a href="#1-4-半浊音" class="headerlink" title="1.4 半浊音"></a>1.4 半浊音</h3><table>
<thead>
<tr>
<th>ぱ行 p</th>
<th>　ぱ pa　</th>
<th>　ぴ　pi</th>
<th>　ぷ pu　</th>
<th>　ぺpe　</th>
<th>　ぽ　po</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>　パ　</td>
<td>　ピ</td>
<td>　プ　</td>
<td>　ペ　</td>
<td>　ポ</td>
</tr>
</tbody>
</table>
<h3 id="1-5-拗音"><a href="#1-5-拗音" class="headerlink" title="1.5 拗音"></a>1.5 拗音</h3><p>拗音是在“い段”假名后面加上复元音“や”、“ゆ”、“よ”拼成的音节。拗音符号是把“や”、“ゆ”、“よ”写在“い段”假名的右下角。把拗音自动拉长一拍就是拗长音。</p>
<table>
<thead>
<tr>
<th>きゃ　キャ kya</th>
<th>きゅ　キュ kyu</th>
<th>きょ　キョ kyo</th>
</tr>
</thead>
<tbody>
<tr>
<td>しゃ　シャ sha</td>
<td>しゅ　シュ shu</td>
<td>しょ　ショ sho</td>
</tr>
<tr>
<td>ちゃ　チャ cha</td>
<td>ちゅ　チュ chu</td>
<td>ちょ　チョ cho</td>
</tr>
<tr>
<td>にゃ　ニャ nya</td>
<td>にゅ　ニュ nyu</td>
<td>にょ　ニョ nyo</td>
</tr>
<tr>
<td>ひゃ　ヒャ hya</td>
<td>ひゅ　ヒュ hyu</td>
<td>ひょ　ヒョ hyo</td>
</tr>
<tr>
<td>みゃ　ミャ mya</td>
<td>みゅ　ミュ myu</td>
<td>みょ　ミョ myo</td>
</tr>
<tr>
<td>りゃ　リャ rya</td>
<td>りゅ　リュ ryu</td>
<td>りょ　リョ ryo</td>
</tr>
<tr>
<td>ぎゃ　ギャ gya</td>
<td>ぎゅ　ギュ gyu</td>
<td>ぎょ　ギョ gyo</td>
</tr>
<tr>
<td>じゃ　ジャ ja</td>
<td>じゅ　ジュ ju</td>
<td>じょ　ジョ jo</td>
</tr>
<tr>
<td>ぢゃ　ヂャ dya</td>
<td>ぢゅ　ヂュ dyu</td>
<td>ぢょ　ヂョ dyo</td>
</tr>
<tr>
<td>びゃ　ビャ bya</td>
<td>びゅ　ビュ byu</td>
<td>びょ　ビョ byo</td>
</tr>
<tr>
<td>ぴゃ　ピャ pya</td>
<td>ぴゅ　ピュ pyu</td>
<td>ぴょ　ピョ pyo</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong></p>
<p>1）が行假名出现在单词首位置，发本音（浊音）；若出现在单词其他位置，发鼻浊音。</p>
<p>2）か行和た行假名出现在单词首位置，发本音（清音）；若出现在其他位置，发近对应的浊音。</p>
<p>3）ぱ行假名出现在单词首位置，发本音（半浊音）；若出现在其他位置，发ば行对应的音。</p>
<h2 id="2-促音"><a href="#2-促音" class="headerlink" title="2 促音"></a>2 促音</h2><p>发音时用发音器官某一部分堵住呼吸，形成一个短促的顿挫，然后放开堵塞使呼气急冲而出，这种音节叫“促音”，用小“つ”表示，即“っ”。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>促音+か行假名</td>
<td>かっこ、がっき、じっけん、せっけん、はっけん、みっか</td>
</tr>
<tr>
<td>促音+さ行假名</td>
<td>あっさり、けっせき、ざっし、じっせん、しっそ、ねっしん</td>
</tr>
<tr>
<td>促音+た行假名</td>
<td>ねったい、おっと、ずっと、ぜったい、はってん、まったく</td>
</tr>
<tr>
<td>促音+ぱ行假名</td>
<td>いっぱい、いっぺん、じっぴ、じっぷん、にっぽん、りっぱ</td>
</tr>
</tbody>
</table>
<h2 id="3-长音"><a href="#3-长音" class="headerlink" title="3 长音"></a>3 长音</h2><table>
<thead>
<tr>
<th>长音规则</th>
<th>示例</th>
<th>特例</th>
</tr>
</thead>
<tbody>
<tr>
<td>あ段假名后加あ</td>
<td>おかあさん</td>
<td></td>
</tr>
<tr>
<td>い段假名后加い</td>
<td>おにいさん</td>
<td></td>
</tr>
<tr>
<td>う段假名后加う</td>
<td>ゆうじん</td>
<td></td>
</tr>
<tr>
<td>え段假名后加い，个别场合加え</td>
<td>せんせい</td>
<td>おねえさん、ええ</td>
</tr>
<tr>
<td>お段假名后加う，个别场合加お</td>
<td>おとうさん</td>
<td>大きい、こお、とお</td>
</tr>
<tr>
<td>外来语用ー</td>
<td>メーデー</td>
</tr>
</tbody>
</table>
<h2 id="4-“何”发音"><a href="#4-“何”发音" class="headerlink" title="4 “何”发音"></a>4 “何”发音</h2><h3 id="4-1-なん"><a href="#4-1-なん" class="headerlink" title="4.1 なん"></a>4.1 なん</h3><p>１）だ、で、と（表内容时）、の假名前</p>
<p>何だ、これ？</p>
<p>これは何ですか。</p>
<p>何と読みますか。</p>
<p>これは何の本ですか。</p>
<p>２）数量词前</p>
<p>今日は何曜日ですか。</p>
<h3 id="4-2-なに"><a href="#4-2-なに" class="headerlink" title="4.2 なに"></a>4.2 なに</h3><p>１）に、を、が、か、も假名前</p>
<p>何にしますか。</p>
<p>何を食べますか。</p>
<p>何か食べますか。</p>
<p>何もありません。</p>
<p>何がありますか。</p>
<p>２）专用名词</p>
<p>何学校（がっこう）ですか。</p>
<h2 id="5-教室用语"><a href="#5-教室用语" class="headerlink" title="5 教室用语"></a>5 教室用语</h2><ul>
<li>1）同学们早</li>
</ul>
<p>みなさん、おはようございます。</p>
<ul>
<li>2）同学们上午（下午）好</li>
</ul>
<p>みなさん、こんにちは。</p>
<ul>
<li>3）同学们晚上好</li>
</ul>
<p>みなさん、こんばんは。</p>
<ul>
<li>4）请大声朗读</li>
</ul>
<p>大（だい）きな声（こえ）で読（よ）んでください。</p>
<ul>
<li>5）再来一次</li>
</ul>
<p>もう一度（いちど）。</p>
<ul>
<li>6）请大家写</li>
</ul>
<p>みなさん、書（か）いてください。</p>
<ul>
<li>7）明白了吗？</li>
</ul>
<p>わかりましたか。</p>
<ul>
<li>8）同学们再见</li>
</ul>
<p>みなさん、さようなら。</p>
<ul>
<li>9）老师再见</li>
</ul>
<p>先生（せんせい）、さようなら。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日语以东京音为标准音，其声调可以分为如下几种：0型，①型，②型，③型，④型，⑤型，⑥型和⑦型等。高声调表示重音，低声调表示轻音。&lt;/p&gt;
&lt;p&gt;0型：表示只有第一拍低，其它各拍都高。&lt;/p&gt;
&lt;p&gt;①型：表示只有第一拍高，以下其它各拍都低。&lt;/p&gt;
&lt;p&gt;②型：表示只有第二拍高，第一拍和以下其它各拍都低。&lt;/p&gt;
&lt;p&gt;③型：表示第二拍，第三拍高，第一拍和以下其它各拍都低。&lt;/p&gt;
&lt;p&gt;④型：表示第二拍，第三拍，第四拍高，第一拍和以下其它各拍都低。&lt;/p&gt;
&lt;p&gt;依此类推其它型。&lt;/p&gt;
    
    </summary>
    
      <category term="talk" scheme="http://chars.tech/categories/talk/"/>
    
    
      <category term="碎碎念" scheme="http://chars.tech/tags/text/"/>
    
      <category term="日语" scheme="http://chars.tech/tags/japan-language/"/>
    
  </entry>
  
  <entry>
    <title>sublime text 实用技巧</title>
    <link href="http://chars.tech/2017/03/30/sublime-text-tool/"/>
    <id>http://chars.tech/2017/03/30/sublime-text-tool/</id>
    <published>2017-03-29T23:51:43.000Z</published>
    <updated>2017-07-05T08:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>Sublime Text 是一个代码编辑器（Sublime Text 2是收费软件，但可以无限期试用），也是HTML和散文先进的文本编辑器。Sublime Text是由程序员Jon Skinner于2008年1月份所开发出来，它最初被设计为一个具有丰富扩展功能的Vim。</p>
<p>笔者整理了一些使用快捷方式，以及一些常用插件，分享一下。</p>
<a id="more"></a>
<h2 id="安装包控制（Package-Control）"><a href="#安装包控制（Package-Control）" class="headerlink" title="安装包控制（Package Control）"></a>安装包控制（Package Control）</h2><p>打开Sublime Text 2，按快捷键 ctrl+` 或者点击 Tools → Command Palette 调出控制台Console；<br>将以下代码复制粘贴进命令行后回车：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib2,os;pf=&apos;Package Control.sublime-package&apos;;ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp)elseNone;open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib2.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read())</span><br></pre></td></tr></table></figure>
<p>重新启动Sublime Text 2，如果在Preferences → Package Settings 中看到 Package Control 这一项，就说明安装成功。</p>
<h2 id="安装Alignment插件"><a href="#安装Alignment插件" class="headerlink" title="安装Alignment插件"></a>安装Alignment插件</h2><p>对于喜欢整齐的码农来说，这不失为一个省事的插件。该插件可以通过上面安装好的 Package Control 来安装：</p>
<p>按ctrl + shift + P调出命令面板；</p>
<p>输入 install 调出 Package Control：Install Package 选项，并回车；</p>
<p>输入Alignment，选中并按回车安装；</p>
<p>重启Sublime Text 2，选中文本并按ctrl + alt + a 就可以进行对齐操作了。</p>
<h2 id="安装-Soda-主题"><a href="#安装-Soda-主题" class="headerlink" title="安装 Soda 主题"></a>安装 Soda 主题</h2><p>这里的主题不同于针对代码的 color scheme，而是针对Sublime Text 2该软件本身的主题，该主题也可以通过万能的 Package Control 来安装。</p>
<p>按ctrl + shift + P调出命令面板；</p>
<p>输入 install 调出 Package Control：Install Package 选项，并回车；</p>
<p>输入 theme soda 选中后回车即可安装；</p>
<p>安装完之后要激活主题，打开 Preferences → Global Settings – User，加上以下代码保存即可生效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;theme&quot;: &quot;Soda Light.sublime-theme&quot; 或者 &quot;theme&quot; : &quot;Soda Dark.sublime-theme&quot;</span><br></pre></td></tr></table></figure>
<h2 id="安装cTags插件"><a href="#安装cTags插件" class="headerlink" title="安装cTags插件"></a>安装cTags插件</h2><p>首先，从Ctags官网下载压缩包下来，解压到电脑的某个地方，比如“C:\Program Files\ctags”，然后把cTags添加到系统变量里去：<br>在“我的电脑”右键属性 → 高级 → 环境变量 → 在“系统变量”里找到“Path”，点击“编辑” → 把“;C:\Program Files\ctags”（不包括双引号）复制到最后 → 最后一路“确定”保存。</p>
<p>然后通过 Package Control 来安装 cTags 插件：</p>
<p>按ctrl + shift + P调出命令面板；</p>
<p>输入 install 调出 Package Control：Install Package 选项，并回车；</p>
<p>输入 ctags 选中后回车即可安装。</p>
<p>安装完之后，在项目的当前目录下按ctrl + t, ctrl + r，会生成.tags的文件。当光标停留在某个函数上时，按快捷键 ctrl+t, ctrl+t就可以打开函数所在的文件，并跳转到相应的位置了。</p>
<p><strong>PS</strong> 安装这个插件折腾了我蛮久，主要是不知道还要从ctags官网下载压缩包，以及修改系统的变量，后来还是一博友给我发的国外的参考资料才知道要这样配置 的。刚开始知道这软件之所以没用是因为没有像eclipse可以追踪函数的功能，后来才知道可以通过安装cTags插件来实现。装上此功能后，就更喜欢用 Sublime Text 2了。</p>
<h2 id="jsFormat插件"><a href="#jsFormat插件" class="headerlink" title="jsFormat插件"></a>jsFormat插件</h2><p>格式化js：选中一段文本，control+alt+f。</p>
<p>DocBlockr</p>
<p>在JS函数上方输入/**，然后回车，doc就生成好了非常好用。</p>
<p>sublime-jslint</p>
<p>打开一个js文件，control+j，即可输出jsLint检查的结果。打开Packages目录，找到插件目录sublime-jslint，打开 sublime-jslint.sublime-settings文件，可以修改jsLint配置，还可以配置文件保存时自动检查等，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; // Path to the jslint jar. // Leave blank to use bundled jar. &quot;jslint_jar&quot;: &quot;&quot;,   // Options pass to jslint. // Jerry Qu注：全部可用配置参考这里，https://github.com/fbzhong/sublime-jslint/wiki/Available- jslint4java-options &quot;jslint_options&quot;: &quot;--encoding utf-8 --bitwise --browser --cap --css --devel --debug --evil --forin --fragment --on --sub --white --windows --sloppy&quot;,   // Ignore errors, regex. &quot;ignore_errors&quot;: [ // &quot;Expected an identifier and instead saw &apos;undefined&apos; \(a reserved word\)&quot; ],   // run jslint on save. &quot;run_on_save&quot;: false,   // debug flag. &quot;debug&quot;:false &#125;</span><br></pre></td></tr></table></figure>
<h2 id="SideBarEnhancements"><a href="#SideBarEnhancements" class="headerlink" title="SideBarEnhancements"></a>SideBarEnhancements</h2><p>推荐通过 Package Control 安装 SideBarEnhancements 这个插件，可以大大加强在侧栏目录树中右键的选项</p>
<h2 id="推荐插件："><a href="#推荐插件：" class="headerlink" title="推荐插件："></a>推荐插件：</h2><p>1）Zen Coding</p>
<p>2）jQuery Package for sublime Text</p>
<p>3）Clipboard History</p>
<p>4）Bracket Highlighter</p>
<p>5）GBK to UTF8</p>
<p>6）Git</p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table>
<thead>
<tr>
<th>按键组合</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command+Shift+L</td>
<td>选中多行即可可以同时编辑这些行</td>
</tr>
<tr>
<td>control + Command +G</td>
<td>可以一次性选择全部相同的文件进行同时编辑</td>
</tr>
<tr>
<td>Ctrl+D</td>
<td>选词（反复按快捷键，即可继续向下同时选中下一个相同的文本进行同时编辑）</td>
</tr>
<tr>
<td>Ctrl+G</td>
<td>跳转到相应的行</td>
</tr>
<tr>
<td>Ctrl+J</td>
<td>合并行（已选择需要合并的多行时）</td>
</tr>
<tr>
<td>Ctrl+L</td>
<td>选择整行（按住-继续选择下行）</td>
</tr>
<tr>
<td>Ctrl+M</td>
<td>光标移动至括号内开始或结束的位置</td>
</tr>
<tr>
<td>Ctrl+T</td>
<td>词互换</td>
</tr>
<tr>
<td>Ctrl+U</td>
<td>软撤销</td>
</tr>
<tr>
<td>Ctrl+P</td>
<td>查找当前项目中的文件和快速搜索；输入@查找文件主标题/函数；或者输入:跳转到文件某行；</td>
</tr>
<tr>
<td>Ctrl+R</td>
<td>快速列出/跳转到某个函数</td>
</tr>
<tr>
<td>Ctrl+KBackspace</td>
<td>从光标处删除至行首</td>
</tr>
<tr>
<td>Ctrl+KB</td>
<td>开启/关闭侧边栏</td>
</tr>
<tr>
<td>Ctrl+KK</td>
<td>从光标处删除至行尾</td>
</tr>
<tr>
<td>Ctrl+KT</td>
<td>折叠属性</td>
</tr>
<tr>
<td>Ctrl+KU</td>
<td>改为大写</td>
</tr>
<tr>
<td>Ctrl+KL</td>
<td>改为小写</td>
</tr>
<tr>
<td>Ctrl+K0</td>
<td>展开所有</td>
</tr>
<tr>
<td>Ctrl+Enter</td>
<td>插入行后（快速换行）</td>
</tr>
<tr>
<td>Ctrl+Tab</td>
<td>当前窗口中的标签页切换</td>
</tr>
<tr>
<td>Ctrl+Shift+A</td>
<td>选择光标位置父标签对儿</td>
</tr>
<tr>
<td>Ctrl+Shift+D</td>
<td>复制光标所在整行，插入在该行之前</td>
</tr>
<tr>
<td>ctrl+shift+F</td>
<td>在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找</td>
</tr>
<tr>
<td>Ctrl+Shift+K</td>
<td>删除整行</td>
</tr>
<tr>
<td>Ctrl+Shift+L</td>
<td>鼠标选中多行（按下快捷键），即可同时编辑这些行</td>
</tr>
<tr>
<td>Ctrl+Shift+M</td>
<td>选择括号内的内容（按住-继续选择父括号）</td>
</tr>
<tr>
<td>Ctrl+Shift+P</td>
<td>打开命令面板</td>
</tr>
<tr>
<td>Ctrl+Shift+/</td>
<td>注释已选择内容</td>
</tr>
<tr>
<td>Ctrl+Shift+↑</td>
<td>可以移动此行代码，与上行互换</td>
</tr>
<tr>
<td>Ctrl+Shift+↓</td>
<td>可以移动此行代码，与下行互换</td>
</tr>
<tr>
<td>Ctrl+Shift+[</td>
<td>折叠代码</td>
</tr>
<tr>
<td>Ctrl+Shift+]</td>
<td>展开代码</td>
</tr>
<tr>
<td>Ctrl+Shift+Enter</td>
<td>光标前插入行</td>
</tr>
<tr>
<td>Ctrl+PageDown、Ctrl+PageUp</td>
<td>文件按开启的前后顺序切换</td>
</tr>
<tr>
<td>Ctrl+Z</td>
<td>撤销</td>
</tr>
<tr>
<td>Ctrl+Y</td>
<td>恢复撤销</td>
</tr>
<tr>
<td>Ctrl+F2</td>
<td>设置书签</td>
</tr>
<tr>
<td>Ctrl+/</td>
<td>注释整行（如已选择内容，同“Ctrl+Shift+/”效果）</td>
</tr>
<tr>
<td>Ctrl+鼠标左键</td>
<td>可以同时选择要编辑的多处文本</td>
</tr>
<tr>
<td>Shift+鼠标右键（或使用鼠标中键）</td>
<td>可以用鼠标进行竖向多行选择</td>
</tr>
<tr>
<td>Shift+F2</td>
<td>上一个书签</td>
</tr>
<tr>
<td>Shift+Tab</td>
<td>去除缩进</td>
</tr>
<tr>
<td>Alt+Shift+1~9（非小键盘）</td>
<td>屏幕显示相等数字的小窗口</td>
</tr>
<tr>
<td>Alt+.</td>
<td>闭合当前标签</td>
</tr>
<tr>
<td>Alt+F3</td>
<td>选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑</td>
</tr>
<tr>
<td>Tab</td>
<td>缩进,自动完成</td>
</tr>
<tr>
<td>F2</td>
<td>下一个书签</td>
</tr>
<tr>
<td>F6</td>
<td>检测语法错误</td>
</tr>
<tr>
<td>F9</td>
<td>行排序(按a-z)</td>
</tr>
<tr>
<td>F11</td>
<td>全屏模式</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sublime Text 是一个代码编辑器（Sublime Text 2是收费软件，但可以无限期试用），也是HTML和散文先进的文本编辑器。Sublime Text是由程序员Jon Skinner于2008年1月份所开发出来，它最初被设计为一个具有丰富扩展功能的Vim。&lt;/p&gt;
&lt;p&gt;笔者整理了一些使用快捷方式，以及一些常用插件，分享一下。&lt;/p&gt;
    
    </summary>
    
      <category term="talk" scheme="http://chars.tech/categories/talk/"/>
    
    
      <category term="工具" scheme="http://chars.tech/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>想说说文章版权</title>
    <link href="http://chars.tech/2017/03/29/article-copyright/"/>
    <id>http://chars.tech/2017/03/29/article-copyright/</id>
    <published>2017-03-29T06:04:50.000Z</published>
    <updated>2017-07-05T08:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章版权，这个词汇以前笔者以前是不怎么有体会的，认为在当今互联网的时代，随便网上Google一下很多地方的文章如出一辙，而作者也是千奇百怪，甚至都不清楚谁才是作者。这篇文章，笔者是遇见了真实的事件，现在很想说一说，看看大家是否也是一样，认为一个版权意识高的视界里，资源与时间都是高效的。不用在看一条，两条都是一样的，浪费时间和资源。</p>
<p>不知道是否有人明白什么叫“版权”。说实在的，笔者并不是很清楚它的定义。这里引入百科的解释：</p>
<blockquote>
<p>版权（copyright）是用来表述创作者因其文学和艺术作品而享有的权利的一个法律用语。</p>
<p>版权是对计算机程序、文学著作、音乐作品、照片、电影等的复制权利的合法所有权。除非转让给另一方，版权通常被认为是属于作者的。大多数计算机程序不仅受到版权的保护，还受软件许可证的保护。版权只保护思想的表达形式，而不保护思想本身。算法、数学方法、技术或机器的设计均不在版权的保护之列。</p>
</blockquote>
<a id="more"></a>
<p>这个是属于法律领域了，只不过在天朝，大家都不认为这是事儿。不过现在好了，慢慢的付费阅读，付费视频等等开始流行，这样大家虽然花了米米，不过质量却是有了保证。</p>
<p>说回这篇文章的初衷，就是在这两天，笔者遇到了自己博客网站的文章别他人拿去分享，并攫取了利益。更巧的是，被笔者知道了。曾经在知乎一个问答里看见，关于招聘，面试官会直接pass掉那些抄袭他们文章的应聘者。看到之后笔者将自己转载，并备注了“转载”二字的文章删除干净。不错，或许笔者没有从中获利，不过确实有些文章是没有联系到作者的，虽然给了原链接，可是确实吸引了眼球。</p>
<p>现在，保证文章都是原创，无论深浅文雅如何，总归是自己的作品。相反，在不断撰写过程中，会发现很多自身的漏洞。网络已经很发达了，大家都能在网上找到自己需要的文章，干嘛还要做搬运工呢，笔者认为，高手应该转载于无形，即看懂原文加上自己的思考，想必比简单的复制拷贝要有价值得多。</p>
<p>笔者之前在一个“同行说”的平台分享自己的文章，后来转行了，渐渐时间少了，也就远离了一段时间的撰文。现在，又要安利大家了，这款<a href="https://toutiao.io/" target="_blank" rel="external">开发者头条</a>，内容不错，文章也很是有质量，笔者使用pocket已经收藏了不少好文。不过，这篇文章的始因也是源于此平台。平台有激励作者自荐的机制，积分商城应该算得上为数不多的几家良心公司。为此，笔者有空会创作原创，因为这样才能登上文章精选的列表。</p>
<p>可是，不得不说的一点是，平台没有很好的原创保护机制。笔者作为一个技术人员。看到几点问题：</p>
<p>1.平台有精选文章缓存。这样的后果就是，即使作者发现了自己文章的错误，修改之后还是不能同步到精选文章列表。</p>
<p>2.对于原创和非原创没有好的保护与甄别，除非巧合遇到像笔者这样的情况，且还是个较真的人。</p>
<p>3.软件聊天体验有待提高。emoji发送太麻烦，iOS平台必须依赖系统键盘的发送。Android端没有用过不清楚。</p>
<p>第一个问题，笔者建议可以使用定时机制，一段时间检测分享链接的内容，这样也能很好的保护原创。当原创作者发现自己的文章被他人肆意分享，只需改变文章地址即可令其失效。这样也就不存在原创甄别问题了。还保证了文章内容的同步。</p>
<p>第二个问题，技术不是问题，关键是否会为这个的细节付出时间。</p>
<p>不过，笔者自己也想过使用什么方式能够避免这样的问题，URL混淆？反爬虫？不知道是否可行。不过迫于无奈，现在笔者的文章顶部都加了一条申明。其实就是小偷和锁的问题，是否有效只取决于剽窃者。</p>
<p>最后，很感谢平台的及时沟通和处理，为笔者补回了损失。不过，却便宜了剽窃者。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章版权，这个词汇以前笔者以前是不怎么有体会的，认为在当今互联网的时代，随便网上Google一下很多地方的文章如出一辙，而作者也是千奇百怪，甚至都不清楚谁才是作者。这篇文章，笔者是遇见了真实的事件，现在很想说一说，看看大家是否也是一样，认为一个版权意识高的视界里，资源与时间都是高效的。不用在看一条，两条都是一样的，浪费时间和资源。&lt;/p&gt;
&lt;p&gt;不知道是否有人明白什么叫“版权”。说实在的，笔者并不是很清楚它的定义。这里引入百科的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;版权（copyright）是用来表述创作者因其文学和艺术作品而享有的权利的一个法律用语。&lt;/p&gt;
&lt;p&gt;版权是对计算机程序、文学著作、音乐作品、照片、电影等的复制权利的合法所有权。除非转让给另一方，版权通常被认为是属于作者的。大多数计算机程序不仅受到版权的保护，还受软件许可证的保护。版权只保护思想的表达形式，而不保护思想本身。算法、数学方法、技术或机器的设计均不在版权的保护之列。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="talk" scheme="http://chars.tech/categories/talk/"/>
    
    
      <category term="碎碎念" scheme="http://chars.tech/tags/text/"/>
    
  </entry>
  
</feed>
