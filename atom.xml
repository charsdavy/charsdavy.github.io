<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chars&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://charsdavy.github.io/"/>
  <updated>2017-04-21T07:45:04.000Z</updated>
  <id>http://charsdavy.github.io/</id>
  
  <author>
    <name>Chars</name>
    <email>chars.davy@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什么是iOS的安全模式</title>
    <link href="http://charsdavy.github.io/2017/04/19/ios-security-pattern/"/>
    <id>http://charsdavy.github.io/2017/04/19/ios-security-pattern/</id>
    <published>2017-04-19T15:18:42.000Z</published>
    <updated>2017-04-21T07:45:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为iOS开发，作品App肯定需要提交到App Store审核。平心而论，App Store确实成功地将许多恶意软件拒之门外。但是，对开发者而言，应用程序的审核流程是令人沮丧的黑箱操作。</p>
<p>当然，什么是恶意程序是由Apple来定义。因为App Store的存在，所以，如果想要实现某些特定的功能，唯一的手段就是将设备越狱或者骗过App Store的审查。</p>
<p>官方的App审查永远无法抓到那些钻空子的恶意程序，所以需要另外一套高效的机制，来阻止恶意程序破坏整个操作系统的安全。</p>
<a id="more"></a>
<h2 id="安全启动"><a href="#安全启动" class="headerlink" title="安全启动"></a>安全启动</h2><p>当启动一台iOS设备时，系统首先会从只读的引导ROM中读取初始化指令，即系统引导程序。这个引导ROM包含Apple官方权威认证的公钥，它会验证底层启动加载器（LLB）的签名，一旦通过验证就启动它。</p>
<p>然后验证第二级引导程序iBoot，iBoot启动后设备就可以进入恢复模式或启动内核。在iBoot验证完成内核签名的合法性之后，整个启动程序开始步入正轨：加载驱动程序、检测设备、启动系统守护进程。</p>
<p>这个信任链确保所有的系统组件都由Apple写入、签名、分发，不能来自第三方机构，特别是那些恶意的攻击者以及企图越狱设备的黑客。App启动时也会用信任链去审查签名。所有的App都必须直接或间接由Apple签名。</p>
<p>越狱工作的原理正是攻击这一信任链。越狱工具的作者需要找到这一信任链条上的漏洞，从而禁掉链条中负责验证的组件。破解引导ROM通常是最可取的方法，因为该组件不会因Apple今后的软件更新而改变。</p>
<p>有关更多签名知识可以参看：</p>
<p><a href="http://wereadteam.github.io/2017/03/13/Signature/" target="_blank" rel="external">《iOS App 签名的原理》</a></p>
<h2 id="沙盒机制"><a href="#沙盒机制" class="headerlink" title="沙盒机制"></a>沙盒机制</h2><p>App的沙盒机制是一种基于FreeBSD系统TrustedBSD框架的强制访问控制（MAC）机制，它采用一种类似于Lisp的配置语言来描述哪些资源系统可以访问，哪些禁止访问。这些资源主要包括文件、系统服务、网络连接、内存资源等。</p>
<p>MAC机制不同于传统的访问控制机制（比如自主访问控制（DAC）），它不允许主体（比如用户进程）操作对象（文件、套接字等）。DAC最常见的形式就是UNIX系统上的用户、组和其它权限，所有这些都可以被授予读、写或执行的权限。在DAC系统中，用户如果拥有一个对象的所有权，也就拥有该对象的修改权限。</p>
<p>MAC在沙盒中意味着App被关进了一个虚拟的容器。该容器遵循一系列的特定规则，即哪些系统资源可以访问。</p>
<p>在文件访问方面，一般只能访问App的包目录；App可以读写存储在该位置的文件。</p>
<p>Android的访问控制机制与MAC不同。Android实现了一个更加传统的DAC模型，App都有自己的用户ID和属于该ID的文件夹，其权限管理严格按照传统的UNIX文件权限管理运作。虽然这两项机制工作起来都没有问题，但MAC的扩展性总体来说还是更强一些。比如，除了App目录隔离，MAC机制还可以限制网络访问或系统守护进程的操作。</p>
<h2 id="数据保护和全盘加密"><a href="#数据保护和全盘加密" class="headerlink" title="数据保护和全盘加密"></a>数据保护和全盘加密</h2><p>数据保护和全盘加密两机制可以实现远程抹除设备数据，在设备丢失的情况下保护用户数据免于泄漏。</p>
<p>文件系统加密并不能防止从一个正在运行的设备上窃取数据的行为。如果一个App可以从磁盘中读取一个文件，那文件系统加密并没有任何用武之处，因为内核对于任何尝试读取这些文件的进程都是透明解密的。换句话说，相比那些读取文件的调用行为，文件系统加密工作都是更底层。一旦攻破者攻破了系统验证，那就能无障碍地读取任意文件。</p>
<p>全盘加密对于以下两个安全特性是必要的：安全删除文件、远程设备擦出。iOS中使用的加密密钥是分层级的，只需要简单丢弃一个加密密钥就能彻底销毁整层的数据，甚至是销毁整个文件系统。</p>
<h2 id="加密密钥的层级"><a href="#加密密钥的层级" class="headerlink" title="加密密钥的层级"></a>加密密钥的层级</h2><p>iOS文件系统中用于数据加密的密钥是分等级的，即用密钥来加密其它密钥，这样Apple就能更精确的控制数据什么时候可用。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-security-pattarn-01.png" alt="加密密钥层级图"></p>
<p>文件密钥（File Key）针对每个文件独立生成，存储在文件的元数据中。</p>
<p>层级密钥（Class Key）为数据提供不同级别的保护。</p>
<p>文件系统密钥（Filesystem Key）是一种全局加密密钥，当元数据被层级密钥加密后，使用文件系统密钥来加密涉及文件安全的元数据。</p>
<p>设备密钥（Device Key）通常被称为UID密钥，每台设备唯一，只能通过硬件的AES引擎访问，操作系统无法直接获取。它是系统的主密钥，用来加密文件系统密钥和层级密钥。</p>
<p>用户密码（User Passcode），可与设备密钥结合起来加密层级密钥。</p>
<p>一旦设置密码，这个密钥等级也允许开发者自己决定本地存储的数据该如何保护，包括在设备锁定时是否能被访问、数据能否备份到其它设备等。</p>
<h2 id="ASLR和XN及其它机制"><a href="#ASLR和XN及其它机制" class="headerlink" title="ASLR和XN及其它机制"></a>ASLR和XN及其它机制</h2><p>iOS用两套标准机制来预防代码执行攻击：地址空间结构随机化（ASLR）和XN bit（eXecute Never，标记该段内存区域不包含可执行代码）。</p>
<p>每次执行程序时，ASLR都会随机分配程序、数据、堆和栈的内存位置。而共享库的内存地址只在每次系统重启时随机设置，因为共享库需要在多个进程中使用。ALSR机制可以预防缓存区移除攻击（return-to-libc），因为函数和库的内存地址随机，而这种攻击依赖于基本库和函数的已知地址。</p>
<p>XN bit，一般对应非ARM平台的NX（No-eXecute）bit，允许操作系统将某段内存标记为不可执行，这由CPU来控制。在iOS中，这个机制默认应用在程序的栈和堆上。</p>
<p>每个程序都有一段可写可执行的内存，但是它必须是经过Apple官方签名授权系统的签名。Safari浏览器中的JavaScript即时（JIT, Just-in-time）编译器会用到这段内存。而WebView并不具备JIT功能，这样虽然可以避免代码执行攻击，但是也使得iOS平台上的Chrome无法做到像Safari那样好用。</p>
<h2 id="越狱检测"><a href="#越狱检测" class="headerlink" title="越狱检测"></a>越狱检测</h2><p>越狱的本质就是通过一系列步骤来禁掉签名机制，从而允许设备运行未经Apple官方审核的应用。黑箱测试应用程序是越狱的重要能力。</p>
<p>其实，越狱不一定要禁掉iOS的沙盒机制，它只是允许你在沙盒外安装App。安装在移动用户主目录下的App（即通过App Store安装）仍然受到沙盒限制。第三方的App需要安装在越狱设备中权限更高的<code>/Applications</code>目录下，与Apple股票应用安装在一起。</p>
<h2 id="动态修复"><a href="#动态修复" class="headerlink" title="动态修复"></a>动态修复</h2><p>一般来说，如果一段原生代码没有经过Apple发布的密钥签名认证，App则无法运行它。如果Apple的签名验证逻辑中存在bug或漏洞，可能会允许下载和执行原生代码。</p>
<p>iOS有一个特性，可以让程序分配一段没有NX保护的内存区块（该内存区块可读、可写，甚至可执行），里面运行的代码也不需要经过签名认证。这个机制在Safari上的JIT编译器上使用。这个运用场景中，就可能会产生漏洞，业界著名的例子就是Charlie Miller。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为iOS开发，作品App肯定需要提交到App Store审核。平心而论，App Store确实成功地将许多恶意软件拒之门外。但是，对开发者而言，应用程序的审核流程是令人沮丧的黑箱操作。&lt;/p&gt;
&lt;p&gt;当然，什么是恶意程序是由Apple来定义。因为App Store的存在，所以，如果想要实现某些特定的功能，唯一的手段就是将设备越狱或者骗过App Store的审查。&lt;/p&gt;
&lt;p&gt;官方的App审查永远无法抓到那些钻空子的恶意程序，所以需要另外一套高效的机制，来阻止恶意程序破坏整个操作系统的安全。&lt;/p&gt;
    
    </summary>
    
      <category term="pieces" scheme="http://charsdavy.github.io/categories/pieces/"/>
    
    
      <category term="ios" scheme="http://charsdavy.github.io/tags/ios/"/>
    
      <category term="安全" scheme="http://charsdavy.github.io/tags/security/"/>
    
      <category term="读书笔记" scheme="http://charsdavy.github.io/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊iOS的那些生命周期</title>
    <link href="http://charsdavy.github.io/2017/04/11/ios-lifecycle/"/>
    <id>http://charsdavy.github.io/2017/04/11/ios-lifecycle/</id>
    <published>2017-04-11T09:07:18.000Z</published>
    <updated>2017-04-12T12:09:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS应用程序的生命周期，还有程序是运行在前台还是后台，应用程序各个状态的变换，这些对于开发者来说都是很重要的。iOS系统的资源是有限的，应用程序在前台和在后台的状态是不一样的。在后台时，程序会受到系统的很多限制，这样可以提高电池的使用和用户体验。</p>
<p>本文所要说到的生命周期，也不仅仅只是应用生命周期；还包括，视图生命周期。</p>
<a id="more"></a>
<h2 id="应用生命周期"><a href="#应用生命周期" class="headerlink" title="应用生命周期"></a>应用生命周期</h2><p>iOS的应用程序一共有5种状态:</p>
<ul>
<li>Not Running(非运行状态)</li>
</ul>
<p>应用没有运行或被系统终止。</p>
<ul>
<li>Inactive(前台非活动状态)</li>
</ul>
<p>应用正在进入前台状态，但是还不能接受事件处理。</p>
<ul>
<li>Active(前台活动状态)</li>
</ul>
<p>应用进入前台状态，能接受事件处理。</p>
<ul>
<li>Background(后台状态)</li>
</ul>
<p>应用进入后台后，依然能够执行代码。如果有可执行的代码，就会执行代码，如果没有可执行的代码或者将可执行的代码执行完毕，应用会马上进入挂起状态。有的程序经过特殊的请求后可以长期处于Backgroud状态。</p>
<ul>
<li>Suspended(挂起状态)</li>
</ul>
<p>处于挂起的应用进入一种“冷冻”状态,不能执行代码。如果系统内存不够,系统就把挂起的程序清除掉，为前台程序提供更多的内存，应用会被终止。</p>
<p>作为应用程序的委托对象，AppDelegate类在应用生命周期的不同阶段会回调不同的方法。首先，让我们先了解一下iOS 应用的不同状态及它们彼此间的关系，如下图所示 ：</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-app-lifecycle-1.png" alt=""></p>
<p>在应用状态跃迁的过程中，iOS 系统会回调AppDelegate中的一些方法，并且发送一些通知。实际上，在应用的生命周期中用到的方法和通知很多，我们选取了几个主要的方法和通知进行详细介绍，具体如下表所述：</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-app-lifecycle-2.jpeg" alt=""></p>
<p>为了便于观察应用程序的运行状态，为AppDelegate.m中的方法添加一些日志输出，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@implementation AppDelegate </span><br><span class="line">  </span><br><span class="line">- (BOOL)application:(UIApplication *)application </span><br><span class="line">    didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;application:didFinishLaunchingWithOptions:&quot;);</span><br><span class="line"> </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">- (void)applicationWillResignActive:(UIApplication *)application&#123;    </span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;applicationWillResignActive:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application&#123;    </span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;applicationDidEnterBackground:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)applicationWillEnterForeground:(UIApplication *)application&#123;    </span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;applicationWillEnterForeground:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)applicationDidBecomeActive:(UIApplication *)application&#123;    </span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;applicationDidBecomeActive:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)applicationWillTerminate:(UIApplication *)application&#123;    </span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;applicationWillTerminate:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>为了让大家更直观地了解各状态与其相应的方法、通知间的关系，下面以几个应用场景为切入点进行系统的分析。</p>
<h3 id="（一）非运行状态——应用启动场景"><a href="#（一）非运行状态——应用启动场景" class="headerlink" title="（一）非运行状态——应用启动场景"></a>（一）非运行状态——应用启动场景</h3><p>场景描述：用户点击应用图标的时候，可能是第一次启动这个应用，也可能是应用终止后再次启动。该场景的状态跃迁过程见下图，共经历两个阶段3个状态：Not running →Inactive→Active。 </p>
<ul>
<li>1)在Not running→Inactive 阶段。</li>
</ul>
<p>调用<code>application:didFinishLaunchingWithOptions:</code>方法，发出<code>UIApplicationDidFinishLaunchingNotification</code> 通知。 </p>
<ul>
<li>2)在Inactive →Active 阶段。</li>
</ul>
<p>调用 <code>applicationDidBecomeActive:</code>方法，发出<code>UIApplicationDidBecomeActiveNotification</code> 通知。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-app-lifecycle-3.png" alt=""></p>
<h3 id="（二）点击Home键——应用退出场景"><a href="#（二）点击Home键——应用退出场景" class="headerlink" title="（二）点击Home键——应用退出场景"></a>（二）点击Home键——应用退出场景</h3><p>场景描述：应用处于运行状态（即Active状态）时，点击Home键或者有其他的应用导致当前应用中断。该场景的状态跃迁过程可以分成两种情况：可以在后台运行或者挂起，不可以在后台运行或者挂起。根据产品属性文件（如HelloWorld-Info.plist）中的相关属性Application does not run in background 是与否可以控制这两种状态。如果采用文本编辑器打开HelloWorldInfo.plist文件该设置项对应的键是UIApplicationExitsOnSuspend。　</p>
<p>状态跃迁的第一种情况：应用可以在后台运行或者挂起，该场景的状态跃迁过程见下图 ，共经历3 个阶段4个状态：Active → Inactive → Background→Suspended。 </p>
<ul>
<li>1)在Active→Inactive 阶段。</li>
</ul>
<p>调用 <code>applicationWillResignActive:</code>方法，发出<code>UIApplicationWillResignActiveNotification</code> 通知。 </p>
<ul>
<li>2)在Inactive →Background阶段。</li>
</ul>
<p>应用从非活动状态进入到后台（不涉及我们要重点说明的方法和通知）。 </p>
<ul>
<li>3)在Background→Suspended 阶段。</li>
</ul>
<p>调用<code>applicationDidEnterBackground:</code>方法，发出<code>UIApplicationDidEnterBackgroundNotification</code> 通知。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-app-lifecycle-4.png" alt=""></p>
<p>状态跃迁的第二种情况：应用不可以在后台运行或者挂起，其状态跃迁情况见下图 ，共经历4个阶段5 个状态：Active  → Inactive  → Background→Suspended→Not running 。</p>
<ul>
<li>1)在Active →Inactivd 阶段。</li>
</ul>
<p>应用由活动状态转为非活动状态（不涉及我们要重点说明的方法和通知）。 </p>
<ul>
<li>2)在Inactive →Background阶段。</li>
</ul>
<p>应用从非活动状态进入到后台（不涉及我们要重点说明的方法和通知）。 </p>
<ul>
<li>3)在Background→Suspended 阶段。</li>
</ul>
<p>调用<code>applicationDidEnterBackground:</code>方法， 发出<code>UIApplicationDidEnterBackgroundNotification</code>通知。</p>
<ul>
<li>4)在Suspended →Not running阶段。</li>
</ul>
<p>调用<code>applicationWillTerminate:</code>方法，发出<code>UIApplicationWillTerminateNotification</code>通知。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-app-lifecycle-5.png" alt=""></p>
<p>iOS 在iOS 4之前不支持多任务，点击Home键时，应用会退出并中断；而在iOS 4之后（包括iOS 4），操作系统能够支持多任务处理，点击Home键应用会进入后台但不会中断（内存不够的情况除外）。 </p>
<p>应用在后台也可以进行部分处理工作，处理完成则进入挂起状态。</p>
<h3 id="（三）挂起重新运行场景"><a href="#（三）挂起重新运行场景" class="headerlink" title="（三）挂起重新运行场景"></a>（三）挂起重新运行场景</h3><p>场景描述：挂起状态的应用重新运行。该场景的状态跃迁过程如下图所示，共经历3 个阶段4 个状态：Suspended  → Background  → Inactive  → Active 。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-app-lifecycle-6.png" alt=""></p>
<ul>
<li>1)Suspended→Background阶段。</li>
</ul>
<p>应用从挂起状态进入后台（不涉及我们讲述的这几个方法和通知）。 </p>
<ul>
<li>2)Background→Inactive 阶段。</li>
</ul>
<p>调用<code>applicationWillEnterForeground:</code>方法，发出<code>UIApplicationWillEnterForegroundNotification</code>通知。 </p>
<ul>
<li>3)Inactive →Active 阶段。</li>
</ul>
<p>调用<code>applicationDidBecomeActive:</code>方法，发出<code>UIApplicationDidBecomeActiveNotification</code> 通知。</p>
<h3 id="（四）内存清除——应用终止场景"><a href="#（四）内存清除——应用终止场景" class="headerlink" title="（四）内存清除——应用终止场景"></a>（四）内存清除——应用终止场景</h3><p>场景描述：应用在后台处理完成时进入挂起状态（这是一种休眠状态），如果这时发出低内存警告，为了满足其他应用对内存的需要，该应用就会被清除内存从而终止运行，该场景的状态跃迁见下图 。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-app-lifecycle-7.png" alt=""></p>
<p>内存清除的时候应用终止运行。内存清除有两种情况，可能是系统强制清除内存，也可能是由使用者从任务栏中手动清除（即删掉应用）。内存清除后如果应用再次运行，上一次的运行状态不会被保存，相当于应用第一次运行。</p>
<p>在内存清除场景下，应用不会调用任何方法，也不会发出任何通知。</p>
<h2 id="视图生命周期"><a href="#视图生命周期" class="headerlink" title="视图生命周期"></a>视图生命周期</h2><p>视图是应用的一个重要组成部分，功能的实现与其息息相关，而视图控制器控制着视图，其重要性在整个应用中不言而喻。</p>
<h3 id="视图生命周期与视图控制器关系"><a href="#视图生命周期与视图控制器关系" class="headerlink" title="视图生命周期与视图控制器关系"></a>视图生命周期与视图控制器关系</h3><p>以视图的4 种状态为基础，我们来系统了解一下视图控制器的生命周期。在视图不同的生命周期中，视图控制器会回调不同的方法，具体如下图所示。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-ui-lifecycle-1.png" alt=""></p>
<p>在视图控制器已被实例化，视图被加载到内存中时调用viewDidLoad方法，这个时候视图并未出现。在该方法中，通常进行的是对所控制的视图进行初始化处理。 </p>
<p>视图可见前后会调用<code>viewWillAppear:</code>方法和<code>viewDidAppear:</code> 方法；视图不可见前后会调用<code>viewWillDisappear:</code> 方法和<code>viewDidDisappear:</code>方法。4个方法调用父类相应的方法以实现其功能，编码时该方法的位置可根据实际情况做以调整，参见如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(void)viewWillAppear:(BOOL)animated&#123;</span><br><span class="line">    [super viewWillAppear:YES];</span><br><span class="line">    //something code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>viewDidLoad</code> 方法在应用运行的时候只调用一次，而这上述4 个方法可以被反复调用多次，它们的使用很广泛但同时也具有很强的技巧性。例如，有的应用会使用重力加速计，重力加速计会不断轮询设备以实时获得设备在z 轴、x 轴和y轴方向的重力加速度。不断的轮询必然会耗费大量电能进而影响电池使用寿命，我们通过利用这4个方法适时地打开或者关闭重力加速计来达到节约电能的目的。怎么使用这4 个方法才能做到“适时”是一个值得思考的问题。 </p>
<p>在低内存情况下，iOS 会调用<code>didReceiveMemoryWarning:</code> 和<code>viewDidUnload:</code>方法。在iOS 6 之后，就不再使用<code>viewDidUnload:</code>，而仅支持<code>didReceiveMemoryWarning：</code>。</p>
<p><code>didReceiveMemoryWarning:</code>方法的主要职能是释放内存，包括视图控制器中的一些成员变量和视图的释放。现举例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    self.button = nil;</span><br><span class="line">    self.myStringD = nil; </span><br><span class="line">    [myStringC release];    //ARC内存管理情况下不用</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了上述5 个方法视图控制器外，还有很多其他方法。</p>
<h3 id="iOS-UI-状态保持和恢复"><a href="#iOS-UI-状态保持和恢复" class="headerlink" title="iOS  UI 状态保持和恢复"></a>iOS  UI 状态保持和恢复</h3><p>iOS 设计规范中要求，当应用退出的时候（包括被终止运行的时候），需要保持界面中UI元素的状态，当再次进来的时候看到的状态与退出时是一样的。在iOS 之后，苹果提供以下API使得UI状态保持和恢复变得很容易。 </p>
<p>在iOS 中，我们可以在以下3种地方实现状态保持和恢复：</p>
<ul>
<li><p>应用程序委托对象 </p>
</li>
<li><p>视图控制器 </p>
</li>
<li><p>自定义视图</p>
</li>
</ul>
<p>恢复标识是iOS为了实现UI状态保持和恢复添加的设置项目。我们还需要在应用程序委托对象AppDelegate代码部分做一些修改，添加的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL) application:(UIApplication *)application shouldSaveApplicationState:(NSCoder *)coder&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">-(BOOL) application:(UIApplication *)application shouldRestoreApplicationState:(NSCoder *)coder&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">- (void)application:(UIApplication *)application willEncodeRestorableStateWithCoder:(NSCoder *)coder&#123;</span><br><span class="line">    [coder encodeFloat:2.0 forKey:@&quot;Version&quot;];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">- (void)application:(UIApplication *)application didDecodeRestorableStateWithCoder:(NSCoder *)coder&#123;</span><br><span class="line">    float lastVer = [coder decodeFloatForKey:@&quot;Version&quot;];</span><br><span class="line">    NSLog(@&quot;lastVer = %f&quot;,lastVer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中application:shouldSaveApplicationState:方法在应用退出时调用，负责控制是否允许保存状态，返回YES 情况是可以保存，NO是不保存。 </p>
<p><code>application:shouldRestoreApplicationState:</code>方法在应用启动时调用，负责控制是否恢复上次退出时的状态，返回YES 表示可以恢复，返回NO表示不可以恢复。 </p>
<p><code>application:willEncodeRestorableStateWithCoder:</code>方法在保存时调用，在这个方法中实现UI状态或数据的保存，其中<code>[coder encodeFloat:2.0 forKey:@&quot;Version&quot;]</code> 语句是保存简单数据。 </p>
<p><code>application:didDecodeRestorableStateWithCoder:</code>方法在恢复时调用，在这个方法中实现UI状态或数据的恢复，其中<code>[coder decodeFloatForKey:@&quot;Version&quot;]</code> 语句用于恢复上次保存的数据。 </p>
<p>想要实现具体界面中控件的保持和恢复，还需要在它的视图控制器中添加一些代码。我们在ViewController.m中添加的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(void)encodeRestorableStateWithCoder:(NSCoder *)coder&#123;</span><br><span class="line">    [super encodeRestorableStateWithCoder:coder];</span><br><span class="line">    [coder encodeObject:self.txtField.text forKey:kSaveKey];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">-(void)decodeRestorableStateWithCoder:(NSCoder *)coder&#123;</span><br><span class="line">    [super decodeRestorableStateWithCoder:coder];</span><br><span class="line">    self.txtField.text = [coder decodeObjectForKey:kSaveKey];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在iOS 6之后，视图控制器都添加了两个方法——<code>encodeRestorableStateWithCoder:</code> 和<code>decodeRestorableStateWithCoder:</code> ，用来实现该控制器中的控件或数据的保存和恢复。</p>
<p>其中<code>encodeRestorableStateWithCoder:</code>方法在保存时候调用，<code>[coder encodeObject:self. txtField.textforKey:kSaveKey]</code>语句是按照指定的键保存文本框的内容。</p>
<p><code>decodeRestorableStateWithCoder:</code>方法在恢复时调用，<code>[coder decodeObjectForKey:kSaveKey]</code>在恢复文本框内容时调用，保存和恢复事实上就是向一个归档文件中编码和解码的过程。</p>
<h2 id="移除Main-storyboard"><a href="#移除Main-storyboard" class="headerlink" title="移除Main.storyboard"></a>移除Main.storyboard</h2><p>每次使用Single View Application模板创建工程之后，总是会有一个Main.storyboard文件，那么，当我们使用代码布局的时候，很显然是不需要它的。那么，如何将它从工程中移除呢？只要进行如下几步即可。</p>
<h3 id="在工程配置中移除关联"><a href="#在工程配置中移除关联" class="headerlink" title="在工程配置中移除关联"></a>在工程配置中移除关联</h3><p><img src="http://o88e8any8.bkt.clouddn.com/ios-remove-storyboard-1.jpeg" alt=""></p>
<p>在TARGETS中，将Main InInterface选项中的值清空并保存设置。</p>
<h3 id="移除Main-storyboard中的关联文件"><a href="#移除Main-storyboard中的关联文件" class="headerlink" title="移除Main.storyboard中的关联文件"></a>移除Main.storyboard中的关联文件</h3><p><img src="http://o88e8any8.bkt.clouddn.com/ios-remove-storyboard-2.png" alt=""></p>
<p>选择storyboard文件。将类关联文件项清空并保存设置。</p>
<h3 id="移除Main-storyboard文件"><a href="#移除Main-storyboard文件" class="headerlink" title="移除Main.storyboard文件"></a>移除Main.storyboard文件</h3><p><img src="http://o88e8any8.bkt.clouddn.com/ios-remove-storyboard-3.jpeg" alt=""></p>
<p>从工程中移除文件。</p>
<h3 id="在AppDelegate中添加代码"><a href="#在AppDelegate中添加代码" class="headerlink" title="在AppDelegate中添加代码"></a>在AppDelegate中添加代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    // Override point for customization after application launch.   </span><br><span class="line">    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];</span><br><span class="line">    </span><br><span class="line">    ViewController *viewController = [[ViewController alloc] init];</span><br><span class="line">    self.window.rootViewController = viewController;  </span><br><span class="line">    self.window.backgroundColor = [UIColor purpleColor];</span><br><span class="line">　[self.window makeKeyAndVisible];    </span><br><span class="line">   return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成以上几步，运行工程即可，顺利运行，没有出现任何error或waring。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS应用程序的生命周期，还有程序是运行在前台还是后台，应用程序各个状态的变换，这些对于开发者来说都是很重要的。iOS系统的资源是有限的，应用程序在前台和在后台的状态是不一样的。在后台时，程序会受到系统的很多限制，这样可以提高电池的使用和用户体验。&lt;/p&gt;
&lt;p&gt;本文所要说到的生命周期，也不仅仅只是应用生命周期；还包括，视图生命周期。&lt;/p&gt;
    
    </summary>
    
      <category term="pieces" scheme="http://charsdavy.github.io/categories/pieces/"/>
    
    
      <category term="ios" scheme="http://charsdavy.github.io/tags/ios/"/>
    
      <category term="objc" scheme="http://charsdavy.github.io/tags/objc/"/>
    
      <category term="application" scheme="http://charsdavy.github.io/tags/application/"/>
    
      <category term="ui" scheme="http://charsdavy.github.io/tags/ui/"/>
    
      <category term="生命周期" scheme="http://charsdavy.github.io/tags/lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>日语-发音</title>
    <link href="http://charsdavy.github.io/2017/04/10/japanese-pronounce/"/>
    <id>http://charsdavy.github.io/2017/04/10/japanese-pronounce/</id>
    <published>2017-04-10T14:05:00.000Z</published>
    <updated>2017-04-17T01:47:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>日语以东京音为标准音，其声调可以分为如下几种：0型，①型，②型，③型，④型，⑤型，⑥型和⑦型等。高声调表示重音，低声调表示轻音。</p>
<p>0型：表示只有第一拍低，其它各拍都高。</p>
<p>①型：表示只有第一拍高，以下其它各拍都低。</p>
<p>②型：表示只有第二拍高，第一拍和以下其它各拍都低。</p>
<p>③型：表示第二拍，第三拍高，第一拍和以下其它各拍都低。</p>
<p>④型：表示第二拍，第三拍，第四拍高，第一拍和以下其它各拍都低。</p>
<p>依此类推其它型。</p>
<a id="more"></a>
<h2 id="五十音图"><a href="#五十音图" class="headerlink" title="五十音图"></a>五十音图</h2><h3 id="清音"><a href="#清音" class="headerlink" title="清音"></a>清音</h3><table>
<thead>
<tr>
<th></th>
<th>あ段</th>
<th>い段</th>
<th>う段</th>
<th>え段</th>
<th>お段</th>
</tr>
</thead>
<tbody>
<tr>
<td>　あ行 　</td>
<td>　あ　ア a　</td>
<td>　い　イ i　</td>
<td>　う　ウ u　</td>
<td>　え　エ e　</td>
<td>　お　オ　o</td>
</tr>
<tr>
<td>　か行 k　</td>
<td>　か　カ ka　</td>
<td>　き　キ ki　</td>
<td>　く　ク ku　</td>
<td>　け　ケ ke　</td>
<td>　こ　コ　ko</td>
</tr>
<tr>
<td>　さ行 s　</td>
<td>　さ　サ sa　</td>
<td>　し　シ shi　</td>
<td>　す　ス su　</td>
<td>　せ セ　se　</td>
<td>　そ　ソ so　</td>
</tr>
<tr>
<td>　た行 t　</td>
<td>　た タ　ta　</td>
<td>　ち　チ chi　</td>
<td>　つ ツ　tsu　</td>
<td>　て　テ　te</td>
<td>　と　ト to　</td>
</tr>
<tr>
<td>　な行 n　</td>
<td>　な　ナ na　</td>
<td>　に　ニ ni　</td>
<td>　ぬ ヌ　nu　</td>
<td>　ね ネ　ne　</td>
<td>　の　ノ no　</td>
</tr>
<tr>
<td>　は行 h　</td>
<td>　は ハ　ha　</td>
<td>　ひ　ヒ hi　</td>
<td>　ふ フ　fu　</td>
<td>　へ　ヘ　he</td>
<td>　ほ　ホ ho　</td>
</tr>
<tr>
<td>　ま行 m　</td>
<td>　ま　マ ma　</td>
<td>　み　ミ　mi</td>
<td>　む　ム mu　</td>
<td>　め　メ　me　</td>
<td>　も　モ　mo</td>
</tr>
<tr>
<td>　や行 y　</td>
<td>　や　ヤ ya　</td>
<td>　</td>
<td>　ゆ　ユ yu　</td>
<td>　</td>
<td>　よ　ヨ yo　</td>
</tr>
<tr>
<td>　ら行 r　</td>
<td>　ら　ラ ra　</td>
<td>　り　リ ri　</td>
<td>　る　ル ru　</td>
<td>　れ　レ re　</td>
<td>　ろ　ロ ro　</td>
</tr>
<tr>
<td>　わ行 w　</td>
<td>　わ　ワ wa　</td>
<td>　</td>
<td>　</td>
<td>　</td>
<td>　を　ヲ wo　</td>
</tr>
<tr>
<td>　</td>
<td>　ん　ン n　</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="拨音-ん"><a href="#拨音-ん" class="headerlink" title="拨音 (ん)"></a>拨音 (ん)</h3><table>
<thead>
<tr>
<th>后续音节</th>
<th>实际发音</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>ぱ、ば、ま行</td>
<td>/m/</td>
<td>　さんぽ、しんぶん、うんめい、こんぶ、かんぶ　</td>
</tr>
<tr>
<td>た、だ、ら、な行</td>
<td>/n/</td>
<td>　ほんとう、もんだい、ほんらい、しんねん、こんど、すんな　</td>
</tr>
<tr>
<td>其它或词尾</td>
<td>/ng/</td>
<td>　へんか、あんしん、れんあい、まんが、バン、おんせん　</td>
</tr>
</tbody>
</table>
<h3 id="浊音"><a href="#浊音" class="headerlink" title="浊音"></a>浊音</h3><table>
<thead>
<tr>
<th>が行 g</th>
<th>　が　ガ ga　</th>
<th>　ぎ　ギ　gi</th>
<th>　ぐ　グ gu　</th>
<th>　げ　ゲ ge　</th>
<th>　ご　ゴ go　</th>
</tr>
</thead>
<tbody>
<tr>
<td>ざ行 z</td>
<td>　ざ　ザ za　</td>
<td>　じ　ジ zi　</td>
<td>　ず　ズ zu　</td>
<td>　ぜ　ゼ ze　</td>
<td>　ぞ　ゾ zo　</td>
</tr>
<tr>
<td>だ行 d</td>
<td>　だ　ダ da　</td>
<td>　ぢ　ヂ zi　</td>
<td>　づ　ヅ zu　</td>
<td>　で　デ de　</td>
<td>　ど　ド do　</td>
</tr>
<tr>
<td>ば行 b</td>
<td>　ば　バ ba　</td>
<td>　び　ビ bi　</td>
<td>　ぶ　ブ bu　</td>
<td>　べ　ベ be　</td>
<td>　ぼ　ボ bo　</td>
</tr>
</tbody>
</table>
<h3 id="半浊音"><a href="#半浊音" class="headerlink" title="半浊音"></a>半浊音</h3><table>
<thead>
<tr>
<th>ぱ行 p</th>
<th>　ぱ pa　</th>
<th>　ぴ　pi</th>
<th>　ぷ pu　</th>
<th>　ぺpe　</th>
<th>　ぽ　po</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>　パ　</td>
<td>　ピ</td>
<td>　プ　</td>
<td>　ペ　</td>
<td>　ポ</td>
</tr>
</tbody>
</table>
<h3 id="拗音"><a href="#拗音" class="headerlink" title="拗音"></a>拗音</h3><p>拗音是在“い段”假名后面加上复元音“や”、“ゆ”、“よ”拼成的音节。拗音符号是把“や”、“ゆ”、“よ”写在“い段”假名的右下角。把拗音自动拉长一拍就是拗长音。</p>
<table>
<thead>
<tr>
<th>きゃ　キャ kya</th>
<th>きゅ　キュ kyu</th>
<th>きょ　キョ kyo</th>
</tr>
</thead>
<tbody>
<tr>
<td>しゃ　シャ sha</td>
<td>しゅ　シュ shu</td>
<td>しょ　ショ sho</td>
</tr>
<tr>
<td>ちゃ　チャ cha</td>
<td>ちゅ　チュ chu</td>
<td>ちょ　チョ cho</td>
</tr>
<tr>
<td>にゃ　ニャ nya</td>
<td>にゅ　ニュ nyu</td>
<td>にょ　ニョ nyo</td>
</tr>
<tr>
<td>ひゃ　ヒャ hya</td>
<td>ひゅ　ヒュ hyu</td>
<td>ひょ　ヒョ hyo</td>
</tr>
<tr>
<td>みゃ　ミャ mya</td>
<td>みゅ　ミュ myu</td>
<td>みょ　ミョ myo</td>
</tr>
<tr>
<td>りゃ　リャ rya</td>
<td>りゅ　リュ ryu</td>
<td>りょ　リョ ryo</td>
</tr>
<tr>
<td>ぎゃ　ギャ gya</td>
<td>ぎゅ　ギュ gyu</td>
<td>ぎょ　ギョ gyo</td>
</tr>
<tr>
<td>じゃ　ジャ ja</td>
<td>じゅ　ジュ ju</td>
<td>じょ　ジョ jo</td>
</tr>
<tr>
<td>ぢゃ　ヂャ dya</td>
<td>ぢゅ　ヂュ dyu</td>
<td>ぢょ　ヂョ dyo</td>
</tr>
<tr>
<td>びゃ　ビャ bya</td>
<td>びゅ　ビュ byu</td>
<td>びょ　ビョ byo</td>
</tr>
<tr>
<td>ぴゃ　ピャ pya</td>
<td>ぴゅ　ピュ pyu</td>
<td>ぴょ　ピョ pyo</td>
</tr>
</tbody>
</table>
<p><strong>注意：</strong></p>
<p>1）が行假名出现在单词首位置，发本音（浊音）；若出现在单词其他位置，发鼻浊音。</p>
<p>2）か行和た行假名出现在单词首位置，发本音（清音）；若出现在其他位置，发近对应的浊音。</p>
<p>3）ぱ行假名出现在单词首位置，发本音（半浊音）；若出现在其他位置，发ば行对应的音。</p>
<h2 id="促音"><a href="#促音" class="headerlink" title="促音"></a>促音</h2><p>发音时用发音器官某一部分堵住呼吸，形成一个短促的顿挫，然后放开堵塞使呼气急冲而出，这种音节叫“促音”，用小“つ”表示，即“っ”。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>促音+か行假名</td>
<td>かっこ、がっき、じっけん、せっけん、はっけん、みっか</td>
</tr>
<tr>
<td>促音+さ行假名</td>
<td>あっさり、けっせき、ざっし、じっせん、しっそ、ねっしん</td>
</tr>
<tr>
<td>促音+た行假名</td>
<td>ねったい、おっと、ずっと、ぜったい、はってん、まったく</td>
</tr>
<tr>
<td>促音+ぱ行假名</td>
<td>いっぱい、いっぺん、じっぴ、じっぷん、にっぽん、りっぱ</td>
</tr>
</tbody>
</table>
<h2 id="长音"><a href="#长音" class="headerlink" title="长音"></a>长音</h2><table>
<thead>
<tr>
<th>长音规则</th>
<th>示例</th>
<th>特例</th>
</tr>
</thead>
<tbody>
<tr>
<td>あ段假名后加あ</td>
<td>おかあさん</td>
<td></td>
</tr>
<tr>
<td>い段假名后加い</td>
<td>おにいさん</td>
<td></td>
</tr>
<tr>
<td>う段假名后加う</td>
<td>ゆうじん</td>
<td></td>
</tr>
<tr>
<td>え段假名后加い，个别场合加え</td>
<td>せんせい</td>
<td>おねえさん、ええ</td>
</tr>
<tr>
<td>お段假名后加う，个别场合加お</td>
<td>おとうさん</td>
<td>大きい、こお、とお</td>
</tr>
<tr>
<td>外来语用ー</td>
<td>メーデー</td>
</tr>
</tbody>
</table>
<h2 id="“何”发音"><a href="#“何”发音" class="headerlink" title="“何”发音"></a>“何”发音</h2><h3 id="なん"><a href="#なん" class="headerlink" title="なん"></a>なん</h3><p>１）だ、で、と（表内容时）、の假名前</p>
<p>何だ、これ？</p>
<p>これは何ですか。</p>
<p>何と読みますか。</p>
<p>これは何の本ですか。</p>
<p>２）数量词前</p>
<p>今日は何曜日ですか。</p>
<h3 id="なに"><a href="#なに" class="headerlink" title="なに"></a>なに</h3><p>１）に、を、が、か、も假名前</p>
<p>何にしますか。</p>
<p>何を食べますか。</p>
<p>何か食べますか。</p>
<p>何もありません。</p>
<p>何がありますか。</p>
<p>２）专用名词</p>
<p>何学校（がっこう）ですか。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日语以东京音为标准音，其声调可以分为如下几种：0型，①型，②型，③型，④型，⑤型，⑥型和⑦型等。高声调表示重音，低声调表示轻音。&lt;/p&gt;
&lt;p&gt;0型：表示只有第一拍低，其它各拍都高。&lt;/p&gt;
&lt;p&gt;①型：表示只有第一拍高，以下其它各拍都低。&lt;/p&gt;
&lt;p&gt;②型：表示只有第二拍高，第一拍和以下其它各拍都低。&lt;/p&gt;
&lt;p&gt;③型：表示第二拍，第三拍高，第一拍和以下其它各拍都低。&lt;/p&gt;
&lt;p&gt;④型：表示第二拍，第三拍，第四拍高，第一拍和以下其它各拍都低。&lt;/p&gt;
&lt;p&gt;依此类推其它型。&lt;/p&gt;
    
    </summary>
    
      <category term="talk" scheme="http://charsdavy.github.io/categories/talk/"/>
    
    
      <category term="碎碎念" scheme="http://charsdavy.github.io/tags/text/"/>
    
      <category term="日语" scheme="http://charsdavy.github.io/tags/japan-language/"/>
    
  </entry>
  
  <entry>
    <title>sublime text 实用技巧</title>
    <link href="http://charsdavy.github.io/2017/03/30/sublime-text-tool/"/>
    <id>http://charsdavy.github.io/2017/03/30/sublime-text-tool/</id>
    <published>2017-03-29T23:51:43.000Z</published>
    <updated>2017-03-31T12:20:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>Sublime Text 是一个代码编辑器（Sublime Text 2是收费软件，但可以无限期试用），也是HTML和散文先进的文本编辑器。Sublime Text是由程序员Jon Skinner于2008年1月份所开发出来，它最初被设计为一个具有丰富扩展功能的Vim。</p>
<p>笔者整理了一些使用快捷方式，以及一些常用插件，分享一下。</p>
<a id="more"></a>
<h2 id="安装包控制（Package-Control）"><a href="#安装包控制（Package-Control）" class="headerlink" title="安装包控制（Package Control）"></a>安装包控制（Package Control）</h2><p>打开Sublime Text 2，按快捷键 ctrl+` 或者点击 Tools → Command Palette 调出控制台Console；<br>将以下代码复制粘贴进命令行后回车：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib2,os;pf=&apos;Package Control.sublime-package&apos;;ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp)elseNone;open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib2.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read())</span><br></pre></td></tr></table></figure>
<p>重新启动Sublime Text 2，如果在Preferences → Package Settings 中看到 Package Control 这一项，就说明安装成功。</p>
<h2 id="安装Alignment插件"><a href="#安装Alignment插件" class="headerlink" title="安装Alignment插件"></a>安装Alignment插件</h2><p>对于喜欢整齐的码农来说，这不失为一个省事的插件。该插件可以通过上面安装好的 Package Control 来安装：</p>
<p>按ctrl + shift + P调出命令面板；</p>
<p>输入 install 调出 Package Control：Install Package 选项，并回车；</p>
<p>输入Alignment，选中并按回车安装；</p>
<p>重启Sublime Text 2，选中文本并按ctrl + alt + a 就可以进行对齐操作了。</p>
<h2 id="安装-Soda-主题"><a href="#安装-Soda-主题" class="headerlink" title="安装 Soda 主题"></a>安装 Soda 主题</h2><p>这里的主题不同于针对代码的 color scheme，而是针对Sublime Text 2该软件本身的主题，该主题也可以通过万能的 Package Control 来安装。</p>
<p>按ctrl + shift + P调出命令面板；</p>
<p>输入 install 调出 Package Control：Install Package 选项，并回车；</p>
<p>输入 theme soda 选中后回车即可安装；</p>
<p>安装完之后要激活主题，打开 Preferences → Global Settings – User，加上以下代码保存即可生效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;theme&quot;: &quot;Soda Light.sublime-theme&quot; 或者 &quot;theme&quot; : &quot;Soda Dark.sublime-theme&quot;</span><br></pre></td></tr></table></figure>
<h2 id="安装cTags插件"><a href="#安装cTags插件" class="headerlink" title="安装cTags插件"></a>安装cTags插件</h2><p>首先，从Ctags官网下载压缩包下来，解压到电脑的某个地方，比如“C:\Program Files\ctags”，然后把cTags添加到系统变量里去：<br>在“我的电脑”右键属性 → 高级 → 环境变量 → 在“系统变量”里找到“Path”，点击“编辑” → 把“;C:\Program Files\ctags”（不包括双引号）复制到最后 → 最后一路“确定”保存。</p>
<p>然后通过 Package Control 来安装 cTags 插件：</p>
<p>按ctrl + shift + P调出命令面板；</p>
<p>输入 install 调出 Package Control：Install Package 选项，并回车；</p>
<p>输入 ctags 选中后回车即可安装。</p>
<p>安装完之后，在项目的当前目录下按ctrl + t, ctrl + r，会生成.tags的文件。当光标停留在某个函数上时，按快捷键 ctrl+t, ctrl+t就可以打开函数所在的文件，并跳转到相应的位置了。</p>
<p><strong>PS</strong> 安装这个插件折腾了我蛮久，主要是不知道还要从ctags官网下载压缩包，以及修改系统的变量，后来还是一博友给我发的国外的参考资料才知道要这样配置 的。刚开始知道这软件之所以没用是因为没有像eclipse可以追踪函数的功能，后来才知道可以通过安装cTags插件来实现。装上此功能后，就更喜欢用 Sublime Text 2了。</p>
<h2 id="jsFormat插件"><a href="#jsFormat插件" class="headerlink" title="jsFormat插件"></a>jsFormat插件</h2><p>格式化js：选中一段文本，control+alt+f。</p>
<p>DocBlockr</p>
<p>在JS函数上方输入/**，然后回车，doc就生成好了非常好用。</p>
<p>sublime-jslint</p>
<p>打开一个js文件，control+j，即可输出jsLint检查的结果。打开Packages目录，找到插件目录sublime-jslint，打开 sublime-jslint.sublime-settings文件，可以修改jsLint配置，还可以配置文件保存时自动检查等，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; // Path to the jslint jar. // Leave blank to use bundled jar. &quot;jslint_jar&quot;: &quot;&quot;,   // Options pass to jslint. // Jerry Qu注：全部可用配置参考这里，https://github.com/fbzhong/sublime-jslint/wiki/Available- jslint4java-options &quot;jslint_options&quot;: &quot;--encoding utf-8 --bitwise --browser --cap --css --devel --debug --evil --forin --fragment --on --sub --white --windows --sloppy&quot;,   // Ignore errors, regex. &quot;ignore_errors&quot;: [ // &quot;Expected an identifier and instead saw &apos;undefined&apos; \(a reserved word\)&quot; ],   // run jslint on save. &quot;run_on_save&quot;: false,   // debug flag. &quot;debug&quot;:false &#125;</span><br></pre></td></tr></table></figure>
<h2 id="SideBarEnhancements"><a href="#SideBarEnhancements" class="headerlink" title="SideBarEnhancements"></a>SideBarEnhancements</h2><p>推荐通过 Package Control 安装 SideBarEnhancements 这个插件，可以大大加强在侧栏目录树中右键的选项</p>
<h2 id="推荐插件："><a href="#推荐插件：" class="headerlink" title="推荐插件："></a>推荐插件：</h2><p>1）Zen Coding</p>
<p>2）jQuery Package for sublime Text</p>
<p>3）Clipboard History</p>
<p>4）Bracket Highlighter</p>
<p>5）GBK to UTF8</p>
<p>6）Git</p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table>
<thead>
<tr>
<th>按键组合</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command+Shift+L</td>
<td>选中多行即可可以同时编辑这些行</td>
</tr>
<tr>
<td>control + Command +G</td>
<td>可以一次性选择全部相同的文件进行同时编辑</td>
</tr>
<tr>
<td>Ctrl+D</td>
<td>选词（反复按快捷键，即可继续向下同时选中下一个相同的文本进行同时编辑）</td>
</tr>
<tr>
<td>Ctrl+G</td>
<td>跳转到相应的行</td>
</tr>
<tr>
<td>Ctrl+J</td>
<td>合并行（已选择需要合并的多行时）</td>
</tr>
<tr>
<td>Ctrl+L</td>
<td>选择整行（按住-继续选择下行）</td>
</tr>
<tr>
<td>Ctrl+M</td>
<td>光标移动至括号内开始或结束的位置</td>
</tr>
<tr>
<td>Ctrl+T</td>
<td>词互换</td>
</tr>
<tr>
<td>Ctrl+U</td>
<td>软撤销</td>
</tr>
<tr>
<td>Ctrl+P</td>
<td>查找当前项目中的文件和快速搜索；输入@查找文件主标题/函数；或者输入:跳转到文件某行；</td>
</tr>
<tr>
<td>Ctrl+R</td>
<td>快速列出/跳转到某个函数</td>
</tr>
<tr>
<td>Ctrl+KBackspace</td>
<td>从光标处删除至行首</td>
</tr>
<tr>
<td>Ctrl+KB</td>
<td>开启/关闭侧边栏</td>
</tr>
<tr>
<td>Ctrl+KK</td>
<td>从光标处删除至行尾</td>
</tr>
<tr>
<td>Ctrl+KT</td>
<td>折叠属性</td>
</tr>
<tr>
<td>Ctrl+KU</td>
<td>改为大写</td>
</tr>
<tr>
<td>Ctrl+KL</td>
<td>改为小写</td>
</tr>
<tr>
<td>Ctrl+K0</td>
<td>展开所有</td>
</tr>
<tr>
<td>Ctrl+Enter</td>
<td>插入行后（快速换行）</td>
</tr>
<tr>
<td>Ctrl+Tab</td>
<td>当前窗口中的标签页切换</td>
</tr>
<tr>
<td>Ctrl+Shift+A</td>
<td>选择光标位置父标签对儿</td>
</tr>
<tr>
<td>Ctrl+Shift+D</td>
<td>复制光标所在整行，插入在该行之前</td>
</tr>
<tr>
<td>ctrl+shift+F</td>
<td>在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找</td>
</tr>
<tr>
<td>Ctrl+Shift+K</td>
<td>删除整行</td>
</tr>
<tr>
<td>Ctrl+Shift+L</td>
<td>鼠标选中多行（按下快捷键），即可同时编辑这些行</td>
</tr>
<tr>
<td>Ctrl+Shift+M</td>
<td>选择括号内的内容（按住-继续选择父括号）</td>
</tr>
<tr>
<td>Ctrl+Shift+P</td>
<td>打开命令面板</td>
</tr>
<tr>
<td>Ctrl+Shift+/</td>
<td>注释已选择内容</td>
</tr>
<tr>
<td>Ctrl+Shift+↑</td>
<td>可以移动此行代码，与上行互换</td>
</tr>
<tr>
<td>Ctrl+Shift+↓</td>
<td>可以移动此行代码，与下行互换</td>
</tr>
<tr>
<td>Ctrl+Shift+[</td>
<td>折叠代码</td>
</tr>
<tr>
<td>Ctrl+Shift+]</td>
<td>展开代码</td>
</tr>
<tr>
<td>Ctrl+Shift+Enter</td>
<td>光标前插入行</td>
</tr>
<tr>
<td>Ctrl+PageDown、Ctrl+PageUp</td>
<td>文件按开启的前后顺序切换</td>
</tr>
<tr>
<td>Ctrl+Z</td>
<td>撤销</td>
</tr>
<tr>
<td>Ctrl+Y</td>
<td>恢复撤销</td>
</tr>
<tr>
<td>Ctrl+F2</td>
<td>设置书签</td>
</tr>
<tr>
<td>Ctrl+/</td>
<td>注释整行（如已选择内容，同“Ctrl+Shift+/”效果）</td>
</tr>
<tr>
<td>Ctrl+鼠标左键</td>
<td>可以同时选择要编辑的多处文本</td>
</tr>
<tr>
<td>Shift+鼠标右键（或使用鼠标中键）</td>
<td>可以用鼠标进行竖向多行选择</td>
</tr>
<tr>
<td>Shift+F2</td>
<td>上一个书签</td>
</tr>
<tr>
<td>Shift+Tab</td>
<td>去除缩进</td>
</tr>
<tr>
<td>Alt+Shift+1~9（非小键盘）</td>
<td>屏幕显示相等数字的小窗口</td>
</tr>
<tr>
<td>Alt+.</td>
<td>闭合当前标签</td>
</tr>
<tr>
<td>Alt+F3</td>
<td>选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑</td>
</tr>
<tr>
<td>Tab</td>
<td>缩进,自动完成</td>
</tr>
<tr>
<td>F2</td>
<td>下一个书签</td>
</tr>
<tr>
<td>F6</td>
<td>检测语法错误</td>
</tr>
<tr>
<td>F9</td>
<td>行排序(按a-z)</td>
</tr>
<tr>
<td>F11</td>
<td>全屏模式</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sublime Text 是一个代码编辑器（Sublime Text 2是收费软件，但可以无限期试用），也是HTML和散文先进的文本编辑器。Sublime Text是由程序员Jon Skinner于2008年1月份所开发出来，它最初被设计为一个具有丰富扩展功能的Vim。&lt;/p&gt;
&lt;p&gt;笔者整理了一些使用快捷方式，以及一些常用插件，分享一下。&lt;/p&gt;
    
    </summary>
    
      <category term="talk" scheme="http://charsdavy.github.io/categories/talk/"/>
    
    
      <category term="工具" scheme="http://charsdavy.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>想说说文章版权</title>
    <link href="http://charsdavy.github.io/2017/03/29/article-copyright/"/>
    <id>http://charsdavy.github.io/2017/03/29/article-copyright/</id>
    <published>2017-03-29T06:04:50.000Z</published>
    <updated>2017-03-31T11:13:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章版权，这个词汇以前笔者以前是不怎么有体会的，认为在当今互联网的时代，随便网上Google一下很多地方的文章如出一辙，而作者也是千奇百怪，甚至都不清楚谁才是作者。这篇文章，笔者是遇见了真实的事件，现在很想说一说，看看大家是否也是一样，认为一个版权意识高的视界里，资源与时间都是高效的。不用在看一条，两条都是一样的，浪费时间和资源。</p>
<p>不知道是否有人明白什么叫“版权”。说实在的，笔者并不是很清楚它的定义。这里引入百科的解释：</p>
<blockquote>
<p>版权（copyright）是用来表述创作者因其文学和艺术作品而享有的权利的一个法律用语。</p>
<p>版权是对计算机程序、文学著作、音乐作品、照片、电影等的复制权利的合法所有权。除非转让给另一方，版权通常被认为是属于作者的。大多数计算机程序不仅受到版权的保护，还受软件许可证的保护。版权只保护思想的表达形式，而不保护思想本身。算法、数学方法、技术或机器的设计均不在版权的保护之列。</p>
</blockquote>
<a id="more"></a>
<p>这个是属于法律领域了，只不过在天朝，大家都不认为这是事儿。不过现在好了，慢慢的付费阅读，付费视频等等开始流行，这样大家虽然花了米米，不过质量却是有了保证。</p>
<p>说回这篇文章的初衷，就是在这两天，笔者遇到了自己博客网站的文章别他人拿去分享，并攫取了利益。更巧的是，被笔者知道了。曾经在知乎一个问答里看见，关于招聘，面试官会直接pass掉那些抄袭他们文章的应聘者。看到之后笔者将自己转载，并备注了“转载”二字的文章删除干净。不错，或许笔者没有从中获利，不过确实有些文章是没有联系到作者的，虽然给了原链接，可是确实吸引了眼球。</p>
<p>现在，保证文章都是原创，无论深浅文雅如何，总归是自己的作品。相反，在不断撰写过程中，会发现很多自身的漏洞。网络已经很发达了，大家都能在网上找到自己需要的文章，干嘛还要做搬运工呢，笔者认为，高手应该转载于无形，即看懂原文加上自己的思考，想必比简单的复制拷贝要有价值得多。</p>
<p>笔者之前在一个“同行说”的平台分享自己的文章，后来转行了，渐渐时间少了，也就远离了一段时间的撰文。现在，又要安利大家了，这款<a href="https://toutiao.io/" target="_blank" rel="external">开发者头条</a>，内容不错，文章也很是有质量，笔者使用pocket已经收藏了不少好文。不过，这篇文章的始因也是源于此平台。平台有激励作者自荐的机制，积分商城应该算得上为数不多的几家良心公司。为此，笔者有空会创作原创，因为这样才能登上文章精选的列表。</p>
<p>可是，不得不说的一点是，平台没有很好的原创保护机制。笔者作为一个技术人员。看到几点问题：</p>
<p>1.平台有精选文章缓存。这样的后果就是，即使作者发现了自己文章的错误，修改之后还是不能同步到精选文章列表。</p>
<p>2.对于原创和非原创没有好的保护与甄别，除非巧合遇到像笔者这样的情况，且还是个较真的人。</p>
<p>3.软件聊天体验有待提高。emoji发送太麻烦，iOS平台必须依赖系统键盘的发送。Android端没有用过不清楚。</p>
<p>第一个问题，笔者建议可以使用定时机制，一段时间检测分享链接的内容，这样也能很好的保护原创。当原创作者发现自己的文章被他人肆意分享，只需改变文章地址即可令其失效。这样也就不存在原创甄别问题了。还保证了文章内容的同步。</p>
<p>第二个问题，技术不是问题，关键是否会为这个的细节付出时间。</p>
<p>不过，笔者自己也想过使用什么方式能够避免这样的问题，URL混淆？反爬虫？不知道是否可行。不过迫于无奈，现在笔者的文章顶部都加了一条申明。其实就是小偷和锁的问题，是否有效只取决于剽窃者。</p>
<p>最后，很感谢平台的及时沟通和处理，为笔者补回了损失。不过，却便宜了剽窃者。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文章版权，这个词汇以前笔者以前是不怎么有体会的，认为在当今互联网的时代，随便网上Google一下很多地方的文章如出一辙，而作者也是千奇百怪，甚至都不清楚谁才是作者。这篇文章，笔者是遇见了真实的事件，现在很想说一说，看看大家是否也是一样，认为一个版权意识高的视界里，资源与时间都是高效的。不用在看一条，两条都是一样的，浪费时间和资源。&lt;/p&gt;
&lt;p&gt;不知道是否有人明白什么叫“版权”。说实在的，笔者并不是很清楚它的定义。这里引入百科的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;版权（copyright）是用来表述创作者因其文学和艺术作品而享有的权利的一个法律用语。&lt;/p&gt;
&lt;p&gt;版权是对计算机程序、文学著作、音乐作品、照片、电影等的复制权利的合法所有权。除非转让给另一方，版权通常被认为是属于作者的。大多数计算机程序不仅受到版权的保护，还受软件许可证的保护。版权只保护思想的表达形式，而不保护思想本身。算法、数学方法、技术或机器的设计均不在版权的保护之列。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="talk" scheme="http://charsdavy.github.io/categories/talk/"/>
    
    
      <category term="碎碎念" scheme="http://charsdavy.github.io/tags/text/"/>
    
  </entry>
  
  <entry>
    <title>iOS的那些面试</title>
    <link href="http://charsdavy.github.io/2017/03/28/ios-interview/"/>
    <id>http://charsdavy.github.io/2017/03/28/ios-interview/</id>
    <published>2017-03-28T00:01:18.000Z</published>
    <updated>2017-03-31T11:55:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔试面试是程序员应聘绕不过的坎，想进大厂就一定要有知识储备量，而这个却是最佳的考察方式。笔者分享一些收集的iOS面试题，答案仅供参考，如有错误，还请指正。</p>
<a id="more"></a>
<h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><p>1.Objective-C语言的基本特点？</p>
<p>Objective-C语言是C语言的一个超集，只是在C的基础之上添加了面向对象（OO）的特性；Objective-C与Java语言相同都是单继承，这一点与C++语言不同（多重继承），这一点可以参看之前有关讲解继承的文章；Objective-C不支持命名空间，取而代之的是在类名之前添加前缀，以此来区分。</p>
<p>2.#include与#import的区别，#import与@class的区别？</p>
<p>1）#include和#import效果相同，只是后者不会引起交叉编译，确保头文件只会被导入一次。</p>
<p>2）#import会包含这个类的所有信息，包括实体变量和方法，而@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂时不用考虑，后面会再告诉你。使用#import编译效率高，防止相互包含的编译错误。</p>
<p>3.简述类目优缺点，如果覆盖本类或者父类的方法会出现什么问题？</p>
<p>优点：不需要通过增加子类而增加现有类的行为（方法），且类目中的方法与原始类方法基本没有区别。</p>
<p>缺点：无法向类目添加实例变量。覆盖原始类方法后，原始类的方法没办法调用。</p>
<p>4.简述内存管理基本原则？</p>
<p>如果使用alloc、copy（mutableCopy）或者retain一个对象时，你就有义务向它发送一条release或autorelease消息。其他方法创建的对象，不需要由你来管理内存。</p>
<p>5.什么是ARC技术？与GC是否相同？</p>
<p>ARC是Automatic Reference Counting的简称，我们称之为自动引用计数，是iOS5.0之后推出的内存管理的新特性。本质上还是使用引用计数来管理对象，只是我们在编写代码时，不需要向对象发送release或autorelease方法，也不可以调用dealloc方法，编译器会在合适的位置自动给用户生成release（autorelease）消息。GC是Garbage Collection，内存垃圾回收机制，ARC比GC性能好。</p>
<p>6.iOS中是否支持垃圾回收机制？</p>
<p>iOS开发只支持MRC与ARC，Mac开发支持GC垃圾回收机制，10.8之后弃用了GC，推荐使用ARC。</p>
<p>7.深、浅复制的基本概念以及区别？</p>
<p>浅复制：只复制对象本身，不对里面的属性复制。</p>
<p>深复制：不仅复制对象本身，对象持有的属性对象也做复制。</p>
<p>8.内存中的堆区和栈区的差别？</p>
<p>栈区（stack）由编译器自动分配释放，存放方法（函数）的参数值，局部变量的值等。</p>
<p>堆区（heap）一般由程序员分配与释放，若程序员不释放，则会内存溢出。</p>
<p>9.用户自定义了一个对象，如何实现拷贝（可变和不可变拷贝）？</p>
<p>必须实现copying和mutableCopying协议，表示返回一个不可变和可变的对象。否则，程序将会出现异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">	Person *person = [[self Class] allocWithZone:zone];</span><br><span class="line">	person-&gt;age = self.age;</span><br><span class="line">	person-&gt;name = self.name;</span><br><span class="line">	return person;</span><br><span class="line">&#125;</span><br><span class="line">-(id)mutableCopyWithZone:(NSZone *)zone;</span><br></pre></td></tr></table></figure>
<p>10.定义属性时，什么时候用assign、retain、copy和nonatomic？</p>
<p>assign：普通赋值，一般常用于基本数据类型，常见委托设计模式，以此来防止循环引用。</p>
<p>retain：保留计数，获得了对象的所有权。引用计数在原有基础上加1。</p>
<p>copy：用来复制对象，一般字符串使用，Foundation中的不可变对象使用，效果相当于retain，只是引用计数加1。</p>
<p>nonatomic：非原子性访问，不加同步，多线程并发访问会提高性能。</p>
<p>11.strong和weak，_unsafe_unretained与weak的区别？</p>
<p>strong：强引用，在ARC中告诉编译器帮助我们自动插入retain。</p>
<p>weak：弱引用，是普通赋值，相当于手动管理内存的assign。</p>
<p>_unsafe_unretained：与weak功能一致，区别在于当指向的对象销毁后，weak会将变量置为nil，防止调用野指针。</p>
<p>12.ARC存在内存泄露吗？</p>
<p>ARC中如果内存管理不当的话，同样会存在内存泄露。例如，ARC中也会循环引用导致内存泄露；Objective-C对象与CoreFoundation类之间桥接时，管理不当也会产生内存泄露。</p>
<p>13.当我们释放对象时，为什么需要调用[super dealloc]方法？</p>
<p>子类是继承自父类，那么子类中有一些实例变量（对象），是继承自父类的，因此，我们需要调用父类方法，将父类所拥有的实例进行释放。</p>
<p>14.自动释放池是什么，如何工作？</p>
<p>自动释放池是NSAutorelease类的一个实例，当向一个对象发送autorelease消息时，该对象会自动入池，待池销毁时，将会向池中所有对象发送一条release消息，释放对象。</p>
<p>15.为什么delegate（代理）属性都是assign而不是retain的？</p>
<p>防止循环引用，以至对象无法得到正确的释放。</p>
<h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><p>1.iOS开发中数据持久性有哪几种？</p>
<p>plist文件写入，对象归档，sqlite3数据库，CoreData。</p>
<p>2.什么是KVC和KVO？它们之间的关系是什么？</p>
<p>KVC：键值编码，是一种间接访问对象实例变量的机制，该机制可以不通过存取方法就可以访问对象的实例变量。</p>
<p>KVO：键值观察，是一种能使得对象获取到其他对象属性变化的通知机制。<br>实现KVO键值观察模式，被观察的对象必须使用KVC键值编码来修改它的实例变量，这样才能被观察者观察到。因此，KVC是KVO的基础或者说KVO的实现是建立在KVC的基础之上的。</p>
<p>3.简述常见的设计模式？</p>
<p>单例模式、代理设计、观察者（通知）、工厂方法、模板方法。</p>
<p>4.内存管理在dealloc方法中用release方法与self.xx=nil哪个好？</p>
<p>使用self.xx=nil更好，因为先调用了release方法，而且还将变量设置为nil，这样就更安全的释放对象，防止野指针调用。</p>
<p>5.线程与进程的区别和联系？</p>
<p>一般的应用程序是单个进程，也有多进程（Chrome），进程是个静态的容器，里面容纳了很多个线程，线程是一系列方法的线性执行路径。</p>
<p>6.Objective-C语言的优缺点？</p>
<p>优点：类目、动态识别、支持C语言、Objective-C与C++可以混编。</p>
<p>缺点：不支持命名空间、不支持运算符重载、不支持多重继承。</p>
<p>7.代理delegate、通知Notification与block的使用区别？</p>
<p>delegate和block一般是用于两个对象一对一之间的通信交互，delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信。block更加简洁，不需要定义繁琐的协议方法，但是如果通信事件比较多的话，建议使用delegate。<br>Notification主要用于一对多情况下通信，而且，通信对象之间不需要建立关系，但是使用通知，代码可读性差。</p>
<p>8.控制器ViewController的loadView、viewDidLoad、viewWillApear和viewDidUnload分别是在什么时候调用？</p>
<p>loadView：当控制器的根视图view为空，且此view被访问时调用。</p>
<p>viewDidLoad：loadView调用之后被调用。</p>
<p>viewWillApear：当控制器根视图view被添加到父视图上时调用。</p>
<p>viewDidUnload：iOS6.0之前，当内存警告时，先卸载视图，再调用<br>viewDidUnload来释放内存。</p>
<p>9.@synthesize和@dynamic的区别？</p>
<p>@synthesize：系统自动生成getter和setter属性声明。</p>
<p>@dynamic：告诉编译器，属性的获取与赋值方法由用户自己实现，不自动生成。</p>
<p>10.事件响应者链的概念？</p>
<p>响应者链表示一系列的响应者对象。事件被交由第一响应者对象处理，如果第一响应者不处理，事件被沿着响应者链向上传递，交给下一个响应者。一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件交由它处理，如果它不处理，事件会被传递给它的视图控制器对象（如果存在），然后是它的父视图对象（如果存在），以此类推，直到顶层视图。接下来会沿着顶层视图到窗口（UIWindow对象），再到程序（UIApplication对象）。如果整个过程都没有响应这个事件，该事件被丢弃。一般情况下，在响应者链中只要有对象处理事件，事件就停止传递。但有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。</p>
<p>11.C语言中的static变量和static函数有什么作用？</p>
<p>1）表示变量是静态存储变量，表示变量存放在静态存储区。</p>
<p>2）加在函数前面的时候表示该函数是内部连接，只在本文件中有效，别的文件中不能使用该函数。</p>
<p>12.指针题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）int a; //一个数值。</span><br><span class="line">2）int *a; //一个指向数值的指针。</span><br><span class="line">3）int **a; //一个指向指针的指针。</span><br><span class="line">4）int a[10]; //一个有10个指针的数组，该指针是指向一个整型数的。</span><br><span class="line">5）int *a[10]; //一个有10个指针的数组，该指针是指向一个整型数的。</span><br><span class="line">6）int (*a)[10]; //一个指向有10个整型数数组的指针。</span><br><span class="line">7）int (*a)(int); //一个指向函数的指针，该函数有一个整型参数并返回一个整型数。</span><br><span class="line">8）int (*a[10])(int); //一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数。</span><br></pre></td></tr></table></figure>
<p>13.写一个NSString类的实现？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+(id)initWithCString:(const char *)nullTerminatedCString encoding:(NSStringEncoding)encoding &#123;</span><br><span class="line">	NSString *obj;</span><br><span class="line">	obj = [self allocWithZone:NSDefaultMallocZone()];</span><br><span class="line">	obj = [obj initWithCString:nullTerminatedCString encoding:encoding];</span><br><span class="line">	return autorelease(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14.Objective-C与C如何混用？Objective-C与C++如何混用？</p>
<p>实现文件的扩展名.m改成.mm即可，但cpp文件必须只能使用C/C++代码，而且cpp文件include的头文件中，也不能出现Objective-C的代码，因为cpp只能写C++的代码。</p>
<p>15.Objective-C中有私有方法和私有变量吗？</p>
<p>使用private修饰的全局变量是私有的变量。</p>
<p>Objective-C在语法上没有设计私有的方法，不过可以通过延展在实现文件里定义方法作为私有的方法。但不是真正意义上的私有方法，也是可以调用的，只是外部不可见而已。</p>
<h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h2><p>1.下面关键字const有什么含义？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const int a;</span><br><span class="line">int const a;</span><br><span class="line">const int *a;</span><br><span class="line">int * const a;</span><br></pre></td></tr></table></figure>
<p>前两个的作用是一样的，a是一个常整型数。</p>
<p>第三个意味着a是一个指向常整型数的指针（即整型数是不可修改的，但指针可以）。</p>
<p>第四个意味着a是一个指向整型数的常指针（即指针指向的整型数是可以修改的，但指针是不可修改的）。</p>
<p>2.C语言中extern的作用，extern “C”的作用？</p>
<p>1）extern可以置于变量或者函数前，以标示变量或函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。</p>
<p>2）C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。</p>
<p>3.Objective-C是如何管理内存的？</p>
<p>Objective-C语言是使用引用计数来管理一个对象的生命周期，当对象被其他“人”使用的时候引用计数加1，不使用时减1，当此对象的引用计数为0时，则对象被系统回收。</p>
<p>4.什么是动态绑定（多态）？</p>
<p>动态绑定是面向对象特性之一多态的体现，声明一个变量，在运行的时候可以绑定不同的对象，比如在方法的参数中声明这样一个变量UIView *view，运行的时候，我们可以根据不同的应用场景给view变量传入不同的对象，可以传递一个UIButton对象，也可以传入UIImageView对象。</p>
<p>5.如何理解delegate？</p>
<p>delegate，又称为委托或代理，它是一种设计模式。delegate主要用于两个对象之间的通信交互，并且解除两个通信对象的耦合性，iOS中大量使用了delegate设计，主要用于视图与使用对象之间的通信交互。</p>
<p>6.block与函数有何异同？block有何优点？</p>
<p>1）block类似于C里面的函数指针，都可以作为参数进行传递，用于回调。但是block的实现可以定义在方法中，函数则不可以。</p>
<p>2）block语法简洁，可以在方法中定义实现，这样可以访问方法中的局部变量，使代码更加的紧凑，结构化。</p>
<p>7.为什么标准头文件都有类似以下的结构？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __INCvxWorksh</span><br><span class="line">#define __INCvxWorksh</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">/*...*/</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif /*__INCvxWorksh*/</span><br></pre></td></tr></table></figure>
<p>显然，头文件中的编译宏“#ifndef <strong>INCvxWorksh、#define </strong>INCvxWorksh、#endif”的作用是防止该头文件被重复引用。</p>
<p>8.CocoaTouch框架？</p>
<p>UIKit、Foundation、CoreGraphic、CoreAnimation</p>
<p>1）音频和视频：Core Audio、OpenAL、Media Library、AV Foundation</p>
<p>2）数据管理：Core Data、SQLite</p>
<p>3）图形和动画：Core Animation、OpenGL ES、Quartz 2D、Core Graphic</p>
<p>4）用户应用：Address Book、Core Location、Map Kit、Store Kit</p>
<p>9.栈结构与队列的区别？</p>
<p>栈（stack）：限定只能在表的一端进行插入和删除操作的线性表。</p>
<p>队列（queue）：限定只能在表的一端插入和在另一端进行删除操作的线性表。</p>
<p>1）队列先进先出，栈先进后出。</p>
<p>2）对插入和删除操作的“限定”不同。</p>
<p>3）遍历数据速度不同。队列遍历数据的速度要快得多。</p>
<p>10.Objective-C中有无多重继承？如何实现多重继承？</p>
<p>Objective-C是没有多重继承的。</p>
<p>Cocoa中所有的类都是NSObject的子类，多继承在这里是用protocol委托代理来实现的。</p>
<p>面向对象语言大部分都是单继承，例如：Java、C#。</p>
<p>C++支持多继承。</p>
<p>11.static全局变量与普通的全局变量的区别？局部变量呢？函数呢？</p>
<p>1）static全局变量与普通全局变量的区别：static全局变量只初始化一次，防止在其他文件单元中被引用。</p>
<p>2）static局部变量与普通局部变量的区别：static局部变量只被初始化一次，下一次依据上一次结果值。</p>
<p>3）static函数与普通函数的区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。</p>
<p>12.什么是类目与延展？</p>
<p>类目：为已知的类增加新的方法。</p>
<p>延展：通知在本类的定义里使用类目来声明私有方法。</p>
<p>13.Objective-C中的协议和Java中的接口区别？</p>
<p>协议定义的方法，可以设置可选实现和必须实现。</p>
<p>接口则是必须全部实现。</p>
<p>14.在一个对象的方法里self.name=”object”和name=”object”有什么不同？</p>
<p>前者调用的是设置器方法，后者是普通赋值。</p>
<p>15.单例设计模式的实现？为什么使用单例设计？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static File *instance = nil;</span><br><span class="line">@implementation File</span><br><span class="line">//获取单例的方法</span><br><span class="line">+(id)shareInstance &#123;</span><br><span class="line">	@synthesize (self) &#123;</span><br><span class="line">		if(instance == nil) &#123;</span><br><span class="line">			instance = [[File alloc] init];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return instance;</span><br><span class="line">&#125;</span><br><span class="line">//覆写allocWithZone、copyWithZone、retain、release和autorelease方法，目的是限制这个类只创建一个对象</span><br></pre></td></tr></table></figure>
<p>为什么使用单例设计？</p>
<p>1）单例设计是用来限制一个类只能创建一个对象，那么此对象中的属性可以存储全局共享的数据，所有的类都可以访问、设置此单例对象中的属性数据。</p>
<p>2）如果一个类创建的时候非常的耗费性能，那么此类如果能满足要求，可以设置为单例节约性能。</p>
<h2 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h2><p>1.层CALayer和UIView的区别是什么？</p>
<p>两者最大的区别是，图层不会直接渲染到屏幕上。UIView是iOS系统中界面元素的基础，所有的界面元素都是继承自它，它本身是由CoreAnimation来实现的，它真正绘图的部分是由一个CALayer类来管理的。UIView本身更像是一个CALayer的管理器。一个UIView上可以有多个CALayer，每个CALayer显示一种东西，增强UIView的展现能力。</p>
<p>2.什么是GCD？</p>
<p>GCD是Apple开发的一个多核编程的较新的解决方法。在Mac OS X 10.6雪豹中首次推出，并引入到iOS4.0。GCD是一个替代诸如NSThread等技术的很高效和强大的技术。GCD完全可以处理诸如数据锁定和资源泄漏等复杂的异步编程问题。</p>
<p>3.TCP/UDP的区别和联系？</p>
<p>1）TCP的全称为传输控制协议，这种协议可以提供面向连接的、可靠的、点到点的通信。</p>
<p>2）UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。</p>
<p>3）用TCP还是UDP，需要看程序注重哪一个方面，需要可靠还是快速。</p>
<p>4.Socket连接和Http连接的区别？</p>
<p>Http连接：Http连接就是所谓的短链接，即客户端向服务器发送一次请求，服务器响应后连接即会断掉。</p>
<p>Socket连接：Socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉。</p>
<p>5.什么是TCP连接的三次握手？</p>
<p>第一次握手：客户端发送SYN包（SYN=j）到服务器，并进入SYN_SEND状态，等待服务器确认。</p>
<p>第二次握手：服务器收到SYN包，必须确认客户的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。</p>
<p>第三次握手：客户端接收到服务器的SYN+ACK包，向服务器发送确认包ACK（ACK=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>6.frame和bounds的区别？</p>
<p>frame指的是：该view在父view坐标系统中的位置大小（参照点是父视图的坐标系统）。</p>
<p>bounds指的是：该view在本身坐标系统中的位置和大小（参照点是本身的坐标系统）。</p>
<p>7.如何理解MVC设计模式？</p>
<p>MVC是一种架构设计，M表示数据模型，V表示视图，C表示控制器。</p>
<p>数据模型：负责存储、定义、操作数据。</p>
<p>视图：用来展示数据给用户，和用户进行操作交互。</p>
<p>控制器：它是M与V的协调者，控制器获取数据，将数据交给视图去展示。</p>
<p>8.控制器的xib是怎么加载的？</p>
<p>当UIViewController的loadView被调用时，在此方法中，通过NSBundle加载xib，先通过控制器的类名作为xib的文件名加载此xib文件。如果找到此xib文件，则加载为view对象作为控制器的根视图，如果没有xib文件，则通过alloc创建一个view对象作为根视图。</p>
<p>9.控制器如何处理系统内存不足警告？</p>
<p>内存不足时，系统会调用控制器didReceiveMemoryWaring方法通知控制器内存不足。iOS6.0与6.0之前的处理方式不一样。</p>
<p>1）iOS6.0之前：调用didReceiveMemoryWaring后，将self.view设置为nil，并且再调用viewDidUnload方法，在此方法中我们应该释放子视图。</p>
<p>2）iOS6.0之后：调用didReceiveMemoryWaring后，不再调用viewDidUnload方法，则应该在didReceiveMemoryWaring方法中手动将self.view=nil，并且释放子视图。</p>
<p>10.iOS中对象间有哪些通信方式？</p>
<p>代理delegate、block、通知和KVO。</p>
<p>11.block在内存管理上的特点？需要注意循环引用，如何解决循环引用？</p>
<p>1）block中使用了局部对象，则会将此对象retain，引用了当前对象的属性或者方法，则会将当前对象retain。</p>
<p>2）解决循环引用：将当前对象赋值给一个局部变量，并且使用__block关键字修饰该局部变量，使用该变量访问当前对象的属性和方法。</p>
<p>12.Objective-C中有线程池（线程队列）吗？NSOperationQueue是如何管理线程的？</p>
<p>NSOperationQueue是Objective-C的线程池，线程池中可以存放多个线程。</p>
<p>NSOperationQueue可以管理线程的并发数，还可以管理线程间的优先级。</p>
<p>13.timer的间隔周期准吗？为什么？怎样实现一个精准的timer？</p>
<p>定时器timer一般都是准确的，但是当主线程有些时候难免会出现堵塞情况，这样就有可能导致定时器timer会延迟从而不准确。我们可以开发一个多线程，在此多线程上运行定时器，这样多线程只运行定时器，不会因堵塞而导致误差。</p>
<p>14.Http协议的特点？GET与POST的区别？什么是Https协议？</p>
<p>1）Http协议是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，连接则断开。</p>
<p>2）GET请求没有请求体，POST含有请求体，请求参数可以放入请求体中，所以，POST可以提交大量的数据给服务器，更加安全。</p>
<p>3）HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议，它是一个安全通信通道，它基于HTTP开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层（SSL）进行信息交换，简单来说它是HTTP的安全版。</p>
<p>15.XML数据的解析方式各有什么不同？JSON解析有哪些框架？</p>
<p>XML数据解析有两种方式：DOM解析和SAX解析。</p>
<p>DOM解析：必须完成DOM树的构造，在处理规模较大的XML文档时就很耗费内存，占用资源较多。</p>
<p>SAX解析：与DOM不同的是，SAX是用事件驱动模型，解析XML文档时每遇到一个开始或者结束标签、属性或一条指令时，程序就产生一个事件来进行相应的处理。因此，SAX相对于DOM来说更适合操作大的XML文档。</p>
<p>JSON解析：现在性能比较好的主要是第三方的JSONKit和iOS自带的JSON解析类，自带的JSON解析性能是最高的，但是只能是iOS5之后才可以使用。</p>
<h2 id="第五部分"><a href="#第五部分" class="headerlink" title="第五部分"></a>第五部分</h2><p>1.tableView是如何复用的？</p>
<p>如果屏幕上能显示10个单元格，则tableView只会创建11个单元格，也就是n+1，当滑到第12个单元格时就会复用第1个单元格对象。tableView中有个单元格池的概念，tableView调用协议方法获取单元格时，先从池子中查找是否有可复用的单元格，如果有则复用，如果没有则创建一个单元格对象。</p>
<p>2.如何优化tableView的滑动速度？</p>
<p>1）复用单元格。</p>
<p>2）使用不透明的视图，单元格中尽量少使用动画。</p>
<p>3）图片加载使用异步加载，并且设置图片加载的并发数。</p>
<p>4）滑动时不加载图片，停止滑动开始加载。</p>
<p>5）文字、图片可直接drawInRect绘制。</p>
<p>6）如非必要，减少reloadData全部cell，只reloadRowsAtIndexPaths。</p>
<p>7）如果cell是动态行高度，计算出高度后缓存。</p>
<p>8）cell高度固定的话直接用cell.rowHeight设置高度。</p>
<p>3.谈谈对Runloop的理解？</p>
<p>Run loops是线程相关的基础框架的一部分。一个run loop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。使用run loop的目的是让你的线程在有工作的时候忙于工作，而没有工作的时候处于休眠状态。</p>
<p>4.如何调用drawRect方法与layoutSubView方法？这两个方法的作用？</p>
<p>通过setNeedsLayout方法异步调用layoutSubView方法。</p>
<p>通过setNeedsDisplay方法异步调用drawRect方法。<br>drawRect方法用于绘图，layoutSubView方法用于布局子视图。</p>
<p>5.UIView与UIViewController的关系？</p>
<p>每个控制器都有一个根视图，控制器UIViewController用来管理此视图的加载和显示。</p>
<p>6.iOS中有哪些手势？</p>
<p>轻击、捏合、平移、轻扫、旋转和长按。</p>
<p>7.Http和Socket的区别？</p>
<p>Http是客户端用Http协议进行请求，发送请求时需要封装http请求头，并绑定请求的数据，服务器一般有Web服务器配合（当然也非绝对）。Http请求方式为客户端主动发起请求，服务器才能给响应，一次请求完毕后则断开连接，以节省资源。服务器不能主动给客户端响应（除非采用http长连接技术）。iPhone主要使用的类是NSURLConnection。</p>
<p>Socket是客户端跟服务器直接使用Socket套接字进行连接，并没有规定连接后断开，所以客户端和服务器可以保持连接通道，双方都可以主动发送数据。一般在游戏开发或股票开发，这种要求即时性很强并且保持发送数据量比较大的场合使用。主要使用的类是CFSocketRef。</p>
<p>8.storyboard有什么特点？</p>
<p>storyboard是iOS5新增的特性，是对xib的升级版本，引入了一个容器用于管理多个xib文件，和它们之间的跳转交互。</p>
<p>优点：不用再为每个控制器创建xib文件；可以使用静态cell，当cell固定且不多时，使用起来比较方便。</p>
<p>缺点：storyboard单个文件，不利于团队协作开发。</p>
<p>9.如何打包静态库？</p>
<p>新建一个Framework&amp;Library的项目，编译的时候会将项目中的代码文件打包成一个.a静态库文件。</p>
<p>10.APP发布的上架流程？</p>
<p>1）在苹果官网的开发者中心，新建一个APP，填写此APP相关的一些描述信息。</p>
<p>2）下载安装发布证书。</p>
<p>3）选择发布证书，使用Archive编译发布包。</p>
<p>4）使用Xcode提交发布包。</p>
<p>11.iOS5有哪些新特性？</p>
<p>iCloud、定制UI、storyboard、ARC、CoreImage滤镜、新增JSON解析类。</p>
<p>12.iOS6有哪些新特性？</p>
<p>UIRefreshControl水滴效果下拉刷新、UICollectionView控件的使用、SLComposeViewController新浪微博控件、PassKit中Passbook、AutoLayout自动布局。</p>
<p>13、iOS7有哪些新特性？</p>
<p>系统：全新的UI设计与交互；Control Center控制中心；全新的多任务Multitasking；AirDrop共享文件；全新的Safari浏览器交互式体验。</p>
<p>SDK：动态UIKit，新增了UIDynamicItem委托，用来为UIView制定动态行为；新增游戏引擎Sprite Kit Framework框架，类似于Cocos2D。</p>
<p>14.ARC有什么特点？</p>
<p>ARC是编译器特性，iOS5.0新添加的特性，使用ARC开发者不需要再retain、release、autorelease，因为编译器会在合适的地方自动插入retain、release。</p>
<p>ARC不会因少release而导致内存泄漏，过度使用release导致程序崩溃，</p>
<p>ARC可以产生更简洁的代码和更健壮的应用。</p>
<p>15.SVN、Git协作开发，怎么防止代码文件冲突？</p>
<p>防止代码冲突：不要多人同时修改同一个文件。例如，A、B都修改同一个文件，先让A修改，然后提交到服务器，然后B更新下来，再进行修改。<br>服务器上的项目文件xcodeproj，仅让一个人管理提交，其他人只更新。防止此文件产生冲突。</p>
<h2 id="第六部分"><a href="#第六部分" class="headerlink" title="第六部分"></a>第六部分</h2><p>1.什么是ARC？</p>
<p>ARC是automatic reference counting自动引用计数，在程序编译时自动加入retain/release。在对象被创建时retain count+1，在对象被release时count-1，当count=0时，销毁对象。程序中加入autoreleasepool对象会由系统自动加上autorelease方法，如果该对象引用计数为0，则销毁。那么ARC是为了解决MRC手动管理内存存在的一些而诞生的。</p>
<p>MRC下内存管理的缺点：</p>
<p>1）释放一个堆内存时，首先要确定指向这个堆空间的指针都被release了。(避免提前释放)</p>
<p>2）释放指针指向的堆空间，首先要确定哪些指向同一个堆，这些指针只能释放一次。(避免释放多次，造成内存泄露)</p>
<p>3）模块化操作时，对象可能被多个模块创建和使用，不能确定最后由谁释放。</p>
<p>4）多线程操作时，不确定哪个线程最后使用完毕。<br>虽然ARC给我们编程带来的很多好多，但也可能出现内存泄露。如下面两种情况：</p>
<p>1）循环参照：A有个属性参照B，B有个属性参照A，如果都是strong参照的话，两个对象都无法释放。</p>
<p>2）死循环：如果有个ViewController中有无限循环，也会导致即使ViewController对应的view消失了，ViewController也不能释放。</p>
<p>2.block一般用哪个关键字修饰，为什么？</p>
<p>block一般使用copy关键之进行修饰，block使用copy是从MRC遗留下来的“传统”，在MRC中，方法内容的block是在栈区的，使用copy可以把它放到堆区。但在ARC中写不写都行：编译器自动对block进行了copy操作。</p>
<p>3.用@property声明的NSString（或NSArray，NSDictionary）经常</p>
<p>使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？<br>用@property声明 NSString、NSArray、NSDictionary 经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>
<p>如果我们使用是strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。</p>
<p>copy此特质所表达的所属关系与strong类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。 当属性类型为NSString时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个NSMutableString类的实例。这个类是NSString的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>
<p>4.runloop、autorelease pool以及线程之间的关系？</p>
<p>每个线程(包含主线程)都有一个Runloop。对于每一个Runloop，系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个像callstack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。</p>
<p>5.@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的？</p>
<p>“属性”(property)有两大概念：ivar(实例变量)、存取方法(access method=getter)，即@property = ivar + getter + setter。<br>例如下面的这个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface WBTextView :UITextView  </span><br><span class="line">@property (nonatomic,copy)NSString *placehold;  </span><br><span class="line">@property (nonatomic,copy)UIColor *placeholdColor;  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>类完成属性的定以后，编译器会自动编写访问这些属性的方法(自动合成autosynthesis)，上述代码写出来的类等效与下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@interface WBTextView :UITextView  </span><br><span class="line">- (NSString *)placehold;  </span><br><span class="line">-(void)setPlacehold:(NSString *)placehold;  </span><br><span class="line">-(UIColor *)placeholdColor;  </span><br><span class="line">-(void)setPlaceholdColor:(UIColor *)placeholdColor;  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>详细介绍见：<a href="http://blog.csdn.net/jasonjwl/article/details/49427377" target="_blank" rel="external">http://blog.csdn.net/jasonjwl/article/details/49427377</a></p>
<p>6.分别写一个setter方法用于完成<code>@property (nonatomic,retain)NSString *name</code>和<code>@property (nonatomic,copy) NSString *name</code>？</p>
<p>retain属性的setter方法是保留新值并释放旧值，然后更新实例变量，令其指向新值。顺序很重要。假如还未保留新值就先把旧值释放了，而且两个值又指向同一个对象，先执行的release操作就可能导致系统将此对象永久回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(void)setName:(NSString *)name&#123;</span><br><span class="line">    [name retain];</span><br><span class="line">    [_name release];</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line">-(void)setName:(NSString *)name&#123;     </span><br><span class="line">    [_name release];</span><br><span class="line">    _name = [name copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7.说说assign和weak，_block和 _weak的区别？</p>
<p>assign适用于基本数据类型，weak是适用于NSObject对象，并且是一个弱引用。</p>
<p>assign其实也可以用来修饰对象，那么为什么不用它呢？因为被assign修饰的对象在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil。如果在后续内存分配中，刚巧分到了这块地址，程序就会崩溃掉。而weak修饰的对象在释放之后，指针地址会被置为nil。</p>
<p><code>_block</code>是用来修饰一个变量，这个变量就可以在block中被修改。</p>
<p><code>_block</code>:使用_block修饰的变量在block代码块中会被retain(ARC下，MRC下不会retain)。</p>
<p>_weak:使用_weak修饰的变量不会在block代码块中被retain。</p>
<p>8.请说出下面代码是否有问题，如果有问题请修改？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">        for (int i=0; i&lt;largeNumber; i++) &#123;</span><br><span class="line">            Person *per = [[Person alloc] init];</span><br><span class="line">            [per autorelease];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>内存管理的原则：如果对一个对象使用了alloc、copy、retain，那么你必须使用相应的release或者autorelease。咋一看，这道题目有alloc，也有autorelease，两者对应起来，应该没问题。但autorelease虽然会使引用计数减一，但是它并不是立即减一，它的本质功能只是把对象放到离他最近的自动释放池里。当自动释放池销毁了，才会向自动释放池中的每一个对象发送release消息。这道题的问题就在autorelease。因为largeNumber是一个很大的数，autorelease又不能使引用计数立即减一，所以在循环结束前会造成内存溢出的问题。</p>
<p>解决方案如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">        for (int i=0; i&lt;100000; i++) &#123; </span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">            Person *per = [[Person alloc] init];</span><br><span class="line">            [per autorelease];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在循环内部再加一个自动释放池，这样就能保证每创建一个对象就能及时释放。</p>
<p>9.请问下面代码是否有问题，如有问题请修改？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">        NSString *str = [[NSString alloc] init];</span><br><span class="line">        [str retain];</span><br><span class="line">        [str retain];</span><br><span class="line">        str = @&quot;jxl&quot;;</span><br><span class="line">        [str release];</span><br><span class="line">        [str release];</span><br><span class="line">        [str release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这道题跟第8题一样存在内存泄露问题，</p>
<p>1）内存泄露 ；</p>
<p>2）指向常量区的对象不能release。</p>
<p>指针变量str原本指向一块开辟的堆区空间，但是经过重新给str赋值，str的指向发生了变化，由原来指向堆区空间，到指向常量区。常量区的变量根本不需要释放，这就导致了原来开辟的堆区空间没有释放，造成内存泄露。</p>
<p>10.什么情况下使用weak关键字，相比assign有什么不同？什么情况使用weak关键字？</p>
<p>1）在ARC中，在有可能出现循环引用的时候，往往要通过让其中一端使用weak来解决。比如delegate代理。</p>
<p>2）自身已经对它进行一次强引用，没有必要再强引用一次，此时也会使用weak，自定义控件属性一般也使用weak。</p>
<p>不同点：</p>
<p>1）weak此特性表明该属性定义了一种“非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特性与assign一样，然而在属性所指的对象遭到销毁时，属性值也会清空。而assign的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。</p>
<p>2）assign可以用非OC对象，而weak必须用于OC对象。</p>
<p>11.内存管理语义(assign、strong、weak等的区别)?</p>
<p>1）assign “设置方法” 只会执行针对“纯量”的简单赋值操作。</p>
<p>2）strong  此特性表明该属性定义了一种“拥有关系”。为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。</p>
<p>3）weak 此特性表明该属性定义了一种“非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特性同assign类似，然而在属性所指的对象遭到销毁时，属性值也会清空。</p>
<p>4）unsafe_unretained  此特性的语义和assign相同，但是它适用于“对象类型”，该特性表达一种“非拥有关系”，当目标对象遭到销毁时，属性值不会自动清空，这一点与weak有区别。</p>
<p>5）copy 此特性所表达的所属关系与strong类似。然而设置方法并不保留新值，而是将其“拷贝”。当属性类型为NSString*时，经常用此特性来保护其封装性，因为传递给设置方法的新值有可能指向一个NSMutableString类的实例。这个类是NSString的子类，表示一种可以修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变”的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的”，就应该在设置新属性值时拷贝一份。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔试面试是程序员应聘绕不过的坎，想进大厂就一定要有知识储备量，而这个却是最佳的考察方式。笔者分享一些收集的iOS面试题，答案仅供参考，如有错误，还请指正。&lt;/p&gt;
    
    </summary>
    
      <category term="talk" scheme="http://charsdavy.github.io/categories/talk/"/>
    
    
      <category term="ios" scheme="http://charsdavy.github.io/tags/ios/"/>
    
      <category term="碎碎念" scheme="http://charsdavy.github.io/tags/text/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C中的NSPredicate</title>
    <link href="http://charsdavy.github.io/2017/03/28/objective-c-NSPredicate/"/>
    <id>http://charsdavy.github.io/2017/03/28/objective-c-NSPredicate/</id>
    <published>2017-03-27T23:51:52.000Z</published>
    <updated>2017-03-31T12:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>编写软件时，经常需要获取一个对象集合，并通过某些已经条件计算该集合的值。你需要保留符合某个条件的对象，删除那些不满足条件的对象，从而提供一些有意义的对象。</p>
<p>在使用软件iPhoto的过程中，经常会看到这种现象，如果通知iPhoto仅显示等级为三星级或三星级以上的图片，则指定的条件为“照片的等级必须为三星级或三星级以上”。这样，所有照片都需要经过该过滤器过滤。满足条件的对象通过了过滤器，而其他对象被筛除了。最后，iPhoto将显示出所有高质量的图片。</p>
<p>Cocoa提供了一个名为NSPredicate的类，它用于指定过滤器的条件。可以创建NSPredicate对象，通过该对象准确地描述所需的条件，对每个对象通过谓词进行筛选，判断它们是否与条件相匹配。这里的“谓词”通常用在数学和计算机科学概念中，表示计算真值或假值的函数。</p>
<a id="more"></a>
<p>Cocoa用NSPredicate描述查询的方式，原理类似于在数据库中进行查询。可以在数据库风格的API中使用NSPredicate类，例如Core Data和Spotlight。可以将NSPredicate看成另一种间接操作方式。例如，如果需要查询满足条件的机器人，可以使用谓词对象进行检查，而不必使用代码进行显示查询。通过交换谓词对象，可以使用通用代码对数据进行过滤，而不必对相关条件进行硬编码。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>1）方式一</p>
<p>创建许多对象，并将它们组合起来。如果正在构建通用用户接口来指定查询，采用这种方式比较简单。</p>
<p>2）方式二</p>
<p>查询代码中的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Car *car;</span><br><span class="line">Car = makeCar(@&quot;Herbie&quot;, @&quot;Honda&quot;, @&quot;CRX&quot;,  1984, 2, 110000, 58);</span><br><span class="line">[garage addCar:car];</span><br><span class="line">/*构建的汽车：品牌为Herbie，型号为双门1984Honda CRX，马力引擎为58，已经行驶距离为110000英里*/</span><br><span class="line">/*创建谓词*/</span><br><span class="line">NSPredicate *predicate;</span><br><span class="line">predicate = [NSPredicate predicateWithFormat:@&quot;name == &apos;Herbie&apos;&quot;];</span><br></pre></td></tr></table></figure>
<p>计算谓词</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BOOL match = [predicate evaluateWithObject:car];</span><br><span class="line">NSLog(@&quot;%s&quot;,(match) ? &quot;YES&quot;:&quot;NO&quot;);</span><br></pre></td></tr></table></figure>
<p>另外一个谓词：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;engine.horsepower &gt;150&quot;];</span><br><span class="line">/*查看车库中哪些车的功率最大，可以循环测试每个汽车的谓词*/</span><br><span class="line">NSArray *cars = [garage cars];</span><br><span class="line">for(Car *car in cars)&#123;</span><br><span class="line">    if([predicate evaluateWithObject:car])&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, car.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>如果我们不必像上文那样编写for循环和if语句，这有什么不好？实际上，某些类别将谓词过滤方法添加到了Cocoa集合类中。<code>-filteredArrayUsingPredicate:</code>是NSArray数组中的一种类别方法，它将循环过滤数组内容，根据谓词计算每个对象的值，并将值为YES的对象累积到将被返回的新数组中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSArray *results;</span><br><span class="line">results = [cars filteredArrayUsingPredicate:predicate];</span><br><span class="line">NSLog(@&quot;%@&quot;,results);</span><br></pre></td></tr></table></figure>
<p>假如有一个可变数组，你需要剔除不属于该数组的所有项目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *carsCopy = [cars mutableCopy];</span><br><span class="line">[carsCopyfilterUsingPredicate:predicate];</span><br></pre></td></tr></table></figure>
<h2 id="格式说明符"><a href="#格式说明符" class="headerlink" title="格式说明符"></a>格式说明符</h2><p>资深编程人员都知道，硬编码并非好方法，因此，我们可以通过格式符构建谓词：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSPredicate  *predicate = [NSPredicate predicateWithFormat:@&quot;engine.horsepower &gt; %d&quot;, 50];</span><br></pre></td></tr></table></figure>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>NSPredicate的格式字符串包含大量不同的运算符。</p>
<p>1）比较和逻辑运算符</p>
<p>谓词字符串语法支持C语言中一些常用的运算符，例如等号运算符==和=。<br>不等号运算符具有各种形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;：大于</span><br><span class="line">&gt;=和=&gt;：大于或等于</span><br><span class="line">&lt;：小于</span><br><span class="line">&lt;=和=&lt;：小于或等于</span><br><span class="line">!=和&lt;&gt;：不等于</span><br></pre></td></tr></table></figure>
<p>此外，谓词字符串语法还支持括号表达式和AND、OR、NOT逻辑运算符或者C样式的等效表达式&amp;&amp;、||和!。</p>
<p>2）数组运算符</p>
<p>谓词字符串“(engine.horsepower&gt; 50) OR (engine.horsepower &lt; 200)”是一种十分常见的模式。等效于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predicate= [NSPredicate predicateWithFormat:@&quot;engine.horespower BETWEEN &#123;50,200&#125;&quot;];</span><br></pre></td></tr></table></figure>
<p>花括号表示数组，BETWEEN将数组中第一个元素看成是数组的下界，第二个元素看成是数组的上界。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *betweens = [NSArray arrayWithObjects:[NSNumber numberWithInt:50],[NSNumber   numberWithInt:200], nil];</span><br><span class="line">predicate = [NSPredicate predicateWithFormat:@&quot;engine.horsepower BETWEEN %@&quot;,betweens];</span><br></pre></td></tr></table></figure>
<p>数组不仅仅用来指定某个区间的端点值。你可以使用IN运算符查找数组中是否含有某个特定值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predicate = [NSPredicate predicateWithFormat:@&quot;name IN &#123;&apos;Herbie&apos;, &apos;Snugs&apos;, &apos;Badger&apos;,&apos;Flap&apos;&#125;&quot;];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编写软件时，经常需要获取一个对象集合，并通过某些已经条件计算该集合的值。你需要保留符合某个条件的对象，删除那些不满足条件的对象，从而提供一些有意义的对象。&lt;/p&gt;
&lt;p&gt;在使用软件iPhoto的过程中，经常会看到这种现象，如果通知iPhoto仅显示等级为三星级或三星级以上的图片，则指定的条件为“照片的等级必须为三星级或三星级以上”。这样，所有照片都需要经过该过滤器过滤。满足条件的对象通过了过滤器，而其他对象被筛除了。最后，iPhoto将显示出所有高质量的图片。&lt;/p&gt;
&lt;p&gt;Cocoa提供了一个名为NSPredicate的类，它用于指定过滤器的条件。可以创建NSPredicate对象，通过该对象准确地描述所需的条件，对每个对象通过谓词进行筛选，判断它们是否与条件相匹配。这里的“谓词”通常用在数学和计算机科学概念中，表示计算真值或假值的函数。&lt;/p&gt;
    
    </summary>
    
      <category term="pieces" scheme="http://charsdavy.github.io/categories/pieces/"/>
    
    
      <category term="ios" scheme="http://charsdavy.github.io/tags/ios/"/>
    
      <category term="objc" scheme="http://charsdavy.github.io/tags/objc/"/>
    
  </entry>
  
  <entry>
    <title>日语-助词</title>
    <link href="http://charsdavy.github.io/2017/03/26/japanese-auxiliary-word/"/>
    <id>http://charsdavy.github.io/2017/03/26/japanese-auxiliary-word/</id>
    <published>2017-03-26T13:34:16.000Z</published>
    <updated>2017-04-17T01:47:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>助词，又称为语助词。文法术语，指的是一种词类，属于虚词，附着在其他词汇、词组，或是句子上，作为辅助之用。通常用于句子前、中、后，表示各种语气；或是用于语句中间，表示结构上的关系。</p>
<p>日语中的助词极为丰富，而每一个助词的使用场景也非常多，不得不承认这是一大难点，也是重点。</p>
<a id="more"></a>
<h2 id="に用法"><a href="#に用法" class="headerlink" title="に用法"></a>に用法</h2><ul>
<li>1）表地点，场所名词+に+名词，具体位置</li>
</ul>
<p>部屋に机があります。</p>
<ul>
<li>2）表时间点（包含数字的时间）</li>
</ul>
<p>学校は８時半に始まります。</p>
<ul>
<li>3）表附着点</li>
</ul>
<p>温泉に入ります。</p>
<p>船に乗ります。</p>
<ul>
<li>4）表目的</li>
</ul>
<p>日本へ花見に行きます。</p>
<p>土曜日か日曜日に買い物に行きます。（第一个に表示时间点，第二个に表示目的）</p>
<ul>
<li>5）表对象，人物对象，抽象事物</li>
</ul>
<p>友達に会います。</p>
<ul>
<li>6）表频率</li>
</ul>
<p>李さんは１週間に２回プールへ行きます。</p>
<p>李さんは週に２回プールへ行きます。</p>
<ul>
<li>7）表目的地</li>
</ul>
<p>日本に行きます。</p>
<p>家に帰ります。</p>
<ul>
<li>8）表选择</li>
</ul>
<p>赤いほうがいいです。じゃあ、これにします。</p>
<h2 id="で用法"><a href="#で用法" class="headerlink" title="で用法"></a>で用法</h2><ul>
<li>1）表交通手段</li>
</ul>
<p>上海まで飛行機で行きます。</p>
<ul>
<li>2）表地点范围，名词+で+动词</li>
</ul>
<p>図書館で勉強します。</p>
<p>お昼は食堂（しよくどう）で食べます。</p>
<p>妹は部屋で音樂を聞きます。</p>
<ul>
<li>3）表方式，手段</li>
</ul>
<p>速達で送ります。</p>
<p>メールで両親と連絡します。</p>
<ul>
<li>4）表原材料（で表示能看出原材料，から表示不能看出原材料）</li>
</ul>
<p>こむぎこでパンを作ります。</p>
<ul>
<li>5）表花费（时间，金钱）</li>
</ul>
<p>このケーキは３個で１５０円です。</p>
<ul>
<li>6）表主体</li>
</ul>
<p>みなさんで読みましょう。</p>
<ul>
<li>7）表并列（二类形容词或名词）</li>
</ul>
<p>森さんは親切（しんせつ）で優（やさ）しいです。</p>
<h3 id="で和に的区别"><a href="#で和に的区别" class="headerlink" title="で和に的区别"></a>で和に的区别</h3><p>１）で强调后接动态动词。に强调后接静态动词。</p>
<h2 id="が用法"><a href="#が用法" class="headerlink" title="が用法"></a>が用法</h2><ul>
<li>1）表情感词前</li>
</ul>
<p>ネズミがこれい。</p>
<ul>
<li>2）表能力词前</li>
</ul>
<p>日本語が分かる。</p>
<p>日本語ができる。</p>
<ul>
<li>3）自动词前</li>
</ul>
<p>足が疲れる。</p>
<p>足が痛い。</p>
<ul>
<li>4）形容词前</li>
</ul>
<p>箱根はホテルや旅館が多いですね。</p>
<ul>
<li>5）存在句（が表听话方不知道的，は表双方都知道的）</li>
</ul>
<p>ホテルで友達の写真展があります。</p>
<ul>
<li>6）疑问词作主语</li>
</ul>
<p>この中でどの料理がいちばんおいしいですか。</p>
<h2 id="を用法"><a href="#を用法" class="headerlink" title="を用法"></a>を用法</h2><ul>
<li>1）表对象，动宾结构，名词+を+动词</li>
</ul>
<p>パンヤミルクなどを食べます。</p>
<ul>
<li>2）表范围，路线</li>
</ul>
<p>駅前を通る（とおる）。</p>
<ul>
<li>3）表出发点</li>
</ul>
<p>家をでます。</p>
<h2 id="から用法"><a href="#から用法" class="headerlink" title="から用法"></a>から用法</h2><ul>
<li>1）表时间起点</li>
</ul>
<p>來週、金曜日の夜７時から、ホテルでパーテイーがあります。</p>
<ul>
<li>2）表空间起点</li>
</ul>
<p>大阪（おおさか）から上海（シャンハイ）まで飛行機（ひこうき）で行きますか。</p>
<ul>
<li>3）表因为</li>
</ul>
<p>私はドリアンを全然食べません。嫌いですから。</p>
<h2 id="へ用法"><a href="#へ用法" class="headerlink" title="へ用法"></a>へ用法</h2><ul>
<li>1）表去向</li>
</ul>
<p>吉田さんは中国へ行きます。</p>
<h2 id="か用法"><a href="#か用法" class="headerlink" title="か用法"></a>か用法</h2><ul>
<li>1）表选择，二选一，名词+か+名词</li>
</ul>
<p>毎月（まいつき）１回か２回映画（えいが）を見ます。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;助词，又称为语助词。文法术语，指的是一种词类，属于虚词，附着在其他词汇、词组，或是句子上，作为辅助之用。通常用于句子前、中、后，表示各种语气；或是用于语句中间，表示结构上的关系。&lt;/p&gt;
&lt;p&gt;日语中的助词极为丰富，而每一个助词的使用场景也非常多，不得不承认这是一大难点，也是重点。&lt;/p&gt;
    
    </summary>
    
      <category term="talk" scheme="http://charsdavy.github.io/categories/talk/"/>
    
    
      <category term="碎碎念" scheme="http://charsdavy.github.io/tags/text/"/>
    
      <category term="日语" scheme="http://charsdavy.github.io/tags/japan-language/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 密码修改</title>
    <link href="http://charsdavy.github.io/2017/03/22/mysql-modify-password/"/>
    <id>http://charsdavy.github.io/2017/03/22/mysql-modify-password/</id>
    <published>2017-03-22T15:04:47.000Z</published>
    <updated>2017-03-31T12:10:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.mysql.com/" target="_blank" rel="external">MySQL</a>是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。<br>MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。<br>MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。</p>
<a id="more"></a>
<p>Mac 安装完 MySQL 之后，软件会生成一个默认密码给我们。但是，当我使用Navicat来建立连接是却提示密码失效，无奈，只能修改数据库默认密码。</p>
<p>接下来，记录整个root密码修改过程。</p>
<p><strong>在开始下面的步骤之前必须先停止mysql服务！</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1, cd /usr/local/mysql/bin/</span><br><span class="line">2, sudo su</span><br><span class="line">3, ./mysqld_safe --skip-grant-tables &amp; //这一步的作用是跨过权限验证</span><br><span class="line">4, ./mysql -uroot //以root身份登录，因为第三步的原因不需要密码了。这之后的命令就不需要在前面加./mysql了</span><br><span class="line">5, use mysql;</span><br><span class="line">6, update user set authentication_string=&apos;123456&apos; where User=&apos;root&apos;;</span><br></pre></td></tr></table></figure>
<p>网上流传的版本全部是set password ＝‘’ ，这样写一直报错说 ‘password’列不存在！<br>最终用sql命令查出来只有authentication_string字段，并没有password字段。</p>
<p>上一步执行之后本来以为已经可以登录了，可是navicat连接测试时出现了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1862 (HY000): Your password has expired. To log in you must</span><br><span class="line">change it using a client that supports expired passwords.</span><br></pre></td></tr></table></figure>
<p>所以还需要下面步骤</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1, cd /usr/local/mysql/bin/</span><br><span class="line">2, sudo su</span><br><span class="line">3, ./mysql -uroot  -p123456</span><br><span class="line">4, set password = password(&apos;123456&apos;)</span><br></pre></td></tr></table></figure>
<p>用户名：root，密码：123456<br>修改成功</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.mysql.com/&quot;&gt;MySQL&lt;/a&gt;是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。&lt;br&gt;MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。&lt;br&gt;MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。&lt;/p&gt;
    
    </summary>
    
      <category term="pieces" scheme="http://charsdavy.github.io/categories/pieces/"/>
    
    
      <category term="数据库" scheme="http://charsdavy.github.io/tags/database/"/>
    
      <category term="web" scheme="http://charsdavy.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>FMDB 代码阅读</title>
    <link href="http://charsdavy.github.io/2017/03/21/fmdb-reading/"/>
    <id>http://charsdavy.github.io/2017/03/21/fmdb-reading/</id>
    <published>2017-03-21T14:51:12.000Z</published>
    <updated>2017-03-31T11:45:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/ccgus/fmdb" target="_blank" rel="external">FMDB</a> 是iOS平台的SQLite数据库框架，以ObjC的方式封装了SQLite的C语言的API。FMDB使用起來更加的面向对象，省去了很多麻烦、冗余的C语言代码。相比Apple自带的Core Data框架，更加的轻量和灵活。提供了多线程安全的数据库操作的方法，有效的防止数据混乱。</p>
<a id="more"></a>
<h2 id="项目文件"><a href="#项目文件" class="headerlink" title="项目文件"></a>项目文件</h2><ul>
<li><p>FMDatabase : 一个SQLite数据库操作单例，通过它可以对数据库进行增删改查等操作。</p>
</li>
<li><p>FMResultSet : FMDatabase执行查询之后的结果集。</p>
</li>
<li><p>FMDatabaseAdditions : 拓展FMDatabase类，新增对查询结果只返回单个值的方法进行简化，对表、列是否存在，版本号，校验SQL等功能。</p>
</li>
<li><p>FMDatabaseQueue : 使用串行对列 ，操作多线程。</p>
</li>
<li><p>FMDatabasePool : 使用任务池的形式，操作多线程。</p>
</li>
</ul>
<h2 id="FMDatabase"><a href="#FMDatabase" class="headerlink" title="FMDatabase"></a>FMDatabase</h2><h3 id="打开数据库连接"><a href="#打开数据库连接" class="headerlink" title="打开数据库连接"></a>打开数据库连接</h3><ul>
<li><p><code>-(BOOL)open;</code> 其实是对sqlite3_open()函数的封装。</p>
</li>
<li><p><code>- (void)setMaxBusyRetryTimeInterval:(NSTimeInterval)timeout;</code> 设置重试时间。其实调用的是 <code>int sqlite3_busy_handler(sqlite3 *,int(*)(void *,int),void *);</code></p>
</li>
</ul>
<p>该函数的第一个参数：需要告知哪一个数据库需要设置busy handler。</p>
<p>第二个参数：需要回调的busy handler，当你调用该回调函数的时候，需要传给它一个void*的参数，也就是sqlite3_busy_handler的第三个参数。</p>
<p>第三个参数：需要传给回调函数的int参数表示这次锁事件，该回调函数被调用的次数。如果回调函数返回0时，将不再尝试再次访问数据库，而返回SQLITE_BUSY或者SQLITE_IOERR_BLOCKED。如果回调函数返回非0，将会不断尝试操作数据库。程序运行过程中，如果有其他进程或者线程在读写数据库，那么sqlite3_busy_handler会不断用用该回调函数，直到其他线程或者进程释放锁。获得锁之后，不会再调用该回调函数，从而继续向下执行下去，进行数据库操作。该函数是在获取不到锁的时候，以执行回调函数的次数來进行延时，等待其他进程或者线程操作数据库结束，从而获得锁进行操作数据库。</p>
<h3 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h3><p>executeQuery 系列函数从根本上看，其实调用的都是</p>
<p><code>- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args</code></p>
<ul>
<li><p>参数sql: 需要查詢的sql语句。</p>
</li>
<li><p>参数arrayArgs: 数组类型的参数。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FMResultSet *resultSet = [_db executeQuery:@&quot;SELECT * FROM t_student WHERE age &gt; ?&quot; withArgumentsInArray:@[@20]];</span><br></pre></td></tr></table></figure>
<ul>
<li>参数dictionaryArgs: 字典类型的参数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FMResultSet *resultSet = [_db executeQuery:@&quot;SELECT * FROM t_student WHERE age &gt; :age&quot; withParameterDictionary:@&#123;@&quot;age&quot;:@20&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>参数args: 可变参数类型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FMResultSet *resultSet = [_db executeQuery:@&quot;SELECT * FROM t_student WHERE age &gt; ?&quot;,@(20)];</span><br></pre></td></tr></table></figure>
<h3 id="更新数据库操作"><a href="#更新数据库操作" class="headerlink" title="更新数据库操作"></a>更新数据库操作</h3><p>这并不只是单单更新数据，而是对数据库有更改的操作，增删改都算。FMDB调用的都是<code>executeupdate</code>系列函数。这个函数基本上跟<code>executeQuery</code>系列函数的实现基本相同。只是它生成statement对象后，直接调用<code>rc = sqlite3_step(pStmt);</code>更新执行，而没有像<code>executeQuery</code>延迟到FMResultSet中的next函数中执行。</p>
<h3 id="一次性执行多条sql语句。"><a href="#一次性执行多条sql语句。" class="headerlink" title="一次性执行多条sql语句。"></a>一次性执行多条sql语句。</h3><p>使用<code>executeStatements</code>函数可以一次性执行多条sql语句。其实现方式就是对<code>sqlite3_exec</code>函数的封装。</p>
<h3 id="FMDB的加解密"><a href="#FMDB的加解密" class="headerlink" title="FMDB的加解密"></a>FMDB的加解密</h3><p>FMDataase中使用<code>- (BOOL)setKey:(NSString*)key;</code>和<code>- (BOOL)setKeyWithData:(NSData *)keyData;</code>输入数据库密码以求验证用户身份，使用<code>- (BOOL)rekey:(NSString*)key;</code>和<code>- (BOOL)rekeyWithData:(NSData *)keyData;</code>来给数据库设置密码或者清除密码。这两类函数分別对<code>sqlite3_key</code>和<code>sqlite3_rekey</code>函数进行了封装。</p>
<h2 id="FMDatabaseAdditions"><a href="#FMDatabaseAdditions" class="headerlink" title="FMDatabaseAdditions"></a>FMDatabaseAdditions</h2><h3 id="XXXForQuery系列函数"><a href="#XXXForQuery系列函数" class="headerlink" title="XXXForQuery系列函数"></a>XXXForQuery系列函数</h3><p>对查询结果只有一个值的情况进行优化，有多个值也只取第一个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  使用FMDatabaseAdditions中的intForQuery函数查找数据,如果返回结果有多个数据只取第一条数据</span><br><span class="line"> */</span><br><span class="line">- (void)queryForIntForQuery&#123;</span><br><span class="line">    int idx = [_db intForQuery:@&quot;SELECT id FROM t_student WHERE age = ?&quot;,@(26)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据库的一些概要信息"><a href="#数据库的一些概要信息" class="headerlink" title="数据库的一些概要信息"></a>数据库的一些概要信息</h3><p><code>-(BOOL)tableExists:(NSString*)tableName;</code>数据库表是否存在。</p>
<p><code>-(BOOL)columnExists:(NSString*)columnName inTableWithName:(NSString*)tableName;</code>在tableName表中columnName是否存在。</p>
<p><code>-(FMResultSet*)getSchema;</code>数据库的一些概要信息。</p>
<h3 id="校验sql语句是否合法"><a href="#校验sql语句是否合法" class="headerlink" title="校验sql语句是否合法"></a>校验sql语句是否合法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL)validateSQL:(NSString *)sql error:(NSError **)error;</span><br></pre></td></tr></table></figure>
<h2 id="FMResultSet"><a href="#FMResultSet" class="headerlink" title="FMResultSet"></a>FMResultSet</h2><h3 id="初始化对象"><a href="#初始化对象" class="headerlink" title="初始化对象"></a>初始化对象</h3><ul>
<li>参数1：(FMStatement *)statement</li>
</ul>
<p>该对象主要是对sqlite3_stmt的封装，sqlite3_stmt * 所表示的内容可以看成是预处理过的sql语句，已经不是我们熟知的sql语句。它是一个已经把sql语句解析了，用sqlite自己表示记录的内部数据结构。</p>
<ul>
<li>参数2：(FMDatabase *)aDB<br>该结果集所属于的FMDatabase数据库操作对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)resultSetWithStatement:(FMStatement *)statement usingParentDatabase:(FMDatabase*)aDB;</span><br></pre></td></tr></table></figure>
<h3 id="遍历取得所有的结果集合"><a href="#遍历取得所有的结果集合" class="headerlink" title="遍历取得所有的结果集合"></a>遍历取得所有的结果集合</h3><p><code>-(BOOL)next;</code> 其实是对 <code>-(BOOL)nextWithError:(NSError **)outErr;</code> 函数的封装。主要作用是通过sqlite3_step函数对FMStatement中的sqlite3_stmt对象进行逐行取值。</p>
<h3 id="列名与该列的列数的一一对应关系"><a href="#列名与该列的列数的一一对应关系" class="headerlink" title="列名与该列的列数的一一对应关系"></a>列名与该列的列数的一一对应关系</h3><ul>
<li><p><code>@property (readonly) NSMutableDictionary  *columnNameToIndexMap;</code> 对象中保存了列名与索引一一对应的关系的对照表。</p>
</li>
<li><p><code>-(int)columnIndexForName:(NSString *)columnName;</code> 根据列名获取该列所在第几列（列的索引）</p>
</li>
<li><p><code>-(NSString *)columnNameForIndex:(int)columnIdx;</code> 根据列的索引获取该列的名称。</p>
</li>
</ul>
<h3 id="获得每一行中每一个列字段的值。"><a href="#获得每一行中每一个列字段的值。" class="headerlink" title="获得每一行中每一个列字段的值。"></a>获得每一行中每一个列字段的值。</h3><ul>
<li><p><code>-XXXForColumnIndex:(int)columnIdx;</code> 根据列的索引获取该列的值。</p>
</li>
<li><p><code>-XXXForColumn:(NSString*)columnName;</code> 根据列的名称获取该列的值。</p>
</li>
<li><p><code>-XXXForColumnIndex:(int)columnIdx;</code> 其实是对sqlite3<em>column</em>*函数的封装。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (int)intForColumnIndex:(int)columnIdx &#123;</span><br><span class="line">    return sqlite3_column_int([_statement statement], columnIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取每一行中所有的结果集合"><a href="#获取每一行中所有的结果集合" class="headerlink" title="获取每一行中所有的结果集合"></a>获取每一行中所有的结果集合</h3><p><code>- (NSDictionary*)resultDictionary;</code></p>
<h2 id="FMDatabaseQueue"><a href="#FMDatabaseQueue" class="headerlink" title="FMDatabaseQueue"></a>FMDatabaseQueue</h2><p>使用实例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];</span><br><span class="line"></span><br><span class="line">[queue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line">    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:1]];</span><br><span class="line">    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:2]];</span><br><span class="line">    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:3]];</span><br><span class="line"></span><br><span class="line">    FMResultSet *rs = [db executeQuery:@&quot;select * from foo&quot;];</span><br><span class="line">    while ([rs next]) &#123;</span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[queue inTransaction:^(FMDatabase *db, BOOL *rollback) &#123;</span><br><span class="line">    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:1]];</span><br><span class="line">    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:2]];</span><br><span class="line">    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:3]];</span><br><span class="line"></span><br><span class="line">    if (whoopsSomethingWrongHappened) &#123;</span><br><span class="line">        *rollback = YES;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // etc…</span><br><span class="line">    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:4]];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>数据库中的事务也是保证数据库安全的一种手段。一段sql语句，要么全部成功，要么全部不成功。</p>
<ul>
<li>关于延时性事务和独占性事务的区别</li>
</ul>
<p>在SQLite 3.0.8或更高版本中，事务可以是延迟的，即时的或者独占的。“延迟的”即是说在数据库第一次被访问之前不获得锁。这样就会延迟事务，BEGIN语句本身不做任何事情。直到初次读取或访问数据库时才获取锁。对数据库的初次读取创建一个SHARED锁，初次写入创建一个RESERVED锁。由于锁的获取被延迟到第一次需要时，别的线程或进程可以在当前线程执行BEGIN语句之后创建另外的事务写入数据库。若事务是即时的，则执行BEGIN命令后立即获取RESERVED锁，而不等数据库被使用。在执行BEGIN IMMEDIATE之后， 你可以确保其它的线程或进程不能写入数据库或执行BEGIN IMMEDIATE或BEGIN EXCLUSIVE. 但其它进程可以获取数据库。 独占事务在所有的数据库获取EXCLUSIVE锁，在执行BEGIN EXCLUSIVE之后，你可以确保在当前事务结束前没有任何其它线程或进程能够读写数据库。</p>
<h2 id="FMDatabasePool"><a href="#FMDatabasePool" class="headerlink" title="FMDatabasePool"></a>FMDatabasePool</h2><p>FMDatabasePool : 使用任务池的形式，对多线程的操作提供支持。</p>
<p>不过官方对这种方式并不推荐使用（ONLY_USE_THE_POOL_IF_YOU_ARE_DOING_READS_OTHERWISE_YOULL_DEADLOCK_USE_FMDATABASEQUEUE_INSTEAD），优先选择FMDatabaseQueue的方式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/ccgus/fmdb&quot;&gt;FMDB&lt;/a&gt; 是iOS平台的SQLite数据库框架，以ObjC的方式封装了SQLite的C语言的API。FMDB使用起來更加的面向对象，省去了很多麻烦、冗余的C语言代码。相比Apple自带的Core Data框架，更加的轻量和灵活。提供了多线程安全的数据库操作的方法，有效的防止数据混乱。&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://charsdavy.github.io/categories/code/"/>
    
    
      <category term="ios" scheme="http://charsdavy.github.io/tags/ios/"/>
    
      <category term="objc" scheme="http://charsdavy.github.io/tags/objc/"/>
    
      <category term="开源框架" scheme="http://charsdavy.github.io/tags/framework/"/>
    
      <category term="数据库" scheme="http://charsdavy.github.io/tags/database/"/>
    
      <category term="存储" scheme="http://charsdavy.github.io/tags/persistence/"/>
    
  </entry>
  
  <entry>
    <title>日语-动词</title>
    <link href="http://charsdavy.github.io/2017/02/26/japanese-verb/"/>
    <id>http://charsdavy.github.io/2017/02/26/japanese-verb/</id>
    <published>2017-02-26T13:33:06.000Z</published>
    <updated>2017-04-17T01:47:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>动词（Verb），简称v 。 一般就是用来表示动作或状态的词汇。基本上每个完整的句子都有一个动词，要表示第二个动作时可使用不定词、动名词、对等连接词、从属连接词或增加子句等方法连结。<br>&lt;比如&gt; 突跃,突击,突袭等描述动作过程均属动词。<br>中文语法中表示人或事物的动作或一种动态变化。一般出现在名词主语或主句后面。</p>
<p>日语中动词主要分为3大类，称为一类动词，二类动词和三类动词（简称，动1，动2和动3），而三类动词中又可以分为2类，即カ变和サ变动词。</p>
<p>另外，还有一种经常用到的动词，即授受动词。</p>
<a id="more"></a>
<h2 id="授受动词"><a href="#授受动词" class="headerlink" title="授受动词"></a>授受动词</h2><ul>
<li>あげます：我或我方给别人，常用于上对下</li>
</ul>
<p>私は小野さんにパンカチをあげます。</p>
<p>彼氏は李さんにバラをあげます。</p>
<p><strong>注意：</strong>若分不清我方和别人时，一律用这种句型。</p>
<p>父は母に本をあげます。</p>
<p>私は先生に本をあげます。</p>
<p><strong>注意：</strong>变疑问句</p>
<p>[我方]は誰（だれ）に何をあげますか。</p>
<ul>
<li>もらいます：我或我方从别人那里得到，礼貌用法</li>
</ul>
<p>私は先生から<strong>に</strong>辞書をもらいます。</p>
<p>私は会社<strong>から</strong>パソコンをもらいます。</p>
<p><strong>注意：</strong>别人为个人时，后面用に；别人为团体时，后面用から。</p>
<ul>
<li>くれます：别人给我或我方，平级间使用</li>
</ul>
<p>先生は私に辞書をくれます。</p>
<p>社長は弟におもちゃをくれます。</p>
<p><strong>注意</strong> 还有一些动词也属于授受类，例如，借东西，还东西。</p>
<p>教えます、貸します：我或我方教别人学习东西或借东西给别人。</p>
<p>習います、借ります：我或我方跟别人学习东西或从别人那里借东西。</p>
<h2 id="动词分类"><a href="#动词分类" class="headerlink" title="动词分类"></a>动词分类</h2><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>一类动词（动1）</td>
<td>以う段假名结尾的词　</td>
<td>　行く、読む、帰る（かえる）、滑る（すべる）　</td>
</tr>
<tr>
<td>二类动词（动2）</td>
<td>以る结尾，且る前为い段假名或え段假名的词　</td>
<td>　寝る、見る、食べる （<strong>注意</strong>一个汉字一个音）</td>
</tr>
<tr>
<td>三类动词（サ变）</td>
<td>する（万能动词）</td>
<td>　勉強する、電話する　</td>
</tr>
<tr>
<td>三类动词（カ变）</td>
<td>　来（く）る　</td>
<td>　</td>
</tr>
</tbody>
</table>
<h2 id="动词变形"><a href="#动词变形" class="headerlink" title="动词变形"></a>动词变形</h2><h3 id="原形变ます形"><a href="#原形变ます形" class="headerlink" title="原形变ます形"></a>原形变ます形</h3><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>一类动词</td>
<td>う段-&gt;い段＋ます　</td>
<td>　行く-&gt;行きます　</td>
</tr>
<tr>
<td>二类动词</td>
<td>去る-&gt;＋ます　</td>
<td>　見る-&gt;見ます　</td>
</tr>
<tr>
<td>三类动词（サ变）</td>
<td>　する-&gt;します　</td>
<td>　勉強する-&gt;勉強します　</td>
</tr>
<tr>
<td>三类动词（カ变）</td>
<td>　くる-&gt;きます　</td>
<td>　来る-&gt;来ます　</td>
</tr>
</tbody>
</table>
<h3 id="ます形变原形"><a href="#ます形变原形" class="headerlink" title="ます形变原形"></a>ます形变原形</h3><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>一类动词</td>
<td>去掉ます，将ます前一个假名按行后移一个　</td>
<td>　あります-&gt;ある　</td>
</tr>
<tr>
<td>二类动词</td>
<td>将ます去掉，直接换成る　</td>
<td>　見ます-&gt;見る　</td>
</tr>
<tr>
<td>三类动词（サ变）</td>
<td>　します-&gt;する　</td>
<td>　勉強します-&gt;勉強する　</td>
</tr>
<tr>
<td>三类动词（カ变）</td>
<td>　きます-&gt;くる　</td>
<td>　来ます-&gt;来る　</td>
</tr>
</tbody>
</table>
<h3 id="原形变て形"><a href="#原形变て形" class="headerlink" title="原形变て形"></a>原形变て形</h3><p>て形作用：两个动词间使用，表中顿，表相继；语法接续。</p>
<ul>
<li>一类动词变て形</li>
</ul>
<p>1）う、つ、る结尾，促音变。即去掉结尾假名变成って</p>
<p>示例：買う-&gt;買って、待つ-&gt;待って、売る（うる）-&gt;売って</p>
<p>2）ぬ、ぶ、む结尾，拨音变。即去掉结尾假名变成んで</p>
<p>示例：死ぬ-&gt;死んで、飛ぶ-&gt;飛んで、飲む-&gt;飲んで</p>
<p>3）く、ぐ结尾，い音变。即去掉结尾假名分别变成いて、いで</p>
<p>示例：歩く-&gt;歩いて、急ぐ-&gt;急いで</p>
<p>4）す变成して</p>
<p>示例：話す-&gt;話して</p>
<p><strong>特例</strong></p>
<p>行く-&gt;行って</p>
<ul>
<li>二类动词变て形</li>
</ul>
<p>去る+て</p>
<p>示例：見る-&gt;見て、食べる-&gt;食べて</p>
<ul>
<li>三类动词变て形</li>
</ul>
<p>1）する-&gt;して</p>
<p>示例：勉強する-&gt;勉強して</p>
<p>2）来る（くる）-&gt;来て（きて）</p>
<h3 id="原形变ない形"><a href="#原形变ない形" class="headerlink" title="原形变ない形"></a>原形变ない形</h3><ul>
<li>一类动词变ない形</li>
</ul>
<p>变う段为あ段+ない</p>
<p>示例：行く（いく）-&gt;行か（いか）ない</p>
<p><strong>特例：</strong>う-&gt;わ</p>
<p>手伝う（てつだう）-&gt;手伝わない（てつだわない）</p>
<ul>
<li>二类动词变ない形</li>
</ul>
<p>去る+ない</p>
<p>示例：見る-&gt;見ない、食べる-&gt;食べない</p>
<ul>
<li>三类动词变ない形</li>
</ul>
<p>1）する-&gt;しない</p>
<p>示例：勉強する-&gt;勉強しない</p>
<p>2）来る（くる）-&gt;来ない（こない）</p>
<h2 id="动词规则"><a href="#动词规则" class="headerlink" title="动词规则"></a>动词规则</h2><ul>
<li>一类动词</li>
</ul>
<table>
<thead>
<tr>
<th>あ段</th>
<th>い段</th>
<th>う段</th>
<th>え段</th>
<th>お段</th>
</tr>
</thead>
<tbody>
<tr>
<td>ない形</td>
<td>ます形</td>
<td>原形</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动词（Verb），简称v 。 一般就是用来表示动作或状态的词汇。基本上每个完整的句子都有一个动词，要表示第二个动作时可使用不定词、动名词、对等连接词、从属连接词或增加子句等方法连结。&lt;br&gt;&amp;lt;比如&amp;gt; 突跃,突击,突袭等描述动作过程均属动词。&lt;br&gt;中文语法中表示人或事物的动作或一种动态变化。一般出现在名词主语或主句后面。&lt;/p&gt;
&lt;p&gt;日语中动词主要分为3大类，称为一类动词，二类动词和三类动词（简称，动1，动2和动3），而三类动词中又可以分为2类，即カ变和サ变动词。&lt;/p&gt;
&lt;p&gt;另外，还有一种经常用到的动词，即授受动词。&lt;/p&gt;
    
    </summary>
    
      <category term="talk" scheme="http://charsdavy.github.io/categories/talk/"/>
    
    
      <category term="碎碎念" scheme="http://charsdavy.github.io/tags/text/"/>
    
      <category term="日语" scheme="http://charsdavy.github.io/tags/japan-language/"/>
    
  </entry>
  
  <entry>
    <title>Mac 安装和配置 Tomcat</title>
    <link href="http://charsdavy.github.io/2017/01/02/mac-install-apache-tomcat/"/>
    <id>http://charsdavy.github.io/2017/01/02/mac-install-apache-tomcat/</id>
    <published>2017-01-01T16:31:23.000Z</published>
    <updated>2017-03-31T12:08:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>Tomcat是由Apache软件基金会下属的Jakarta项目开发的一个Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。由于Tomcat本身也内含了一个HTTP服务器，它也可以被视作一个单独的Web服务器。但是，不能将Tomcat和Apache Web服务器混淆，Apache Web Server是一个用C语言实现的HTTP web server；这两个HTTP web server不是捆绑在一起的。Apache Tomcat包含了一个配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。</p>
<p>这篇文章主要介绍Mac环境下，使用Eclipse + Tomcat搭建Java EE开发环境。</p>
<a id="more"></a>
<h2 id="下载资源"><a href="#下载资源" class="headerlink" title="下载资源"></a>下载资源</h2><p>前去<a href="http://tomcat.apache.org/" target="_blank" rel="external">官网</a>下载安装包，<code>zip</code>和<code>tar.gz</code>均可。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>解压下载的压缩包文件，将文件放置<code>/Library/Tomcat</code>路径。</p>
<p>设置权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 755  /Library/Tomcat/bin/*.sh</span><br></pre></td></tr></table></figure>
<h2 id="启动Tomacat"><a href="#启动Tomacat" class="headerlink" title="启动Tomacat"></a>启动Tomacat</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh /Library/Tomcat/bin/startup.sh</span><br></pre></td></tr></table></figure>
<p>成功的话会出现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tomcat started.</span><br></pre></td></tr></table></figure>
<p>打开浏览器输入：<code>localhost:8080</code> 。就可以看见Tomcat:</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/mac-install-apache-tomcat.png?imageView/2/w/600" alt=""></p>
<h2 id="关闭Tomcat"><a href="#关闭Tomcat" class="headerlink" title="关闭Tomcat"></a>关闭Tomcat</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh /Library/Tomcat/bin/shutdown.sh</span><br></pre></td></tr></table></figure>
<h2 id="创建快捷命令"><a href="#创建快捷命令" class="headerlink" title="创建快捷命令"></a>创建快捷命令</h2><p>每次按照上述的开启，关闭命令来操作，太麻烦，我们可以使用下列方法创建简洁快捷的命令。</p>
<h4 id="创建shell文件"><a href="#创建shell文件" class="headerlink" title="创建shell文件"></a>创建shell文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/bin </span><br><span class="line">sudo touch tomcat</span><br></pre></td></tr></table></figure>
<h4 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 /usr/local/bin/tomcat</span><br></pre></td></tr></table></figure>
<h4 id="添加shell代码"><a href="#添加shell代码" class="headerlink" title="添加shell代码"></a>添加shell代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">start)</span><br><span class="line">sudo sh /Library/Tomcat/bin/startup.sh</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">sudo sh /Library/Tomcat/bin/shutdown.sh</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line">sudo sh /Library/Tomcat/bin/shutdown.sh</span><br><span class="line">sudo sh /Library/Tomcat/bin/startup.sh</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;Usage: start|stop|restart&quot;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tomcat start</span><br><span class="line">tomcat stop</span><br><span class="line">tomcat restart</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>为了便于配置Tomcat，我们需要安装Eclipse <a href="https://sourceforge.net/projects/tomcatplugin/?source=typ_redirect" target="_blank" rel="external">Tomcat插件</a> 。</p>
<p>打开Eclipse，选择菜单中的Preferences，选择Tomcat的版本，安装路径等。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/mac-install-apache-tomcat-02.png?imageView/2/w/600" alt=""></p>
<h2 id="第一个Web程序"><a href="#第一个Web程序" class="headerlink" title="第一个Web程序"></a>第一个Web程序</h2><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ol>
<li><p><code>File</code>-&gt;<code>New</code>-&gt;<code>Dynamic Web Project</code></p>
</li>
<li><p><code>File</code>-&gt;<code>New</code>-&gt;<code>JSP File</code><br> 新建JSP文件<code>index.jsp</code>，保存在<code>WebContent</code>根目录下。</p>
</li>
<li><p>添加代码至<code>index.jsp</code>文件</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">    pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;% java.util.Date d = new java.util.Date(); %&gt;</span><br><span class="line">&lt;h1&gt;</span><br><span class="line">Today&apos;s date is &lt;%= d.toString() %&gt; and this jsp page worked!</span><br><span class="line">&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>选中项目，<code>Run As</code>-&gt;<code>Run on Server</code></p>
<p><img src="http://o88e8any8.bkt.clouddn.com/mac-install-apache-tomcat-03.png?imageView/2/w/600" alt=""></p>
<p>运行效果：</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/mac-install-apache-tomcat-04.png?imageView/2/w/600" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tomcat是由Apache软件基金会下属的Jakarta项目开发的一个Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。由于Tomcat本身也内含了一个HTTP服务器，它也可以被视作一个单独的Web服务器。但是，不能将Tomcat和Apache Web服务器混淆，Apache Web Server是一个用C语言实现的HTTP web server；这两个HTTP web server不是捆绑在一起的。Apache Tomcat包含了一个配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。&lt;/p&gt;
&lt;p&gt;这篇文章主要介绍Mac环境下，使用Eclipse + Tomcat搭建Java EE开发环境。&lt;/p&gt;
    
    </summary>
    
      <category term="pieces" scheme="http://charsdavy.github.io/categories/pieces/"/>
    
    
      <category term="工具" scheme="http://charsdavy.github.io/tags/tool/"/>
    
      <category term="web" scheme="http://charsdavy.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>日语-形容词</title>
    <link href="http://charsdavy.github.io/2016/12/26/japanese-adjective/"/>
    <id>http://charsdavy.github.io/2016/12/26/japanese-adjective/</id>
    <published>2016-12-26T13:33:38.000Z</published>
    <updated>2017-04-13T02:09:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>形容词（Adjective），很多语言中均有的主要词类中的一种。形容词主要用来描写或修饰名词或代词，表示人或事物的性质、 状态、特征<br>或属性，常用作定语，也可作表语、补语或状语。</p>
<p>日语中的形容词分为两大类，称为一类形容词和二类形容词（简称，形1和形2）。形容词所表示的事物的属性，一般具有静止的、固定的、永恒的特点。</p>
<a id="more"></a>
<h2 id="形容词分类"><a href="#形容词分类" class="headerlink" title="形容词分类"></a>形容词分类</h2><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>一类形容词（形1）</td>
<td>以い结尾的词</td>
<td>美味しい（おいしい）、暑い（あっい）　</td>
</tr>
<tr>
<td>二类形容词（形2）</td>
<td>不以い结尾的词</td>
<td>　元気（げんき）、暇（ひま）</td>
</tr>
</tbody>
</table>
<p><strong>注意特例</strong></p>
<p><code>綺麗い（きれい）、嫌い（きらい）、いっぱい</code> 是形2。</p>
<h2 id="形容词变形"><a href="#形容词变形" class="headerlink" title="形容词变形"></a>形容词变形</h2><h3 id="形容词变否定"><a href="#形容词变否定" class="headerlink" title="形容词变否定"></a>形容词变否定</h3><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>一类形容词（形1）</td>
<td>去い变成くない或者くありません</td>
<td>　１）この料理は美味しくないです。２）この料理は美味しくありません。</td>
</tr>
<tr>
<td>二类形容词（形2）</td>
<td>　形2＋ではありません</td>
<td>　この通りはにぎやかではありません。</td>
</tr>
</tbody>
</table>
<p><strong>注意特例</strong></p>
<p><code>いいです</code>的否定形式是<code>よくないです</code>或<code>よくありません</code>。</p>
<h3 id="形容词变过去时"><a href="#形容词变过去时" class="headerlink" title="形容词变过去时"></a>形容词变过去时</h3><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>一类形容词（形1）</td>
<td>　去い变成かった　</td>
<td>　よい-&gt;よかった</td>
</tr>
<tr>
<td>二类形容词（形2）</td>
<td>　</td>
<td>　有名です-&gt;有名でした</td>
</tr>
</tbody>
</table>
<h3 id="形容词变过去否定时"><a href="#形容词变过去否定时" class="headerlink" title="形容词变过去否定时"></a>形容词变过去否定时</h3><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>一类形容词（形1）</td>
<td>　去い变成くなかった　</td>
<td>　よい-&gt;よくなかった</td>
</tr>
<tr>
<td>二类形容词（形2）</td>
<td>　</td>
<td>　有名です-&gt;有名ではありませんでした　</td>
</tr>
</tbody>
</table>
<p><strong>示例</strong></p>
<table>
<thead>
<tr>
<th>时态</th>
<th>一类形容词</th>
<th>变形</th>
<th>二类形容词</th>
<th>变形</th>
</tr>
</thead>
<tbody>
<tr>
<td>否定</td>
<td>よい</td>
<td>よくない</td>
<td>有名です</td>
<td>有名ではありません</td>
</tr>
<tr>
<td>过去时</td>
<td>よい</td>
<td>よかった</td>
<td>有名です</td>
<td>有名でした</td>
</tr>
<tr>
<td>过去否定时</td>
<td>よい</td>
<td>よくなかった</td>
<td>有名です</td>
<td>有名ではありませんでした</td>
</tr>
</tbody>
</table>
<h3 id="形容词变副词"><a href="#形容词变副词" class="headerlink" title="形容词变副词"></a>形容词变副词</h3><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>一类形容词（形1）</td>
<td>　去い变成く　</td>
<td>　多い（おおい）-&gt;多く</td>
</tr>
<tr>
<td>二类形容词（形2）</td>
<td>　直接加に　</td>
<td>　きれい-&gt;きれいに</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong></p>
<p>名词变副词规则与形2一致。</p>
<h3 id="形容词变て形"><a href="#形容词变て形" class="headerlink" title="形容词变て形"></a>形容词变て形</h3><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>一类形容词（形1）</td>
<td>　去い变成くて　</td>
<td>　広い（ひろい）-&gt;広くて</td>
</tr>
<tr>
<td>二类形容词（形2）</td>
<td>　直接加で　</td>
<td>　簡単（かんたん）-&gt;簡単で</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong><br>いい不能用来变形，要用其对应的よい进行变形。</p>
<p>名词变て形规则与形2一致。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;形容词（Adjective），很多语言中均有的主要词类中的一种。形容词主要用来描写或修饰名词或代词，表示人或事物的性质、 状态、特征&lt;br&gt;或属性，常用作定语，也可作表语、补语或状语。&lt;/p&gt;
&lt;p&gt;日语中的形容词分为两大类，称为一类形容词和二类形容词（简称，形1和形2）。形容词所表示的事物的属性，一般具有静止的、固定的、永恒的特点。&lt;/p&gt;
    
    </summary>
    
      <category term="talk" scheme="http://charsdavy.github.io/categories/talk/"/>
    
    
      <category term="碎碎念" scheme="http://charsdavy.github.io/tags/text/"/>
    
      <category term="日语" scheme="http://charsdavy.github.io/tags/japan-language/"/>
    
  </entry>
  
  <entry>
    <title>iOS App 上架（Analysis 工具使用）</title>
    <link href="http://charsdavy.github.io/2016/11/15/apple-app-release-analysis/"/>
    <id>http://charsdavy.github.io/2016/11/15/apple-app-release-analysis/</id>
    <published>2016-11-15T10:26:02.000Z</published>
    <updated>2017-03-31T11:12:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着iOS开发的流行，针对iOS开发涉及的方方面面，早有一些公司提供了专门的解决方案或工具。这些解决方案或工具包括：用户行为统计工具（友盟，Flurry，Google Analytics等), App Store销售分析工具（例如App annie)， App crash收集工具（例如Crashlytics)，App测试发布工具（Test Flight）, App Push服务等。</p>
<p>这些解决方案或工具节省了iOS开发者大量的开发时间，但是由于相关介绍文章的缺乏，许多开发者都在重复着自己一次又一次重新造轮子。所以将自己使用的相关的第三方服务使用经验，整理成一系列文章，以便广大开发者能够省去大量的重复性工作。</p>
<a id="more"></a>
<h1 id="用户习惯数据收集"><a href="#用户习惯数据收集" class="headerlink" title="用户习惯数据收集"></a>用户习惯数据收集</h1><p>了解用户的使用习惯以及相关数据信息，可以更好的帮助开发者调整产品的方向和重点。首先是数据的收集，受工作的影响，选择 <a href="https://mtj.baidu.com/" target="_blank" rel="external">百度移动统计</a> 。不得不说，这是一款很符合国人使用习惯的工具。</p>
<p>使用方法很简单，接入过程直接根据官方文档。自定义统计事件需要自己在web端逐个添加。而页面访问统计则不需要，只需要在App上将名字传入调用接口即可。</p>
<p>百度移动统计不仅仅是做应用统计，也可以做crash分析，游戏统计分析，DSP统计，还有广告营销分析。</p>
<p>页面数据的分析，可以帮助开发者很明了的知道用户群体的习惯与流失，有助于产品成长。</p>
<h1 id="Crash-数据收集"><a href="#Crash-数据收集" class="headerlink" title="Crash 数据收集"></a>Crash 数据收集</h1><p>作为上线App，最担心的就是crash数据的收集。<a href="http://try.crashlytics.com/" target="_blank" rel="external">Crashlytics</a> 是专门为移动应用开者发提供的保存和分析应用崩溃信息的工具。</p>
<h2 id="使用Crashlytics的好处"><a href="#使用Crashlytics的好处" class="headerlink" title="使用Crashlytics的好处"></a>使用Crashlytics的好处</h2><ul>
<li><p>Crashlytics不会漏掉任何应用崩溃信息。在iTunes Connect的后台查看不到任何崩溃信息。但是用户通过微博或者客服电话反馈应用崩溃的情况，在Crashlytics中都可以统计到。</p>
</li>
<li><p>Crashlytics可以像Bug管理工具那样，管理这些崩溃日志。例如：Crashlytics会根据每种类型的Crash的出现频率以及影响的用户量来自动设置优先级。对于每种类型的Crash，Crashlytics除了会像一般的工具提供Call Stack外，还会显示更多相关的有助于诊断的信息，例如：设备是否越狱，当时的内存量，当时的iOS版本等。对于修复掉的Crash日志，可以在Crashlytics的后台将其关掉。</p>
</li>
<li><p>Crashlytics可以每天和每周将崩溃信息汇总发到你的邮箱，所有信息一目了然。</p>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>注册</li>
</ul>
<p>使用邮箱在<a href="http://try.crashlytics.com/" target="_blank" rel="external">Crashlytic官网</a>注册。稍后会收到官方验证邮件，根据邮件内容及稍后提示一步步操作。</p>
<ul>
<li>接入工程</li>
</ul>
<p>根据官方接入引导<a href="https://www.fabric.io/kits" target="_blank" rel="external">教程</a>，分为使用pod方式和手动下载sdk接入方式。具体的可以根据官方文档来操作。这里主要分享一下自己遇到的问题。</p>
<p>1) 忘记添加 Run Script ，这个步骤会导致App无法build成功。</p>
<p>2) 重新配置 Crashlytics 之后，需要删除 <code>~/Library/Caches/com.crashlytics.data/</code> 和 <code>~/Library/Caches/com.crashlytics.mac/</code> 文件夹下的所有文件，重新build。</p>
<p>3) 注意配置 <code>Build Settings</code> 中 <code>Debug Information Format</code> 选项将debug和release全部设置成<code>DWARF with dSYM File</code>。</p>
<p>4) 如果提示 <code>missing dSYMs</code> ，就需要自行上载文件，具体<a href="https://docs.fabric.io/apple/crashlytics/missing-dsyms.html" target="_blank" rel="external">方法教程</a> 。</p>
<p>希望对大家有所帮助。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着iOS开发的流行，针对iOS开发涉及的方方面面，早有一些公司提供了专门的解决方案或工具。这些解决方案或工具包括：用户行为统计工具（友盟，Flurry，Google Analytics等), App Store销售分析工具（例如App annie)， App crash收集工具（例如Crashlytics)，App测试发布工具（Test Flight）, App Push服务等。&lt;/p&gt;
&lt;p&gt;这些解决方案或工具节省了iOS开发者大量的开发时间，但是由于相关介绍文章的缺乏，许多开发者都在重复着自己一次又一次重新造轮子。所以将自己使用的相关的第三方服务使用经验，整理成一系列文章，以便广大开发者能够省去大量的重复性工作。&lt;/p&gt;
    
    </summary>
    
      <category term="pieces" scheme="http://charsdavy.github.io/categories/pieces/"/>
    
    
      <category term="ios" scheme="http://charsdavy.github.io/tags/ios/"/>
    
      <category term="application" scheme="http://charsdavy.github.io/tags/application/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0 读书笔记 -- 熟悉Objective-C语言</title>
    <link href="http://charsdavy.github.io/2016/09/05/effective-objc-2-introduction-objc/"/>
    <id>http://charsdavy.github.io/2016/09/05/effective-objc-2-introduction-objc/</id>
    <published>2016-09-05T07:27:15.000Z</published>
    <updated>2017-03-31T11:43:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>看到Effective这个词，大家一定会想到《Effective C++》、《Effective Java》等业界名著，那些书里汇聚了多项实用技巧，又系统而深入的讲解了各种编程知识。那么，《Effective Objective-C 2.0》也是如此。</p>
<p>作为Mac OS X与iOS应用程序的开发语言，Objective-C作为首选。那么，它有哪些需要注意的呢？</p>
<a id="more"></a>
<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>Objective-C与C++、Java一样，是面向对象的语言，是由Smalltalk演化而来。Smalltalk是消息型语言的鼻祖。消息与函数调用之间的区别看上去就像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Messaging (Objective-C)</span><br><span class="line">Object *obj = [Object new];</span><br><span class="line">[obj performWith:parameter1 and:parameter2];</span><br><span class="line"></span><br><span class="line">//Function calling (C++)</span><br><span class="line">Object *obj = new Object;</span><br><span class="line">obj-&gt;perform(parameter1, parameter2);</span><br></pre></td></tr></table></figure>
<p>关键区别在于：使用消息结构的语言，其运行时所应执行的代码由运行环境来决定；而使用函数调用的语言，则由编译器决定。</p>
<p>Objective-C是C的“超集”(superset)，所以C语言中的所有功能在编写Objective-C代码时依然适用。理解C语言的内存模型(memory model)，有助于理解Objective-C的内存模型及其“引用计数”(reference counting)机制的工作原理。Objective-C语言中的指针是用来指示对象的。</p>
<h2 id="关于使用头文件"><a href="#关于使用头文件" class="headerlink" title="关于使用头文件"></a>关于使用头文件</h2><p>主要使用 <code>import</code> 关键字。然而，我们在 <code>.h</code> 文件中一般首选使用 <code>@class</code> 关键字，它能“向前声明”一个类。对于不需要知道类细节的情况下我们使用它。否则不会轻易使用 <code>import</code> 来引入整个头文件。</p>
<p>过多的引入头文件，会增加编译时间。这就是我们多使用 <code>@class</code> 关键字的直接原因。</p>
<p>除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用“向前声明”来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合(coupling)。</p>
<p>有时无法使用“向前声明”，比如要声明某个类遵循一项协议。这种情况下，尽量把“该类遵循某协议”的这条声明移至“class-continuation分类”中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。</p>
<h2 id="字面量语法"><a href="#字面量语法" class="headerlink" title="字面量语法"></a>字面量语法</h2><p>在编写Objective-C程序时，总会用到某几个类，它们属于Foundation框架。虽然从技术上来说，不用Foundation框架也能写出Objective-C代码，但是实际上却经常要用到此框架。这几个类是NSString、NUNumber、NSArray、NSDictionary。从类名上即可看出各自所表示的数据结构。</p>
<p>Objective-C以语法繁杂而著称。不过从Objective-C 1.0起，有一种简单的方式能创建NSString 对象。这就是“字符串字面量”(string literal)，其语法如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@"Effective Objective-C 2.0"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="字面数值"><a href="#字面数值" class="headerlink" title="字面数值"></a>字面数值</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *number = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">10</span>];</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="built_in">NSNumber</span> *number = @<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>更多表示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *intNumber = @11;</span><br><span class="line">NSNumber *floatNumber = @2.5f;</span><br><span class="line">NSNumber *doubleNumber = @3.1415926;</span><br><span class="line">NSNumber *boolNumber = @YES;</span><br><span class="line">NSNumber *charNumber = @'ABC';</span><br></pre></td></tr></table></figure>
<p>字面量语法也适用于下述表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x =5;</span><br><span class="line">float y = 6.5f</span><br><span class="line">NSNumber *expressionNumber = @(x * y);</span><br></pre></td></tr></table></figure>
<h3 id="字面量数组"><a href="#字面量数组" class="headerlink" title="字面量数组"></a>字面量数组</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSarray</span> *animals = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"cat"</span>, <span class="string">@"dog"</span>, <span class="string">@"mouse"</span>, <span class="string">@"badger"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">NSarray</span> *animals = @[<span class="string">@"cat"</span>, <span class="string">@"dog"</span>, <span class="string">@"mouse"</span>, <span class="string">@"badger"</span>];</span><br></pre></td></tr></table></figure>
<p>使用数组</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *dog = [animals objectAtIndex:<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">NSString</span> *dog = animals[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h3 id="字面量字典"><a href="#字面量字典" class="headerlink" title="字面量字典"></a>字面量字典</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *personData = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAnsKeys:<span class="string">@"Matt"</span>, <span class="string">@"firstName"</span>, <span class="string">@"Galloway"</span>, <span class="string">@"lastName"</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">28</span>], <span class="string">@"age"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *personData = @&#123;<span class="string">@"firstName"</span>:<span class="string">@"Matt"</span>, <span class="string">@"lastName"</span>:<span class="string">@"Galloway"</span>, <span class="string">@"age"</span>:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">28</span>]&#125;;</span><br></pre></td></tr></table></figure>
<p>使用字典</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *lastName = [personData objectForKey:<span class="string">@"lastName"</span>];</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">NSString</span> *lastName = personData[<span class="string">@"lastName"</span>];</span><br></pre></td></tr></table></figure>
<h3 id="可变数组和字典"><a href="#可变数组和字典" class="headerlink" title="可变数组和字典"></a>可变数组和字典</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mutableArray replaceObjectAtIndex:<span class="number">1</span> withObject:<span class="string">@"dog"</span>];</span><br><span class="line">[mutableDictionary setObject:<span class="string">@"Galloway"</span> forKey:<span class="string">@"lastName"</span>];</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">mutableArray[<span class="number">1</span>] = <span class="string">@"dog"</span>;</span><br><span class="line">mutableDictionary[<span class="string">@"lastName"</span>] = <span class="string">@"Galloway"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>字面量语法有个小小的限制，就是除了字符串以外，所创建出来的对象必须属于Foundation框架才行。如果自定义了这些类的子类，则无法用字面量语法创建其对象。要想创建自定义子类的实例，必须采用“非字面量语法”(nonliteral syntax)。</p>
<p>使用字面量语法创建出来的字符串、数组、字典对象都是不可变的(immutable)。若想要可变版本的对象，则需要复制一份：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *<span class="keyword">mutable</span> = [@[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>, @<span class="number">4</span>] mutableCopy];</span><br></pre></td></tr></table></figure>
<p>这么做会多调用一个方法，而且还要再创建一个对象，不过使用字面量语法所带来的好处还是多于上述缺点的。</p>
<p>用字面量语法创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值里不含nil。</p>
<h2 id="多用类型常量-少用-define预处理指令"><a href="#多用类型常量-少用-define预处理指令" class="headerlink" title="多用类型常量 少用#define预处理指令"></a>多用类型常量 少用#define预处理指令</h2><p>编写代码时经常要定义常量。掌握了Objective-C与其C语言的基础的人，也许会用这种方法来做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ANIMATION_DURATION 0.3</span><br></pre></td></tr></table></figure>
<p>上述预处理指令会把源代码中的ANIMATION_DURATION字符串替换为0.3.预处理过程会把碰到的所有ANIMATION_DURATION一律替换成0.3，这样的话，假设此指令声明在某个头文件中，那么所有引入了这个头文件的代码，其ANIMATION_DURATION都会被替换。</p>
<p>要解决此问题，应该设法利用编译器的某些特性才对。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure>
<p>用此方式定义的常量包含类型信息，其好处的清楚地描述了常量的含义。</p>
<p>常用的命名法是：</p>
<ul>
<li>若常量局限于某”编译单元”(translation unit，也就是“实现文件”，implementation file)之内，则在前面加字母k；</li>
<li>若常量在类之外可见，则通常以类名为前缀。</li>
</ul>
<p>定义常量的位置很重要。在头文件里声明预处理指令，这样会增加常量名称互相冲突的可能性。</p>
<p>在头文件中使用extern来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区隔，通常用与之相关的类名做前缀。</p>
<h2 id="枚举使用"><a href="#枚举使用" class="headerlink" title="枚举使用"></a>枚举使用</h2><p>枚举只是一种常量命名方式。某个对象所经历的各种状态就可以定义为一个简单的枚举集(enumeration set)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> IHConnectionState &#123;</span><br><span class="line">	IHConnectionStateDisconnected,</span><br><span class="line">	IHConnectionStateConnecting,</span><br><span class="line">	IHConnectionStateConnected</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>默认情况下，枚举起始值为0，以后依次递增，1,2,3…</p>
<p>其实还可以我们自己指定枚举值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> IHConnectionState &#123;</span><br><span class="line">	IHConnectionStateDisconnected = <span class="number">1</span>,</span><br><span class="line">	IHConnectionStateConnecting,</span><br><span class="line">	IHConnectionStateConnected</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以定义为位移值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="built_in">UIViewAutoresizing</span> &#123;</span><br><span class="line">	<span class="built_in">UIViewAutoresizing</span> = <span class="number">0</span>,</span><br><span class="line">	<span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">	<span class="built_in">UIViewAutoresizingFlexibleWidth</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">	<span class="built_in">UIViewAutoresizingFlexibleRightMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">	<span class="built_in">UIViewAutoresizingFlexibleTopMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">	<span class="built_in">UIViewAutoresizingFlexibleHeight</span> = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">	<span class="built_in">UIViewAutoresizingFlexibleBottomMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于枚举，Foundation框架中定义了一些辅助的宏，用这些来定义枚举类型时，也可以指定用于保存枚举值的底层数据类型。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, IHConnectionState) &#123;</span><br><span class="line">	IHConnectionStateDisconnected = <span class="number">1</span>,</span><br><span class="line">	IHConnectionStateConnecting,</span><br><span class="line">	IHConnectionStateConnected</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, IHPermittedDirection) &#123;</span><br><span class="line">	IHPermittedDirectionUp = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">	IHPermittedDirectionDown = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">	IHPermittedDirectionLeft = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">	IHPermittedDirectionRight = <span class="number">1</span> &lt;&lt; <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些宏的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span>(__cplusplus &amp;&amp; __cplusplus &gt;= 201103L &amp;&amp; (__has_extension(cxx_strong_enums) || __has_feature(objc_fixed_enum))) || (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum))</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> NS_ENUM(_type, _name)</span></span><br><span class="line">		<span class="keyword">enum</span> _name:_type _name; <span class="keyword">enum</span> _name:_type</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> (__cplusplus)</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">define</span> NS_OPTIONS(_type, _name)</span></span><br><span class="line">			type _name; <span class="keyword">enum</span>:_type</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">define</span> NS_OPTIONS(_type, _name)</span></span><br><span class="line">			<span class="keyword">enum</span> _name:_type _name; <span class="keyword">enum</span> _name:_type</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> NS_ENUM(_type, _name) _type _name; enum</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> NS_OPTIONS(_type, _name) _type _name; enum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>第一个#if用于判断编译器是否支持新式枚举。如果不支持，那么就用老式语法来定义枚举。</p>
<p>在处理枚举类型的switch语句中不要实现default分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch语句并未处理所有枚举。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到Effective这个词，大家一定会想到《Effective C++》、《Effective Java》等业界名著，那些书里汇聚了多项实用技巧，又系统而深入的讲解了各种编程知识。那么，《Effective Objective-C 2.0》也是如此。&lt;/p&gt;
&lt;p&gt;作为Mac OS X与iOS应用程序的开发语言，Objective-C作为首选。那么，它有哪些需要注意的呢？&lt;/p&gt;
    
    </summary>
    
      <category term="pieces" scheme="http://charsdavy.github.io/categories/pieces/"/>
    
    
      <category term="ios" scheme="http://charsdavy.github.io/tags/ios/"/>
    
      <category term="objc" scheme="http://charsdavy.github.io/tags/objc/"/>
    
  </entry>
  
  <entry>
    <title>Mac 如何升级 Ruby 版本</title>
    <link href="http://charsdavy.github.io/2016/09/03/mac-ruby-update/"/>
    <id>http://charsdavy.github.io/2016/09/03/mac-ruby-update/</id>
    <published>2016-09-03T08:47:54.000Z</published>
    <updated>2017-03-31T12:09:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>Ruby 是一种面向对象、命令式、函数式、动态的通用编程语言。 在20世纪90年代中期由日本人松本行弘（Matz）设计并开发。 遵守BSD许可证和Ruby License。 它的灵感与特性来自于Perl、Smalltalk、Eiffel、Ada以及Lisp语言。</p>
<p>Ruby 可运行于多种平台，如 Windows、MAC OS 和 UNIX 的各种版本。</p>
<p>Ruby用于最明显，且和Apple系列的程序员最直接关联的就是Mac的开发环境，直接关联于Cocoapods工具。但是，cocoapods工具与Ruby的版本有一定的关联性，难免不涉及到升级。</p>
<p>那么，如何升级最方便快捷呢？</p>
<a id="more"></a>
<p>这就是rvm大展身手的时候啦。rvm是什么？rvm是ruby版本管理器。为什么要安装rvm呢？因为rvm可以让你拥有多个版本的Ruby，并且可以在多个版本之间自由切换。</p>
<h3 id="第一步：安装rvm"><a href="#第一步：安装rvm" class="headerlink" title="第一步：安装rvm"></a>第一步：安装rvm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L get.rvm.io | bash -s stable</span><br><span class="line">$ source ~/.profile</span><br></pre></td></tr></table></figure>
<p>等待终端加载完毕，后输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm -v</span><br></pre></td></tr></table></figure>
<p>如果能显示版本号,则安装成功。</p>
<h3 id="第二步：安装ruby"><a href="#第二步：安装ruby" class="headerlink" title="第二步：安装ruby"></a>第二步：安装ruby</h3><p>列出ruby可安装的版本信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm list known</span><br></pre></td></tr></table></figure>
<p>安装一个ruby版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm install 2.3</span><br></pre></td></tr></table></figure>
<p>如果想设置为默认版本，可以用这条命令来完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm use 2.1.4 --default</span><br></pre></td></tr></table></figure>
<p>查看已安装的ruby</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm list</span><br></pre></td></tr></table></figure>
<p>卸载一个已安装ruby版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rvm remove 2.3</span><br></pre></td></tr></table></figure>
<h3 id="第三步：更换源"><a href="#第三步：更换源" class="headerlink" title="第三步：更换源"></a>第三步：更换源</h3><p>查看已有的源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem source -l</span><br></pre></td></tr></table></figure>
<p>显示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CURRENT SOURCES</span><br><span class="line">http://rubygems.org/</span><br></pre></td></tr></table></figure>
<p>然后我们需要修改更换源（由于国内被墙），所以要把源切换至淘宝镜像服务器，在终端执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gem update --system</span><br><span class="line">$ gem uninstall rubygems-update</span><br><span class="line">$ gem sources -r http://rubygems.org/</span><br><span class="line">$ gem sources -a https://ruby.taobao.org</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ruby 是一种面向对象、命令式、函数式、动态的通用编程语言。 在20世纪90年代中期由日本人松本行弘（Matz）设计并开发。 遵守BSD许可证和Ruby License。 它的灵感与特性来自于Perl、Smalltalk、Eiffel、Ada以及Lisp语言。&lt;/p&gt;
&lt;p&gt;Ruby 可运行于多种平台，如 Windows、MAC OS 和 UNIX 的各种版本。&lt;/p&gt;
&lt;p&gt;Ruby用于最明显，且和Apple系列的程序员最直接关联的就是Mac的开发环境，直接关联于Cocoapods工具。但是，cocoapods工具与Ruby的版本有一定的关联性，难免不涉及到升级。&lt;/p&gt;
&lt;p&gt;那么，如何升级最方便快捷呢？&lt;/p&gt;
    
    </summary>
    
      <category term="talk" scheme="http://charsdavy.github.io/categories/talk/"/>
    
    
      <category term="mac" scheme="http://charsdavy.github.io/tags/mac-os/"/>
    
      <category term="工具" scheme="http://charsdavy.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS 开发 － 聊聊如何打包dmg文件</title>
    <link href="http://charsdavy.github.io/2016/09/03/mac-os-archive-app/"/>
    <id>http://charsdavy.github.io/2016/09/03/mac-os-archive-app/</id>
    <published>2016-09-03T01:43:24.000Z</published>
    <updated>2017-03-31T12:08:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为博主自己的需求，而App Store上的App不能满足需求，或者是说，想借此机会涉猎一下Mac OS的开发。之前一直臆想iOS开发和Mac OS差不多，实则不然。</p>
<p>BTW 推荐一款非Apple官方的App Store，<code>HackStore</code>是一款来自俄罗斯的Mac应用商店，我们可以将自己开发完的App免费发布上去，也是具有审核机制的，博主目前推广自己的<code>ImageHosting</code>，一款图床软件，目前支持七牛云存储。有需求欢迎大家使用，吐槽。 <a href="https://github.com/charsdavy/ImageHosting/releases" target="_blank" rel="external">ImageHosting for Mac</a></p>
<p>现在，分享一下，当我们完成Mac开发，release一个<code>.app</code>文件之后，我们应该如何打包成一个dmg文件的方法。</p>
<a id="more"></a>
<p>言归正传，说到dmg，这个我们熟悉的格式，那么它是怎么生成的呢，跟着接下来的步骤吧。博主将它们分为<code>系统默认</code>和<code>自定义</code>，不过，两者都离不开一个工具 －－ <code>磁盘工具（Disk Utility）</code>。</p>
<h3 id="系统默认"><a href="#系统默认" class="headerlink" title="系统默认"></a>系统默认</h3><p>打开 <code>磁盘工具</code> －&gt; <code>文件</code> －&gt; <code>新建映像</code> －&gt; <code>来自文件夹的映像</code></p>
<p><img src="http://o88e8any8.bkt.clouddn.com/mac-os-archive-app-default-build.png?imageView2/2/w/460" alt=""></p>
<p>资源文件夹内容</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/mac-os-archive-app-default-folder.png?imageView2/2/w/460" alt=""></p>
<p>配置 选择包括 <code>.app</code> 和 <code>Applications 替身</code> 文件夹的路径，也就是上图说的 资源文件夹 路径</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/mac-os-archive-app-default-build-config.png?imageView2/2/w/460" alt=""></p>
<p>点击 <code>打开</code> ，配置相关信息 点击 <code>存储</code> 即可。</p>
<h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>1 准备资源，包括：背景图片，<code>.app</code> 和 <code>Applications 替身</code> 文件。</p>
<p>2 创建一个空的映像文件</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/mac-os-archive-app-build-blank-dmg.png?imageView2/2/w/460" alt=""></p>
<p>配置信息</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/mac-os-archive-app-config-blank-dmg.png?imageView2/2/w/460" alt=""></p>
<p>3 配置资源 －－ 配置背景图</p>
<p>1）打开显示选项</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/mac-os-archive-app-blank-fill-src.png?imageView2/2/w/460" alt=""></p>
<p>2）配置背景图</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/mac-os-archive-app-show-view-option.png?imageView2/2/w/360" alt=""></p>
<p>3）隐藏背景图片文件</p>
<p>使用<code>mv</code>命令进行重命名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mv background.tif .background.tif</span><br></pre></td></tr></table></figure>
<p><img src="http://o88e8any8.bkt.clouddn.com/mac-os-archive-app-hidden-bg.png?imageView2/2/w/460" alt=""></p>
<p>4 配置资源 －－ 拖拽<code>.app</code> 和 <code>Applications 替身</code></p>
<p>5 转换</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/mac-os-archive-app-convert.png?imageView2/2/w/480" alt=""></p>
<p>配置转换信息</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/mac-os-archive-app-convert-config.png?imageView2/2/w/480" alt=""></p>
<p>6 效果</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/mac-os-archive-app-build-result.png?imageView2/2/w/460" alt=""></p>
<h3 id="附言"><a href="#附言" class="headerlink" title="附言"></a>附言</h3><p>每次自定义类型打包dmg，都需要从零开始，不能使用上一次的未转换时的文件直接替换<code>.app</code>文件。否则，呈现的样式将不是CD样式。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因为博主自己的需求，而App Store上的App不能满足需求，或者是说，想借此机会涉猎一下Mac OS的开发。之前一直臆想iOS开发和Mac OS差不多，实则不然。&lt;/p&gt;
&lt;p&gt;BTW 推荐一款非Apple官方的App Store，&lt;code&gt;HackStore&lt;/code&gt;是一款来自俄罗斯的Mac应用商店，我们可以将自己开发完的App免费发布上去，也是具有审核机制的，博主目前推广自己的&lt;code&gt;ImageHosting&lt;/code&gt;，一款图床软件，目前支持七牛云存储。有需求欢迎大家使用，吐槽。 &lt;a href=&quot;https://github.com/charsdavy/ImageHosting/releases&quot;&gt;ImageHosting for Mac&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在，分享一下，当我们完成Mac开发，release一个&lt;code&gt;.app&lt;/code&gt;文件之后，我们应该如何打包成一个dmg文件的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="pieces" scheme="http://charsdavy.github.io/categories/pieces/"/>
    
    
      <category term="mac" scheme="http://charsdavy.github.io/tags/mac-os/"/>
    
      <category term="工具" scheme="http://charsdavy.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>ImageHosting 开源软件的使用说明</title>
    <link href="http://charsdavy.github.io/2016/08/22/ImageHosting-use-introduction/"/>
    <id>http://charsdavy.github.io/2016/08/22/ImageHosting-use-introduction/</id>
    <published>2016-08-22T10:58:24.000Z</published>
    <updated>2017-04-06T02:23:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>博主在转战iOS开发以来，一直坚持撰写自己的技术博客。使用Github Pages + Hexo 搭建了属于自己的空间。具体搭建方法可以参考<a href="http://charsdavy.github.io/2016/05/31/build-blog-by-hexo/">《手把手教 GitHub + Hexo 搭建博客》</a> 。 然而，博客中有很多时候需要使用图片说明，俗话说“一图胜千言”，博主使用 七牛云 做图床，然每次编写博客时需要打开Web版上传图片，甚是繁琐。故此，博主自己编写了一个自己的图片上传软件。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ImageHosting-use-introduction-launchpad.png" alt=""></p>
<p>软件下载地址：<a href="https://github.com/charsdavy/ImageHosting/releases" target="_blank" rel="external">ImageHosting for Mac</a></p>
<p><a href="https://github.com/charsdavy/ImageHosting" target="_blank" rel="external">源代码地址</a></p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>遇到提示“不能安装未知来源程序”时，处理方法为，将权限改为“任何来源”即可。</p>
<h2 id="软件菜单栏"><a href="#软件菜单栏" class="headerlink" title="软件菜单栏"></a>软件菜单栏</h2><p><img src="http://o88e8any8.bkt.clouddn.com/ImageHosting-use-introduction-stateMenu.png" alt=""></p>
<h2 id="打开软件配置，添加账户信息"><a href="#打开软件配置，添加账户信息" class="headerlink" title="打开软件配置，添加账户信息"></a>打开软件配置，添加账户信息</h2><p><img src="http://o88e8any8.bkt.clouddn.com/ImageHosting-use-introduction-account.png" alt=""></p>
<h2 id="打开文件选择页，选择文件"><a href="#打开文件选择页，选择文件" class="headerlink" title="打开文件选择页，选择文件"></a>打开文件选择页，选择文件</h2><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p><img src="http://o88e8any8.bkt.clouddn.com/ImageHosting-use-introduction-upload-main.png" alt=""></p>
<h2 id="上传进度提示"><a href="#上传进度提示" class="headerlink" title="上传进度提示"></a>上传进度提示</h2><p><img src="http://o88e8any8.bkt.clouddn.com/ImageHosting-use-introduction-upload_1.png" alt=""></p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ImageHosting-use-introduction-upload_2.png" alt=""></p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ImageHosting-use-introduction-upload_3.png" alt=""></p>
<h2 id="上传完成"><a href="#上传完成" class="headerlink" title="上传完成"></a>上传完成</h2><p><img src="http://o88e8any8.bkt.clouddn.com/ImageHosting-use-introduction-upload-success-main.png" alt=""></p>
<h2 id="操作提示"><a href="#操作提示" class="headerlink" title="操作提示"></a>操作提示</h2><h3 id="未添加账户信息提示"><a href="#未添加账户信息提示" class="headerlink" title="未添加账户信息提示"></a>未添加账户信息提示</h3><p><img src="http://o88e8any8.bkt.clouddn.com/ImageHosting-use-introduction-no-account.png" alt=""></p>
<h3 id="未选择上传文件提示"><a href="#未选择上传文件提示" class="headerlink" title="未选择上传文件提示"></a>未选择上传文件提示</h3><p><img src="http://o88e8any8.bkt.clouddn.com/ImageHosting-use-introduction-no-select.png" alt=""></p>
<h3 id="上传文件成功提示"><a href="#上传文件成功提示" class="headerlink" title="上传文件成功提示"></a>上传文件成功提示</h3><p><img src="http://o88e8any8.bkt.clouddn.com/ImageHosting-use-introduction-upload-success.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博主在转战iOS开发以来，一直坚持撰写自己的技术博客。使用Github Pages + Hexo 搭建了属于自己的空间。具体搭建方法可以参考&lt;a href=&quot;http://charsdavy.github.io/2016/05/31/build-blog-by-hexo/&quot;&gt;《手把手教 GitHub + Hexo 搭建博客》&lt;/a&gt; 。 然而，博客中有很多时候需要使用图片说明，俗话说“一图胜千言”，博主使用 七牛云 做图床，然每次编写博客时需要打开Web版上传图片，甚是繁琐。故此，博主自己编写了一个自己的图片上传软件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ImageHosting-use-introduction-launchpad.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;软件下载地址：&lt;a href=&quot;https://github.com/charsdavy/ImageHosting/releases&quot;&gt;ImageHosting for Mac&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/charsdavy/ImageHosting&quot;&gt;源代码地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="project" scheme="http://charsdavy.github.io/categories/project/"/>
    
    
      <category term="mac" scheme="http://charsdavy.github.io/tags/mac-os/"/>
    
      <category term="工具" scheme="http://charsdavy.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊大小端问题</title>
    <link href="http://charsdavy.github.io/2016/08/13/memory-big-little-endian/"/>
    <id>http://charsdavy.github.io/2016/08/13/memory-big-little-endian/</id>
    <published>2016-08-13T13:34:48.000Z</published>
    <updated>2017-03-31T12:09:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器）。另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。</p>
<a id="more"></a>
<p>先来看一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> bits32;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> bytes[<span class="number">4</span>];</span><br><span class="line">&#125;value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLittleEndian</span><span class="params">()</span></span>&#123;</span><br><span class="line">        value.bytes[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        value.bytes[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        value.bytes[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        value.bytes[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value.bits32 == <span class="number">256</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( isLittleEndian())</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"is little endian! "</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"is big endian! "</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所谓的<strong>大端模式</strong>，是指数据的低位（就是权值较小的后面那几位）保存在内存的高地址中，而数据的高位，保存在内存的低地址中。这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；</p>
<p>所谓的<strong>小端模式</strong>，是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。 </p>
<p><strong>为什么会有大小端模式之分呢？</strong></p>
<p>这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器）。另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。</p>
<p>例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。<br>下面这段代码可以用来测试一下你的编译器是大端模式还是小端模式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> x; </span><br><span class="line"><span class="keyword">char</span> x0, x1; </span><br><span class="line">x = <span class="number">0x1122</span>; </span><br><span class="line">x0 = ((<span class="keyword">char</span>*)&amp;x)[<span class="number">0</span>]; <span class="comment">//低地址单元 </span></span><br><span class="line">x1 = ((<span class="keyword">char</span>*)&amp;x)[<span class="number">1</span>]; <span class="comment">//高地址单元</span></span><br></pre></td></tr></table></figure>
<p>若x0=0x11,则是大端; 若x0=0x22,则是小端。</p>
<p>上面的程序还可以看出，数据寻址时，用的是低位字节的地址。</p>
<p><strong>什么是字节对齐，为什么要对齐?</strong></p>
<p>现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p>
<p><strong>对齐的作用和原因</strong>：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。</p>
<p><strong>字节对齐对程序的影响？</strong></p>
<p>先让我们看几个例子(32bit，x86环境，gcc编译器)：<br>设结构体如下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">short</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">short</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在已知32位机器上各种数据类型的长度如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char:1(有符号无符号同) </span><br><span class="line">short:2(有符号无符号同) </span><br><span class="line">int:4(有符号无符号同) </span><br><span class="line">long:4(有符号无符号同) </span><br><span class="line">float:4    double:8</span><br></pre></td></tr></table></figure>
<p>那么上面两个结构大小如何呢?</p>
<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sizeof(strcut A)值为8</span><br><span class="line">sizeof(struct B)的值却是12</span><br></pre></td></tr></table></figure>
<p>结构体A中包含了4字节长度的int一个，1字节长度的char一个和2字节长度的short型数据一个,B也一样；按理说A，B大小应该都是7字节。之所以出现上面的结果是因为编译器要对数据成员在空间上进行对齐。上面是按照编译器的默认设置进行对齐的结果，那么我们是不是可以改变编译器的这种默认对齐设置呢，当然可以。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#pragma pack (2) /*指定按2字节对齐*/</span><br><span class="line">struct C</span><br><span class="line">&#123;</span><br><span class="line">    char b;</span><br><span class="line">    int a;</span><br><span class="line">    short c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</span><br><span class="line">sizeof(struct C)值是8。</span><br><span class="line">修改对齐值为1：</span><br><span class="line">#pragma pack (1) /*指定按1字节对齐*/</span><br><span class="line">struct D</span><br><span class="line">&#123;</span><br><span class="line">    char b;</span><br><span class="line">    int a;</span><br><span class="line">    short c;</span><br><span class="line">&#125;;</span><br><span class="line">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</span><br><span class="line">sizeof(struct D)值为7。</span><br></pre></td></tr></table></figure>
<p><strong>编译器是按照什么样的原则进行对齐的?</strong></p>
<p>先让我们看四个重要的基本概念：</p>
<p>1.数据类型自身的对齐值：</p>
<p>对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，单位字节。</p>
<p>2.结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。</p>
<p>3.指定对齐值：#pragma pack (value)时的指定对齐值value。</p>
<p>4.数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。</p>
<p>有了这些值，我们就可以很方便的来讨论具体数据结构的成员和其自身的对齐方式。有效对齐值N是最终用来决定数据存放地址方式的值，最重要。有效对齐N，就是表示“对齐在N上”，也就是说该数据的“存放起始地址%N=0”。而数据结构中的数据变量都是按定义的先后顺序来排放的。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐排放，结构体本身也要根据自身的有效对齐值圆整(就是结构体成员变量占用总长度需要是对结构体有效对齐值的整数倍，结合下面例子理解)。这样就不难理解上面的几个例子的值了。</p>
<p>例子分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">short</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假设B从地址空间0x0000开始排放。该例子中没有定义指定对齐值，在笔者环境下，该值默认为4。第一个成员变量b的自身对齐值是1，比指定或者默认指定对齐值4小，所以其有效对齐值为1，所以其存放地址0x0000符合0x0000%1=0。第二个成员变量a，其自身对齐值为4，所以有效对齐值也为4，所以只能存放在起始地址为0x0004到0x0007这四个连续的字节空间中，复核0x0004%4=0,且紧靠第一个变量。第三个变量c，自身对齐值为2，所以有效对齐值也是2，可以存放在0x0008到0x0009这两个字节空间中，符合0x0008%2=0。所以从0x0000到0x0009存放的都是B内容。再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b）所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求，0x0009到0x0000=10字节，（10＋2）％4＝0。所以0x000A到0x000B也为结构体B所占用。故B从0x0000到0x000B共有12个字节，sizeof(struct B)=12;其实如果就这一个就来说它已经满足字节对齐了，因为它的起始地址是0，因此肯定是对齐的。之所以在后面补充2个字节，是因为编译器为了实现结构数组的存取效率，试想如果我们定义了一个结构B的数组，那么第一个结构起始地址是0没有问题，但是第二个结构呢?按照数组的定义，数组中所有元素都是紧挨着的，如果我们不把结构的大小补充为4的整数倍，那么下一个结构的起始地址将是0x000A，这显然不能满足结构的地址对齐了，因此我们要把结构补充成有效对齐大小的整数倍。其实诸如：对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，这些已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知了，所以他们的自身对齐值也就已知了。</p>
<p>同理，分析下面例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#pragma pack (2) /*指定按2字节对齐*/</span><br><span class="line">struct C</span><br><span class="line">&#123;</span><br><span class="line">    char b;</span><br><span class="line">    int a;</span><br><span class="line">    short c;</span><br><span class="line">&#125;;</span><br><span class="line">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</span><br></pre></td></tr></table></figure>
<p>第一个变量b的自身对齐值为1，指定对齐值为2，所以，其有效对齐值为1，假设C从0x0000开始，那么b存放在0x0000，符合0x0000%1=0；第二个变量，自身对齐值为4，指定对齐值为2，所以有效对齐值为2，所以顺序存放在0x0002、0x0003、0x0004、0x0005四个连续字节中，符合0x0002%2=0。第三个变量c的自身对齐值为2，所以有效对齐值为2，顺序存放在0x0006、0x0007中，符合0x0006%2=0。所以从0x0000到0x00007共八字节存放的是C的变量。又C的自身对齐值为4，所以C的有效对齐值为2。又8%2=0，C只占用0x0000到0x0007的八个字节。所以sizeof(struct C)=8。</p>
<p><strong>如何修改编译器的默认对齐值?</strong></p>
<p>1.在VC IDE中，可以这样修改：[Project]|[Settings],c/c++选项卡Category的Code Generation选项的Struct Member Alignment中修改，默认是8字节。</p>
<p>2.在编码时，可以这样动态修改：#pragma pack。注意：是pragma而不是progma。</p>
<p><strong>针对字节对齐，我们在编程中如何考虑?</strong></p>
<p>如果在编程的时候要考虑节约空间的话,那么我们只需要假定结构的首地址是0，然后各个变量按照上面的原则进行排列即可，基本的原则就是把结构中的变量按照类型大小从小到大声明，尽量减少中间的填补空间。还有一种就是为了以空间换取时间的效率，我们显示的进行填补空间进行对齐，比如：有一种使用空间换时间做法是显式的插入reserved成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> A&#123;</span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">char</span> reserved[<span class="number">3</span>];<span class="comment">//使用空间换时间</span></span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reserved成员对我们的程序没有什么意义，它只是起到填补空间以达到字节对齐的目的。当然即使不加这个成员，通常编译器也会给我们自动填补对齐，我们自己加上它只是起到显式的提醒作用。</p>
<p><strong>字节对齐可能带来的隐患？</strong></p>
<p>代码中关于对齐的隐患，很多是隐式的。比如在强制类型转换的时候。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> *p1=<span class="literal">NULL</span>;</span><br><span class="line">p=&amp;i;</span><br><span class="line">*p=<span class="number">0x00</span>;</span><br><span class="line">p1=(<span class="keyword">unsigned</span> <span class="keyword">short</span> *)(p+<span class="number">1</span>);</span><br><span class="line">*p1=<span class="number">0x0000</span>;</span><br></pre></td></tr></table></figure>
<p>最后两句代码，从奇数边界去访问unsigned short型变量，显然不符合对齐的规定。在x86上，类似的操作只会影响效率，但是在MIPS或者sparc上，可能就是一个error，因为它们要求必须字节对齐。</p>
<p><strong>如何查找与字节对齐方面的问题？</strong></p>
<p>如果出现对齐或者赋值问题首先查看:</p>
<ol>
<li>编译器的big little端设置；</li>
<li>看这种体系本身是否支持非对齐访问；</li>
<li>如果支持，看设置了对齐与否；如果没有，则看访问时需要加某些特殊的修饰来标志其特殊访问操作。</li>
</ol>
<p><strong>ARM下的对齐处理？</strong></p>
<p>对齐的使用：</p>
<p>1.__align(num)</p>
<p>这个用于修改最高级别对象的字节边界。在汇编中使用LDRD或者STRD时，就要用到此命令<strong>align(8)进行修饰限制来保证数据对象是相应对齐。这个修饰对象的命令最大是8个字节限制，可以让2字节的对象进行4字节对齐，但是不能让4字节的对象2字节对齐。</strong>align是存储类修改，它只修饰最高级类型对象，不能用于结构或者函数对象。</p>
<p>2.__packed </p>
<p>__packed是进行一字节对齐</p>
<p>1）不能对packed的对象进行对齐；</p>
<p>2）所有对象的读写访问都进行非对齐访问；</p>
<p>3）float及包含float的结构联合及未用__packed的对象将不能字节对齐；</p>
<p>4）__packed对局部整型变量无影响；</p>
<p>5）强制由unpacked对象向packed对象转化是未定义，整型指针可以合法定义为packed。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__packed int* p;  //__packed int 则没有意义</span><br></pre></td></tr></table></figure>
<p>6）对齐或非对齐读写访问带来问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">__packed struct STRUCT_TEST</span><br><span class="line">&#123;</span><br><span class="line">   char a;</span><br><span class="line">   int b;</span><br><span class="line">   char c;</span><br><span class="line">&#125;;    //定义如下结构此时b的起始地址一定是不对齐的</span><br><span class="line">       //在栈中访问b可能有问题,因为栈上数据肯定是对齐访问[from CL]</span><br><span class="line">//将下面变量定义成全局静态不在栈上 </span><br><span class="line">static char* p;</span><br><span class="line">static struct STRUCT_TEST a;</span><br><span class="line">void Main()</span><br><span class="line">&#123;</span><br><span class="line">__packed int* q;  //此时定义成__packed来修饰当前q指向为非对齐的数据地址下面的访问则可以</span><br><span class="line">p = (char*)&amp;a;          </span><br><span class="line">q = (int*)(p+1);      </span><br><span class="line"></span><br><span class="line">*q = 0x87654321; </span><br><span class="line">/*   </span><br><span class="line">得到赋值的汇编指令很清楚</span><br><span class="line">ldr      r5,0x20001590 ; = #0x12345678</span><br><span class="line">[0xe1a00005]   mov      r0,r5</span><br><span class="line">[0xeb0000b0]   bl       __rt_uwrite4  //在此处调用一个写4byte的操作函数 </span><br><span class="line">      </span><br><span class="line">[0xe5c10000]   strb     r0,[r1,#0]   //函数进行4次strb操作然后返回保证了数据正确的访问</span><br><span class="line">[0xe1a02420]   mov      r2,r0,lsr #8</span><br><span class="line">[0xe5c12001]   strb     r2,[r1,#1]</span><br><span class="line">[0xe1a02820]   mov      r2,r0,lsr #16</span><br><span class="line">[0xe5c12002]   strb     r2,[r1,#2]</span><br><span class="line">[0xe1a02c20]   mov      r2,r0,lsr #24</span><br><span class="line">[0xe5c12003]   strb     r2,[r1,#3]</span><br><span class="line">[0xe1a0f00e]   mov      pc,r14</span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line">如果q没有加__packed修饰则汇编出来指令是这样直接会导致奇地址处访问失败</span><br><span class="line">[0xe59f2018]   ldr      r2,0x20001594 ; = #0x87654321</span><br><span class="line">[0xe5812000]   str      r2,[r1,#0]</span><br><span class="line">*/</span><br><span class="line">//这样可以很清楚的看到非对齐访问是如何产生错误的</span><br><span class="line">//以及如何消除非对齐访问带来问题</span><br><span class="line">//也可以看到非对齐访问和对齐访问的指令差异导致效率问题</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关于内存对齐的问题，可以看看<a href="http://charsdavy.github.io/2016/02/10/memory-alignment/">《内存对齐详解》</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器）。另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。&lt;/p&gt;
    
    </summary>
    
      <category term="pieces" scheme="http://charsdavy.github.io/categories/pieces/"/>
    
    
      <category term="c" scheme="http://charsdavy.github.io/tags/c-language/"/>
    
      <category term="内存" scheme="http://charsdavy.github.io/tags/storage/"/>
    
      <category term="windows" scheme="http://charsdavy.github.io/tags/windows-os/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS 开发 (一) 准备工作</title>
    <link href="http://charsdavy.github.io/2016/08/12/mac-os-develop-prepare/"/>
    <id>http://charsdavy.github.io/2016/08/12/mac-os-develop-prepare/</id>
    <published>2016-08-12T00:00:05.000Z</published>
    <updated>2017-03-31T12:08:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>程序猿，一个另类的物种。</p>
</blockquote>
<p>其实很多时候，懒懒的程序猿因为自己的需要，或者是因为使用别人的工具并不满意，而催发出自己解决问题的想法。这个 Mac OS 开发系列，就是因为博主自己写博客是需要上传图片，而目前的 App 并不满意的情况下，决心自己学习，自己开发出喜欢的 App 而诞生的。</p>
<p>本文章为该系列开篇，循序渐进，从基础开始。</p>
<a id="more"></a>
<h1 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h1><p>这是开发的基础，至于是 Mac Book Pro，还是iMac，或者Mac mini 就随个人喜欢和实际状况。总之，不建议使用黑苹果。</p>
<h1 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a>Xcode</h1><p>这是毫无置疑的开发工具，具体如何使用，Google 一大把，这里就不再详说，以后若是博主自己写了相关内容，会后续放上链接跳转。</p>
<h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><p>启动Xcode，选择Create a new Xcode project，(非首次运行Xcode，从菜单File-New-&gt;Project) 进入工程模版选择界面，选择OSX-&gt;Application-&gt;Cocoa Application</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/mac-os-develop-prepare-1.png" alt=""></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="info-plist"><a href="#info-plist" class="headerlink" title="info.plist"></a>info.plist</h2><p><img src="http://o88e8any8.bkt.clouddn.com/mac-os-develop-prepare-2.png" alt=""></p>
<p><code>Application is agent(UIElement)</code> 字段可以控制App的MainMenu是否显示，Logo在Dock是否显示。</p>
<h2 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h2><p><img src="http://o88e8any8.bkt.clouddn.com/mac-os-develop-prepare-3.png" alt=""></p>
<p>这里我们重点关注下App Sandbox，Apple现在要求上架Mac AppStore的应用必须使用沙盒，所以发布到Mac商店的应用你必须选择打开。</p>
<p>如果你的应用要访问服务器的API接口，必须打开Outgoing Connections。</p>
<p>Hardware里面必须选择打开Printing，否则审核不通过。</p>
<p>File Accedd:如果你需要让用户选择访问本地的文件，User Selected File 中选择读/写权限。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/mac-os-develop-prepare-4.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;程序猿，一个另类的物种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实很多时候，懒懒的程序猿因为自己的需要，或者是因为使用别人的工具并不满意，而催发出自己解决问题的想法。这个 Mac OS 开发系列，就是因为博主自己写博客是需要上传图片，而目前的 App 并不满意的情况下，决心自己学习，自己开发出喜欢的 App 而诞生的。&lt;/p&gt;
&lt;p&gt;本文章为该系列开篇，循序渐进，从基础开始。&lt;/p&gt;
    
    </summary>
    
      <category term="code" scheme="http://charsdavy.github.io/categories/code/"/>
    
    
      <category term="mac" scheme="http://charsdavy.github.io/tags/mac-os/"/>
    
      <category term="碎碎念" scheme="http://charsdavy.github.io/tags/text/"/>
    
  </entry>
  
</feed>
