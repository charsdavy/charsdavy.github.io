<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chars&#39;s Tech Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://charsdavy.github.io/"/>
  <updated>2016-06-04T05:37:07.000Z</updated>
  <id>http://charsdavy.github.io/</id>
  
  <author>
    <name>Chars Davy</name>
    <email>chars_d@126.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>七牛云存储应用</title>
    <link href="http://charsdavy.github.io/2016/06/02/qiniu-using/"/>
    <id>http://charsdavy.github.io/2016/06/02/qiniu-using/</id>
    <published>2016-06-02T00:17:42.000Z</published>
    <updated>2016-06-04T05:37:07.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：七牛云存储，是专为移动时代开发者打造的数据管理平台，为互联网网站和移动App提供数据的在线托管、传输加速以及图片、音视频等富媒体的云处理服务。本文讲述如何使用七牛云存储来作为自己APP的数据云存储空间。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;七牛云存储，是专为移动时代开发者打造的数据管理平台，为互联网网站和移动App提供数据的在线托管、传输加速以及图片、音视频等富媒体的云处理服务。&lt;br&gt;七牛云官网&lt;a href=&quot;http://www.qiniu.com/&quot;&gt;http://www.qiniu.com/&lt;/a&gt; ，进入开发者平台，浏览了所有的开发指南，可是却是没有具体清晰的操作步骤。今天自己试着通过网络，实现了使用七牛云存储文件。现在，将操作步骤记录如下。&lt;/p&gt;
&lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h1&gt;&lt;p&gt;1.注册七牛云账号。&lt;/p&gt;
&lt;p&gt;2.创建空间。&lt;/p&gt;
&lt;p&gt;3.获取Access Key。&lt;/p&gt;
&lt;p&gt;4.获取Secret Key。&lt;/p&gt;
&lt;p&gt;5.获取官方SDK（&lt;a href=&quot;https://github.com/qiniu/objc-sdk&quot;&gt;https://github.com/qiniu/objc-sdk&lt;/a&gt; ）。&lt;/p&gt;
&lt;h1 id=&quot;导入工程&quot;&gt;&lt;a href=&quot;#导入工程&quot; class=&quot;headerlink&quot; title=&quot;导入工程&quot;&gt;&lt;/a&gt;导入工程&lt;/h1&gt;&lt;p&gt;1.打开Xcode创建Project。&lt;/p&gt;
&lt;p&gt;2.从获取的官方SDK导入库，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:06:02:qiniu-using:1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;3.获取token&lt;/p&gt;
&lt;p&gt;这一步，网上大家都说得很简单，在这一步卡壳许久。现在说说自己使用的方法：&lt;/p&gt;
&lt;p&gt;1）获取服务器代码，编译工程，以备生成token。&lt;/p&gt;
&lt;p&gt;服务器代码地址：&lt;a href=&quot;https://github.com/CharsDavy/QiNiuGenertorToken&quot;&gt;https://github.com/CharsDavy/QiNiuGenertorToken&lt;/a&gt;&lt;br&gt;2）使用Eclipse导入上述服务器代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:06:02:qiniu-using:2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Test.java文件中，修改自己的空间名称，Access Key和Secret Key。运行程序，即可获得token。&lt;/p&gt;
&lt;p&gt;这种方式生成的token的有效期是可以自己设定的，如果你想，设定1000年过期也是可以的。&lt;/p&gt;
&lt;p&gt;4.使用代码上传文件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;QiniuSDK.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString token = @&amp;quot;从服务端SDK获取&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QNUploadManager *upManager = [[QNUploadManager alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSData *data = [@&amp;quot;Hello, World!&amp;quot; dataUsingEncoding : NSUTF8StringEncoding];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [upManager putData:data key:@&amp;quot;hello&amp;quot; token:token&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        complete: ^(QNResponseInfo *info, NSString *key, NSDictionary *resp) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;%@&amp;quot;, info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;%@&amp;quot;, resp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; option:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;调试&quot;&gt;&lt;a href=&quot;#调试&quot; class=&quot;headerlink&quot; title=&quot;调试&quot;&gt;&lt;/a&gt;调试&lt;/h1&gt;&lt;p&gt;工程导入之后，可能会出现以下几种可能的错误。&lt;/p&gt;
&lt;p&gt;1.若报 &lt;code&gt;Undefined symbols for architecture x86_64: &amp;quot;_crc32&amp;quot;, referenced from:&lt;/code&gt;，项目中需导入 libz.dylib。(Build Phases—Link Binary With Libraries)&lt;/p&gt;
&lt;p&gt;2.若报&lt;code&gt;&amp;quot;_res_9_ninit&amp;quot;, referenced from: _setup_dns_server in QNResolver.o&lt;/code&gt;等，&lt;/p&gt;
&lt;p&gt;1）项目中需导入 libresolv.dylib或libresolv.9.dylib。(Build Phases— Link Binary With Libraries)；&lt;/p&gt;
&lt;p&gt;2）或 (Build Settings— Linking— Other Linker Flags) 添加 -lresolv选项。&lt;/p&gt;
&lt;p&gt;3.若报 Thread 1: EXC_BAD_ACCESS(code=1,address=0x180f4beb8)类似错误，将 QN打头的都设置 arc (Build Phases — Compile Sources)&lt;/p&gt;
&lt;p&gt;4.可能需要修改部分内容，如 &lt;code&gt;#import &amp;lt;AFNetworking/AFNetworking.h&amp;gt;&lt;/code&gt;改为 &lt;code&gt;#import &amp;quot;AFNetworking.h&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h1&gt;&lt;p&gt;以上就是本人在工程中使用七牛云进行文件云存储的过程，本文中使用的仅仅是上传文件，更多其他操作功能请参照官方文档。&lt;/p&gt;
&lt;p&gt;最后，附上一个使用七牛云存储的软件，源码地址：&lt;a href=&quot;https://github.com/CharsDavy/MyNotes&quot;&gt;https://github.com/CharsDavy/MyNotes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实，对于获取token来完成上载操作，也可以参考官方文档，地址&lt;br&gt;&lt;a href=&quot;http://developer.qiniu.com/docs/v6/api/reference/security/put-policy.html&quot;&gt;http://developer.qiniu.com/docs/v6/api/reference/security/put-policy.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：七牛云存储，是专为移动时代开发者打造的数据管理平台，为互联网网站和移动App提供数据的在线托管、传输加速以及图片、音视频等富媒体的云处理服务。本文讲述如何使用七牛云存储来作为自己APP的数据云存储空间。&lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="iOS" scheme="http://charsdavy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>你和日本的距离只差5mm</title>
    <link href="http://charsdavy.github.io/2016/06/01/chopsticks-using/"/>
    <id>http://charsdavy.github.io/2016/06/01/chopsticks-using/</id>
    <published>2016-06-01T12:38:19.000Z</published>
    <updated>2016-06-04T05:23:49.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：世界上使用筷子的国家并不是很多，很多人都认为能够使用筷子是件很神奇的事情。那么，不同的国家地区使用筷子的讲究也有所不同。这里主要说说日本使用筷子的禁忌，有些也很符合天朝国情的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;日本在使用筷子的时候，也有很大的「箸（はし）」学问，有什么禁忌是千万不要犯的呢？！&lt;/p&gt;
&lt;p&gt;✖握り箸（にぎりばし）——握筷子，这是初级错误，一般来说只有初学使用筷子的孩子和外国人会犯。&lt;/p&gt;
&lt;p&gt;✖クロス箸——两根筷子交叉，很不雅观。 &lt;/p&gt;
&lt;p&gt;✖迷い箸（まよいばし）——拿起筷子犹豫不决，前后左右晃动，似乎在挑拣食物。&lt;/p&gt;
&lt;p&gt;✖移り箸（うつりばし）——前面食物的味道还残留在口中，就取另外的食物。&lt;/p&gt;
&lt;p&gt;✖こじ箸——在碗底翻腾取食物。&lt;/p&gt;
&lt;p&gt;✖寄せ箸（よせばし）——用筷子拨动、移动盘子。&lt;/p&gt;
&lt;p&gt;✖刺し箸（さしばし）——用筷子扎取食物（对于不会用筷子的人来说，吃丸子的时候不这样会很难~）。&lt;/p&gt;
&lt;p&gt;✖涙箸——“泪筷子”，这个名称很形象，筷子夹起食物滴滴答答的流汤。&lt;/p&gt;
&lt;p&gt;✖かき箸——把碗放在嘴边，用筷子把食品拨拉到嘴里。&lt;/p&gt;
&lt;p&gt;✖込み箸（こみばし）——筷子进嘴塞食。&lt;/p&gt;
&lt;p&gt;✖持ち箸（もちばし）——把筷子拿在手里，端起碗吸食，日本农民 。&lt;/p&gt;
&lt;p&gt;✖ねぶり箸——把筷子放在嘴里吸允。&lt;/p&gt;
&lt;p&gt;✖渡し箸（わたしばし）——把筷子架在碗上。&lt;/p&gt;
&lt;p&gt;✖叩き箸（はたきばし）——用筷子敲碗催促他人（这样真的很招人烦）。&lt;/p&gt;
&lt;p&gt;✖指さし箸（ゆびさしばし）——用筷子指人（用手指人也是很不好的）。&lt;/p&gt;
&lt;p&gt;✖直箸（じかばし）——有公筷不用，直接使用自己的筷子在盘内取食。&lt;/p&gt;
&lt;p&gt;✖立箸——把筷子插在米饭碗里。&lt;/p&gt;
&lt;p&gt;✖そろえ箸——用舌头、嘴唇或者其他平面整理、理顺两根筷子（为什么不用手，这样多累啊）。 &lt;/p&gt;
&lt;p&gt;✖探り箸（さぐりばし）——用筷子在盘子里搅拌、寻找食物（瞄准一个直接吃得了，在那ba la啥）。&lt;/p&gt;
&lt;p&gt;✖せせり箸——把筷子当牙签使（小花儿表示：她的牙缝没这么大）。&lt;/p&gt;
&lt;p&gt;✖かみ箸——用牙齿咬筷子。&lt;/p&gt;
&lt;p&gt;✖振り箸（ふりばし）——甩手抖落筷子上的汤汁（轻微洁癖真的有点接受不了）。&lt;/p&gt;
&lt;p&gt;✖洗い箸（あらい）——在碗盘汤中涮洗筷子。&lt;/p&gt;
&lt;p&gt;✖箸渡し（はしわたし）——用筷子向他人的筷子递送食品。&lt;br&gt;✖そら箸——筷子靠近了盘子，却又不取食品。&lt;/p&gt;
&lt;p&gt;以上是25条使用筷子的禁忌。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：世界上使用筷子的国家并不是很多，很多人都认为能够使用筷子是件很神奇的事情。那么，不同的国家地区使用筷子的讲究也有所不同。这里主要说说日本使用筷子的禁忌，有些也很符合天朝国情的。&lt;/p&gt;
    
    </summary>
    
      <category term="爱好" scheme="http://charsdavy.github.io/categories/hobby/"/>
    
    
      <category term="日语" scheme="http://charsdavy.github.io/tags/Japanese/"/>
    
  </entry>
  
  <entry>
    <title>手把手教 GitHub + Hexo 搭建博客</title>
    <link href="http://charsdavy.github.io/2016/05/31/build-blog-by-hexo/"/>
    <id>http://charsdavy.github.io/2016/05/31/build-blog-by-hexo/</id>
    <published>2016-05-31T14:07:27.000Z</published>
    <updated>2016-06-04T05:23:49.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：本文章主要介绍使用hexo框架搭建博客，使用GitHub免费托管自己的博客代码，并使用GitHub Pages提供的免费服务。换句话说，就是使用免费资源搭建属于自己的博客网站。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在很久以前，博主就想着要有自主的博客专栏或者网站。经历了博客园这个需要所谓的编辑审核，一直比较困惑，这些编辑是什么出身，怎么知道技术博客的价值性。&lt;/p&gt;
&lt;p&gt;接下来找到了开源中国，这个可以自由发言的地方。不过，不知道是不是受众面不广，访问量都不是很理想。&lt;/p&gt;
&lt;p&gt;再然后就来自己动手开始搭建博客。从手写html发布文章，到使用jekyll，最后到了hexo阵营。&lt;/p&gt;
&lt;p&gt;终于，有种找到家的赶脚。hexo不仅搭建方便，而且在后续的功能扩展以及文章发布都是非常方便的。不仅如此，还可以本地调试，预览效果。最方便的是支持markdown编写文档。&lt;/p&gt;
&lt;p&gt;本文就是介绍如何安装使用hexo搭建属于自己的博客。从此不再担心投稿被莫名拒绝。可以在自己的一亩三分地讲述着自己的故事。&lt;/p&gt;
&lt;h1 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h1&gt;&lt;h2 id=&quot;安装Git&quot;&gt;&lt;a href=&quot;#安装Git&quot; class=&quot;headerlink&quot; title=&quot;安装Git&quot;&gt;&lt;/a&gt;安装Git&lt;/h2&gt;&lt;p&gt;MAC OS X 是自带Git命令行工具。&lt;/p&gt;
&lt;p&gt;Windows 可以安装Git Bash。&lt;/p&gt;
&lt;h2 id=&quot;安装Node-js&quot;&gt;&lt;a href=&quot;#安装Node-js&quot; class=&quot;headerlink&quot; title=&quot;安装Node.js&quot;&gt;&lt;/a&gt;安装Node.js&lt;/h2&gt;&lt;p&gt;前往&lt;a href=&quot;https://nodejs.org/en/&quot;&gt;官网地址&lt;/a&gt;，根据教程安装即可。&lt;/p&gt;
&lt;h2 id=&quot;安装hexo&quot;&gt;&lt;a href=&quot;#安装hexo&quot; class=&quot;headerlink&quot; title=&quot;安装hexo&quot;&gt;&lt;/a&gt;安装hexo&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo npm install hexo-cli -g&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;使用hexo&quot;&gt;&lt;a href=&quot;#使用hexo&quot; class=&quot;headerlink&quot; title=&quot;使用hexo&quot;&gt;&lt;/a&gt;使用hexo&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 创建hexo文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ mkdir hexo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 进入hexo文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ cd hexo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 初始化hexo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ hexo init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 安装依赖包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ npm install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 本地查看&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 先运行下面的命令，再在浏览器输入localhost:4000即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 问题：执行hexo server提示找不到该指令&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 解决办法：在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ npm install hexo -server --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;生成静态网站&quot;&gt;&lt;a href=&quot;#生成静态网站&quot; class=&quot;headerlink&quot; title=&quot;生成静态网站&quot;&gt;&lt;/a&gt;生成静态网站&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── .deploy #需要部署的文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── node_modules #Hexo插件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── public #生成的静态网页文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── scaffolds #模板&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| ├── _drafts #草稿&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| └── _posts #文章&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── themes #主题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── _config.yml #全局配置文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;└── package.json&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;全局配置-config-yml&quot;&gt;&lt;a href=&quot;#全局配置-config-yml&quot; class=&quot;headerlink&quot; title=&quot;全局配置 _config.yml&quot;&gt;&lt;/a&gt;全局配置 _config.yml&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# Hexo Configuration&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## Docs: http://hexo.io/docs/configuration.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## Source: https://github.com/hexojs/hexo/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Site #站点信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;title:  #标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;subtitle:  #副标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;description:  #站点描述，给搜索引擎看的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;author:  #作者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;email:  #电子邮箱&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;language: zh-CN #语言&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# URL #链接格式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;url:  #网址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root: / #根目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;permalink: :year/:month/:day/:title/ #文章的链接格式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tag_dir: tags #标签目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;archive_dir: archives #存档目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;category_dir: categories #分类目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;code_dir: downloads/code&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;permalink_defaults:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Directory #目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;source_dir: source #源文件目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public_dir: public #生成的网页文件目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Writing #写作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;new_post_name: :title.md #新文章标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;titlecase: false #标题转换成大写&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;external_link: true #在新选项卡中打开连接&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;filename_case: 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;render_drafts: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;post_asset_folder: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;relative_link: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;highlight: #语法高亮&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  enable: true #是否启用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  line_number: true #显示行号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  tab_replace:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Category &amp;amp; Tag #分类和标签&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;default_category: uncategorized #默认分类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;category_map:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tag_map:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Archives&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2: 开启分页&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1: 禁用分页&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0: 全部禁用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;archive: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;category: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tag: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Server #本地服务器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;port: 4000 #端口号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;server_ip: localhost #IP 地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;logger: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;logger_format: dev&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Date / Time format #日期时间格式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;time_format: H:mm:ss&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Pagination #分页&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;per_page: 10 #每页文章数，设置成 0 禁用分页&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pagination_dir: page&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Disqus #Disqus评论，替换为多说&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;disqus_shortname:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Extensions #拓展插件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;theme: landscape-plus #主题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exclude_generator:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plugins: #插件，例如生成 RSS 和站点地图的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- hexo-generator-feed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- hexo-generator-sitemap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# Deployment #部署，将 lmintlcx 改成用户名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;deploy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type: git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  repo: github创库地址.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  branch: master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置文件的冒号“:”后面有一个空格&lt;/li&gt;
&lt;li&gt;repo: github创库地址.git&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;hexo命令行使用&quot;&gt;&lt;a href=&quot;#hexo命令行使用&quot; class=&quot;headerlink&quot; title=&quot;hexo命令行使用&quot;&gt;&lt;/a&gt;hexo命令行使用&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;常用命令：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo help #查看帮助&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo init #初始化一个目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo new &amp;quot;postName&amp;quot; #新建文章&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo new page &amp;quot;pageName&amp;quot; #新建页面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo generate #生成网页，可以在 public 目录查看整个网站的文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo server #本地预览，&amp;apos;Ctrl+C&amp;apos;关闭&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo deploy #部署.deploy目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo clean #清除缓存，强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;简写：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo n == hexo new&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo g == hexo generate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo s == hexo server&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo d == hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;使用GitHub&quot;&gt;&lt;a href=&quot;#使用GitHub&quot; class=&quot;headerlink&quot; title=&quot;使用GitHub&quot;&gt;&lt;/a&gt;使用GitHub&lt;/h1&gt;&lt;h2 id=&quot;注册账号&quot;&gt;&lt;a href=&quot;#注册账号&quot; class=&quot;headerlink&quot; title=&quot;注册账号&quot;&gt;&lt;/a&gt;注册账号&lt;/h2&gt;&lt;p&gt;前往GitHub官网注册账号，按照网站提示注册。&lt;/p&gt;
&lt;h2 id=&quot;创建代码仓库&quot;&gt;&lt;a href=&quot;#创建代码仓库&quot; class=&quot;headerlink&quot; title=&quot;创建代码仓库&quot;&gt;&lt;/a&gt;创建代码仓库&lt;/h2&gt;&lt;p&gt;这个仓库的名字需要和你的账号对应。格式: yourname.github.io&lt;/p&gt;
&lt;p&gt;具体使用GitHub可以参考：&lt;a href=&quot;http://charsdavy.github.io/2016/05/20/github-using/&quot;&gt;《GitHub 使用》&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;编辑文章&quot;&gt;&lt;a href=&quot;#编辑文章&quot; class=&quot;headerlink&quot; title=&quot;编辑文章&quot;&gt;&lt;/a&gt;编辑文章&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 新建文章&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &amp;quot;标题&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 _posts 目录下会生成文件标题.md&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;title: Hello World&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;date: 2015-07-30 07:56:29 #发表日期，一般不改动&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;categories: hexo #文章文类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tags: [hexo,github] #文章标签，多于一项时用这种格式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;正文，使用Markdown语法书写&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;编辑完后保存, 预览&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;hexo部署&quot;&gt;&lt;a href=&quot;#hexo部署&quot; class=&quot;headerlink&quot; title=&quot;hexo部署&quot;&gt;&lt;/a&gt;hexo部署&lt;/h1&gt;&lt;p&gt;执行下列指令完成部署&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo generate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以下提示说明部署成功&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[info] Deploy done: git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;hexo插件使用&quot;&gt;&lt;a href=&quot;#hexo插件使用&quot; class=&quot;headerlink&quot; title=&quot;hexo插件使用&quot;&gt;&lt;/a&gt;hexo插件使用&lt;/h1&gt;&lt;h2 id=&quot;添加rss订阅功能&quot;&gt;&lt;a href=&quot;#添加rss订阅功能&quot; class=&quot;headerlink&quot; title=&quot;添加rss订阅功能&quot;&gt;&lt;/a&gt;添加rss订阅功能&lt;/h2&gt;&lt;p&gt;安装hexo-generator-feed插件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ npm install hexo-generator-feed --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;安装完后，会在node_modules目录下生成hexo-generator-feed目录。然后将其配置到根目录的_config.yml&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# Extensions&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## Plugins: http://hexo.io/plugins/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#RSS订阅&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plugin:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- hexo-generator-feed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#Feed Atom&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;feed: #可选项，可以不填&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;type: atom&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;path: atom.xml&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;limit: 20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后，在你当前主题下的_config.yml下，添加RSS订阅链接即可，这里博主用的是Yilia主题，subnav下添加rss：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# SubNav&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;subnav:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rss: &amp;quot;/atom.xml&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;至此，博客搭建完成，基本使用介绍完毕。希望对大家有所帮助。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：本文章主要介绍使用hexo框架搭建博客，使用GitHub免费托管自己的博客代码，并使用GitHub Pages提供的免费服务。换句话说，就是使用免费资源搭建属于自己的博客网站。&lt;/p&gt;
    
    </summary>
    
      <category term="应用实战" scheme="http://charsdavy.github.io/categories/apply/"/>
    
    
      <category term="hexo" scheme="http://charsdavy.github.io/tags/script/"/>
    
  </entry>
  
  <entry>
    <title>YYModel源代码阅读 - 基础知识</title>
    <link href="http://charsdavy.github.io/2016/05/27/YYModel-reading/"/>
    <id>http://charsdavy.github.io/2016/05/27/YYModel-reading/</id>
    <published>2016-05-27T12:51:21.000Z</published>
    <updated>2016-06-04T05:27:55.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：YYModel堪称神级大作，虽然不免一些小bug，但是完全不影响膝盖碎一地。文章主要分享在阅读YYModel源代码时，所引发的知识点的补充与思考。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这段时间因为工作需要，阅读了YYModel这个开源框架，至于它能做什么，最直白的讲述就是JSON与Model之间的相互转化。&lt;/p&gt;
&lt;p&gt;源代码在&lt;a href=&quot;https://github.com/ibireme/YYModel&quot;&gt;Github&lt;/a&gt;，大家可以自行&lt;code&gt;git clone&lt;/code&gt;或者download。&lt;/p&gt;
&lt;p&gt;接下来，笔者主要分析阅读源代码而引出的各种问题与知识点，不足之处请大家指正。&lt;/p&gt;
&lt;h1 id=&quot;NS-ASSUME-NONNULL-BEGIN-amp-NS-ASSUME-NONNULL-END&quot;&gt;&lt;a href=&quot;#NS-ASSUME-NONNULL-BEGIN-amp-NS-ASSUME-NONNULL-END&quot; class=&quot;headerlink&quot; title=&quot;NS_ASSUME_NONNULL_BEGIN &amp;amp; NS_ASSUME_NONNULL_END&quot;&gt;&lt;/a&gt;NS_ASSUME_NONNULL_BEGIN &amp;amp; NS_ASSUME_NONNULL_END&lt;/h1&gt;&lt;p&gt;这组宏是成对使用的，不得不说我们自己写代码的时候使用的很少，以至于遗漏这个知识点，现在我们就来看看这两个宏会引出什么问题。&lt;/p&gt;
&lt;p&gt;这组宏会引出几个关于Objective-C新特性的知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Nullability Annotations&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Lightweight Generics&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;__kindof&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Nullability-Annotations&quot;&gt;&lt;a href=&quot;#Nullability-Annotations&quot; class=&quot;headerlink&quot; title=&quot;Nullability Annotations&quot;&gt;&lt;/a&gt;Nullability Annotations&lt;/h2&gt;&lt;p&gt;我们都知道在swift中，可以使用!和?来表示一个对象是optional的还是non-optional，如view?和view!。而在 Objective-C中则没有这一区分，view既可表示这个对象是optional，也可表示是non-optioanl。这样就会造成一个问题：在 Swift与Objective-C混编时，Swift编译器并不知道一个Objective-C对象到底是optional还是non-optional，因此这种情况下编译器会隐式地将Objective-C的对象当成是non-optional。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，苹果在Xcode 6.3引入了一个Objective-C的新特性：&lt;strong&gt;nullability annotations&lt;/strong&gt;。这一新特性的核心是两个新的类型注释：&lt;strong&gt; __nullable&lt;/strong&gt; 和 &lt;strong&gt;__nonnull&lt;/strong&gt; 。从字面上我们可以猜到，&lt;code&gt;__nullable&lt;/code&gt;表示对象可以是NULL或nil，而&lt;code&gt;__nonnull&lt;/code&gt;表示对象不应该为空。当我们不遵循这一规则时，编译器就会给出警告。&lt;/p&gt;
&lt;p&gt;我们来看看以下的实例，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface TestNullabilityClass ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, copy) NSArray * items;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)itemWithName:(NSString * __nonnull)name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation TestNullabilityClass&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)testNullability &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self itemWithName:nil];    // 编译器警告：Null passed to a callee that requires a non-null argument&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)itemWithName:(NSString * __nonnull)name &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不过这只是一个警告，程序还是能编译通过并运行。&lt;/p&gt;
&lt;p&gt;事实上，在任何可以使用const关键字的地方都可以使用&lt;code&gt;__nullable&lt;/code&gt;和&lt;code&gt;__nonnull&lt;/code&gt;，不过这两个关键字仅限于使用在指针类型上。而在方法的声明中，我们还可以使用不带下划线的&lt;code&gt;nullable&lt;/code&gt;和&lt;code&gt;nonnull&lt;/code&gt;，如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (nullable id)itemWithName:(NSString * nonnull)name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在属性声明中，也增加了两个相应的特性，因此上例中的items属性可以如下声明：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, copy, nonnull) NSArray * items;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当然也可以用以下这种方式：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, copy) NSArray * __nonnull items;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;推荐使用nonnull这种方式，这样可以让属性声明看起来更清晰。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Nonnull区域设置-Audited-Regions&quot;&gt;&lt;a href=&quot;#Nonnull区域设置-Audited-Regions&quot; class=&quot;headerlink&quot; title=&quot;Nonnull区域设置(Audited Regions)&quot;&gt;&lt;/a&gt;Nonnull区域设置(Audited Regions)&lt;/h3&gt;&lt;p&gt;如果需要每个属性或每个方法都去指定&lt;code&gt;nonnull&lt;/code&gt;和&lt;code&gt;nullable&lt;/code&gt;，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：&lt;strong&gt;NS_ASSUME_NONNULL_BEGIN&lt;/strong&gt;和&lt;strong&gt;NS_ASSUME_NONNULL_END&lt;/strong&gt;。在这两个宏之间的代码，所有简单指针对象都被假定为 &lt;code&gt;nonnull&lt;/code&gt;，因此我们只需要去指定那些&lt;code&gt;nullable&lt;/code&gt;的指针。如下代码所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NS_ASSUME_NONNULL_BEGIN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface TestNullabilityClass ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, copy) NSArray * items;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)itemWithName:(nullable NSString *)name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NS_ASSUME_NONNULL_END&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在上面的代码中，items属性默认是nonnull的，itemWithName:方法的返回值也是nonnull，而参数是指定为nullable的。&lt;/p&gt;
&lt;p&gt;不过，为了安全起见，苹果还制定了几条规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;typedef定义的类型的nullability特性通常依赖于上下文，即使是在Audited Regions中，也不能假定它为nonnull。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;复杂的指针类型(如id &lt;em&gt;)必须显示去指定是nonnull还是nullable。例如，指定一个指向nullable对象的nonnull指针，可以使用”__nullable id &lt;/em&gt; __nonnull”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们经常使用的NSError **通常是被假定为一个指向nullable NSError对象的nullable指针。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;兼容性&quot;&gt;&lt;a href=&quot;#兼容性&quot; class=&quot;headerlink&quot; title=&quot;兼容性&quot;&gt;&lt;/a&gt;兼容性&lt;/h3&gt;&lt;p&gt;因为Nullability Annotations是Xcode 6.3新加入的，所以我们需要考虑之前的老代码。实际上，苹果已以帮我们处理好了这种兼容问题，我们可以安全地使用它们：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;老代码仍然能正常工作，即使对nonnull对象使用了nil也没有问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;老代码在需要和swift混编时，在新的swift编译器下会给出一个警告。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;nonnull不会影响性能。事实上，我们仍然可以在运行时去判断我们的对象是否为nil。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事实上，我们可以将nonnull/nullable与我们的断言和异常一起看待，其需要处理的问题都是同一个：违反约定是一个程序员的错误。特别是，返回值是我们可控的东西，如果返回值是nonnull的，则我们不应该返回nil，除非是为了向后兼容。&lt;/p&gt;
&lt;h2 id=&quot;Lightweight-Generics&quot;&gt;&lt;a href=&quot;#Lightweight-Generics&quot; class=&quot;headerlink&quot; title=&quot;Lightweight Generics&quot;&gt;&lt;/a&gt;Lightweight Generics&lt;/h2&gt;&lt;p&gt;Lightweight Generics 轻量级泛型，轻量是因为这是个纯编译器的语法支持（LLVM 7.0），和 Nullability 一样，没有借助任何 objc runtime 的升级，也就是说，这个新语法在 Xcode 7 上可以使用且完全向下兼容（更低的 iOS 版本）&lt;/p&gt;
&lt;h3 id=&quot;带泛型的容器&quot;&gt;&lt;a href=&quot;#带泛型的容器&quot; class=&quot;headerlink&quot; title=&quot;带泛型的容器&quot;&gt;&lt;/a&gt;带泛型的容器&lt;/h3&gt;&lt;p&gt;这无疑是本次最重大的改进，有了泛型后终于可以指定容器类中对象的类型了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSArray&amp;lt;NSString *&amp;gt; *strings = @[@&amp;quot;sun&amp;quot;, @&amp;quot;yuan&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDictionary&amp;lt;NSString *, NSNumber *&amp;gt; *mapping = @&amp;#123;@&amp;quot;a&amp;quot;: @1, @&amp;quot;b&amp;quot;: @2&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回值的 id 被替换成具体的类型后，令人感动的代码提示也出来了。&lt;/p&gt;
&lt;p&gt;假如向泛型容器中加入错误的对象，编译器会不开心的。&lt;/p&gt;
&lt;p&gt;系统中常用的一系列容器类型都增加了泛型支持，甚至连 &lt;code&gt;NSEnumerator&lt;/code&gt; 都支持了，这是非常 Nice 的改进。和 &lt;code&gt;Nullability&lt;/code&gt; 一样，我认为最大的意义还是丰富了接口描述信息，对比下面两种写法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (readonly) NSArray *imageURLs;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (readonly) NSArray&amp;lt;NSURL *&amp;gt; *imageURLs;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不用多想就清楚下面的数组中存的是什么，避免了 &lt;code&gt;NSString&lt;/code&gt; 和 &lt;code&gt;NSURL&lt;/code&gt; 的混乱。&lt;/p&gt;
&lt;h3 id=&quot;自定义泛型类&quot;&gt;&lt;a href=&quot;#自定义泛型类&quot; class=&quot;headerlink&quot; title=&quot;自定义泛型类&quot;&gt;&lt;/a&gt;自定义泛型类&lt;/h3&gt;&lt;p&gt;比起使用系统的泛型容器，更好玩的是自定义一个泛型类，目前这里还没什么文档，但拦不住我们写测试代码，假设我们要自定义一个 Stack 容器类：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface Stack&amp;lt;ObjectType&amp;gt; : NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)pushObject:(ObjectType)object;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (ObjectType)popObject;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, readonly) NSArray&amp;lt;ObjectType&amp;gt; *allObjects;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个 &lt;code&gt;ObjectType&lt;/code&gt; 是传入类型的 &lt;code&gt;placeholder&lt;/code&gt;，它只能在 &lt;code&gt;@interface&lt;/code&gt; 上定义（类声明、类扩展、Category），如果你喜欢用 T 表示也 OK，这个类型在 &lt;code&gt;@interface&lt;/code&gt; 和 &lt;code&gt;@end&lt;/code&gt; 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型，应该说一切都是符合预期的。我们还可以给 ObjectType 增加类型限制，比如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 只接受 NSNumber * 的泛型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface Stack&amp;lt;ObjectType: NSNumber *&amp;gt; : NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 只接受满足 NSCopying 协议的泛型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface Stack&amp;lt;ObjectType: id&amp;lt;NSCopying&amp;gt;&amp;gt; : NSObject&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;若什么都不加，表示接受任意类型 ( id )；当类型不满足时编译器将产生 error。&lt;br&gt;实例化一个 Stack，一切工作正常：&lt;/p&gt;
&lt;p&gt;对于多参数的泛型，用逗号隔开，其他都一样，可以参考 NSDictionary 的头文件。&lt;/p&gt;
&lt;h3 id=&quot;协变性和逆变性&quot;&gt;&lt;a href=&quot;#协变性和逆变性&quot; class=&quot;headerlink&quot; title=&quot;协变性和逆变性&quot;&gt;&lt;/a&gt;协变性和逆变性&lt;/h3&gt;&lt;p&gt;当类支持泛型后，它们的 Type 发生了变化，比如下面三个对象看上去都是 Stack，但实际上属于三个 Type：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Stack *stack; // Stack *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack&amp;lt;NSString *&amp;gt; *stringStack; // Stack&amp;lt;NSString *&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack&amp;lt;NSMutableString *&amp;gt; *mutableStringStack; // Stack&amp;lt;NSMutableString *&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当其中两种类型做类型转化时，编译器需要知道哪些转化是允许的，哪些是禁止的，比如，默认情况下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Stack *stack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack&amp;lt;NSString *&amp;gt; *stringStack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Stack&amp;lt;NSMutableString *&amp;gt; *mutableStringStack; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stack = stringStack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stack = mutableStringStack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stringStack = stack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stringStack = mutableStringStack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mutableStringStack = stack;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mutableStringStack = stringStack&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在Xcode中我们可以看到，不指定泛型类型的 Stack 可以和任意泛型类型转化，但指定了泛型类型后，两个不同类型间是不可以强转的，假如你希望主动控制转化关系，就需要使用泛型的协变性和逆变性修饰符了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;__covariant - 协变性，子类型可以强转到父类型（里氏替换原则）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__contravariant - 逆变性，父类型可以强转到子类型（WTF）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;协变&quot;&gt;&lt;a href=&quot;#协变&quot; class=&quot;headerlink&quot; title=&quot;协变&quot;&gt;&lt;/a&gt;协变&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface Stack&amp;lt;__covariant ObjectType&amp;gt; : NSObject&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;逆变&quot;&gt;&lt;a href=&quot;#逆变&quot; class=&quot;headerlink&quot; title=&quot;逆变&quot;&gt;&lt;/a&gt;逆变&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface Stack&amp;lt;__contravariant ObjectType&amp;gt; : NSObject&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;协变是非常好理解的，像 &lt;code&gt;NSArray&lt;/code&gt; 的泛型就用了协变的修饰符。&lt;/p&gt;
&lt;h2 id=&quot;kindof&quot;&gt;&lt;a href=&quot;#kindof&quot; class=&quot;headerlink&quot; title=&quot;__kindof&quot;&gt;&lt;/a&gt;__kindof&lt;/h2&gt;&lt;p&gt;&lt;code&gt;__kindof&lt;/code&gt; 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 &lt;code&gt;UITableView&lt;/code&gt; 的这个方法来说：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用时前面基本会使用 &lt;code&gt;UITableViewCell&lt;/code&gt; 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 &lt;code&gt;UITableViewCell&lt;/code&gt; 或 &lt;code&gt;UITableViewCell&lt;/code&gt; 子类的实例，于是新的 &lt;code&gt;__kindof&lt;/code&gt; 关键字解决了这个问题：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView 的 subviews 属性被修改成了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, readonly, copy) NSArray&amp;lt;__kindof UIView *&amp;gt; *subviews;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，写下面的代码时就没有任何警告了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIButton *button = view.subviews.lastObject;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;NS-ENUM-amp-NS-OPTIONS&quot;&gt;&lt;a href=&quot;#NS-ENUM-amp-NS-OPTIONS&quot; class=&quot;headerlink&quot; title=&quot;NS_ENUM &amp;amp; NS_OPTIONS&quot;&gt;&lt;/a&gt;NS_ENUM &amp;amp; NS_OPTIONS&lt;/h1&gt;&lt;p&gt;枚举是指将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。&lt;/p&gt;
&lt;p&gt;枚举本质上是一个整数，枚举的作用是把值限定在指定的范围内，并且增加代码的可读性。 枚举的成员如果没有显示指定值，那么第一个成员的值总是0，后面成员的值依次递增。枚举可以直接用于比较。&lt;/p&gt;
&lt;p&gt;一般我们声明枚举：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 声明枚举类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;enum Direction &amp;#123;up, down, left = 10, right&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main(int argc, const char * argv[])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其中up = 0, down = 1, left = 10, right = 11。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们会发现枚举中一些不可自定义的部分，例如，枚举名。&lt;/p&gt;
&lt;p&gt;NS_ENUM 和 NS_OPTIONS 都不算太古老的宏，在iOS 6 / OS X Mountain Lion才开始有，它们都是代替 enum 的更好的办法。&lt;/p&gt;
&lt;h2 id=&quot;NS-ENUM&quot;&gt;&lt;a href=&quot;#NS-ENUM&quot; class=&quot;headerlink&quot; title=&quot;NS_ENUM&quot;&gt;&lt;/a&gt;NS_ENUM&lt;/h2&gt;&lt;p&gt;如果要在早期的iOS或OS X系统中使用这两个宏，简单定义一下就好&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#ifndef NS_ENUM&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在OS X 10.4 中的原始定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define NS_ENUM(_type, _name) CF_ENUM(_type, _name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define NS_OPTIONS(_type, _name) CF_OPTIONS(_type, _name)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在之前枚举可以这么定义：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef enum &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellStyleDefault,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellStyleValue1,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellStyleValue2,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellStyleSubtitle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef NSInteger UITableViewCellStyle;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在，有了统一的风格&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef NS_ENUM(NSInteger, UITableViewCellSelectionStyle) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellSelectionStyleNone,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellSelectionStyleBlue,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellSelectionStyleGray,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITableViewCellSelectionStyleDefault&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;NS_ENUM&lt;/code&gt; 的第一个参数是用于存储的新类型的类型。在64位环境下，&lt;code&gt;UITableViewCellStyle&lt;/code&gt; 和 &lt;code&gt;NSInteger&lt;/code&gt; 一样有8 bytes长。你要保证你给出的所有值能被该类型容纳，否则就会产生错误。第二个参数是新类型的名字。大括号里面和以前一样，是你要定义的各种值。&lt;/p&gt;
&lt;h2 id=&quot;NS-OPTIONS&quot;&gt;&lt;a href=&quot;#NS-OPTIONS&quot; class=&quot;headerlink&quot; title=&quot;NS_OPTIONS&quot;&gt;&lt;/a&gt;NS_OPTIONS&lt;/h2&gt;&lt;p&gt;语法和 &lt;code&gt;NS_ENUM&lt;/code&gt; 完全相同，但这个宏提示编译器值是如何通过位掩码 | 组合在一起的。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef NS_OPTIONS(NSUInteger, AMGResizing) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AMGResizingNone            = 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AMGResizingFlexibleWidth   = 1 &amp;lt;&amp;lt; 0,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AMGResizingFlexibleHeight  = 1 &amp;lt;&amp;lt; 1,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AMGResizingFlexibleUnicorn = 1 &amp;lt;&amp;lt; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;attribute-always-inline&quot;&gt;&lt;a href=&quot;#attribute-always-inline&quot; class=&quot;headerlink&quot; title=&quot;attribute((always_inline))&quot;&gt;&lt;/a&gt;&lt;strong&gt;attribute&lt;/strong&gt;((always_inline))&lt;/h1&gt;&lt;p&gt;我们知道一般的函数调用都会通过call的方式来调用，这样让攻击很容易对一个函数做手脚，如果是以&lt;code&gt;inline&lt;/code&gt;的方式编译的会，会把该函数的code拷贝到每次调用该函数的地方。而&lt;code&gt;static&lt;/code&gt;会让生成的二进制文件中没有清晰的符号表，让逆向的人很难弄清楚逻辑。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__attribute__((always_inline))&lt;/code&gt; 的意思是强制内联，所有加了&lt;code&gt;__attribute__((always_inline))&lt;/code&gt; 的函数再被调用时不会被编译成函数调用而是直接扩展到调用函数体内，比如定义了函数&lt;br&gt;&lt;code&gt;__attribute__((always_inline)) void a()&lt;/code&gt;&lt;br&gt;和&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void b()｛  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;｝&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;b 调用 a 函数的汇编代码不会是跳转到a执行，而是 a 函数的代码直接在 b 内成为 b 的一部分。&lt;br&gt;&lt;code&gt;#define __inline __attribute__((always_inline))&lt;/code&gt; 的意思就是用&lt;br&gt;&lt;code&gt;__inline&lt;/code&gt; 代替&lt;code&gt;__attribute__((always_inline))&lt;/code&gt;&lt;br&gt;内声明a的时候可以直接写成&lt;code&gt;__inline void a()&lt;/code&gt; 这样比较方便因为&lt;code&gt;__attribute__((always_inline))&lt;/code&gt; 字多。&lt;/p&gt;
&lt;h1 id=&quot;undef&quot;&gt;&lt;a href=&quot;#undef&quot; class=&quot;headerlink&quot; title=&quot;undef&quot;&gt;&lt;/a&gt;undef&lt;/h1&gt;&lt;p&gt;这是预编译指令，和&lt;code&gt;#define&lt;/code&gt;搭配使用，意思是取消之前的宏定义。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define PROC_ADD &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void main(void) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#ifdef PROC_ADD &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Do this code here then undefined it to run the code in the else &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// processing work &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#undef PROC_ADD &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#else &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// now that PROC_ADD has been undefined run this code &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// processing work &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;unsafe-unretained&quot;&gt;&lt;a href=&quot;#unsafe-unretained&quot; class=&quot;headerlink&quot; title=&quot;__unsafe_unretained&quot;&gt;&lt;/a&gt;__unsafe_unretained&lt;/h1&gt;&lt;p&gt;&lt;code&gt;__unsafe_unretained&lt;/code&gt;是对对象的非zeroing的weak reference，意思是当对象所指向的内存被销毁了，对象还存在，称为“野指针”。&lt;/p&gt;
&lt;p&gt;在iOS引入了Automatic Reference Count（ARC）之后，编译器可以在编译时对obj-c对象进行内存管理。大致规则如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;alloc的要release;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;retain/copy的要release;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSAutoreleasePool在ARC中被禁止使用,替换成@autoreleasepool 函数体;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;使用@ autoreleasepool,在函数入口的时候,autorelease pool入栈,正常退出时,autorelease pool出栈,从而释放变量.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;注意:@ autoreleasepool在非ARC模式下,也能使用,并据说使用@autoreleasepool比使用NSAutoreleasePool速度能快6倍, 明显提升程序性能.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;package&quot;&gt;&lt;a href=&quot;#package&quot; class=&quot;headerlink&quot; title=&quot;@package&quot;&gt;&lt;/a&gt;@package&lt;/h1&gt;&lt;p&gt;为了强制一个对象隐藏其数据，编译器限制实例变量范围以限制其在程序中的可见性，但是为了提供灵活性，苹果也让开发者显式设置范围。&lt;/p&gt;
&lt;p&gt;以下是这些关键字的使用范围：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@private&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The instance variable is accessible only within the class that declares it.&lt;/p&gt;
&lt;p&gt;实例变量只能被声明它的类访问.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@protected&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The instance variable is accessible within the class that declares it and within classes that inherit it. All instance variables without an explicit scope directive have @protected scope.&lt;/p&gt;
&lt;p&gt;实例变量能被声明它的类和子类访问，所有没有显式制定范围的实例变量都是.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@public&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The instance variable is accessible everywhere.&lt;/p&gt;
&lt;p&gt;实例变量可以被在任何地方访问.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@package&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Using the modern runtime, an &lt;code&gt;@package&lt;/code&gt; instance variable has &lt;code&gt;@public&lt;/code&gt; scope inside the executable image that implements the class, but acts like &lt;code&gt;@private&lt;/code&gt; outside.使用modern运行时，一个&lt;code&gt;@package&lt;/code&gt;实例变量在实现这个类的可执行文件镜像中实际上是&lt;code&gt;@public&lt;/code&gt;的，但是在外面就是&lt;code&gt;@private&lt;/code&gt;【runtime需要再看一下苹果文档Runtime Programming Guide】&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;@package&lt;/code&gt; scope for Objective-C instance variables is analogous to private_extern for C variables and functions. Any code outside the class implementation’s image that tries to use the instance variable gets a link error.&lt;/p&gt;
&lt;p&gt;Objective-C中的&lt;code&gt;@package&lt;/code&gt;与C语言中变量和函数的private_extern类似。任何在实现类的镜像之外的代码想使用这个实例变量都会引发link error&lt;/p&gt;
&lt;p&gt;This scope is most useful for instance variables in framework classes, where &lt;code&gt;@private&lt;/code&gt; may be too restrictive but &lt;code&gt;@protected&lt;/code&gt; or &lt;code&gt;@public&lt;/code&gt; too permissive.&lt;/p&gt;
&lt;p&gt;这个类型最常用于框架类的实例变量，使用&lt;code&gt;@private&lt;/code&gt;太限制，使用&lt;code&gt;@protected&lt;/code&gt;或者&lt;code&gt;@public&lt;/code&gt;又太开放. |&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：YYModel堪称神级大作，虽然不免一些小bug，但是完全不影响膝盖碎一地。文章主要分享在阅读YYModel源代码时，所引发的知识点的补充与思考。&lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="开源框架" scheme="http://charsdavy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 并发概念浅析</title>
    <link href="http://charsdavy.github.io/2016/05/26/ios-simultaneously/"/>
    <id>http://charsdavy.github.io/2016/05/26/ios-simultaneously/</id>
    <published>2016-05-26T00:32:15.000Z</published>
    <updated>2016-06-04T05:28:46.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：并发（concurrency）是一个常用且较好的解决APP的流畅度方法，但并发涉及串行、并发、并行、同步、异步、多线程、GCD、NSOperation和NSOperationQueue等诸多容易混淆的概念。本文主要分享对一些易混淆概念的理解。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在进行iOS开发过程中，我们常会遇到网络请求、复杂计算、数据存取等比较耗时的操作，如果处理不合理，将对APP的流畅度产生较大影响。除了优化APP架构，并发（concurrency）是一个常用且较好的解决方法，但并发涉及串行、并发、并行、同步、异步、多线程、GCD、NSOperation和NSOperationQueue等诸多容易混淆的概念。接下来，主要分享对一些易混淆概念的理解。&lt;/p&gt;
&lt;h1 id=&quot;一、线程和任务&quot;&gt;&lt;a href=&quot;#一、线程和任务&quot; class=&quot;headerlink&quot; title=&quot;一、线程和任务&quot;&gt;&lt;/a&gt;一、线程和任务&lt;/h1&gt;&lt;p&gt;线程（thread） 和任务（task）是其他并发概念的基础，因此也是首要需理清的概念，以下是其要点，详细可参考&lt;a href=&quot;https://en.wikipedia.org/wiki/Thread_%28computing%29&quot;&gt;Thread (computing)&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Task_%28computing&quot;&gt;Task (computing)&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;1）任务（task）&quot;&gt;&lt;a href=&quot;#1）任务（task）&quot; class=&quot;headerlink&quot; title=&quot;1）任务（task）&quot;&gt;&lt;/a&gt;1）任务（task）&lt;/h2&gt;&lt;p&gt;a）任务（task）是从程序中划分出来，可以独立执行的代码片段；&lt;/p&gt;
&lt;p&gt;b）任务间可以添加依赖关系，如B任务依赖A任务，taskB.addDependency(taskA)，这意味着B任务的执行以A任务完成为前提。&lt;/p&gt;
&lt;p&gt;需要注意的是一个任务是否可以添加依赖，完全取决于任务封装类和其相关管理类的具体实现，GCD不支持任务依赖，NSOperationQueue就支持任务依赖。&lt;/p&gt;
&lt;p&gt;下面的代码是对一个任务的简单封装，并支持任务间的依赖。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//Task是一个任务的简单封装类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Task &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let taskBlock: () -&amp;gt; ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var dependencies = [Task]() &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    init(block: () -&amp;gt; ()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        taskBlock = block&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func addDependency(task: Task) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dependencies.append(task)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//初始化两个自定义任务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var taskA = Task()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //自定义任务A，自定义需要执行的代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var taskB = Task()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //自定义任务B，自定义需要执行的代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//添加依赖关系&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;taskB.addDependency(taskA)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;2）线程（thread）&quot;&gt;&lt;a href=&quot;#2）线程（thread）&quot; class=&quot;headerlink&quot; title=&quot;2）线程（thread）&quot;&gt;&lt;/a&gt;2）线程（thread）&lt;/h2&gt;&lt;p&gt;a）线程（thread）是代码执行的独立路径，一条线程只能同时执行一行代码（一行代码，其实就是一条处理器命令）。&lt;/p&gt;
&lt;p&gt;b）线程中代码管理是以任务（task）为单位，一条线程逐行执行一个任务中的代码（任务可以取消），完成后再逐行执行下一个任务中的代码。&lt;/p&gt;
&lt;p&gt;c）一条线程跳出一个任务的执行，即意味着这个任务的完成。因此，一条线程不能执行taskA一段时间后，还未完成就开始执行taskB，然后又返回执行taskA（这其实是单线程内的并发，与单核处理器的并发概念相同，具体实践中不存在线程内并发）。&lt;/p&gt;
&lt;h1 id=&quot;二、概念释疑&quot;&gt;&lt;a href=&quot;#二、概念释疑&quot; class=&quot;headerlink&quot; title=&quot;二、概念释疑&quot;&gt;&lt;/a&gt;二、概念释疑&lt;/h1&gt;&lt;h2 id=&quot;1）并行（parallelism）和并发（concurrency）&quot;&gt;&lt;a href=&quot;#1）并行（parallelism）和并发（concurrency）&quot; class=&quot;headerlink&quot; title=&quot;1）并行（parallelism）和并发（concurrency）&quot;&gt;&lt;/a&gt;1）并行（parallelism）和并发（concurrency）&lt;/h2&gt;&lt;p&gt;并发和并行都是指多个任务可以同时执行，都属于多线程编程概念，因此二者必然十分相近，容易混淆。二者区别只有一点，即是否多任务执行于严格的同一时刻。并发不是，而并行是。&lt;/p&gt;
&lt;p&gt;单核处理器时代（一个处理器同一时刻只能执行一条命令），为了实现多任务的同时执行，系统利用时间分片（time-slicing）技术，将处理器的执行时间切分为多个小片段，一会执行threadA，一会执行threadB，一会再执行threadA，即在多个线程（任务是在线程上执行的）之间来回跳动执行。虽不是真的多线程多任务同时执行，但由于处理器的处理速度非常快，在用户看来，仍然是同时执行的。这种伪多线程就是并发。&lt;/p&gt;
&lt;p&gt;多核处理器时代（不同处理器相互独立，可以同时执行各自的命令），多条线程完全可以严格同一时刻执行，这种真多线程就是并行。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//三个线程的并发&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread1 -&amp;gt; |---A---|             -&amp;gt;|---A---|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread2 ------&amp;gt;    -&amp;gt;|------B----|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread3 ------------------------------------&amp;gt; |------C------|&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述代码是三个线程的并发执行，可以看出thread1、thread2和thread3不可能严格同一时刻执行，但也都获得了处理器的一小段执行时间。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//三个线程的并行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread1 -&amp;gt; |-----A-----|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread2 -&amp;gt;       |------B----|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread3 -&amp;gt;     |------C------|&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述代码是三个线程的并行执行，可以看出thread1、thread2和thread3有一段时间同时执行。&lt;/p&gt;
&lt;p&gt;现在的终端设备无论是手机还是PC的处理器，大多都已是多核处理器，可以实现并行计算，但为了最大化的利用处理器的性能，现代处理器还是融合了time-slicing技术和多核技术，因此实际运行中，有时并发，有时并行。但相对来说，并发是个更广泛的概念，因此Apple的多线程编程叫做concurrency programming并发编程。汉语中，并发和并行的区别其实没那么清晰，可以互用，而且有时用并行更加明确，如串并行比串行、并发针对性更强。（为概念清晰起见，下文中有时会用并行，其实即是并发。）&lt;/p&gt;
&lt;h2 id=&quot;2）串并行与线程&quot;&gt;&lt;a href=&quot;#2）串并行与线程&quot; class=&quot;headerlink&quot; title=&quot;2）串并行与线程&quot;&gt;&lt;/a&gt;2）串并行与线程&lt;/h2&gt;&lt;h3 id=&quot;串行（serial）和并行&quot;&gt;&lt;a href=&quot;#串行（serial）和并行&quot; class=&quot;headerlink&quot; title=&quot;串行（serial）和并行&quot;&gt;&lt;/a&gt;串行（serial）和并行&lt;/h3&gt;&lt;p&gt;串行和并行主要区别在于一个任务的执行是否以上一个任务的完成为前提。串行中，一个任务的执行必须以上一个任务执行结束为前提；并行中，一个任务的执行与上一个任务的执行状态无关。以排队买票为例，串行像单个买票队伍，单个卖票窗口，必须一个一个来；串行像单个买票队伍，多个卖票窗口，多个人可以同时买票。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//三个串行任务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|-----A-----||------B--------||----C--|&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上文为三个串行任务，任务A完成后，才执行任务B，B结束后，才最后执行任务C。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//三个并发任务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|-----A-----|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      |------B----|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   |--C---|&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上文为三个并行任务，任务A早于任务C开始，却晚于任务C结束。&lt;/p&gt;
&lt;h3 id=&quot;串并行与线程&quot;&gt;&lt;a href=&quot;#串并行与线程&quot; class=&quot;headerlink&quot; title=&quot;串并行与线程&quot;&gt;&lt;/a&gt;串并行与线程&lt;/h3&gt;&lt;p&gt;串并行主要关注多个任务之间的相互依赖关系，与线程无关。但实际中，任务是在线程中执行的，是否串行一定在单线程上执行，并行一定在多个线程中执行呢？并非如此。&lt;/p&gt;
&lt;p&gt;单线程既可以实现串行，也可以实现并行。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//单线程串行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 thread -&amp;gt;   |----A-----||-----B-----------||-------C------|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//单线程并行（理论上，实际中不可行）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         A-Start ---------------------------------------- A-End  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           | B-Start ----------------------------------------|--- B-End  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           |   |     C-Start -------------------- C-End      |     |  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           V   V       V                           V         V     V      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 thread-&amp;gt; |-A-|---B---|-C-|-A-|-C-|--A--|-B-|--C--|---A-----|--B--|&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要指出的是单线程内的并行已经类似单核处理器，并不是本文提及的常规线程，现实中也不常见。&lt;/p&gt;
&lt;p&gt;多线程既可以实现串行，也可以实现并行，实际上，多线程串行和并行都很常见。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//多线程串行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread1 -&amp;gt; |----A-----|  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       \  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread2 ---------------&amp;gt;|-----B-----------|  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                           \  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread3 -----------------------------------&amp;gt;|-------C------|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//多线程并发&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread1 -&amp;gt;     |----A-----|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread2 -----&amp;gt;     |-----B-----------|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;thread3 ---------&amp;gt;     |-------C----------|&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;3）同步（synchronize）、异步（asynchronous）与线程&quot;&gt;&lt;a href=&quot;#3）同步（synchronize）、异步（asynchronous）与线程&quot; class=&quot;headerlink&quot; title=&quot;3）同步（synchronize）、异步（asynchronous）与线程&quot;&gt;&lt;/a&gt;3）同步（synchronize）、异步（asynchronous）与线程&lt;/h2&gt;&lt;p&gt;同步和异步是站在当前线程的角度，考察添加任务到新线程后，何时返回到当前线程执行下面的代码的问题，也即新添加的线程阻不阻塞当前线程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;override viewDidLoad() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_sync(queue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //block1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&amp;quot;-----1-----&amp;quot;) //1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&amp;quot;-----2-----&amp;quot;) //2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;block1是添加到系统全局队列中的新任务，由于是同步的，因此block1执行返回后，才会回到当前主线程，执行//2及以后的代码。输出结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-----1-----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-----2-----&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;异步&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//viewDidLoad()在主线程中执行，因此当前线程为主线程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;override viewDidLoad() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //block1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&amp;quot;-----1-----&amp;quot;) //1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&amp;quot;-----2-----&amp;quot;) //2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;block1是添加到系统全局队列中的新任务，由于是异步的，因此block1添加全局队列后（会在另外一个线程上执行），不等到执行完成，就会返回到当前主线程，执行//2及以后的代码，所以输出结果可能为 21 12。但由于block1和主线程中的任务都是不耗时的简单任务，而创建新的线程是要消耗一定时间的（主线程一直存在，不用新创建），因此很可能的输出结果是：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-----2-----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-----1-----&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;同异步结合的情形&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果同异步结合:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//viewDidLoad()在主线程中执行，因此当前线程为主线程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;override viewDidLoad() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    super.viewDidLoad()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //block1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&amp;quot;-----A-----&amp;quot;) //1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dispatch_async(dispatch_get_main_queue()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //block2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            print(&amp;quot;-----B-----&amp;quot;) //2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&amp;quot;-----C-----&amp;quot;) //3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&amp;quot;-----D-----&amp;quot;) //4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(true) &amp;#123; &amp;#125; //5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&amp;quot;-----E-----&amp;quot;) //6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;block1是添加到系统全局队列中的新任务，由于是异步的，因此block1添加全局队列后（会在另外一个线程上执行），不等到执行完成，就返回到当前主线程，执行//4及以后的代码，结果是block1所在的线程与主线程同时执行，因此理论上，D和A谁先输出不一定。但由于block1和主线程中的任务都是不耗时的简单任务，而创建新的线程是要消耗一定时间的（主线程一直存在，不用新创建），因此一般输出结果为DA。&lt;/p&gt;
&lt;p&gt;block1所在线程输出完A后，将block2添加到主调度队列中，由于是异步的，因此block2添加主调度队列后（会在主线程上执行），不等到执行完成，就返回到block2所在的线程，继续执行，因此A和C一定会输出，且C一定在A之后输出。但block2却不一定能执行，因为block1在执行时，主线程也在执行（主线程是串行单线程，任务按顺序一个一个执行），如果此时主线程执行到//5对应的死循环，则block2一定不能被执行，B一定不能被输出，如果此时主线程尚未执行到//5对应的死循环，block2已经添加到主线程中，则block2会被执行，B能被输出。但由于主线程无需另外创建，block1（所对应的线程需另外创建）执行到添加block2到主调度队列时，主线程很可能已经执行到//5对应的死循环，因此block2很可能不被执行。&lt;/p&gt;
&lt;p&gt;//6前有个死循环，因此E一定不会被输出。&lt;/p&gt;
&lt;p&gt;因此可能的输出结果是；DAC ADC ADCB DACB ACDB ACBD ABDC ABCD&lt;/p&gt;
&lt;p&gt;但很可能的输出结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-----D-----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-----A-----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-----C-----&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;4）同异步与串并行&quot;&gt;&lt;a href=&quot;#4）同异步与串并行&quot; class=&quot;headerlink&quot; title=&quot;4）同异步与串并行&quot;&gt;&lt;/a&gt;4）同异步与串并行&lt;/h2&gt;&lt;p&gt;串行和同步，并行和异步似是完全不同的概念，一个关注任务的独立关系，一个看中的是返回的时机。但事实上，串行和同步近似，并发和异步相同，他们指代的事情几乎完全相同。&lt;br&gt;就同步和串行而言，需要任务执行结束后才能返回，其实就是一个任务执行完成后，才能执行其他的任务，反应的就是串行依赖关系。&lt;/p&gt;
&lt;p&gt;而异步和并行就更相同了，不等任务执行完成，就直接返回，反应的就是并发任务之间的独立性。&lt;/p&gt;
&lt;p&gt;当然，同异步所暗含的串行和并行是当前线程的任务与新线程的任务之间的相互关系。&lt;/p&gt;
&lt;h1 id=&quot;三、GCD与NSOperationQueue&quot;&gt;&lt;a href=&quot;#三、GCD与NSOperationQueue&quot; class=&quot;headerlink&quot; title=&quot;三、GCD与NSOperationQueue&quot;&gt;&lt;/a&gt;三、GCD与NSOperationQueue&lt;/h1&gt;&lt;p&gt;GCD(grand central dispatch)和NSOperationQueue二者均是系统级的多线程封装，在使用时，我们只需创建任务队列即可，其他的如线程创立、任务分配等，均由系统自动处理。不得不说，这让多线程编程变得更高效，更简单，当然并不是没有坑。&lt;br&gt;需要强调的是，GCD和NSOperationQueue的使用核心是任务（task）和任务队列（task queue），暂时可以忘了线程（thread）这烦人的概念。&lt;/p&gt;
&lt;p&gt;关于GCD和NSOperationQueue网上已经有不少高质量的文章对其详细介绍，推荐&lt;a href=&quot;http://www.cocoachina.com/ios/20160201/15179.html&quot;&gt;《iOS并行开发：从NSOperation和调度队列开始》&lt;/a&gt;，其对基本概念、使用方法等的介绍非常清晰详尽，这里就不再赘述，只写一些个人认为容易忽略却影响认知深度的小知识点。当然如果你英语过硬，去直接看官方文档&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html&quot;&gt;《ConcurrencyProgrammingGuide》&lt;/a&gt;是最好的。&lt;/p&gt;
&lt;h2 id=&quot;1）GCD&quot;&gt;&lt;a href=&quot;#1）GCD&quot; class=&quot;headerlink&quot; title=&quot;1）GCD&quot;&gt;&lt;/a&gt;1）GCD&lt;/h2&gt;&lt;p&gt;GCD是基于C的API，因此比较底层。&lt;/p&gt;
&lt;p&gt;GCD所管理的调度队列（dispatch queue）主要有三类：串行队列（private dispatch queue）、并发队列 （global dispatch queue，又称全局调度队列）和主队列（main dispatch queue）。&lt;/p&gt;
&lt;p&gt;我们常用的 dispatch_get_global&lt;em&gt;queue(&lt;/em&gt;: _:)所获得的dispatch queue就是全局调度队列(global dispatch queue)，并发，而且全局调度队列是全局共用的，每一个优先级的全局调度队列只有一个实体。四种不同优先级的全局调度队列对应的四种优先级的线程，同一个优先级的全局调度队列可以同时拥有多条相应优先级的线程。&lt;/p&gt;
&lt;p&gt;dispatch_get_main_queue()所获得的dispatch queue是主调度队列，主调度队列是串行队列。&lt;/p&gt;
&lt;h2 id=&quot;2）NSOperationQueue&quot;&gt;&lt;a href=&quot;#2）NSOperationQueue&quot; class=&quot;headerlink&quot; title=&quot;2）NSOperationQueue&quot;&gt;&lt;/a&gt;2）NSOperationQueue&lt;/h2&gt;&lt;p&gt;NSOperationQueue是对GCD的Objective-C封装，相对于GCD具有更多先进的特性，如可以添加NSOperation依赖，取消NSOperation等。&lt;/p&gt;
&lt;p&gt;NSOperationQueue是并发队列，且不遵循先进先出（FIFO）排序原则。&lt;/p&gt;
&lt;h1 id=&quot;四、总结与感悟&quot;&gt;&lt;a href=&quot;#四、总结与感悟&quot; class=&quot;headerlink&quot; title=&quot;四、总结与感悟&quot;&gt;&lt;/a&gt;四、总结与感悟&lt;/h1&gt;&lt;p&gt;1）串并行、同异步与线程无关，单线程、多线程都可以实现串并行和同异步。&lt;/p&gt;
&lt;p&gt;2）串行和同步相同，异步和并行相同，他们只是看待同一件事物的角度不同。&lt;/p&gt;
&lt;p&gt;3）GCD和NSOperationQueue的使用核心是任务（task）和任务队列（task queue）。&lt;/p&gt;
&lt;p&gt;4）全局调度队列(global dispatch queue)是全局共用的，系统有时也会向这些调度队列添加系统任务。&lt;/p&gt;
&lt;p&gt;5) App的主调度队列是串行单线程队列。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：并发（concurrency）是一个常用且较好的解决APP的流畅度方法，但并发涉及串行、并发、并行、同步、异步、多线程、GCD、NSOperation和NSOperationQueue等诸多容易混淆的概念。本文主要分享对一些易混淆概念的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="iOS" scheme="http://charsdavy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>GitHub 使用</title>
    <link href="http://charsdavy.github.io/2016/05/20/github-using/"/>
    <id>http://charsdavy.github.io/2016/05/20/github-using/</id>
    <published>2016-05-20T14:17:11.000Z</published>
    <updated>2016-06-04T05:28:12.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：GitHub就是程序员的facebook，在这个开源、大神云集的地方，小菜是可以学到，找到很多很棒的资源的。那么，如何进入这个圈子呢？我们从使用开始。这篇文章主要讲解如何使用GitHub托管自己的代码，注意，托管是公开的喔，私有的要付费的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;下载github客户端软件&quot;&gt;&lt;a href=&quot;#下载github客户端软件&quot; class=&quot;headerlink&quot; title=&quot;下载github客户端软件&quot;&gt;&lt;/a&gt;下载github客户端软件&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;官网&lt;a href=&quot;https://help.github.com/&quot;&gt;下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Google搜索，一般用于windows7以前的系统&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;安装github软件&quot;&gt;&lt;a href=&quot;#安装github软件&quot; class=&quot;headerlink&quot; title=&quot;安装github软件&quot;&gt;&lt;/a&gt;安装github软件&lt;/h1&gt;&lt;p&gt;根据软件安装指导，按步骤安装即可。&lt;/p&gt;
&lt;h1 id=&quot;使用git命令提交&quot;&gt;&lt;a href=&quot;#使用git命令提交&quot; class=&quot;headerlink&quot; title=&quot;使用git命令提交&quot;&gt;&lt;/a&gt;使用git命令提交&lt;/h1&gt;&lt;h2 id=&quot;git-config&quot;&gt;&lt;a href=&quot;#git-config&quot; class=&quot;headerlink&quot; title=&quot;git config&quot;&gt;&lt;/a&gt;git config&lt;/h2&gt;&lt;p&gt;安装Git后首先要做的事情是设置用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.name &amp;quot;Chars Davy&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.email chars_d@example.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;重申一遍，只需要做一次这个设置。如果传递了 &lt;code&gt;--global&lt;/code&gt; 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要&lt;code&gt;--global&lt;/code&gt;选项。&lt;/p&gt;
&lt;h2 id=&quot;git-clone&quot;&gt;&lt;a href=&quot;#git-clone&quot; class=&quot;headerlink&quot; title=&quot;git clone&quot;&gt;&lt;/a&gt;git clone&lt;/h2&gt;&lt;p&gt;这是一种较为简单的初始化方式，当你已经有一个远程的Git版本库，只需要在本地克隆一份:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git  clone  git://github.com/someone/some_project.git   some_project&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的命令就是将&lt;code&gt;git://github.com/someone/some_project.git&lt;/code&gt;这个URL地址的远程版本库，完全克隆到本地some_project目录下。&lt;/p&gt;
&lt;h2 id=&quot;git-init-和-git-remote&quot;&gt;&lt;a href=&quot;#git-init-和-git-remote&quot; class=&quot;headerlink&quot; title=&quot;git init 和 git remote&quot;&gt;&lt;/a&gt;git init 和 git remote&lt;/h2&gt;&lt;p&gt;这种方式稍微复杂一些，当你本地创建了一个工作目录，你可以进入这个目录，使用&lt;code&gt;git init&lt;/code&gt;命令进行初始化；Git以后就会对该目录下的文件进行版本控制，这时候如果你需要将它放到远程服务器上，可以在远程服务器上创建一个目录，并把可访问的URL记录下来，此时你就可以利用&lt;code&gt;git remote add&lt;/code&gt;命令来增加一个远程服务器端，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git  remote  add  origin  git://github.com/someone/another_project.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的命令就会增加URL地址为&lt;code&gt;git: //github.com/someone/another_project.git&lt;/code&gt;，名称为origin的远程服务器，以后提交代码的时候只需要使用 origin别名即可。&lt;/p&gt;
&lt;h2 id=&quot;git-add&quot;&gt;&lt;a href=&quot;#git-add&quot; class=&quot;headerlink&quot; title=&quot;git add&quot;&gt;&lt;/a&gt;git add&lt;/h2&gt;&lt;p&gt;将当前更改或者新增的文件加入到Git的索引中，加入到Git的索引中就表示记入了版本历史中，这也是提交之前所需要执行的一步，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git add app/model/user.rb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就会增加&lt;code&gt;app/model/user.rb&lt;/code&gt;文件到Git的索引中，该功能类似于SVN的add，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git add .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的命令会将所有改动过的文件及文件夹迭代全部添加进本地代码仓库。&lt;/p&gt;
&lt;h2 id=&quot;git-commit&quot;&gt;&lt;a href=&quot;#git-commit&quot; class=&quot;headerlink&quot; title=&quot;git commit&quot;&gt;&lt;/a&gt;git commit&lt;/h2&gt;&lt;p&gt;提交当前工作空间的修改内容，类似于SVN的commit命令，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git commit -m story #3, add user model&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;提交的时候必须用-m来输入一条提交信息，该功能类似于SVN的commit，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git commit –m beta&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的命令会将beta作为log显示在代码提交记录中。&lt;/p&gt;
&lt;h2 id=&quot;git-push&quot;&gt;&lt;a href=&quot;#git-push&quot; class=&quot;headerlink&quot; title=&quot;git push&quot;&gt;&lt;/a&gt;git push&lt;/h2&gt;&lt;p&gt;将本地commit的代码更新到远程版本库中，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git push origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的命令就会将本地的代码更新到名为orgin的远程版本库中。&lt;/p&gt;
&lt;h1 id=&quot;git代码提交中可能遇到的问题&quot;&gt;&lt;a href=&quot;#git代码提交中可能遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;git代码提交中可能遇到的问题&quot;&gt;&lt;/a&gt;git代码提交中可能遇到的问题&lt;/h1&gt;&lt;p&gt;问题1：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;You can&amp;apos;t push to git://github.com/example/example_pro.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Use https://github.com/ example/example_pro.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git remote remove origin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git remote add origin git@github.com:user_name/user_repo.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git push origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;p&gt;如果在&lt;code&gt;git clone&lt;/code&gt;的时候用的是&lt;code&gt;git://github.com:xx/xxx.git&lt;/code&gt; 的形式, 那么就会出现这个问题，因为这个protocol是不支持push的，而使用&lt;code&gt;git clone git@github.com:lujinjianst/myNCCL.git&lt;/code&gt;就可以用git push。&lt;/p&gt;
&lt;p&gt;问题2：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Permission denied(publickey).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fatal:Could not read from remote repository.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;p&gt;在终端输入:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh-keygen -t rsa -C &amp;quot;chars&amp;quot;//注意,chars为用户名&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果执行成功。返回:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Generating public/private rsa key pair. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Enter file in which to save the key (/home/forwhat.cn/.ssh/id_rsa):&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这里就是设置存储地址了.反正我是直接按的回车,然后还会返回:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Enter passphrase (empty for no passphrase):&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再次直接回车。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Enter same passphrase again:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;再次回车。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Your identification has been saved in /home/forwhat.cn/.ssh/id_rsa. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Your public key has been saved in /home/forwhat.cn/.ssh/id_rsa.pub. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The key fingerprint is:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;The key&amp;apos;s randomart image is: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+--[ RSA 2048]----+ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                 | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                 | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|                 | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|    o            | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|   + .  S        | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  . = .  o       | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|   o + +o.o      | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|E o . o.=+.      | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|.+   ==+ooo.     | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+-----------------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样SSH key就生成了。直接cat一下就好了。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;:~/a$ cat /home/forwhat.cn/.ssh/id_rsa.pub&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;把显示出来的直接添加到github账户设置里边的SSH keys。&lt;br&gt;回来再git pull就开始远程拷贝代码了。&lt;/p&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;p&gt;没有在github账号添加SSH key。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：GitHub就是程序员的facebook，在这个开源、大神云集的地方，小菜是可以学到，找到很多很棒的资源的。那么，如何进入这个圈子呢？我们从使用开始。这篇文章主要讲解如何使用GitHub托管自己的代码，注意，托管是公开的喔，私有的要付费的。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://charsdavy.github.io/categories/tool/"/>
    
    
      <category term="Git" scheme="http://charsdavy.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>均匀分布随机函数的实现</title>
    <link href="http://charsdavy.github.io/2016/04/30/uniform-random/"/>
    <id>http://charsdavy.github.io/2016/04/30/uniform-random/</id>
    <published>2016-04-30T01:37:10.000Z</published>
    <updated>2016-06-04T05:28:58.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：随机函数可以说是用途很广。可是，系统提供的random函数，一般符合正态分布，所以说，这是伪随机函数。甚至在一些场合是非随机函数。为了满足项目需要，必须实现均匀分布。在此，分享博主实现均匀随机函数的实现过程与方法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;随机函数就是产生数的函数，C语言里使用rand(),srand()等随机函数实现随机数生成。&lt;/p&gt;
&lt;h1 id=&quot;函数简介&quot;&gt;&lt;a href=&quot;#函数简介&quot; class=&quot;headerlink&quot; title=&quot;函数简介&quot;&gt;&lt;/a&gt;函数简介&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int rand( void );&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回的是一个界于0～32767（0x7FFF）之间的伪随机数，包括0和32767。&lt;br&gt;C预先生成一组随机数，每次调用随机函数时从指针所指向的位置开始取值，因此使用rand()重复运行程序产生的随机数都是相同的，可以通过srand()函数来改变指针位置。&lt;br&gt;srand()会设置供rand()使用的随机数种子。如果在第一次使用rand()之前没有调用srand()，那么系统会自动调用srand()。而使用同种子相同的数调用 rand()会导致相同的随机数序列被生成。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void srand( unsigned int seed );&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;改变随机数表的指针位置（用seed变量控制）。&lt;br&gt;使用系统定时/计数器的值作为随机种子。每个种子对应一组根据算法预先生成的随机数，所以，在相同的平台环境下，不同时间产生的随机数会是不同的，相应的，若将srand（unsigned）time(NULL)改为srand(TP)（TP为任一常量），则无论何时运行、运行多少次得到的“随机数”都会是一组固定的序列，因此srand生成的随机数是伪随机数。&lt;br&gt;一般配合time(NULL)使用，因为时间每时每刻都在改变，产生的seed值都不同。&lt;/p&gt;
&lt;h1 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h1&gt;&lt;p&gt;使用rand函数生成的随机数严格满足正态分布。而在很多时候，我们希望随机数的生成不要满足正态分布，特别是在处理网络通信报文的时候。&lt;br&gt;例如，我们需要在交换机处理到海量报文时，能够使远端的从设备尽可能的分段同时向局端回应报文，以减轻局部报文处理压力。&lt;/p&gt;
&lt;h1 id=&quot;均匀分布随机函数实现&quot;&gt;&lt;a href=&quot;#均匀分布随机函数实现&quot; class=&quot;headerlink&quot; title=&quot;均匀分布随机函数实现&quot;&gt;&lt;/a&gt;均匀分布随机函数实现&lt;/h1&gt;&lt;h2 id=&quot;开发环境&quot;&gt;&lt;a href=&quot;#开发环境&quot; class=&quot;headerlink&quot; title=&quot;开发环境&quot;&gt;&lt;/a&gt;开发环境&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-b2f082073e33ca94.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;开发环境&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现步骤&quot;&gt;&lt;a href=&quot;#实现步骤&quot; class=&quot;headerlink&quot; title=&quot;实现步骤&quot;&gt;&lt;/a&gt;实现步骤&lt;/h2&gt;&lt;p&gt;1）打开Qt Creater，创建GUI工程&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-1c06b87e7e219e93.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;创建GUI工程&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-4b288fe958b3e962.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;项目文件结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;2）在mainwindow.h中添加函数声明&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void paintEvent(QPaintEvent *);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3）在mainwindow.cpp中添加函数实现&lt;/p&gt;
&lt;p&gt;导入头文件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;QPainter&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实现&lt;code&gt;void paintEvent(QPaintEvent *)&lt;/code&gt;函数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *Qt中函数paintEvent(QPaintEvent*)是被系统自动调用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *paintEvent(QPaintEvent *)函数是QWidget类中的虚函数，用于ui的绘制，会在多种情况下被其他函数自动调用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void MainWindow::paintEvent(QPaintEvent *)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QPainter painter(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QPen pen; //画笔&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pen.setColor(QColor(255,0,0)); //设置画笔颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    painter.setPen(pen); //添加画笔&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    long int r[kSum] = &amp;#123;0&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int j = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        r[i] = Uniform(0, 300);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;while(i &amp;lt; kSum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while((j + 30) &amp;lt; (kSum + 30))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        painter.drawPoint(j, r[j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;4）添加随机函数实现代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define kSum 1000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//算法一&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *均匀分布随机函数均匀化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;double _uniform(double min, double max, long int *seed) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    double t = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *seed = 2045 * (*seed) + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *seed = *seed - (*seed / 1048576) * 1048576;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t = (*seed) / 1048576.0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t = min + (max - min) * t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *均匀分布随机函数产生随机数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;long int Uniform(double min, double max) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    long int s = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    double r = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //srand((unsigned int)time(NULL)); /*同一个时间种子可能会从产生相同的随机数列*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s = rand();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    r = _uniform(min, max, &amp;amp;s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return ((long int)r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//算法二&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;double AverageRandom(double min, double max) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int minInteger = (int)(min * 10000);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int maxInteger = (int)(max * 10000);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int randInteger = rand() * rand();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int diffInteger = maxInteger - minInteger;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int resultInteger = randInteger % diffInteger + minInteger;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return (resultInteger/10000.0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;实现效果&quot;&gt;&lt;a href=&quot;#实现效果&quot; class=&quot;headerlink&quot; title=&quot;实现效果&quot;&gt;&lt;/a&gt;实现效果&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-af95ccbacb9b3231.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;实现效果&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h1&gt;&lt;p&gt;从图中可以看出，使用上述函数生成的随机数符合均匀分布。&lt;br&gt;本案例主要使用了Qt的绘图功能，用来直观展示生成随机数的效果。检验随机函数生成随机数的效果。&lt;/p&gt;
&lt;h1 id=&quot;附录&quot;&gt;&lt;a href=&quot;#附录&quot; class=&quot;headerlink&quot; title=&quot;附录&quot;&gt;&lt;/a&gt;附录&lt;/h1&gt;&lt;p&gt;最后附上该算法实现的全部代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//mainwindow.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#ifndef MAINWINDOW_H&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define MAINWINDOW_H&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;QMainWindow&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;namespace Ui &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class MainWindow;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class MainWindow : public QMainWindow&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Q_OBJECT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    explicit MainWindow(QWidget *parent = 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ~MainWindow();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void paintEvent(QPaintEvent *);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Ui::MainWindow *ui;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif // MAINWINDOW_H&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//mainwindow.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;mainwindow.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;ui_mainwindow.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;QPainter&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define kSum 1000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MainWindow::MainWindow(QWidget *parent) :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QMainWindow(parent),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui(new Ui::MainWindow)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ui-&amp;gt;setupUi(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MainWindow::~MainWindow()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    delete ui;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *均匀分布随机函数均匀化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;double _uniform(double min, double max, long int *seed) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    double t = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *seed = 2045 * (*seed) + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *seed = *seed - (*seed / 1048576) * 1048576;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t = (*seed) / 1048576.0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t = min + (max - min) * t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *均匀分布随机函数产生随机数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;long int Uniform(double min, double max) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    long int s = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    double r = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //srand((unsigned int)time(NULL)); /*同一个时间种子可能会从产生相同的随机数列*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s = rand();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    r = _uniform(min, max, &amp;amp;s);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return ((long int)r);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *Qt中函数paintEvent(QPaintEvent*)是被系统自动调用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *paintEvent(QPaintEvent *)函数是QWidget类中的虚函数，用于ui的绘制，会在多种情况下被其他函数自动调用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void MainWindow::paintEvent(QPaintEvent *)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QPainter painter(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QPen pen; //画笔&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    pen.setColor(QColor(255,0,0)); //设置画笔颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    painter.setPen(pen); //添加画笔&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    long int r[kSum] = &amp;#123;0&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int j = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        r[i] = Uniform(0, 300);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;while(i &amp;lt; kSum);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while((j + 30) &amp;lt; (kSum + 30))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        painter.drawPoint(j, r[j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//main.cpp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;quot;mainwindow.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;QApplication&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main(int argc, char *argv[])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QApplication a(argc, argv);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MainWindow w;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    w.show();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return a.exec();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：随机函数可以说是用途很广。可是，系统提供的random函数，一般符合正态分布，所以说，这是伪随机函数。甚至在一些场合是非随机函数。为了满足项目需要，必须实现均匀分布。在此，分享博主实现均匀随机函数的实现过程与方法。&lt;/p&gt;
    
    </summary>
    
      <category term="进阶" scheme="http://charsdavy.github.io/categories/advance/"/>
    
    
      <category term="算法" scheme="http://charsdavy.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Charles 安装与使用</title>
    <link href="http://charsdavy.github.io/2016/04/20/charles-using/"/>
    <id>http://charsdavy.github.io/2016/04/20/charles-using/</id>
    <published>2016-04-20T13:21:14.000Z</published>
    <updated>2016-06-04T09:45:54.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：Charles是在 Mac 下常用的网络封包截取工具，在做 移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。&lt;/p&gt;
&lt;p&gt;Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。&lt;/p&gt;
&lt;p&gt;除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。&lt;/p&gt;
&lt;p&gt;Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。&lt;/p&gt;
&lt;p&gt;本文将分享如何使用Charles，并且发放福利喔。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h1&gt;&lt;p&gt;Charles 主要的功能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;截取 Http 和 Https 网络封包。&lt;/li&gt;
&lt;li&gt;支持重发网络请求，方便后端调试。&lt;/li&gt;
&lt;li&gt;支持修改网络请求参数。&lt;/li&gt;
&lt;li&gt;支持网络请求的截获并动态修改。&lt;/li&gt;
&lt;li&gt;支持模拟慢速网络。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;安装Charles&quot;&gt;&lt;a href=&quot;#安装Charles&quot; class=&quot;headerlink&quot; title=&quot;安装Charles&quot;&gt;&lt;/a&gt;安装Charles&lt;/h1&gt;&lt;p&gt;1.&lt;a href=&quot;http://www.charlesproxy.com&quot;&gt;官网下载&lt;/a&gt; , 然后安装即可。&lt;/p&gt;
&lt;p&gt;2.&lt;a href=&quot;http://download.csdn.net/detail/dengw0716/9320153&quot;&gt;下载破解版软件&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;将Charles设置成系统代理&quot;&gt;&lt;a href=&quot;#将Charles设置成系统代理&quot; class=&quot;headerlink&quot; title=&quot;将Charles设置成系统代理&quot;&gt;&lt;/a&gt;将Charles设置成系统代理&lt;/h1&gt;&lt;p&gt;使用Charles的第一步就是要将其设置成系统的代理服务器。启动Charles，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:1.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;第一次Charles会请求你给它设置系统代理的权限，你可以输入登录密码授予Charles该权限，也可以选择忽略，然后在需要将Charles设置成系统代理时，选择菜单中的“Proxy”–&amp;gt;“Mac OS X Proxy”来将Charles设置成系统代理，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:2.png?imageView/2/w/400&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;此后，就可以看见源源不绝的网络请求出现在Charles的界面中。&lt;/p&gt;
&lt;p&gt;需要注意的是，Chrome 和 Firefox 浏览器默认并不使用系统的代理服务器设置，而 Charles 是通过将自己设置成代理服务器来完成封包截取的，所以在默认情况下无法截取 Chrome 和 Firefox 浏览器的网络通讯内容。如果你需要截取的话，在 Chrome 中设置成使用系统的代理服务器设置即可，或者直接将代理服务器设置成 127.0.0.1:8888也可达到相同效果。&lt;/p&gt;
&lt;h1 id=&quot;Charles主界面&quot;&gt;&lt;a href=&quot;#Charles主界面&quot; class=&quot;headerlink&quot; title=&quot;Charles主界面&quot;&gt;&lt;/a&gt;Charles主界面&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:3.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;图中，structure和sequence是两种视图模式，structure视图将网络请求按访问的域名分类，sequence视图将网络请求按访问的时间排序，Filter处可以设置过滤关键词，Request显示请求内容，Response显示响应内容。&lt;/p&gt;
&lt;h1 id=&quot;过滤网络请求&quot;&gt;&lt;a href=&quot;#过滤网络请求&quot; class=&quot;headerlink&quot; title=&quot;过滤网络请求&quot;&gt;&lt;/a&gt;过滤网络请求&lt;/h1&gt;&lt;p&gt;方法多种，以下列举几种常用的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法一：&lt;/strong&gt;在主界面的中部的 Filter 栏中填入需要过滤出来的关键字。例如我们的服务器的地址是：&lt;a href=&quot;http://www.baidu.com&quot;&gt;http://www.baidu.com&lt;/a&gt;, 那么只需要在 Filter 栏中填入 baidu 即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法二：&lt;/strong&gt;在 Charles 的菜单栏选择 “Proxy”–&amp;gt;“Recording Settings”，然后选择 Include 栏，选择添加一个项目，然后填入需要监控的协议，主机地址，端口号。这样就可以只截取目标网站的封包了。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:4.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;通常情况下，我们使用方法一做一些临时性的封包过滤，使用方法二做一些经常性的封包过滤。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法三：&lt;/strong&gt;在想过滤的网络请求上右击，选择 “Focus”，之后在 Filter 一栏勾选上 Focussed 一项，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:5.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种方式可以临时性的，快速地过滤出一些没有通过关键字的一类网络请求。&lt;/p&gt;
&lt;h1 id=&quot;截取移动设备上的网络封包&quot;&gt;&lt;a href=&quot;#截取移动设备上的网络封包&quot; class=&quot;headerlink&quot; title=&quot;截取移动设备上的网络封包&quot;&gt;&lt;/a&gt;截取移动设备上的网络封包&lt;/h1&gt;&lt;p&gt;下面我们以iPhone为例，讲解步骤。&lt;/p&gt;
&lt;h2 id=&quot;Charles上的设置&quot;&gt;&lt;a href=&quot;#Charles上的设置&quot; class=&quot;headerlink&quot; title=&quot;Charles上的设置&quot;&gt;&lt;/a&gt;Charles上的设置&lt;/h2&gt;&lt;p&gt;要截取 iPhone 上的网络请求，我们首先需要将 Charles 的代理功能打开。在 Charles 的菜单栏上选择 “Proxy”–&amp;gt;“Proxy Settings”，填入代理端口 8888，并且勾上 “Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:6.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;iPhone上的设置&quot;&gt;&lt;a href=&quot;#iPhone上的设置&quot; class=&quot;headerlink&quot; title=&quot;iPhone上的设置&quot;&gt;&lt;/a&gt;iPhone上的设置&lt;/h2&gt;&lt;p&gt;首先我们需要获取 Charles 运行所在电脑的 IP 地址，Charles 的顶部菜单的 “Help”–&amp;gt;“Local IP Address”，即可在弹出的对话框中看到 IP 地址，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:7.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 iPhone 的 “ 设置 ”–&amp;gt;“ 无线局域网 ” 中，可以看到当前连接的 wifi 名，通过点击右边的详情键，可以看到当前连接上的 wifi 的详细信息，包括 IP 地址，子网掩码等信息。在其最底部有“HTTP 代理”一项，我们将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，以及端口号 8888，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:8.png?imageView/2/w/300&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设置好之后，我们打开 iPhone 上的任意需要网络通讯的程序，就可以看到 Charles 弹出 iPhone 请求连接的确认菜单，点击 “Allow” 即可完成设置。&lt;/p&gt;
&lt;h1 id=&quot;截取HTTPS通讯信息&quot;&gt;&lt;a href=&quot;#截取HTTPS通讯信息&quot; class=&quot;headerlink&quot; title=&quot;截取HTTPS通讯信息&quot;&gt;&lt;/a&gt;截取HTTPS通讯信息&lt;/h1&gt;&lt;h2 id=&quot;安装证书&quot;&gt;&lt;a href=&quot;#安装证书&quot; class=&quot;headerlink&quot; title=&quot;安装证书&quot;&gt;&lt;/a&gt;安装证书&lt;/h2&gt;&lt;p&gt;如果你需要截取分析 Https 协议相关的内容。那么需要安装 Charles 的 CA 证书。具体步骤如下。&lt;/p&gt;
&lt;p&gt;首先我们需要在 Mac 电脑上安装证书。点击 Charles 的顶部菜单，选择 “Help” –&amp;gt; “SSL Proxying” –&amp;gt; “Install Charles Root Certificate”，然后输入系统的帐号密码，即可在 KeyChain 看到添加好的证书。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:9.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，即使是安装完证书之后，Charles 默认也并不截取 Https 网络通讯的信息，如果你想对截取某个网站上的所有 HTTPS 网络请求，可以在该请求上右击，选择 SSL proxy，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:10.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这样，对于该 Host 的所有 SSL 请求可以被截取到了。&lt;/p&gt;
&lt;p&gt;##截取移动设备中的HTTPS通讯信息&lt;br&gt;如果我们需要在 iOS 或 Android 机器上截取 Https 协议的通讯内容，还需要在手机上安装相应的证书。点击 Charles 的顶部菜单，选择 “Help” –&amp;gt; “SSL Proxying” –&amp;gt; “Install Charles Root Certificate on a Mobile Device or Remote Browser”，然后就可以看到 Charles 弹出的简单的安装教程。&lt;/p&gt;
&lt;p&gt;按照我们之前说的教程，在设备上设置好 Charles 为代理后，在手机浏览器中访问地址：&lt;a href=&quot;http://charlesproxy.com/getssl&quot;&gt;http://charlesproxy.com/getssl&lt;/a&gt; ，即可打开证书安装的界面，安装完证书后，就可以截取手机上的 Https 通讯内容了。不过同样需要注意，默认情况下 Charles 并不做截取，你还需要在要截取的网络请求上右击，选择 SSL proxy 菜单项。&lt;/p&gt;
&lt;p&gt;#模拟慢速网络&lt;br&gt;在做移动开发的时候，我们常常需要模拟慢速网络或者高延迟的网络，以测试在移动网络下，应用的表现是否正常。Charles 对此需求提供了很好的支持。&lt;/p&gt;
&lt;p&gt;在 Charles 的菜单上，选择 “Proxy”–&amp;gt;“Throttle Setting” 项，在之后弹出的对话框中，我们可以勾选上 “Enable Throttling”，并且可以设置 Throttle Preset 的类型。如下图：&lt;br&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:11.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;br&gt;如果我们只想模拟指定网站的慢速网络，可以再勾选上图中的 “Only for selected hosts” 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。&lt;/p&gt;
&lt;p&gt;#修改网络请求内容&lt;br&gt;有些时候为了调试服务器的接口，我们需要反复尝试不同参数的网络请求。Charles 可以方便地提供网络请求的修改和重发功能。只需要在以往的网络请求上点击右键，选择 “Edit”，即可创建一个可编辑的网络请求。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:12.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可以修改该请求的任何信息，包括 URL 地址、端口、参数等，之后点击 “Execute” 即可发送该修改后的网络请求（如下图）。Charles 支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:13.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;给服务器做压力测试&quot;&gt;&lt;a href=&quot;#给服务器做压力测试&quot; class=&quot;headerlink&quot; title=&quot;给服务器做压力测试&quot;&gt;&lt;/a&gt;给服务器做压力测试&lt;/h1&gt;&lt;p&gt;我们可以使用 Charles 的 Repeat 功能来简单地测试服务器的并发处理能力，方法如下。&lt;/p&gt;
&lt;p&gt;我们在想打压的网络请求上（POST 或 GET 请求均可）右击，然后选择“Repeat Advanced”菜单项，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:14.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;接着我们就可以在弹出的对话框中，选择打压的并发线程数以及打压次数，确定之后，即可开始打压。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:15.png?imageView/2/w/400&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;弱弱的说一句，一些写得很弱的投票网站，也可以用这个办法来快速投票。当然，我也拿 Charles 的 Repeat 功能给一些诈骗的钓鱼网站喂了不少垃圾数据，上次不小心还把一个钓鱼网站的数据库打挂了，嗯，请叫我雷锋。&lt;/p&gt;
&lt;h1 id=&quot;修改服务器返回内容&quot;&gt;&lt;a href=&quot;#修改服务器返回内容&quot; class=&quot;headerlink&quot; title=&quot;修改服务器返回内容&quot;&gt;&lt;/a&gt;修改服务器返回内容&lt;/h1&gt;&lt;p&gt;有些时候我们想让服务器返回一些指定的内容，方便我们调试一些特殊情况。例如列表页面为空的情况，数据异常的情况，部分耗时的网络请求超时的情况等。如果没有 Charles，要服务器配合构造相应的数据显得会比较麻烦。这个时候，使用 Charles 相关的功能就可以满足我们的需求。&lt;/p&gt;
&lt;p&gt;根据具体的需求，Charles 提供了 Map 功能、 Rewrite 功能以及 Breakpoints 功能，都可以达到修改服务器返回内容的目的。这三者在功能上的差异是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Map 功能适合长期地将某一些请求重定向到另一个网络地址或本地文件。&lt;/li&gt;
&lt;li&gt;Rewrite 功能适合对网络请求进行一些正则替换。&lt;/li&gt;
&lt;li&gt;Breakpoints 功能适合做一些临时性的修改。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Map-功能&quot;&gt;&lt;a href=&quot;#Map-功能&quot; class=&quot;headerlink&quot; title=&quot;Map 功能&quot;&gt;&lt;/a&gt;Map 功能&lt;/h2&gt;&lt;p&gt;Charles 的 Map 功能分 Map Remote 和 Map Local 两种，顾名思义，Map Remote 是将指定的网络请求重定向到另一个网址请求地址，Map Local 是将指定的网络请求重定向到本地文件。&lt;/p&gt;
&lt;p&gt;在 Charles 的菜单中，选择 “Tools”–&amp;gt;“Map Remote” 或 “Map Local” 即可进入到相应功能的设置页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:16.png?imageView/2/w/460&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于 Map Remote 功能，我们需要分别填写网络重定向的源地址和目的地址，对于不需要限制的条件，可以留空。下图是一个示例，我将www.sohu.com的请求重定向到了 www.baidu.com&lt;br&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:17.png?imageView/2/w/460&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于 Map Local 功能，我们需要填写的重定向的源地址和本地的目标文件。对于有一些复杂的网络请求结果，我们可以先使用 Charles 提供的 “Save Response…” 功能，将请求结果保存到本地（如下图），然后稍加修改，成为我们的目标映射文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:20:charles-using:18.png?imageView/2/w/600&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Rewrite-功能&quot;&gt;&lt;a href=&quot;#Rewrite-功能&quot; class=&quot;headerlink&quot; title=&quot;Rewrite 功能&quot;&gt;&lt;/a&gt;Rewrite 功能&lt;/h2&gt;&lt;p&gt;Rewrite 功能功能适合对某一类网络请求进行一些正则替换，以达到修改结果的目的。&lt;/p&gt;
&lt;h2 id=&quot;Breakpoints-功能&quot;&gt;&lt;a href=&quot;#Breakpoints-功能&quot; class=&quot;headerlink&quot; title=&quot;Breakpoints 功能&quot;&gt;&lt;/a&gt;Breakpoints 功能&lt;/h2&gt;&lt;p&gt;上面提供的 Rewrite 功能最适合做批量和长期的替换，但是很多时候，我们只是想临时修改一次网络请求结果，这个时候，使用 Rewrite 功能虽然也可以达到目的，但是过于麻烦，对于临时性的修改，我们最好使用 Breakpoints 功能。&lt;/p&gt;
&lt;p&gt;Breakpoints 功能类似我们在 Xcode 中设置的断点一样，当指定的网络请求发生时，Charles 会截获该请求，这个时候，我们可以在 Charles 中临时修改网络请求的返回内容。&lt;/p&gt;
&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;通过 Charles 软件，我们可以很方便地在日常开发中，截取和调试网络请求内容，分析封包协议以及模拟慢速网络。Charles 可以极大的方便我们对于带有网络请求的 App 的开发和调试。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：Charles是在 Mac 下常用的网络封包截取工具，在做 移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。&lt;/p&gt;
&lt;p&gt;Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。&lt;/p&gt;
&lt;p&gt;除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。&lt;/p&gt;
&lt;p&gt;Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。&lt;/p&gt;
&lt;p&gt;本文将分享如何使用Charles，并且发放福利喔。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://charsdavy.github.io/categories/tool/"/>
    
    
      <category term="开发助手" scheme="http://charsdavy.github.io/tags/assistant/"/>
    
  </entry>
  
  <entry>
    <title>VFL 语言简介</title>
    <link href="http://charsdavy.github.io/2016/04/17/VFL-introduction/"/>
    <id>http://charsdavy.github.io/2016/04/17/VFL-introduction/</id>
    <published>2016-04-17T13:49:29.000Z</published>
    <updated>2016-06-04T09:50:07.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：VFL（Visual Format Language），“可视化格式语言”。VFL是苹果公司为了简化autolayout的编码而推出的抽象语言。本文分享VFL的基本使用方法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;什么是VFL语言&quot;&gt;&lt;a href=&quot;#什么是VFL语言&quot; class=&quot;headerlink&quot; title=&quot;什么是VFL语言&quot;&gt;&lt;/a&gt;什么是VFL语言&lt;/h1&gt;&lt;p&gt;VFL（Visual Format Language），“可视化格式语言”。&lt;/p&gt;
&lt;p&gt;VFL 是苹果公司为了简化autolayout的编码而推出的抽象语言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:17:VFL-introduction:1.png?imageView/2/w/460&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;语法说明&quot;&gt;&lt;a href=&quot;#语法说明&quot; class=&quot;headerlink&quot; title=&quot;语法说明&quot;&gt;&lt;/a&gt;语法说明&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;H:[cancelButton(72)]-12-[acceptButton(50)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cancelButton宽72，acceptButton宽50，它们之间间距12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;H:[wideView(&amp;gt;=60@700)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wideView宽度大于等于60point，该约束条件优先级为700（优先级最大值为1000，优先级越高的约束条件越先被满足）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;V:[redBox][yellowBox(==redBox)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;垂直方向上，先有一个redBox，其下方紧接一个高度等于redBox高度的yellowBox&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;H:|-10-[Find]-[FindNext]-[FindField(&amp;gt;=20)]-|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;水平方向上，Find距离父view左边缘间隔10，之后是FindNext距离Find间隔默认宽度；再之后是宽度不小于20的FindField，它和FindNext以及父view右边边缘的间距都是默认宽度。（竖线“|”表示superview的边缘）。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;使用方法&quot;&gt;&lt;a href=&quot;#使用方法&quot; class=&quot;headerlink&quot; title=&quot;使用方法&quot;&gt;&lt;/a&gt;使用方法&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;使用VFL来创建约束数组&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+(NSArray *)constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)opts metrics:(NSDictionary *)metrics views:(NSDictionary *)views;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;format：VFL语句&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;opts：约束类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;metrics：VFL语句中用到的具体数值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;views：VFL语句中用到的控件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;创建一个字典（内部包含VFL语句中用到的控件）的快捷宏定义&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDictionaryOfVariableBindings(...)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;实例展示&quot;&gt;&lt;a href=&quot;#实例展示&quot; class=&quot;headerlink&quot; title=&quot;实例展示&quot;&gt;&lt;/a&gt;实例展示&lt;/h1&gt;&lt;p&gt;效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:17:VFL-introduction:2.png?imageView/2/w/340&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:17:VFL-introduction:3.png?imageView/2/w/340&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;实现代码&quot;&gt;&lt;a href=&quot;#实现代码&quot; class=&quot;headerlink&quot; title=&quot;实现代码&quot;&gt;&lt;/a&gt;实现代码&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(void)horizontalLayout&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //1.添加两个控件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIView *blueView = [[UIView alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blueView.backgroundColor = [UIColor blueColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blueView.translatesAutoresizingMaskIntoConstraints = NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:blueView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIView *redView = [[UIView alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    redView.backgroundColor = [UIColor redColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    redView.translatesAutoresizingMaskIntoConstraints = NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:redView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //2.添加约束&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //2.1水平方向的约束&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString *hVFL = @&amp;quot;H:|-30-[blueView]-30-[redView(==blueView)]-30-|&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSArray *hCons = [NSLayoutConstraint constraintsWithVisualFormat:hVFL options:NSLayoutFormatAlignAllBottom | NSLayoutFormatAlignAllTop metrics:nil views:@&amp;#123;@&amp;quot;blueView&amp;quot;:blueView, @&amp;quot;redView&amp;quot;:redView&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addConstraints:hCons];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //2.2垂直方向的约束&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString *vVFL = @&amp;quot;V:[blueView(50)]-30-|&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSArray *vCons = [NSLayoutConstraint constraintsWithVisualFormat:vVFL options:0 metrics:nil views:@&amp;#123;@&amp;quot;blueView&amp;quot;:blueView&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addConstraints:vCons];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)verticalLayout&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //1.添加两个控件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIView *blueView = [[UIView alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blueView.backgroundColor = [UIColor blueColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    blueView.translatesAutoresizingMaskIntoConstraints = NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:blueView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIView *redView = [[UIView alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    redView.backgroundColor = [UIColor redColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    redView.translatesAutoresizingMaskIntoConstraints = NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:redView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //2.添加约束&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //2.1水平方向的约束&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString *hVFL = @&amp;quot;H:|-30-[blueView]-30-|&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSArray *hCons = [NSLayoutConstraint constraintsWithVisualFormat:hVFL options:0 metrics:nil views:@&amp;#123;@&amp;quot;blueView&amp;quot;:blueView&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addConstraints:hCons];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //2.2垂直方向的约束&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString *vVFL = @&amp;quot;V:|-30-[blueView(50)]-30-[redView(==blueView)]&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSArray *vCons = [NSLayoutConstraint constraintsWithVisualFormat:vVFL options:NSLayoutFormatAlignAllRight metrics:nil views:@&amp;#123;@&amp;quot;blueView&amp;quot;:blueView, @&amp;quot;redView&amp;quot;:redView&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addConstraints:vCons];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLayoutConstraint *redLeftCon = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:blueView attribute:NSLayoutAttributeCenterX multiplier:1.0 constant:0];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addConstraint:redLeftCon];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h1&gt;&lt;p&gt;最后对格式的字符串作一个总结介绍：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;表达式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;水平方向&lt;/td&gt;
&lt;td&gt;H:&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;垂直方向&lt;/td&gt;
&lt;td&gt;V:&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Views&lt;/td&gt;
&lt;td&gt;[view]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SuperView&lt;/td&gt;
&lt;td&gt;竖线符号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;关系&lt;/td&gt;
&lt;td&gt;&amp;gt;=,==,&amp;lt;=&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;空间，间隙&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;优先级&lt;/td&gt;
&lt;td&gt;@value&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：VFL（Visual Format Language），“可视化格式语言”。VFL是苹果公司为了简化autolayout的编码而推出的抽象语言。本文分享VFL的基本使用方法。&lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="iOS" scheme="http://charsdavy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods安装与使用</title>
    <link href="http://charsdavy.github.io/2016/04/16/cocoapods-using/"/>
    <id>http://charsdavy.github.io/2016/04/16/cocoapods-using/</id>
    <published>2016-04-16T13:38:49.000Z</published>
    <updated>2016-06-04T09:41:58.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：CocoaPods 是iOS最常用的第三方库依赖管理工具，且绝大多数优秀的开源框架都支持CocoaPods。&lt;/p&gt;
&lt;p&gt;CocoaPods项目的源码 在 Github 上管理。该项目开始于 2011 年 8 月 12 日，开发 iOS 项目不可避免地要使用第三方开源库，CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间。&lt;/p&gt;
&lt;p&gt;文章分享在自己的工程中如何使用CocoaPods 工具管理第三方库。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;CocoaPods 是将所有的依赖库都放到另一个名为 Pods 项目中，然后让主项目依赖 Pods 项目，这样，源码管理工作都从主项目移到了 Pods 项目中。&lt;/p&gt;
&lt;p&gt;1)Pods 项目最终会编译成一个名为 libPods.a 的文件，主项目只需要依赖这个 .a 文件即可。&lt;/p&gt;
&lt;p&gt;2)对于资源文件，CocoaPods 提供了一个名为 Pods-resources.sh 的 bash 脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。&lt;/p&gt;
&lt;p&gt;3)CocoaPods 通过一个名为 Pods.xcconfig 的文件来在编译时设置所有的依赖和参数。&lt;/p&gt;
&lt;h1 id=&quot;CocoaPods-的安装&quot;&gt;&lt;a href=&quot;#CocoaPods-的安装&quot; class=&quot;headerlink&quot; title=&quot;CocoaPods 的安装&quot;&gt;&lt;/a&gt;CocoaPods 的安装&lt;/h1&gt;&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;安装方式异常简单 , Mac 下都自带 ruby，使用 ruby 的 gem 命令即可下载安装：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo gem install cocoapods&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ pod setup&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你的 gem 太老，可能也会有问题，可以尝试用如下命令升级 gem:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo gem update --system&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而这样执行命令，却会出错，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:16:cocoapods-using:1.png?imageView/2/w/460&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这是因为ruby 的软件源 &lt;a href=&quot;https://rubygems.org&quot;&gt;https://rubygems.org&lt;/a&gt; 因为使用的是亚马逊的云服务，所以被墙了，需要更新一下 ruby 的源，使用如下代码将官方的 ruby 源替换成国内淘宝的源：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ gem sources --remove https:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//rubygems.org/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ gem sources -a https:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//ruby.taobao.org/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ gem sources -l&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后再执行之前的命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo gem install cocoapods&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ pod setup&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有一点需要注意，pod setup在执行时，会输出Setting up CocoaPods master repo，但是会等待比较久的时间。这一步其实是 Cocoapods 在将它的信息下载到 ~/.cocoapods目录下，如果你等太久，可以试着 cd 到那个目录，用du -sh *来查看下载进度。你也可以使用 cocoapods 的镜像来提高下载速度。&lt;/p&gt;
&lt;h2 id=&quot;使用-CocoaPods-的镜像索引&quot;&gt;&lt;a href=&quot;#使用-CocoaPods-的镜像索引&quot; class=&quot;headerlink&quot; title=&quot;使用 CocoaPods 的镜像索引&quot;&gt;&lt;/a&gt;使用 CocoaPods 的镜像索引&lt;/h2&gt;&lt;p&gt;所有的项目的 Podspec 文件都托管在&lt;a href=&quot;https://github.com/CocoaPods/Specs&quot;&gt;https://github.com/CocoaPods/Specs&lt;/a&gt; 。第一次执行pod setup时，CocoaPods 会将这些podspec索引文件更新到本地的 ~/.cocoapods/&lt;br&gt;目录下，这个索引文件比较大，有 80M 左右。所以第一次更新时非常慢。&lt;/p&gt;
&lt;p&gt;一个叫 akinliu 的朋友在 gitcafe 和 oschina 上建立了 CocoaPods 索引库的镜像，因为 gitcafe 和 oschina 都是国内的服务器，所以在执行索引更新操作时，会快很多。如下操作可以将 CocoaPods 设置成使用 gitcafe 镜像：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pod repo remove master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ pod repo add master https:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//gitcafe.com/akuandev/Specs.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ pod repo update&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将以上代码中的 &lt;a href=&quot;https://gitcafe.com/akuandev/Specs.git&quot;&gt;https://gitcafe.com/akuandev/Specs.git&lt;/a&gt; 替换成 &lt;a href=&quot;http://git.oschina.net/akuandev/Specs.git&quot;&gt;http://git.oschina.net/akuandev/Specs.git&lt;/a&gt; 即可使用 oschina 上的镜像。&lt;/p&gt;
&lt;h2 id=&quot;使用-CocoaPods&quot;&gt;&lt;a href=&quot;#使用-CocoaPods&quot; class=&quot;headerlink&quot; title=&quot;使用 CocoaPods&quot;&gt;&lt;/a&gt;使用 CocoaPods&lt;/h2&gt;&lt;p&gt;使用时需要新建一个名为 Podfile 的文件，以如下格式，将依赖的库名字依次列在文件中即可&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;platform :ios&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;JSONKit&amp;apos;,  &amp;apos;~&amp;gt; 1.4&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;Reachability&amp;apos;, &amp;apos;~&amp;gt; 3.0.0&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后将编辑好的 Podfile 文件放到项目根目录中，执行如下命令即可：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ cd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;your project home&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ pod install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在，所有的第三方库都已经下载完成并且设置好了编译参数和依赖，需要记住如下两点：&lt;/p&gt;
&lt;p&gt;1)使用 CocoaPods 生成的 &lt;em&gt;.xcworkspace &lt;/em&gt;文件来打开工程，而不是以前的&lt;em&gt; &lt;/em&gt;.xcodeproj 文件。&lt;br&gt;2)每次更改了 Podfile 文件，需要重新执行一次pod update命令。&lt;/p&gt;
&lt;h2 id=&quot;查找第三方库&quot;&gt;&lt;a href=&quot;#查找第三方库&quot; class=&quot;headerlink&quot; title=&quot;查找第三方库&quot;&gt;&lt;/a&gt;查找第三方库&lt;/h2&gt;&lt;p&gt;如果不知道 cocoaPods 管理的库中，是否有你想要的库，那么可以通过 pod search 命令进行查找，以下是用 pod search json 查找到的所有可用的库：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;span class=&amp;quot;nv&amp;quot;&amp;gt;$ pod search json&amp;lt;/span&amp;gt;&amp;lt;br&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; AFJSONPRequestOperation (1.0.0)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AFNetworking Extension for the JSONP format.   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;AFJSONPRequestOperation&amp;apos;,&amp;apos;~&amp;gt; 1.0.0&amp;apos;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- Homepage: https:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//github.com/acerbetti/AFJSONPRequestOperation   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- Source:   https:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//github.com/acerbetti/AFJSONPRequestOperation.git   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- Versions: 1.0.0 [master repo]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; AFJSONRPCClient (2.1.1)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A JSON-RPC client build on AFNetworking.   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;AFJSONRPCClient&amp;apos;,&amp;apos;~&amp;gt; 2.1.1&amp;apos;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- Homepage: https:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//github.com/AFNetworking/AFJSONRPCClient  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- Source:   https:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//github.com/AFNetworking/AFJSONRPCClient.git &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- Versions: 2.1.1, 2.1.0, 2.0.0, 1.0.0, 0.4.0, 0.3.1, 0.3.0 [master repo]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-&amp;gt; ARSafeJSON (0.0.7)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ARSafeJSON is a small library that will strip all occurences of NSNull from a JSON of any depth.   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;ARSafeJSON&amp;apos;, &amp;apos;~&amp;gt; 0.0.7&amp;apos;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- Homepage: https:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//bitbucket.org/antoine_r/arsafejson   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- Source:   https:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//bitbucket.org/antoine_r/arsafejson.git &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- Versions: 0.0.7, 0.0.3 [master repo]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//以下省去若干行&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;关于-Podfile-lock&quot;&gt;&lt;a href=&quot;#关于-Podfile-lock&quot; class=&quot;headerlink&quot; title=&quot;关于 Podfile.lock&quot;&gt;&lt;/a&gt;关于 Podfile.lock&lt;/h1&gt;&lt;p&gt;当执行pod install之后，除了 Podfile 外，CocoaPods 还会生成一个名为Podfile.lock的文件，Podfile.lock 应该加入到版本控制里面，不应该把这个文件加入到.gitignore中。因为Podfile.lock会锁定当前各依赖库的版本，之后如果多次执行pod install不会更改版本，要pod update才会改Podfile.lock了。这样多人协作的时候，可以防止第三方库升级时造成大家各自的第三方库版本不一致。&lt;/p&gt;
&lt;p&gt;CocoaPods 的这篇 官方文档 也在What is a Podfile.lock一节中介绍了Podfile.lock的作用，并且指出：&lt;br&gt;　　“This file should always be kept under version control.”&lt;br&gt;为自己的项目创建 podspec 文件我们可以为自己的开源项目创建podspec文件，首先通过如下命令初始化一个podspec文件：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pod spec create your_pod_spec_name&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该命令执行之后，CocoaPods 会生成一个名为your_pod_spec_name.podspec的文件，然后我们修改其中的相关内容即可。&lt;/p&gt;
&lt;p&gt;具体步骤可以参看：&lt;/p&gt;
&lt;p&gt;《如何编写一个 CocoaPods 的 spec 文件》&lt;/p&gt;
&lt;p&gt;《Cocoapods 入门》。&lt;/p&gt;
&lt;h1 id=&quot;使用私有的-pods&quot;&gt;&lt;a href=&quot;#使用私有的-pods&quot; class=&quot;headerlink&quot; title=&quot;使用私有的 pods&quot;&gt;&lt;/a&gt;使用私有的 pods&lt;/h1&gt;&lt;p&gt;我们可以直接指定某一个依赖的podspec，这样就可以使用团队内部的私有库。该方案有利于使团队内部的公共项目支持 CocoaPods。如下是一个示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pod&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;apos;MyCommon&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;, :podspec =&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;apos;https://yuantiku.com/common/myCommon.podspec&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;不更新-podspec&quot;&gt;&lt;a href=&quot;#不更新-podspec&quot; class=&quot;headerlink&quot; title=&quot;不更新 podspec&quot;&gt;&lt;/a&gt;不更新 podspec&lt;/h2&gt;&lt;p&gt;CocoaPods 在执行&lt;code&gt;pod install&lt;/code&gt;和&lt;code&gt;pod update&lt;/code&gt;时，会默认先更新一次podspec索引。使用–no-repo-update参数可以禁止其做索引更新操作。如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ pod install --no-repo-update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ pod update --no-repo-update&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;生成第三方库的帮助文档&quot;&gt;&lt;a href=&quot;#生成第三方库的帮助文档&quot; class=&quot;headerlink&quot; title=&quot;生成第三方库的帮助文档&quot;&gt;&lt;/a&gt;生成第三方库的帮助文档&lt;/h1&gt;&lt;p&gt;如果想利用 CococaPods 生成第三方库的帮助文档，并集成到 Xcode 中，那么用 brew 安装 appledoc 即可：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ brew install appledoc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;关于 appledoc，可以参看 《使用 Objective-C 的文档生成工具:appledoc》 中有专门介绍。它最大的优点是可以将帮助文档集成到 Xcode 中，这样你在敲代码的时候，按住 option 键单击类名或方法名，就可以显示出相应的帮助文档。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：CocoaPods 是iOS最常用的第三方库依赖管理工具，且绝大多数优秀的开源框架都支持CocoaPods。&lt;/p&gt;
&lt;p&gt;CocoaPods项目的源码 在 Github 上管理。该项目开始于 2011 年 8 月 12 日，开发 iOS 项目不可避免地要使用第三方开源库，CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间。&lt;/p&gt;
&lt;p&gt;文章分享在自己的工程中如何使用CocoaPods 工具管理第三方库。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://charsdavy.github.io/categories/tool/"/>
    
    
      <category term="开发助手" scheme="http://charsdavy.github.io/tags/assistant/"/>
    
  </entry>
  
  <entry>
    <title>认识与入门 - Markdown</title>
    <link href="http://charsdavy.github.io/2016/04/15/markdown-introduction/"/>
    <id>http://charsdavy.github.io/2016/04/15/markdown-introduction/</id>
    <published>2016-04-15T13:09:44.000Z</published>
    <updated>2016-06-04T05:23:49.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。文章介绍markdown基本使用方法，放心，看过之后你肯定会爱上它，无法自拔。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;一、认识-Markdown&quot;&gt;&lt;a href=&quot;#一、认识-Markdown&quot; class=&quot;headerlink&quot; title=&quot;一、认识 Markdown&quot;&gt;&lt;/a&gt;一、认识 Markdown&lt;/h1&gt;&lt;p&gt;在刚才的导语里提到，Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。目前来看，支持 Markdown 语法的编辑器有很多，包括很多网站（例如简书）也支持了 Markdown 的文字录入。Markdown 从写作到完成，导出格式随心所欲，你可以导出 HTML 格式的文件用来网站发布，也可以十分方便的导出 PDF 格式，这种格式写出的简历更能得到 HR 的好感。甚至可以利用 CloudApp 这种云服务工具直接上传至网页用来分享你的文章，全球最大的轻博客平台 Tumblr，也支持使用 Mou 这类 Markdown 工具进行编辑并直接上传。&lt;/p&gt;
&lt;h2 id=&quot;Markdown-官方文档&quot;&gt;&lt;a href=&quot;#Markdown-官方文档&quot; class=&quot;headerlink&quot; title=&quot;Markdown 官方文档&quot;&gt;&lt;/a&gt;Markdown 官方文档&lt;/h2&gt;&lt;p&gt;这里可以看到官方的 Markdown 语法规则文档，当然，后文我也会用自己的方式，阐述这些语法在实际使用中的用法。&lt;/p&gt;
&lt;p&gt;创始人 John Gruber 的 Markdown 语法说明&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://daringfireball.net/projects/markdown/syntax&quot;&gt;http://daringfireball.net/projects/markdown/syntax&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Markdown 中文版语法说明&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wowubuntu.com/markdown/#list&quot;&gt;http://wowubuntu.com/markdown/#list&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用-Markdown-的优点&quot;&gt;&lt;a href=&quot;#使用-Markdown-的优点&quot; class=&quot;headerlink&quot; title=&quot;使用 Markdown 的优点&quot;&gt;&lt;/a&gt;使用 Markdown 的优点&lt;/h2&gt;&lt;p&gt;专注你的文字内容而不是排版样式。&lt;/p&gt;
&lt;p&gt;轻松的导出 HTML、PDF 和本身的 .md 文件。&lt;/p&gt;
&lt;p&gt;纯文本内容，兼容所有的文本编辑器与字处理软件。&lt;/p&gt;
&lt;p&gt;可读，直观。适合所有人的写作语言。&lt;/p&gt;
&lt;h2 id=&quot;我该用什么工具&quot;&gt;&lt;a href=&quot;#我该用什么工具&quot; class=&quot;headerlink&quot; title=&quot;我该用什么工具&quot;&gt;&lt;/a&gt;我该用什么工具&lt;/h2&gt;&lt;h3 id=&quot;Mac-平台&quot;&gt;&lt;a href=&quot;#Mac-平台&quot; class=&quot;headerlink&quot; title=&quot;Mac 平台&quot;&gt;&lt;/a&gt;Mac 平台&lt;/h3&gt;&lt;p&gt;在 Mac OS X 上，我强烈建议你用 Mou 这款免费且十分好用的 Markdown 编辑器，它支持实时预览，既左边是你编辑 Markdown 语言，右边会实时的生成预览效果，笔者文章就是 Mou 这款应用写出来的。&lt;/p&gt;
&lt;p&gt;其次还有很多同类选择。如果你是个编辑作者，我强烈建议你购买 Ulysses Ⅲ，这款应用入围了苹果去年 Mac App Store 的 The Best of 2013，相比 Mou 它支持更多的写作格式、多文档的支持。Mou、iA Writer 这些应用都是基于单文档的管理方式，而 Ulysses Ⅲ 支持 Folder、Filter 的管理，一个 Folder 里面可以创建多个 Sheet，Sheet 之间还可以进行 Combine 处理。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Windows、iOS、Web-平台&quot;&gt;&lt;a href=&quot;#Windows、iOS、Web-平台&quot; class=&quot;headerlink&quot; title=&quot;Windows、iOS、Web 平台&quot;&gt;&lt;/a&gt;Windows、iOS、Web 平台&lt;/h3&gt;&lt;p&gt;笔者并未使用过 Windows 下的 Markdown 工具，但经朋友介绍，有两款还算不错，一款叫 MarkdownPad ，另一款叫 MarkPad。&lt;/p&gt;
&lt;p&gt;iOS 端已有相当多的 app 支持 Markdown 语法编辑，例如 Drafts、Day One、iA Writer 等。&lt;/p&gt;
&lt;p&gt;Web 端上，笔者强烈推荐 简书 这款产品，上面有无数热爱文字的人在不停的创造、分享。在 Web 端使用 Markdown 没有比简书更舒服的地方了，它同样支持左右两栏的实时预览，字体优雅、简洁。&lt;/p&gt;
&lt;p&gt;同样是 Web 端，Draftin 这款在线 MD 编辑器也近乎完美。&lt;/p&gt;
&lt;h1 id=&quot;二、Markdown-语法的简要规则&quot;&gt;&lt;a href=&quot;#二、Markdown-语法的简要规则&quot; class=&quot;headerlink&quot; title=&quot;二、Markdown 语法的简要规则&quot;&gt;&lt;/a&gt;二、Markdown 语法的简要规则&lt;/h1&gt;&lt;h2 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-3f6606d01e29d996.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;标题.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。&lt;/p&gt;
&lt;h1 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot; title=&quot;一级标题&quot;&gt;&lt;/a&gt;一级标题&lt;/h1&gt;&lt;h2 id=&quot;二级标题&quot;&gt;&lt;a href=&quot;#二级标题&quot; class=&quot;headerlink&quot; title=&quot;二级标题&quot;&gt;&lt;/a&gt;二级标题&lt;/h2&gt;&lt;h3 id=&quot;三级标题&quot;&gt;&lt;a href=&quot;#三级标题&quot; class=&quot;headerlink&quot; title=&quot;三级标题&quot;&gt;&lt;/a&gt;三级标题&lt;/h3&gt;&lt;p&gt;以此类推，总共六级标题，建议在#号后加一个空格，这是最标准的 Markdown 语法。&lt;/p&gt;
&lt;h2 id=&quot;列表&quot;&gt;&lt;a href=&quot;#列表&quot; class=&quot;headerlink&quot; title=&quot;列表&quot;&gt;&lt;/a&gt;列表&lt;/h2&gt;&lt;p&gt;熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加 1. 2. 3. 符号要和文字之间加上一个字符的空格。&lt;/p&gt;
&lt;h2 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;p&gt;如果你需要引用一小段别处的句子，那么就要用引用的格式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如这样&lt;br&gt;只需要在文本前加入 &amp;gt; 这种尖括号（大于号）即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-89dff7c1bf5167de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;引用.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;图片与链接&quot;&gt;&lt;a href=&quot;#图片与链接&quot; class=&quot;headerlink&quot; title=&quot;图片与链接&quot;&gt;&lt;/a&gt;图片与链接&lt;/h2&gt;&lt;p&gt;插入链接与插入图片的语法很像，区别在一个 !号&lt;br&gt;插入图片的地址需要图床，这里推荐 CloudApp 的服务，生成URL地址即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-aa3bd9ef3b8cfb9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图片与链接.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;粗体与斜体&quot;&gt;&lt;a href=&quot;#粗体与斜体&quot; class=&quot;headerlink&quot; title=&quot;粗体与斜体&quot;&gt;&lt;/a&gt;粗体与斜体&lt;/h2&gt;&lt;p&gt;Markdown 的粗体和斜体也非常简单，用两个 &lt;em&gt; 包含一段文本就是粗体的语法，用一个 &lt;/em&gt; 包含一段文本就是斜体的语法。&lt;/p&gt;
&lt;p&gt;例如：&lt;strong&gt;这里是粗体&lt;/strong&gt; &lt;em&gt;这里是斜体&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;表格&quot;&gt;&lt;a href=&quot;#表格&quot; class=&quot;headerlink&quot; title=&quot;表格&quot;&gt;&lt;/a&gt;表格&lt;/h2&gt;&lt;p&gt;表格是我觉得 Markdown 比较累人的地方，例子如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-70d3dcdde3f27fde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;表格.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码框&quot;&gt;&lt;a href=&quot;#代码框&quot; class=&quot;headerlink&quot; title=&quot;代码框&quot;&gt;&lt;/a&gt;代码框&lt;/h2&gt;&lt;p&gt;如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown 下实现也非常简单，只需要用两个 连续三个顿点符号 把中间的代码包裹起来，如 ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-2a96aad92c711885.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;代码框.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用 tab 键即可缩进。&lt;/p&gt;
&lt;h2 id=&quot;分割线&quot;&gt;&lt;a href=&quot;#分割线&quot; class=&quot;headerlink&quot; title=&quot;分割线&quot;&gt;&lt;/a&gt;分割线&lt;/h2&gt;&lt;p&gt;分割线的语法只需要另起一行，连续输入三个星号 &lt;em&gt;*&lt;/em&gt; 即可。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h2&gt;&lt;p&gt;到这里，Markdown 的基本语法在日常的使用中基本就没什么大问题了，只要多加练习，配合好用的工具，写起东西来肯定会行云流水。更多的语法规则，其实 Mou 的 Help 文档例子很好，当你第一次使用 Mou 时，就会显示该文档，其次，你也可在撰写过程中，使用 CMD+R 快捷键来快速打开文档，以随时查阅和学习语法。&lt;/p&gt;
&lt;h1 id=&quot;三、与-Markdown-相关的一些推荐&quot;&gt;&lt;a href=&quot;#三、与-Markdown-相关的一些推荐&quot; class=&quot;headerlink&quot; title=&quot;三、与 Markdown 相关的一些推荐&quot;&gt;&lt;/a&gt;三、与 Markdown 相关的一些推荐&lt;/h1&gt;&lt;h2 id=&quot;可配套使用的工具&quot;&gt;&lt;a href=&quot;#可配套使用的工具&quot; class=&quot;headerlink&quot; title=&quot;可配套使用的工具&quot;&gt;&lt;/a&gt;可配套使用的工具&lt;/h2&gt;&lt;p&gt;Droplr&lt;/p&gt;
&lt;p&gt;Cloudapp&lt;/p&gt;
&lt;p&gt;ezShare for Mac&lt;/p&gt;
&lt;p&gt;围脖图床修复计划&lt;/p&gt;
&lt;p&gt;马克飞象，专为印象笔记打造的 Markdown 编辑器，非常推荐&lt;/p&gt;
&lt;h2 id=&quot;相关文章阅读&quot;&gt;&lt;a href=&quot;#相关文章阅读&quot; class=&quot;headerlink&quot; title=&quot;相关文章阅读&quot;&gt;&lt;/a&gt;相关文章阅读&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://apple4us.com/2012/02/why-writers-should-use-markdown&quot;&gt;为什么作家应该用 Markdown 保存自己的文稿&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.yangzhiping.com/tech/r-markdown-knitr.html&quot;&gt;Markdown 写作浅谈&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.appinn.com/markdown-tools&quot;&gt;Markdown 工具补完&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/63HYZ6&quot;&gt;Drafts + Scriptogr.am + Dropbox 打造移动端 Markdown 风格博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ituring.com.cn/article/23&quot;&gt;图灵社区 - 怎样使用 Markdown&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://news.cnblogs.com/n/139649&quot;&gt;为什么我们要学习 Markdown 的三个理由&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后，分享一个MarkDown开源编辑工具MacDown，源代码地址&lt;br&gt;&lt;a href=&quot;https://github.com/uranusjr/macdown&quot;&gt;https://github.com/uranusjr/macdown&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。文章介绍markdown基本使用方法，放心，看过之后你肯定会爱上它，无法自拔。&lt;/p&gt;
    
    </summary>
    
      <category term="应用实战" scheme="http://charsdavy.github.io/categories/apply/"/>
    
    
      <category term="markdown" scheme="http://charsdavy.github.io/tags/script/"/>
    
  </entry>
  
  <entry>
    <title>GCD（Grand Central Dispatch）</title>
    <link href="http://charsdavy.github.io/2016/04/14/Grand-Central-Dispatch/"/>
    <id>http://charsdavy.github.io/2016/04/14/Grand-Central-Dispatch/</id>
    <published>2016-04-14T00:24:46.000Z</published>
    <updated>2016-06-04T05:23:49.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：GCD（Grand Central Dispatch），是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如NSThread,NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术。文章分享关于GCD的种种概念以及使用。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;GCD（Grand Central Dispatch），是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如NSThread,NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术。&lt;/p&gt;
&lt;p&gt;GCD 和 block 的配合使用，可以方便地进行多线程编程。&lt;/p&gt;
&lt;h1 id=&quot;优势&quot;&gt;&lt;a href=&quot;#优势&quot; class=&quot;headerlink&quot; title=&quot;优势&quot;&gt;&lt;/a&gt;优势&lt;/h1&gt;&lt;p&gt;1）  苹果官方为多核的并行运算提出的解决方案。&lt;/p&gt;
&lt;p&gt;2）  会自动利用更多的CPU内核。&lt;/p&gt;
&lt;p&gt;3）  会自动管理线程的生命周期（创建线程、调度任务、销毁线程）。&lt;/p&gt;
&lt;h1 id=&quot;核心概念&quot;&gt;&lt;a href=&quot;#核心概念&quot; class=&quot;headerlink&quot; title=&quot;核心概念&quot;&gt;&lt;/a&gt;核心概念&lt;/h1&gt;&lt;p&gt;1）  任务：执行什么操作。block&lt;/p&gt;
&lt;p&gt;2）  队列：用来存放任务。&lt;/p&gt;
&lt;p&gt;串行队列：顺序，一个一个执行。一个任务执行完毕后才执行下一个任务。&lt;/p&gt;
&lt;p&gt;并发队列：同时，同时执行很多个任务。自动开启多个线程同时执行任务。并发功能只有在异步函数下才生效。&lt;/p&gt;
&lt;h1 id=&quot;使用步骤：&quot;&gt;&lt;a href=&quot;#使用步骤：&quot; class=&quot;headerlink&quot; title=&quot;使用步骤：&quot;&gt;&lt;/a&gt;使用步骤：&lt;/h1&gt;&lt;p&gt;1）  定制任务&lt;/p&gt;
&lt;p&gt;确定想要做的事情。&lt;/p&gt;
&lt;p&gt;2）  将任务添加到队列中&lt;/p&gt;
&lt;p&gt;GCD会自动将队列中的任务取出，放到对应的线程中执行。&lt;/p&gt;
&lt;p&gt;任务的取出原则遵循队列的原则：先进先出，后进后出。&lt;/p&gt;
&lt;h1 id=&quot;执行任务的函数&quot;&gt;&lt;a href=&quot;#执行任务的函数&quot; class=&quot;headerlink&quot; title=&quot;执行任务的函数&quot;&gt;&lt;/a&gt;执行任务的函数&lt;/h1&gt;&lt;p&gt;1）同步方式　　&lt;/p&gt;
&lt;p&gt;dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);&lt;/p&gt;
&lt;p&gt;queue:队列&lt;/p&gt;
&lt;p&gt;block:任务&lt;/p&gt;
&lt;p&gt;2）异步方式&lt;/p&gt;
&lt;p&gt;dispatch_async(dispatch_queue_t queue, dispatch_block_t block);&lt;/p&gt;
&lt;p&gt;queue:队列&lt;/p&gt;
&lt;p&gt;block:任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步和异步的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步：在当前线程中执行。&lt;/p&gt;
&lt;p&gt;异步：在另一条线程中执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步任务的作用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）  用户登录&lt;/p&gt;
&lt;p&gt;2）  下载任务1&lt;/p&gt;
&lt;p&gt;3）  下载任务2&lt;/p&gt;
&lt;h1 id=&quot;术语&quot;&gt;&lt;a href=&quot;#术语&quot; class=&quot;headerlink&quot; title=&quot;术语&quot;&gt;&lt;/a&gt;术语&lt;/h1&gt;&lt;p&gt;1）  同步和异步决定了是否要开辟新线程。&lt;/p&gt;
&lt;p&gt;同步：在当前线程中执行任务，不具备开启新线程的能力。&lt;/p&gt;
&lt;p&gt;异步：在新的线程中执行任务，具备开启新线程的能力。&lt;/p&gt;
&lt;p&gt;2）  并发和串行决定了任务执行的方式。&lt;/p&gt;
&lt;p&gt;并发：多个任务同时执行。&lt;/p&gt;
&lt;p&gt;串行：一个任务执行完毕后，再执行下一个任务。&lt;/p&gt;
&lt;h1 id=&quot;代码使用&quot;&gt;&lt;a href=&quot;#代码使用&quot; class=&quot;headerlink&quot; title=&quot;代码使用　&quot;&gt;&lt;/a&gt;代码使用　&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*串行队列*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*创建队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数：1.队列标签。 2.队列属性。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(”dengw”,DISPATCH_QUEUE_SERIAL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*同步执行任务，不会开辟新线程，在当前线程中顺序执行。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一般只要使用“同步”执行，串行队列对添加的同步任务，立马执行*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_sync(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*异步执行任务，开辟新线程，在新线程中执行。开辟新线程的数量与队列模式有关。串行队列中异步执行只会开启一个新线程。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int I = 0; I &amp;lt; 10; I++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*并发队列：需要程序员释放。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*创建队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数：1.队列标签。 2.队列属性。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_queue_create(”dengw”,DISPATCH_QUEUE_CONCURRENT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*异步执行任务，开辟新线程，在新线程中执行。开辟新线程的数量程序员无法控制。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int I = 0; I &amp;lt; 10; I++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*同步执行任务，不开辟新线程，顺序执行*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int I = 0; I &amp;lt; 10; I++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_sync(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*主队列，专门负责在主线程上调度任务。程序启动以后至少有一个主线程，则会创建主队列。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*主队列不允许开辟新线程。不会在子线程调度任务。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*获得主队列*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_get_main_queue();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*异步执行任务，在主队列中，只能顺序执行。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int I = 0; I &amp;lt; 10; I++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*异步：把任务放到主队列中，但不需要马上执行。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*同步执行任务*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int I = 0; I &amp;lt; 10; I++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*同步：把任务放到主队列中，需要马上执行。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*阻塞*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_sync(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*全局队列：本质是并发队列。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;与并发队列的区别：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1）全局队列没有名字，而并发队列有名字。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2）全局队列，是供所有的应用程序使用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3）在MRC中，全局队列不需要释放，并发队列需要释放。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*获得全局队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iOS7中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_HEGH    2 高优先级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT  0 默认优先级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_LOW   (-2) 低优先级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_BACKGROUND    INT16_MIN 后台优先级（最低）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iOS8中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_HEGH:QOS_CLASS_USER_INITIATED&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT:QOS_CLASS_USER_DEFAULT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_LOW:QOS_CLASS_USER_UTILITY&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DISPATCH_QUEUE_PRIORITY_BACKGROUND: QOS_CLASS_USER_BACKGROUND&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;保留参数。*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_get_global_queue(QOS_CLASS_USER_DEFAULT,0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*异步执行任务*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int I = 0; I &amp;lt; 10; I++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@”%@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;各队列的执行效果&quot;&gt;&lt;a href=&quot;#各队列的执行效果&quot; class=&quot;headerlink&quot; title=&quot;各队列的执行效果&quot;&gt;&lt;/a&gt;各队列的执行效果&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;全局并行队列&lt;/th&gt;
&lt;th&gt;手动创建串行队列&lt;/th&gt;
&lt;th&gt;主队列&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;同步（sync）&lt;/td&gt;
&lt;td&gt;没有开启新线程。串行执行任务。&lt;/td&gt;
&lt;td&gt;没有开启新线程。串行执行任务。&lt;/td&gt;
&lt;td&gt;会死锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;异步（async）&lt;/td&gt;
&lt;td&gt;有开启新线程。并行执行任务。&lt;/td&gt;
&lt;td&gt;有开启新线程。串行执行任务。&lt;/td&gt;
&lt;td&gt;没有开启新线程。串行执行任务。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;队列的选择&quot;&gt;&lt;a href=&quot;#队列的选择&quot; class=&quot;headerlink&quot; title=&quot;队列的选择&quot;&gt;&lt;/a&gt;队列的选择&lt;/h1&gt;&lt;p&gt;1）串行队列异步执行&lt;/p&gt;
&lt;p&gt;开一条线程，顺序执行。&lt;/p&gt;
&lt;p&gt;效率不高，执行比较慢，资源占用小，省电。&lt;/p&gt;
&lt;p&gt;应用场景：一般3G网络，对性能要求不高。&lt;/p&gt;
&lt;p&gt;2）并发队列异步执行&lt;/p&gt;
&lt;p&gt;开启多条线程，并发执行。&lt;/p&gt;
&lt;p&gt;效率高，执行快，资源消耗大，费电。&lt;/p&gt;
&lt;p&gt;应用场景：WIFI网络，或需要快速响应，用户体验要求高，对任务执行顺序没有要求。&lt;/p&gt;
&lt;p&gt;3）  同步任务&lt;/p&gt;
&lt;p&gt;一般只会在并发队列，需要阻塞后续任务，必须等待同步任务执行完毕，再去执行其他任务。“依赖关系” &lt;/p&gt;
&lt;h1 id=&quot;线程间通信&quot;&gt;&lt;a href=&quot;#线程间通信&quot; class=&quot;headerlink&quot; title=&quot;线程间通信&quot;&gt;&lt;/a&gt;线程间通信&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*从子线程回到主线程*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //执行耗时的异步操作…&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_async(dispatch_get_main_queue(), ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //回到主线程，执行UI刷新操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;延时操作&quot;&gt;&lt;a href=&quot;#延时操作&quot; class=&quot;headerlink&quot; title=&quot;延时操作&quot;&gt;&lt;/a&gt;延时操作&lt;/h1&gt;&lt;p&gt;1）方式一，调用NSObject的方法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//2秒后再调用run方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self performSelector:@selector(run) withObject:nil afterDelay:2.0];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2）方式二，使用GCD函数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)),dispatch_get_main_queue(), ^&amp;#123;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //2秒后再异步执行这里的代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;调度组（分组）&quot;&gt;&lt;a href=&quot;#调度组（分组）&quot; class=&quot;headerlink&quot; title=&quot;调度组（分组）&quot;&gt;&lt;/a&gt;调度组（分组）&lt;/h1&gt;&lt;p&gt;应用场景：开发的时候，有的时候出现多个网络请求（每一个网络请求时间长短不一），都完成以后统一更新UI或通知用户。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*实例化一个调度组*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_t group = dispatch_group_create();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_get_global_queue(0, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//将任务添加到队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_async(group, queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@”A %@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_async(group, queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@”B %@”, [NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//获得所有调度组里面的异步任务完成的通知&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*在调度组完成通知里，可以跨队列通信*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_notifity(group, queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //异步的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@”finished”);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;一次性执行&quot;&gt;&lt;a href=&quot;#一次性执行&quot; class=&quot;headerlink&quot; title=&quot;一次性执行&quot;&gt;&lt;/a&gt;一次性执行&lt;/h1&gt;&lt;p&gt;常见于单例模型中代码使用。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static dispatch_once_t onceToken;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_once(&amp;amp;onceToken, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //只执行一次&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@”hi”);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：GCD（Grand Central Dispatch），是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如NSThread,NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术。文章分享关于GCD的种种概念以及使用。&lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="iOS" scheme="http://charsdavy.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Ruby 正则表达式</title>
    <link href="http://charsdavy.github.io/2016/04/13/ruby-regular-expression/"/>
    <id>http://charsdavy.github.io/2016/04/13/ruby-regular-expression/</id>
    <published>2016-04-13T14:17:11.000Z</published>
    <updated>2016-06-04T05:23:49.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：正则表达式是一种特殊序列的字符，它通过使用有专门语法的模式来匹配或查找字符串集合。&lt;br&gt;正则表达式用事先定义好的一些特定字符、及这些特定字符的组合，组成一个”规则字符串”，这个”规则字符串”用来表达对字符串的一种过滤逻辑。&lt;br&gt;文章分享关于Ruby中的正则表达式的相关知识与使用。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h1&gt;&lt;p&gt;正则表达式从字面上看是一种介于斜杠之间或介于跟在 %r 后的任意分隔符之间的模式，如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/pattern/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/pattern/im    # 可以指定选项&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%r!/usr/local! # 使用分隔符的正则表达式&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;实例&quot;&gt;&lt;a href=&quot;#实例&quot; class=&quot;headerlink&quot; title=&quot;实例&quot;&gt;&lt;/a&gt;实例&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#!/usr/bin/ruby&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;line1 = &amp;quot;Cats are smarter than dogs&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;line2 = &amp;quot;Dogs also like meat&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if ( line1 =~ /Cats(.*)/ )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  puts &amp;quot;Line1 contains Cats&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if ( line2 =~ /Cats(.*)/ )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  puts &amp;quot;Line2 contains  Dogs&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实例运行输出结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Line1 contains Cats&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;正则表达式修饰符&quot;&gt;&lt;a href=&quot;#正则表达式修饰符&quot; class=&quot;headerlink&quot; title=&quot;正则表达式修饰符&quot;&gt;&lt;/a&gt;正则表达式修饰符&lt;/h1&gt;&lt;p&gt;正则表达式从字面上看可能包含一个可选的修饰符，用于控制各方面的匹配。修饰符在第二个斜杠字符后指定，如上面实例所示。下标列出了 可能的修饰符：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;修饰符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;当匹配文本时忽略大小写。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;只执行一次 #{} 插值，正则表达式在第一次时就进行判断。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;忽略空格，允许在整个表达式中放入空白符和注释。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;匹配多行，把换行字符识别为正常字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u,e,s,n&lt;/td&gt;
&lt;td&gt;把正则表达式解释为 Unicode（UTF-8）、EUC、SJIS 或 ASCII。如果没有指定修饰符，则认为正则表达式使用的是源编码。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;就像字符串通过 %Q 进行分隔一样，Ruby 允许您以 %r 作为正则表达式的开头，后面跟着任意分隔符。这在描述包含大量您不想转义的斜杠字符时非常有用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# 下面匹配单个斜杠字符，不转义&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%r|/|&lt;/code&gt;  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;# Flag 字符可通过下面的语法进行匹配&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%r[&amp;lt;/(.*)&amp;gt;]i&lt;/code&gt; &lt;/p&gt;
&lt;h1 id=&quot;正则表达式模式&quot;&gt;&lt;a href=&quot;#正则表达式模式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式模式&quot;&gt;&lt;/a&gt;正则表达式模式&lt;/h1&gt;&lt;p&gt;除了控制字符，(+ ? . * ^ $ ( ) [ ] { } | )，其他所有字符都匹配本身。您可以通过在控制字符前放置一个反斜杠来对控制字符进行转义。&lt;/p&gt;
&lt;p&gt;下表列出了 Ruby 中可用的正则表达式语法。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模式&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;匹配行的开头。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;匹配行的结尾。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;匹配除了换行符以外的任意单字符。使用 m 选项时，它也可以匹配换行符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[…]&lt;/td&gt;
&lt;td&gt;匹配在方括号中的任意单字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[^…]&lt;/td&gt;
&lt;td&gt;匹配不在方括号中的任意单字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;re*&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式零次或多次。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;re+&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式一次或多次。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;re?&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式零次或一次。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;re{ n}&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式 n 次。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;re{ n,}&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式 n 次或 n 次以上。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;re{ n, m}&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式至少 n 次至多 m 次。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(re)&lt;/td&gt;
&lt;td&gt;对正则表达式进行分组，并记住匹配文本。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?imx)&lt;/td&gt;
&lt;td&gt;暂时打开正则表达式内的 i、 m 或 x 选项。如果在圆括号中，则只影响圆括号内的部分。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?-imx)&lt;/td&gt;
&lt;td&gt;暂时关闭正则表达式内的 i、 m 或 x 选项。如果在圆括号中，则只影响圆括号内的部分。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?: re)&lt;/td&gt;
&lt;td&gt;对正则表达式进行分组，但不记住匹配文本。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?imx: re)&lt;/td&gt;
&lt;td&gt;暂时打开圆括号内的 i、 m 或 x 选项。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?-imx: re)&lt;/td&gt;
&lt;td&gt;暂时关闭圆括号内的 i、 m 或 x 选项。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?#…)&lt;/td&gt;
&lt;td&gt;注释。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?= re)&lt;/td&gt;
&lt;td&gt;使用模式指定位置。没有范围。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?! re)&lt;/td&gt;
&lt;td&gt;使用模式的否定指定位置。没有范围。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(?&amp;gt; re)&lt;/td&gt;
&lt;td&gt;匹配无回溯的独立模式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;匹配单词字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\W&lt;/td&gt;
&lt;td&gt;匹配非单词字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\s&lt;/td&gt;
&lt;td&gt;匹配空白字符。等价于 [\t\n\r\f]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\S&lt;/td&gt;
&lt;td&gt;匹配非空白字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\d&lt;/td&gt;
&lt;td&gt;匹配数字。等价于 [0-9]。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\D&lt;/td&gt;
&lt;td&gt;匹配非数字。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\A&lt;/td&gt;
&lt;td&gt;匹配字符串的开头。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\Z&lt;/td&gt;
&lt;td&gt;匹配字符串的结尾。如果存在换行符，则只匹配到换行符之前。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\z&lt;/td&gt;
&lt;td&gt;匹配字符串的结尾。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\G&lt;/td&gt;
&lt;td&gt;匹配最后一个匹配完成的点。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\b&lt;/td&gt;
&lt;td&gt;当在括号外时匹配单词边界，当在括号内时匹配退格键（0x08）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\B&lt;/td&gt;
&lt;td&gt;匹配非单词边界。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\n, \t, etc.&lt;/td&gt;
&lt;td&gt;匹配换行符、回车符、制表符，等等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\1…\9&lt;/td&gt;
&lt;td&gt;匹配第 n 个分组子表达式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\10&lt;/td&gt;
&lt;td&gt;如果已匹配过，则匹配第 n 个分组子表达式。否则指向字符编码的八进制表示。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;补充：&lt;/strong&gt; &lt;code&gt;a|b&lt;/code&gt; ：匹配 a 或 b。&lt;/p&gt;
&lt;h1 id=&quot;正则表达式实例&quot;&gt;&lt;a href=&quot;#正则表达式实例&quot; class=&quot;headerlink&quot; title=&quot;正则表达式实例&quot;&gt;&lt;/a&gt;正则表达式实例&lt;/h1&gt;&lt;h2 id=&quot;字符&quot;&gt;&lt;a href=&quot;#字符&quot; class=&quot;headerlink&quot; title=&quot;字符&quot;&gt;&lt;/a&gt;字符&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/ruby/&lt;/td&gt;
&lt;td&gt;匹配 “ruby”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;¥&lt;/td&gt;
&lt;td&gt;匹配 Yen 符号。Ruby 1.9 和 Ruby 1.8 支持多个字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;字符类&quot;&gt;&lt;a href=&quot;#字符类&quot; class=&quot;headerlink&quot; title=&quot;字符类&quot;&gt;&lt;/a&gt;字符类&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/[Rr]uby/&lt;/td&gt;
&lt;td&gt;匹配 “Ruby” 或 “ruby”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/rub[ye]/&lt;/td&gt;
&lt;td&gt;匹配 “ruby” 或 “rube”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/[aeiou]/&lt;/td&gt;
&lt;td&gt;匹配任何一个小写元音字母&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/[0-9]/&lt;/td&gt;
&lt;td&gt;匹配任何一个数字，与 /[0123456789]/ 相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/[a-z]/&lt;/td&gt;
&lt;td&gt;匹配任何一个小写 ASCII 字母&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/[A-Z]/&lt;/td&gt;
&lt;td&gt;匹配任何一个大写 ASCII 字母&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/[a-zA-Z0-9]/&lt;/td&gt;
&lt;td&gt;匹配任何一个括号内的字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/[^aeiou]/&lt;/td&gt;
&lt;td&gt;匹配任何一个非小写元音字母的字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/[^0-9]/&lt;/td&gt;
&lt;td&gt;匹配任何一个非数字字符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;特殊字符类&quot;&gt;&lt;a href=&quot;#特殊字符类&quot; class=&quot;headerlink&quot; title=&quot;特殊字符类&quot;&gt;&lt;/a&gt;特殊字符类&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/./&lt;/td&gt;
&lt;td&gt;匹配除了换行符以外的其他任意字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/./m&lt;/td&gt;
&lt;td&gt;在多行模式下，也能匹配换行符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\d/&lt;/td&gt;
&lt;td&gt;匹配一个数字，等同于 /[0-9]/&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\D/&lt;/td&gt;
&lt;td&gt;匹配一个非数字，等同于 /[^0-9]/&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\s/&lt;/td&gt;
&lt;td&gt;匹配一个空白字符，等同于 /[ \t\r\n\f]/&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\S/&lt;/td&gt;
&lt;td&gt;匹配一个非空白字符，等同于 /[^ \t\r\n\f]/&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\w/&lt;/td&gt;
&lt;td&gt;匹配一个单词字符，等同于 /[A-Za-z0-9_]/&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\W/&lt;/td&gt;
&lt;td&gt;匹配一个非单词字符，等同于 /[^A-Za-z0-9_]/&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;重复&quot;&gt;&lt;a href=&quot;#重复&quot; class=&quot;headerlink&quot; title=&quot;重复&quot;&gt;&lt;/a&gt;重复&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/ruby?/&lt;/td&gt;
&lt;td&gt;匹配 “rub” 或 “ruby”。其中，y 是可有可无的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/ruby*/&lt;/td&gt;
&lt;td&gt;匹配 “rub” 加上 0 个或多个的 y。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/ruby+/&lt;/td&gt;
&lt;td&gt;匹配 “rub” 加上 1 个或多个的 y。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\d{3}/&lt;/td&gt;
&lt;td&gt;刚好匹配 3 个数字。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\d{3,}/&lt;/td&gt;
&lt;td&gt;匹配 3 个或多个数字。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\d{3,5}/&lt;/td&gt;
&lt;td&gt;匹配 3 个、4 个或 5 个数字。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;非贪婪重复&quot;&gt;&lt;a href=&quot;#非贪婪重复&quot; class=&quot;headerlink&quot; title=&quot;非贪婪重复&quot;&gt;&lt;/a&gt;非贪婪重复&lt;/h2&gt;&lt;p&gt;这会匹配最小次数的重复。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/&amp;lt;.*&amp;gt;/&lt;/td&gt;
&lt;td&gt;贪婪重复：匹配 “&lt;ruby&gt;perl&amp;gt;”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/&amp;lt;.*?&amp;gt;/&lt;/td&gt;
&lt;td&gt;非贪婪重复：匹配 “&lt;ruby&gt;perl&amp;gt;” 中的 “&lt;ruby&gt;“&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;通过圆括号进行分组&quot;&gt;&lt;a href=&quot;#通过圆括号进行分组&quot; class=&quot;headerlink&quot; title=&quot;通过圆括号进行分组&quot;&gt;&lt;/a&gt;通过圆括号进行分组&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/\D\d+/&lt;/td&gt;
&lt;td&gt;无分组： + 重复 \d&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/(\D\d)+/&lt;/td&gt;
&lt;td&gt;分组： + 重复 \D\d 对&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/([Rr]uby(, )?)+/&lt;/td&gt;
&lt;td&gt;匹配 “Ruby”、”Ruby, ruby, ruby”，等等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;反向引用&quot;&gt;&lt;a href=&quot;#反向引用&quot; class=&quot;headerlink&quot; title=&quot;反向引用&quot;&gt;&lt;/a&gt;反向引用&lt;/h2&gt;&lt;p&gt;这会再次匹配之前匹配过的分组。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/([Rr])uby&amp;amp;\1ails/&lt;/td&gt;
&lt;td&gt;匹配 ruby&amp;amp;rails 或 Ruby&amp;amp;Rails&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/([‘“])(?:(?!\1).)*\1/&lt;/td&gt;
&lt;td&gt;单引号或双引号字符串。\1 匹配第一个分组所匹配的字符，\2 匹配第二个分组所匹配的字符，依此类推。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;替换&quot;&gt;&lt;a href=&quot;#替换&quot; class=&quot;headerlink&quot; title=&quot;替换&quot;&gt;&lt;/a&gt;替换&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/ruby&lt;/td&gt;
&lt;td&gt;rube/&lt;/td&gt;
&lt;td&gt;匹配 “ruby” 或 “rube”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/rub(y&lt;/td&gt;
&lt;td&gt;le))/&lt;/td&gt;
&lt;td&gt;匹配 “ruby” 或 “ruble”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/ruby(!+&lt;/td&gt;
&lt;td&gt;\?)/&lt;/td&gt;
&lt;td&gt;“ruby” 后跟一个或多个 ! 或者跟一个 ?&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;锚&quot;&gt;&lt;a href=&quot;#锚&quot; class=&quot;headerlink&quot; title=&quot;锚&quot;&gt;&lt;/a&gt;锚&lt;/h2&gt;&lt;p&gt;这需要指定匹配位置。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/^Ruby/&lt;/td&gt;
&lt;td&gt;匹配以 “Ruby” 开头的字符串或行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/Ruby$/&lt;/td&gt;
&lt;td&gt;匹配以 “Ruby” 结尾的字符串或行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\ARuby/&lt;/td&gt;
&lt;td&gt;匹配以 “Ruby” 开头的字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/Ruby\Z/&lt;/td&gt;
&lt;td&gt;匹配以 “Ruby” 结尾的字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\bRuby\b/&lt;/td&gt;
&lt;td&gt;匹配单词边界的 “Ruby”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/\brub\B/&lt;/td&gt;
&lt;td&gt;\B 是非单词边界：匹配 “rube” 和 “ruby” 中的 “rub”，但不匹配单独的 “rub”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/Ruby(?=!)/&lt;/td&gt;
&lt;td&gt;如果 “Ruby” 后跟着一个感叹号，则匹配 “Ruby”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/Ruby(?!!)/&lt;/td&gt;
&lt;td&gt;如果 “Ruby” 后没有跟着一个感叹号，则匹配 “Ruby”&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;圆括号的特殊语法&quot;&gt;&lt;a href=&quot;#圆括号的特殊语法&quot; class=&quot;headerlink&quot; title=&quot;圆括号的特殊语法&quot;&gt;&lt;/a&gt;圆括号的特殊语法&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/R(?#comment)/&lt;/td&gt;
&lt;td&gt;匹配 “R”。所有剩余的字符都是注释。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/R(?i)uby/&lt;/td&gt;
&lt;td&gt;当匹配 “uby” 时不区分大小写。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/R(?i:uby)/&lt;/td&gt;
&lt;td&gt;与上面相同。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt; &lt;code&gt;/rub(?:y|le))/&lt;/code&gt; ：只分组，不进行 \1 反向引用&lt;/p&gt;
&lt;h1 id=&quot;搜索和替换&quot;&gt;&lt;a href=&quot;#搜索和替换&quot; class=&quot;headerlink&quot; title=&quot;搜索和替换&quot;&gt;&lt;/a&gt;搜索和替换&lt;/h1&gt;&lt;p&gt;sub 和 gsub 及它们的替代变量 sub! 和 gsub! 是使用正则表达式时重要的字符串方法。&lt;/p&gt;
&lt;p&gt;所有这些方法都是使用正则表达式模式执行搜索与替换操作。sub 和 sub! 替换模式的第一次出现，gsub 和 gsub! 替换模式的所有出现。&lt;/p&gt;
&lt;p&gt;sub 和 gsub 返回一个新的字符串，保持原始的字符串不被修改，而 sub! 和 gsub! 则会修改它们调用的字符串。&lt;/p&gt;
&lt;p&gt;下面是一个实例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#!/usr/bin/ruby&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# -*- coding: UTF-8 -*-&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;phone = &amp;quot;138-3453-1111 #这是一个电话号码&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 删除 Ruby 的注释&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;phone = phone.sub!(/#.*$/, &amp;quot;&amp;quot;)   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   puts &amp;quot;电话号码 : #&amp;#123;phone&amp;#125;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 移除数字以外的其他字符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;phone = phone.gsub!(/\D/, &amp;quot;&amp;quot;)    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    puts &amp;quot;电话号码 : #&amp;#123;phone&amp;#125;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;以上实例运行结果：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;电话号码 : 138-3453-1111 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;电话号码 : 13834531111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;下面是另一个实例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#!/usr/bin/ruby&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# -*- coding: UTF-8 -*-&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;text = &amp;quot;rails 是 rails,  Ruby on Rails 非常好的 Ruby 框架&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 把所有的 &amp;quot;rails&amp;quot; 改为 &amp;quot;Rails&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;text.gsub!(&amp;quot;rails&amp;quot;, &amp;quot;Rails&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 把所有的单词 &amp;quot;Rails&amp;quot; 都改成首字母大写&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;text.gsub!(/\brails\b/, &amp;quot;Rails&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;puts &amp;quot;#&amp;#123;text&amp;#125;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上实例运行结果：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Rails 是 Rails,  Ruby on Rails 非常好的 Ruby 框架&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：正则表达式是一种特殊序列的字符，它通过使用有专门语法的模式来匹配或查找字符串集合。&lt;br&gt;正则表达式用事先定义好的一些特定字符、及这些特定字符的组合，组成一个”规则字符串”，这个”规则字符串”用来表达对字符串的一种过滤逻辑。&lt;br&gt;文章分享关于Ruby中的正则表达式的相关知识与使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Ruby" scheme="http://charsdavy.github.io/categories/script/"/>
    
    
      <category term="正则表达式" scheme="http://charsdavy.github.io/tags/script/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://charsdavy.github.io/2016/04/13/singleton-pattern/"/>
    <id>http://charsdavy.github.io/2016/04/13/singleton-pattern/</id>
    <published>2016-04-13T00:23:37.000Z</published>
    <updated>2016-06-04T09:57:48.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：单例模式的作用是解决“应用中只有一个实例”的一类问题。本文主要介绍单例模式所谓何物，以及如何实现。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;问题的提出&quot;&gt;&lt;a href=&quot;#问题的提出&quot; class=&quot;headerlink&quot; title=&quot;问题的提出　&quot;&gt;&lt;/a&gt;问题的提出　&lt;/h1&gt;&lt;p&gt;在一个iOS 应用的生命周期中，有时候我们只需要某个类的一个实例。例如，iOS 设备都有一个重力加速计硬件设备，要访问设备在x轴、y轴和z轴上的重力加速度，就必然要有一个类能够与硬件设备沟通来实时获得这些数据，这个类就是UIAccelerometer 。除了实时地获得数据，该类还能够保持x 轴、y轴和z 轴的状态。但是这个类只需要一个实例就够了，如果有多个实例，就会占用过多的内存。 再有，当应用程序启动时，应用的状态由UIApplication 类的一个实例维护，这个实例代表了整个“应用程序对象”，它只能是一个实例，其作用是实现应用程序中一些共享资源的访问和状态的保持等。&lt;/p&gt;
&lt;h1 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h1&gt;&lt;p&gt;单例模式一般会封装一个静态属性，并提供静态实例的创建方法，其UML类图如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:04:13:singleton-pattern:1.jpg?imageView/2/w/400&quot; alt=&quot;单例设计模式类图&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;示例代码：&quot;&gt;&lt;a href=&quot;#示例代码：&quot; class=&quot;headerlink&quot; title=&quot;示例代码：&quot;&gt;&lt;/a&gt;示例代码：&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//Singleton.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface Singleton : NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (Singleton*)sharedManager;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic ,strong) NSString* singletonData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//Singleton.m &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;Singleton.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation Singleton&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@synthesize singletonData = _singletonData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static Singleton *sharedManager = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (Singleton*)sharedManager&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static dispatch_once_t once;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_once(&amp;amp;once, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sharedManager = [[self alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return sharedManager;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中&lt;code&gt;static Singleton *sharedManager&lt;/code&gt; 为静态变量，类方法为&lt;code&gt;+ (Singleton*)sharedManager&lt;/code&gt;。sharedManager 方法采用了GCD（Grand Central Dispatch）技术，这是一种基于C语言的多线程访问技术。在上述代码中，&lt;code&gt;dispatch_once&lt;/code&gt; 函数就是由GCD提供的，它的作用是在整个应用程序生命周期中只执行一次代码块（^{…}）。 &lt;code&gt;dispatch_once_t&lt;/code&gt; 是GCD提供的结构体，使用时需要将GCD地址传给&lt;code&gt;dispatch_once&lt;/code&gt; 函数。&lt;code&gt;dispatch_once&lt;/code&gt; 函数能够记录该代码块是否被调用过。&lt;code&gt;dispatch_once&lt;/code&gt;函数不仅意味着代码仅会被运行一次，而且还意味着此运行还是线程同步的。也就是说，当我们使用了&lt;code&gt;dispatch_once&lt;/code&gt;函数时，就不再需要使用诸如&lt;code&gt;@synchronized&lt;/code&gt;之类的语句。&lt;/p&gt;
&lt;p&gt;将以上单例实现代码，抽成宏，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// @interface&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define singleton_interface(className) \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (className *)shared##className;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// @implementation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define singleton_implementation(className) \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;static className *_instance; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (id)allocWithZone:(NSZone *)zone \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static dispatch_once_t onceToken; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_once(&amp;amp;onceToken, ^&amp;#123; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _instance = [super allocWithZone:zone]; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;); \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return _instance; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (className *)shared##className \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    static dispatch_once_t onceToken; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_once(&amp;amp;onceToken, ^&amp;#123; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _instance = [[self alloc] init]; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;); \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return _instance; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;应用案例&quot;&gt;&lt;a href=&quot;#应用案例&quot; class=&quot;headerlink&quot; title=&quot;应用案例&quot;&gt;&lt;/a&gt;应用案例&lt;/h1&gt;&lt;p&gt;在Cocoa Touch框架中，有UIApplication、UIAccelerometer 、NSUserDefaults和NSNotificationCenter等单例类。另外，NSFileManager 和NSBundle 类虽然属于Cocoa框架的内容，但也可以在Cocoa Touch框架中使用（Cocoa框架中的单例类有NSFileManager 、NSBundle 、NSWorkspace和NSApplication 等）。 &lt;/p&gt;
&lt;h2 id=&quot;1-UIApplication&quot;&gt;&lt;a href=&quot;#1-UIApplication&quot; class=&quot;headerlink&quot; title=&quot;1. UIApplication&quot;&gt;&lt;/a&gt;1. UIApplication&lt;/h2&gt;&lt;p&gt;UIApplication 类的实例提供了应用程序的集中控制点来保持应用的状态。UIApplication 实例总是分配给应用程序委托对象（UIApplicationDelegate ），通过应用程序委托对象来响应低内存、应用启动、后台运行和应用终止等事件。在HelloWorld 案例中，AppDelegate 就是这个应用程序的委托对象，它实现了UIApplicationDelegate协议。&lt;/p&gt;
&lt;p&gt;UIApplication 类有很多方法和属性，下面我们重点介绍其中几个：&lt;br&gt;&lt;code&gt;+ sharedApplication&lt;/code&gt; 方法。创建和获得UIApplication 实例的方法。&lt;br&gt;&lt;code&gt;idleTimerDisabled&lt;/code&gt;属性。设定和获得“空闲时间禁止”的状态。idleTimerDisabled属性的默认值是NO，即默认情况下系统会锁定屏幕。当idleTimerDisabled = YES 时，则不会开启“空闲时间禁止”状态，系统不会锁定屏幕。开启这项设定需要谨慎，它会使你的应用比较耗电。&lt;br&gt;&lt;code&gt;- openURL:&lt;/code&gt;方法。可以打开一些内置的iOS 应用，其中包括打开浏览器、打开Google 地图、拨打电话、发送短信和发送E-mail 等。&lt;/p&gt;
&lt;p&gt;打开浏览器的示例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSURL *url = [NSURL URLWithString:@&amp;quot;http://www.cnblogs.com/chars&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[UIApplication sharedApplication] openURL:url];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;打开Google 地图时，实际上是通过内置浏览器来打开，示例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString* searchQuery = @&amp;quot;清华大学&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;searchQuery = [searchQuery stringByAddingPercentEscapesUsingEncoding: NSUTF8StringEncoding];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString* urlString = [NSString stringWithFormat: @&amp;quot;http://maps.google.com/maps?q=%@&amp;quot;, searchQuery];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中NSString 的&lt;code&gt;stringByAddingPercentEscapesUsingEncoding&lt;/code&gt;方法将字符串转换为URL编码，例如 “%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6 ”是“清华大学”的 URL 编码。 拨打电话时，苹果官方要求使用该方法调用内置拨号程序，示例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&amp;quot;tel://10010&amp;quot;]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;发送短信时，苹果官方要求使用该方法调用内置发送短信程序，示例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&amp;quot;sms:10010&amp;quot;]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;发送E-mail 时，这种方式可以发送简单的不带附件的E-mail ，示例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&amp;quot;mailto://eorient@sina.com&amp;quot;]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-UIAccelerometer&quot;&gt;&lt;a href=&quot;#2-UIAccelerometer&quot; class=&quot;headerlink&quot; title=&quot;2.   UIAccelerometer&quot;&gt;&lt;/a&gt;2.   UIAccelerometer&lt;/h2&gt;&lt;p&gt;单例类UIAccelerometer 前面也讲过，它可以访问重力加速计硬件设备，实时获得设备在x 轴、y轴和z 轴方向上的重力加速度。&lt;br&gt;&lt;code&gt;+ sharedAccelerometer&lt;/code&gt;方法是创建和获得UIAccelerometer实例的共享方法。&lt;/p&gt;
&lt;p&gt;与UIApplication类似，UIAccelerometer也有对应的委托对象，其委托对象为UIAccelerometerDelegate。UIAccelerometer 将实例分配给委托对象UIAccelerometerDelegate ，然后由委托对象响应重力加速计事件。&lt;/p&gt;
&lt;h2 id=&quot;3-NSUserDefaults&quot;&gt;&lt;a href=&quot;#3-NSUserDefaults&quot; class=&quot;headerlink&quot; title=&quot;3.   NSUserDefaults&quot;&gt;&lt;/a&gt;3.   NSUserDefaults&lt;/h2&gt;&lt;p&gt;单例类NSUserDefaults可以很方便地读取应用设置项目。&lt;br&gt;&lt;code&gt;+ standardUserDefaults&lt;/code&gt;方法是创建和获得NSUserDefaults实例的静态方法。&lt;/p&gt;
&lt;h2 id=&quot;4-NSNotificationCenter&quot;&gt;&lt;a href=&quot;#4-NSNotificationCenter&quot; class=&quot;headerlink&quot; title=&quot;4.   NSNotificationCenter&quot;&gt;&lt;/a&gt;4.   NSNotificationCenter&lt;/h2&gt;&lt;p&gt;单例类NSNotificationCenter提供信息广播通知，它采用观察者模式的通知机制。&lt;br&gt;&lt;code&gt;+ defaultCenter&lt;/code&gt;方法是创建和获得NSNotificationCenter实例的共享方法。&lt;/p&gt;
&lt;h2 id=&quot;5-NSFileManager&quot;&gt;&lt;a href=&quot;#5-NSFileManager&quot; class=&quot;headerlink&quot; title=&quot;5.   NSFileManager&quot;&gt;&lt;/a&gt;5.   NSFileManager&lt;/h2&gt;&lt;p&gt;NSFileManager 提供了访问文件系统的通用操作，可以定位、创建、复制文件和文件夹。在iOS 5和Mac OS X v10.7之后，它还可以管理存储在iCloud 上的数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;+ defaultManager&lt;/code&gt;方法是创建和获得NSFileManager 实例的方法。除了该方法外，创建NSFileMa nager对象时还可以使用实例构造方法– init。这两种方法有着比较大的差别，+ defaultManager方法总是返回相同的NSFileManager 对象，但如果要使用委托（NSFileManagerDelegate）完成基于文件的操作并接收通知，应该使用– init 方法创建一个新的实例，而不是使用共享的对象。&lt;/p&gt;
&lt;h2 id=&quot;6-NSBundle&quot;&gt;&lt;a href=&quot;#6-NSBundle&quot; class=&quot;headerlink&quot; title=&quot;6.   NSBundle&quot;&gt;&lt;/a&gt;6.   NSBundle&lt;/h2&gt;&lt;p&gt;NSBundle 提供了动态加载（或卸载）可执行代码、定位资源文件以及资源本地化、访问文件系统等功能。&lt;br&gt;&lt;code&gt;+ mainBundle&lt;/code&gt;方法是创建和获得NSBundle 实例的共享方法。&lt;/p&gt;
&lt;h1 id=&quot;尾声&quot;&gt;&lt;a href=&quot;#尾声&quot; class=&quot;headerlink&quot; title=&quot;尾声&quot;&gt;&lt;/a&gt;尾声&lt;/h1&gt;&lt;p&gt;单例模式无疑是Cocoa框架下最重要的设计模式之一。灵活而有机地运用设计模式，意味着编程工作的高效性和产品健壮性、安全性的提高。因此，我们应该要善于使用设计模式，将自己的开发经验与代码、设计模式完美融合起来，提高软件代码质量。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：单例模式的作用是解决“应用中只有一个实例”的一类问题。本文主要介绍单例模式所谓何物，以及如何实现。&lt;/p&gt;
    
    </summary>
    
      <category term="进阶" scheme="http://charsdavy.github.io/categories/advance/"/>
    
    
      <category term="设计模式" scheme="http://charsdavy.github.io/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 - 概述</title>
    <link href="http://charsdavy.github.io/2016/04/12/design-pattern-introduction/"/>
    <id>http://charsdavy.github.io/2016/04/12/design-pattern-introduction/</id>
    <published>2016-04-12T00:08:59.000Z</published>
    <updated>2016-06-04T10:08:11.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是 GOF（四人帮，全拼 Gang of Four）？&lt;/strong&gt;&lt;br&gt;在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 &lt;strong&gt;Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）&lt;/strong&gt; 的书，该书首次提到了软件开发中设计模式的概念。&lt;br&gt;四位作者合称 &lt;strong&gt;GOF（四人帮，全拼 Gang of Four）&lt;/strong&gt;。他们所提出的设计模式主要是基于以下的面向对象设计原则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对接口编程而不是对实现编程。&lt;/li&gt;
&lt;li&gt;优先使用对象组合而不是继承。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;设计模式的使用&lt;/strong&gt;&lt;br&gt;设计模式在软件开发中的两个主要用途。&lt;br&gt;&lt;strong&gt;开发人员的共同平台&lt;/strong&gt;&lt;br&gt;设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。&lt;br&gt;&lt;strong&gt;最佳的实践&lt;/strong&gt;&lt;br&gt;设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计模式的类型&lt;/strong&gt;&lt;br&gt;根据设计模式的参考书 &lt;strong&gt;Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）&lt;/strong&gt; 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建型模式&lt;/strong&gt;&lt;br&gt;这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工厂模式（Factory Pattern）&lt;/li&gt;
&lt;li&gt;抽象工厂模式（Abstract Factory Pattern）&lt;/li&gt;
&lt;li&gt;单例模式（Singleton Pattern）&lt;/li&gt;
&lt;li&gt;建造者模式（Builder Pattern）&lt;/li&gt;
&lt;li&gt;原型模式（Prototype Pattern）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;结构型模式&lt;/strong&gt;&lt;br&gt;这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适配器模式（Adapter Pattern）&lt;/li&gt;
&lt;li&gt;桥接模式（Bridge Pattern）&lt;/li&gt;
&lt;li&gt;过滤器模式（Filter、Criteria Pattern）&lt;/li&gt;
&lt;li&gt;组合模式（Composite Pattern）&lt;/li&gt;
&lt;li&gt;装饰器模式（Decorator Pattern）&lt;/li&gt;
&lt;li&gt;外观模式（Facade Pattern）&lt;/li&gt;
&lt;li&gt;享元模式（Flyweight Pattern）&lt;/li&gt;
&lt;li&gt;代理模式（Proxy Pattern）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;行为型模式&lt;/strong&gt;&lt;br&gt;这些设计模式特别关注对象之间的通信。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;责任链模式（Chain of Responsibility Pattern）&lt;/li&gt;
&lt;li&gt;命令模式（Command Pattern）&lt;/li&gt;
&lt;li&gt;解释器模式（Interpreter Pattern）&lt;/li&gt;
&lt;li&gt;迭代器模式（Iterator Pattern）&lt;/li&gt;
&lt;li&gt;中介者模式（Mediator Pattern）&lt;/li&gt;
&lt;li&gt;备忘录模式（Memento Pattern）&lt;/li&gt;
&lt;li&gt;观察者模式（Observer Pattern）&lt;/li&gt;
&lt;li&gt;状态模式（State Pattern）&lt;/li&gt;
&lt;li&gt;空对象模式（Null Object Pattern）&lt;/li&gt;
&lt;li&gt;策略模式（Strategy Pattern）&lt;/li&gt;
&lt;li&gt;模板模式（Template Pattern）&lt;/li&gt;
&lt;li&gt;访问者模式（Visitor Pattern）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;J2EE 模式&lt;/strong&gt;&lt;br&gt;这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MVC 模式（MVC Pattern）&lt;/li&gt;
&lt;li&gt;业务代表模式（Business Delegate Pattern）&lt;/li&gt;
&lt;li&gt;组合实体模式（Composite Entity Pattern）&lt;/li&gt;
&lt;li&gt;数据访问对象模式（Data Access Object Pattern）&lt;/li&gt;
&lt;li&gt;前端控制器模式（Front Controller Pattern）&lt;/li&gt;
&lt;li&gt;拦截过滤器模式（Intercepting Filter Pattern）&lt;/li&gt;
&lt;li&gt;服务定位器模式（Service Locator Pattern）&lt;/li&gt;
&lt;li&gt;传输对象模式（Transfer Object Pattern）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面用一个图片来整体描述一下设计模式之间的关系：&lt;br&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/2016-04-12-design-pattern-introduction-1.png?imageView/2/w/600&quot; alt=&quot;设计模式之间的关系&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计模式的六大原则&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;1、开闭原则（Open Close Principle）&lt;/strong&gt;&lt;br&gt;开闭原则的意思是：&lt;strong&gt;对扩展开放，对修改关闭&lt;/strong&gt;。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。&lt;br&gt;&lt;strong&gt;2、里氏代换原则（Liskov Substitution Principle）&lt;/strong&gt;&lt;br&gt;里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。&lt;br&gt;&lt;strong&gt;3、依赖倒转原则（Dependence Inversion Principle）&lt;/strong&gt;&lt;br&gt;这个原则是开闭原则的基础，具体内容：针对对接口编程，依赖于抽象而不依赖于具体。&lt;br&gt;&lt;strong&gt;4、接口隔离原则（Interface Segregation Principle）&lt;/strong&gt;&lt;br&gt;这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。&lt;br&gt;&lt;strong&gt;5、迪米特法则，又称最少知道原则（Demeter Principle）&lt;/strong&gt;&lt;br&gt;最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。&lt;br&gt;&lt;strong&gt;6、合成复用原则（Composite Reuse Principle）&lt;/strong&gt;&lt;br&gt;合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。&lt;/p&gt;
    
    </summary>
    
      <category term="进阶" scheme="http://charsdavy.github.io/categories/advance/"/>
    
    
      <category term="设计模式" scheme="http://charsdavy.github.io/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://charsdavy.github.io/2016/04/10/hello-world/"/>
    <id>http://charsdavy.github.io/2016/04/10/hello-world/</id>
    <published>2016-04-10T10:32:15.000Z</published>
    <updated>2016-06-04T05:28:28.000Z</updated>
    
    <content type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate-static-files&quot;&gt;&lt;a href=&quot;#Generate-static-files&quot; class=&quot;headerlink&quot; title=&quot;Generate static files&quot;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/generating.html&quot;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Deploy-to-remote-sites&quot;&gt;&lt;a href=&quot;#Deploy-to-remote-sites&quot; class=&quot;headerlink&quot; title=&quot;Deploy to remote sites&quot;&gt;&lt;/a&gt;Deploy to remote sites&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/deployment.html&quot;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="应用实战" scheme="http://charsdavy.github.io/categories/apply/"/>
    
    
      <category term="hexo" scheme="http://charsdavy.github.io/tags/script/"/>
    
  </entry>
  
  <entry>
    <title>常用的算法思想总结</title>
    <link href="http://charsdavy.github.io/2016/02/22/algorithm-idea/"/>
    <id>http://charsdavy.github.io/2016/02/22/algorithm-idea/</id>
    <published>2016-02-22T04:17:11.000Z</published>
    <updated>2016-06-04T05:23:49.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：对于计算机科学而言，算法是一个非常重要的概念。它是程序设计的灵魂，是将实际问题同解决该问题的计算机程序建立起联系的桥梁。文章主要介绍一些常用的算法思想。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;一、穷举法思想&quot;&gt;&lt;a href=&quot;#一、穷举法思想&quot; class=&quot;headerlink&quot; title=&quot;一、穷举法思想&quot;&gt;&lt;/a&gt;一、穷举法思想&lt;/h1&gt;&lt;p&gt;穷举法，又称为强力法。它是一种最为直接，实现最为简单，同时又最为耗时的一种解决实际问题的算法思想。&lt;/p&gt;
&lt;p&gt;基本思想：在可能的解空间中穷举出每一种可能的解，并对每一个可能解进行判断，从中得到问题的答案。&lt;/p&gt;
&lt;p&gt;使用穷举法思想解决实际问题，最关键的步骤是划定问题的解空间，并在该解空间中一一枚举每一个可能的解。这里有两点需要注意，一是解空间的划定必须保证覆盖问题的全部解，二是解空间集合及问题的解集一定是离散的集合，也就是说集合中的元素是可列的、有限的。&lt;/p&gt;
&lt;p&gt;穷举法用时间上的牺牲换来了解的全面性保证，因此穷举法的优势在于确保得到问题的全部解，而瓶颈在于运算效率十分低下。但是穷举法算法思想简单，易于实现，在解决一些规模不是很大的问题，使用穷举法不失为一种很好地选择。&lt;/p&gt;
&lt;p&gt;现在我们通过具体的实例来理解穷举法思想。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  实例：寻找[1,100]之间的素数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  判断n是否是素数，是则返回1，不是则返回0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int isPrime(int n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (i = 2; i &amp;lt; n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (0 == n % i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  寻找[low,high]之间的素数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void getPrime(int low, int high)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (i = low; i &amp;lt;= high; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (isPrime(i)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printf(&amp;quot;%d &amp;quot;, i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main(int argc, const char * argv[]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // insert code here...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int low = 0, high = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;Please input the domain for searching prime\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;low limitation:&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    scanf(&amp;quot;%d&amp;quot;, &amp;amp;low);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;high limitation:&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    scanf(&amp;quot;%d&amp;quot;, &amp;amp;high);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;The whole primes in this domain are\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getPrime(low, high);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getchar();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;程序运行结果：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Please input the domain for searching prime&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;low limitation:1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;high limitation:100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The whole primes in this domain are&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;二、递归与分治思想&quot;&gt;&lt;a href=&quot;#二、递归与分治思想&quot; class=&quot;headerlink&quot; title=&quot;二、递归与分治思想&quot;&gt;&lt;/a&gt;二、递归与分治思想&lt;/h1&gt;&lt;p&gt;递归与分治的算法思想往往是相伴而生的，它们在各类算法中使用非常频繁，应用递归和分治的算法思想有时可以设计出代码简洁且比较高效的算法来。&lt;/p&gt;
&lt;p&gt;在解决一些比较复杂的问题，特别是解决一些规模较大得问题时，常常将问题进行分解。具体来说，就是将一个规模较大的问题分割成规模较小的同类问题，然后将这些小问题的子问题逐个加以解决，最终也就将整个大问题解决了。这种思想称之为分治。在解决一些问题比较复杂、计算量庞大的问题时经常被用到。&lt;/p&gt;
&lt;p&gt;最为经典的使用分治思想设计的算法就是“折半查找算法”。折半查找算法利用了元素之间的顺序关系（有序序列），采用分而治之的策略，不断缩小问题的规模，每次都将问题的规模减小至上一次的一半。&lt;/p&gt;
&lt;p&gt;而递归思想也是一种常见的算法设计思想，所谓递归算法，就是一种直接或间接地调用原算法本身的一种算法。&lt;/p&gt;
&lt;p&gt;接下来我们通过实例代码来理解递归、分治思想。&lt;/p&gt;
&lt;p&gt;分治思想：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  有一个数组A[10]，里面存放了10个整数，顺序递增&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  A[10] = &amp;#123;2, 3, 5, 7, 8, 10, 12, 15, 19, 21&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int bin_search(int A[], int n, int key)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int low = 0, high = 0, mid = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    high = n - 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while (low &amp;lt;= high) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mid = (low + high) / 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (A[mid] == key) &amp;#123; //查找成功，返回mid&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (A[mid] &amp;lt; key) &amp;#123; //在后半序列中查找&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            low = mid + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (A[mid] &amp;gt; key) &amp;#123; //在前半序列中查找&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            high = mid - 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return -1; //查找失败&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main(int argc, const char * argv[]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // insert code here...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int A[10] = &amp;#123;2, 3, 5, 7, 8, 10, 12, 15, 19, 21&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i = 0, n = 0, addr = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;The contents of the Array A[10] are\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (i = 0; i &amp;lt; 10; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        printf(&amp;quot;%d &amp;quot;,A[i]); //显示数组A中的内容&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;\nPlease input a interger for search\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n); //输入待查找得元素&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    addr = bin_search(A, 10, n); //折半查找，返回该元素在数组中的下标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (-1 != addr) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        printf(&amp;quot;%d is at the %dth unit is array A\n&amp;quot;, n, addr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        printf(&amp;quot;There is no %d in array A\n&amp;quot;, n); //查找失败&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getchar();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;The contents of the Array A[10] are&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 3 5 7 8 10 12 15 19 21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Please input a interger for search&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12 is at the 6th unit is array A&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;递归思想：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  计算n的阶乘n!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int factorial(int n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (0 == n) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return n * factorial(n - 1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main(int argc, const char * argv[]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // insert code here...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int n = 0, result = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;Please input factorial number\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result = factorial(n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;result is %d&amp;quot;, result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getchar();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Please input factorial number&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;result is 720&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;三、贪心算法思想&quot;&gt;&lt;a href=&quot;#三、贪心算法思想&quot; class=&quot;headerlink&quot; title=&quot;三、贪心算法思想&quot;&gt;&lt;/a&gt;三、贪心算法思想&lt;/h1&gt;&lt;p&gt;贪心算法的思想非常简单且算法效率很高，在一些问题的解决上有着明显的优势。&lt;/p&gt;
&lt;p&gt;先来看一个生活中的例子。假设有3种硬币，面值分别为1元、5角、1角。这3种硬币各自的数量不限，现在要找给顾客3元6角钱，请问怎样找才能使得找给顾客的硬币数量最少呢？你也许会不假思索的说出答案：找给顾客3枚1元硬币，1枚5角硬币，1枚1角硬币。其实也可以找给顾客7枚5角硬币，1枚1角硬币。可是在这里不符合题意。在这里，我们下意识地应用了所谓贪心算法解决这个问题。&lt;/p&gt;
&lt;p&gt;所谓贪心算法，就是总是做出在当前看来是最好的选择的一种方法。以上述的题目为例，为了找给顾客的硬币数量最少，在选择硬币的面值时，当然是尽可能地选择面值大的硬币。因此，下意识地遵循了以下方案：&lt;/p&gt;
&lt;p&gt;（1）首先找出一个面值不超过3元6角的最大硬币，即1元硬币。&lt;/p&gt;
&lt;p&gt;（2）然后从3元6角中减去1元，得到2元6角，再找出一个面值不超过2元6角的最大硬币，即1元硬币。&lt;/p&gt;
&lt;p&gt;（3）然后从2元6角中减去1元，得到1元6角，再找出一个面值不超过1元6角的最大硬币，即1元硬币。&lt;/p&gt;
&lt;p&gt;（4）然后从1元6角中减去1元，得到6角，再找出一个面值不超过6角的最大硬币，即5角硬币。&lt;/p&gt;
&lt;p&gt;（5）然后从6角中减去5角，得到1角，再找出一个面值不超过1角的最大硬币，即1角硬币。&lt;/p&gt;
&lt;p&gt;（6）找零钱的过程结束。&lt;/p&gt;
&lt;p&gt;这个过程就是一个典型的贪心算法思想。&lt;/p&gt;
&lt;p&gt;因此，不难看出应用贪心算法求解问题，并不从问题的整体最优上加以考虑，它所作出的每一步选择只是在某种意义上得局部最优选择。因此，严格意义上讲，要使用贪心算法求解问题，该问题应当具备以下性质。&lt;/p&gt;
&lt;p&gt;（1）贪心选择性质&lt;/p&gt;
&lt;p&gt;所谓贪心选择性质，就是指所求解的问题的整体最优解可以通过一系列的局部最优解得到。所谓局部最优解，就是指在当前的状态下做出的最好选择。&lt;/p&gt;
&lt;p&gt;（2）最优子结构性质&lt;/p&gt;
&lt;p&gt;当一个问题的最优解包含着它的子问题的最优解时，就称此问题具有最优子结构性质。&lt;/p&gt;
&lt;p&gt;我们经常使用的哈夫曼（Huffman Tree）编码算法，求解最小生成树的克鲁斯卡尔（Kruskal）算法和普利姆（Prim）算法，求解图的单源最短路径的迪克斯特拉（Dijkstra）算法都是基于贪心算法的思想设计的。&lt;/p&gt;
&lt;p&gt;下面，我们来通过实例代码来理解贪心算法思想。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  最优装船问题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  有一批集装箱要装入一个载质量为C的货船中，每个集装箱的质量由用户自己输入指定，在货船的装载体积不限的前提下，如何装载集装箱才能尽可能多地将集装箱装入货船中。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void sort(int w[], int t[], int n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i = 0, j = 0, tmp = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //存放w[]中的内容，用于排序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int *w_tmp = (int *)malloc(sizeof(int) * n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (i = 0; i &amp;lt; n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        t[i] = i;  //初始化数组t&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (i = 0; i &amp;lt; n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        w_tmp[i] = w[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (i = 0; i &amp;lt; n - 1; i++) &amp;#123; //冒泡排序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (j = 0; j &amp;lt; n - i - 1; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (w_tmp[j] &amp;gt; w_tmp[j+1]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                tmp = w_tmp[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                w_tmp[j] = w_tmp[j+1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                w_tmp[j+1] = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                tmp = t[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                t[j] = t[j+1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                t[j+1] = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void Loading(int x[], int w[], int c, int n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //存放w[]的下标，如果t[i]、t[j]、i&amp;lt;j，则w[i]&amp;lt;=w[j]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int *t = (int *)malloc(sizeof(int) * n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //排序，用数组t[[]存放w[]的下标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sort(w, t, n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (i = 0; i &amp;lt; n; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        x[i] = 0;  //初始化数组x[]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (i = 0; i &amp;lt; n &amp;amp;&amp;amp; w[t[i]] &amp;lt;= c; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        x[t[i]] = 1; //将第t[i]个集装箱装入货船中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        c = c - w[t[i]]; //变量c中存放货船的剩余载质量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main(int argc, const char * argv[]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // insert code here...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int x[5], w[5], c = 0, i = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;Please input the maximum loading of the sheep\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    scanf(&amp;quot;%d&amp;quot;, &amp;amp;c); //&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;Please input the weight of FIVE box\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (i = 0; i &amp;lt; 5; i++) &amp;#123; //&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        scanf(&amp;quot;%d&amp;quot;, &amp;amp;w[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Loading(x, w, c, 5); //&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;The following boxes will be loaded\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (i = 0; i &amp;lt; 5; i++) &amp;#123; //&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (1 == x[i]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            printf(&amp;quot;BOX:%d &amp;quot;, i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getchar();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Please input the maximum loading of the sheep&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Please input the weight of FIVE box&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5 7 6 3 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The following boxes will be loaded&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOX:0 BOX:3 BOX:4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上，就是对算法设计中几个常见的思想的总结。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：对于计算机科学而言，算法是一个非常重要的概念。它是程序设计的灵魂，是将实际问题同解决该问题的计算机程序建立起联系的桥梁。文章主要介绍一些常用的算法思想。&lt;/p&gt;
    
    </summary>
    
      <category term="进阶" scheme="http://charsdavy.github.io/categories/advance/"/>
    
    
      <category term="算法" scheme="http://charsdavy.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Apk 反编译</title>
    <link href="http://charsdavy.github.io/2016/02/18/apk-decompile/"/>
    <id>http://charsdavy.github.io/2016/02/18/apk-decompile/</id>
    <published>2016-02-18T14:17:11.000Z</published>
    <updated>2016-06-04T05:23:49.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：最近看见一些正版软件，便想到pc端软件的破解，便在网络上大肆搜索，终于找到了一个办公软件破解key的软件，对其实现非常感兴趣，想着反编译其apk，在网上也找了很多相关的实现方式，这里，本文介绍博主使用的简约方法与工具。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h1&gt;&lt;p&gt;1、将apk文件解压，得到其中的classes.dex（java文件编译再通过dx工具打包而成的）。&lt;/p&gt;
&lt;p&gt;将classes.dex复制到d2j-dex2jar.bat所在目录dex2jar-0.0.9.13文件夹。 &lt;/p&gt;
&lt;p&gt;在命令行下定位到d2j-dex2jar.bat所在目录，运行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;d2j-dex2jar.bat&lt;/code&gt;    &lt;code&gt;classes.dex&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;生成&lt;code&gt;classes_dex2jar.jar&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://download.csdn.net/detail/dengw0716/5270008&quot;&gt;dex2jar工具下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、使用jdgui.exe打开classes_dex2jar.jar，即可看见源码。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://download.csdn.net/detail/dengw0716/5270043&quot;&gt;jdgui工具下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;只需以上两步，即可获得apk源码。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：最近看见一些正版软件，便想到pc端软件的破解，便在网络上大肆搜索，终于找到了一个办公软件破解key的软件，对其实现非常感兴趣，想着反编译其apk，在网上也找了很多相关的实现方式，这里，本文介绍博主使用的简约方法与工具。&lt;/p&gt;
    
    </summary>
    
      <category term="移动开发" scheme="http://charsdavy.github.io/categories/develop/"/>
    
    
      <category term="开发助手" scheme="http://charsdavy.github.io/tags/assistant/"/>
    
  </entry>
  
  <entry>
    <title>内存对齐详解</title>
    <link href="http://charsdavy.github.io/2016/02/10/memory-alignment/"/>
    <id>http://charsdavy.github.io/2016/02/10/memory-alignment/</id>
    <published>2016-02-10T12:17:11.000Z</published>
    <updated>2016-06-04T05:23:49.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问， 这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是内存对齐。&lt;br&gt;本文分享博主对内存对齐的一些理解。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;一、什么是内存对齐&quot;&gt;&lt;a href=&quot;#一、什么是内存对齐&quot; class=&quot;headerlink&quot; title=&quot;一、什么是内存对齐&quot;&gt;&lt;/a&gt;一、什么是内存对齐&lt;/h1&gt;&lt;p&gt;现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问， 这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是内存对齐。&lt;/p&gt;
&lt;h1 id=&quot;二、内存对齐的原因&quot;&gt;&lt;a href=&quot;#二、内存对齐的原因&quot; class=&quot;headerlink&quot; title=&quot;二、内存对齐的原因&quot;&gt;&lt;/a&gt;二、内存对齐的原因&lt;/h1&gt;&lt;p&gt;1、平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。&lt;/p&gt;
&lt;p&gt;2、性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。&lt;/p&gt;
&lt;h1 id=&quot;三、对齐规则&quot;&gt;&lt;a href=&quot;#三、对齐规则&quot; class=&quot;headerlink&quot; title=&quot;三、对齐规则&quot;&gt;&lt;/a&gt;三、对齐规则&lt;/h1&gt;&lt;p&gt;每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。程序员可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16 来改变这一系数，其中的n 就是你要指定的“对齐系数”。&lt;/p&gt;
&lt;h2 id=&quot;规则1&quot;&gt;&lt;a href=&quot;#规则1&quot; class=&quot;headerlink&quot; title=&quot;规则1&quot;&gt;&lt;/a&gt;规则1&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;数据成员对齐规则：&lt;/strong&gt;结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0 的地方，以后每个数据成员的对齐按照#pragma pack 指定的数值和这个数据成员自身长度中，比较小的那个进行。&lt;/p&gt;
&lt;h2 id=&quot;规则2&quot;&gt;&lt;a href=&quot;#规则2&quot; class=&quot;headerlink&quot; title=&quot;规则2&quot;&gt;&lt;/a&gt;规则2&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;结构（或联合）的整体对齐规则：&lt;/strong&gt;在数据成员完成各自对齐之后，结构（或联合）本身也要进行对齐，对齐将按照#pragma pack 指定的数值和结构（或联合）最大数据成员长度中，比较小的那个进行。&lt;/p&gt;
&lt;h2 id=&quot;规则3&quot;&gt;&lt;a href=&quot;#规则3&quot; class=&quot;headerlink&quot; title=&quot;规则3&quot;&gt;&lt;/a&gt;规则3&lt;/h2&gt;&lt;p&gt;结合1、2 可推断：当#pragma pack 的n 值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。&lt;/p&gt;
&lt;h1 id=&quot;四、试验&quot;&gt;&lt;a href=&quot;#四、试验&quot; class=&quot;headerlink&quot; title=&quot;四、试验&quot;&gt;&lt;/a&gt;四、试验&lt;/h1&gt;&lt;p&gt;接下来我们通过实际例子来说明这些规则。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;试验环境：&lt;/strong&gt;编译器包括GCC 3.4.2 和VC6.0 的C 编译器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平台：&lt;/strong&gt;Windows XP SP2。&lt;/p&gt;
&lt;p&gt;我们将用典型的struct 对齐来说明。首先我们定义一个struct：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#pragma pack(n) /* n = 1, 2, 4, 8, 16 */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct test_t&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    short c;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char d;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;#pragma pack(n)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先我们首先确认在试验平台上的各个类型的size，经验证两个编译器的输出均为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sizeof(char) = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sizeof(short) = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sizeof(int) = 4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;验证过程如下：通过#pragma pack(n)改变“对齐系数”，然后查看sizeof(struct test_t)的值。&lt;/p&gt;
&lt;h2 id=&quot;字节对齐-pragma-pack-1&quot;&gt;&lt;a href=&quot;#字节对齐-pragma-pack-1&quot; class=&quot;headerlink&quot; title=&quot;字节对齐(#pragma pack(1))&quot;&gt;&lt;/a&gt;字节对齐(#pragma pack(1))&lt;/h2&gt;&lt;p&gt;输出结果：sizeof(struct test_t) = 8 [两个编译器输出一致]&lt;/p&gt;
&lt;p&gt;分析过程：&lt;/p&gt;
&lt;h3 id=&quot;成员数据对齐&quot;&gt;&lt;a href=&quot;#成员数据对齐&quot; class=&quot;headerlink&quot; title=&quot;成员数据对齐&quot;&gt;&lt;/a&gt;成员数据对齐&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#pragma pack(1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct test_t &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 长度4 &amp;lt; 1 按1 对齐；起始offset=0 0%1=0；存放位置区间[0,3] */   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 长度1 = 1 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 长度2 &amp;gt; 1 按1 对齐；起始offset=5 5%1=0；存放位置区间[5,6] */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    short c;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 长度1 = 1 按1 对齐；起始offset=7 7%1=0；存放位置区间[7] */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char d;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;#pragma pack()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;成员总大小=8&lt;/p&gt;
&lt;h3 id=&quot;整体对齐&quot;&gt;&lt;a href=&quot;#整体对齐&quot; class=&quot;headerlink&quot; title=&quot;整体对齐&quot;&gt;&lt;/a&gt;整体对齐&lt;/h3&gt;&lt;p&gt;整体对齐系数= min((max(int,short,char), 1) = 1&lt;/p&gt;
&lt;p&gt;整体大小(size)=$(成员总大小) 按$(整体对齐系数) 圆整= 8 /&lt;em&gt; 8%1=0 &lt;/em&gt;/ [注1]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[注1] 什么是圆整&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举例说明：如上面的8 字节对齐中的“整体对齐”，整体大小=9 按4 圆整= 12&lt;/p&gt;
&lt;p&gt;圆整的过程：从9 开始每次加一，看是否能被4 整除，这里9，10，11 均不能被4 整除，到12 时可以，则圆整结束。&lt;/p&gt;
&lt;h2 id=&quot;字节对齐-pragma-pack-2&quot;&gt;&lt;a href=&quot;#字节对齐-pragma-pack-2&quot; class=&quot;headerlink&quot; title=&quot;字节对齐(#pragma pack(2))&quot;&gt;&lt;/a&gt;字节对齐(#pragma pack(2))&lt;/h2&gt;&lt;p&gt;输出结果：sizeof(struct test_t) = 10 [两个编译器输出一致]&lt;/p&gt;
&lt;p&gt;分析过程：&lt;/p&gt;
&lt;h3 id=&quot;成员数据对齐-1&quot;&gt;&lt;a href=&quot;#成员数据对齐-1&quot; class=&quot;headerlink&quot; title=&quot;成员数据对齐&quot;&gt;&lt;/a&gt;成员数据对齐&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#pragma pack(2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct test_t &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 长度4 &amp;gt; 2 按2 对齐；起始offset=0 0%2=0；存放位置区间[0,3] */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     /* 长度1 &amp;lt; 2 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 长度2 = 2 按2 对齐；起始offset=6 6%2=0；存放位置区间[6,7] */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    short c;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 长度1 &amp;lt; 2 按1 对齐；起始offset=8 8%1=0；存放位置区间[8] */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char d;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;#pragma pack()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;成员总大小=9&lt;/p&gt;
&lt;h3 id=&quot;整体对齐-1&quot;&gt;&lt;a href=&quot;#整体对齐-1&quot; class=&quot;headerlink&quot; title=&quot;整体对齐&quot;&gt;&lt;/a&gt;整体对齐&lt;/h3&gt;&lt;p&gt;整体对齐系数= min((max(int,short,char), 2) = 2&lt;/p&gt;
&lt;p&gt;整体大小(size)=$(成员总大小) 按$(整体对齐系数) 圆整= 10 /&lt;em&gt; 10%2=0 &lt;/em&gt;/&lt;/p&gt;
&lt;h2 id=&quot;字节对齐-pragma-pack-4&quot;&gt;&lt;a href=&quot;#字节对齐-pragma-pack-4&quot; class=&quot;headerlink&quot; title=&quot;字节对齐(#pragma pack(4))&quot;&gt;&lt;/a&gt;字节对齐(#pragma pack(4))&lt;/h2&gt;&lt;p&gt;输出结果：sizeof(struct test_t) = 12 [两个编译器输出一致]&lt;/p&gt;
&lt;p&gt;分析过程：&lt;/p&gt;
&lt;h3 id=&quot;成员数据对齐-2&quot;&gt;&lt;a href=&quot;#成员数据对齐-2&quot; class=&quot;headerlink&quot; title=&quot;成员数据对齐&quot;&gt;&lt;/a&gt;成员数据对齐&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#pragma pack(4)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct test_t &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 长度4 = 4 按4 对齐；起始offset=0 0%4=0；存放位置区间[0,3] */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 长度1 &amp;lt; 4 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 长度2 &amp;lt; 4 按2 对齐；起始offset=6 6%2=0；存放位置区间[6,7] */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    short c;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 长度1 &amp;lt; 4 按1 对齐；起始offset=8 8%1=0；存放位置区间[8] */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char d;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;#pragma pack()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;成员总大小=9&lt;/p&gt;
&lt;h3 id=&quot;整体对齐-2&quot;&gt;&lt;a href=&quot;#整体对齐-2&quot; class=&quot;headerlink&quot; title=&quot;整体对齐&quot;&gt;&lt;/a&gt;整体对齐&lt;/h3&gt;&lt;p&gt;整体对齐系数= min((max(int,short,char), 4) = 4&lt;/p&gt;
&lt;p&gt;整体大小(size)=$(成员总大小) 按$(整体对齐系数) 圆整= 12 /&lt;em&gt; 12%4=0 &lt;/em&gt;/&lt;/p&gt;
&lt;h2 id=&quot;字节对齐-pragma-pack-8&quot;&gt;&lt;a href=&quot;#字节对齐-pragma-pack-8&quot; class=&quot;headerlink&quot; title=&quot;字节对齐(#pragma pack(8))&quot;&gt;&lt;/a&gt;字节对齐(#pragma pack(8))&lt;/h2&gt;&lt;p&gt;输出结果：sizeof(struct test_t) = 12 [两个编译器输出一致]&lt;/p&gt;
&lt;p&gt;分析过程：&lt;/p&gt;
&lt;h3 id=&quot;成员数据对齐-3&quot;&gt;&lt;a href=&quot;#成员数据对齐-3&quot; class=&quot;headerlink&quot; title=&quot;成员数据对齐&quot;&gt;&lt;/a&gt;成员数据对齐&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma pack(8)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct test_t &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 长度4 &amp;lt; 8 按4 对齐；起始offset=0 0%4=0；存放位置区间[0,3] */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 长度1 &amp;lt; 8 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 长度2 &amp;lt; 8 按2 对齐；起始offset=6 6%2=0；存放位置区间[6,7] */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    short c; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 长度1 &amp;lt; 8 按1 对齐；起始offset=8 8%1=0；存放位置区间[8] */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char d;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;#pragma pack()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;成员总大小=9&lt;/p&gt;
&lt;h3 id=&quot;整体对齐-3&quot;&gt;&lt;a href=&quot;#整体对齐-3&quot; class=&quot;headerlink&quot; title=&quot;整体对齐&quot;&gt;&lt;/a&gt;整体对齐&lt;/h3&gt;&lt;p&gt;整体对齐系数= min((max(int,short,char), 8) = 4&lt;/p&gt;
&lt;p&gt;整体大小(size)=$(成员总大小) 按$(整体对齐系数) 圆整= 12 /&lt;em&gt; 12%4=0 &lt;/em&gt;/&lt;/p&gt;
&lt;h2 id=&quot;字节对齐-pragma-pack-16&quot;&gt;&lt;a href=&quot;#字节对齐-pragma-pack-16&quot; class=&quot;headerlink&quot; title=&quot;字节对齐(#pragma pack(16))&quot;&gt;&lt;/a&gt;字节对齐(#pragma pack(16))&lt;/h2&gt;&lt;p&gt;输出结果：sizeof(struct test_t) = 12 [两个编译器输出一致]&lt;/p&gt;
&lt;p&gt;分析过程：&lt;/p&gt;
&lt;h3 id=&quot;成员数据对齐-4&quot;&gt;&lt;a href=&quot;#成员数据对齐-4&quot; class=&quot;headerlink&quot; title=&quot;成员数据对齐&quot;&gt;&lt;/a&gt;成员数据对齐&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma pack(16)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct test_t &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 长度4 &amp;lt; 16 按4 对齐；起始offset=0 0%4=0；存放位置区间[0,3] */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 长度1 &amp;lt; 16 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 长度2 &amp;lt; 16 按2 对齐；起始offset=6 6%2=0；存放位置区间[6,7] */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    short c;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /* 长度1 &amp;lt; 16 按1 对齐；起始offset=8 8%1=0；存放位置区间[8] */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char d;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;#pragma pack()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;成员总大小=9&lt;/p&gt;
&lt;h3 id=&quot;整体对齐-4&quot;&gt;&lt;a href=&quot;#整体对齐-4&quot; class=&quot;headerlink&quot; title=&quot;整体对齐&quot;&gt;&lt;/a&gt;整体对齐&lt;/h3&gt;&lt;p&gt;整体对齐系数= min((max(int,short,char), 16) = 4&lt;/p&gt;
&lt;p&gt;整体大小(size)=$(成员总大小) 按$(整体对齐系数) 圆整= 12 /&lt;em&gt; 12%4=0 &lt;/em&gt;/&lt;/p&gt;
&lt;h1 id=&quot;五、结论&quot;&gt;&lt;a href=&quot;#五、结论&quot; class=&quot;headerlink&quot; title=&quot;五、结论&quot;&gt;&lt;/a&gt;五、结论&lt;/h1&gt;&lt;p&gt;8 字节和16 字节对齐试验证明了“规则”的第3 点：“当#pragma pack 的n 值等于或超过所有数据成员长度的时候，这个n 值的大小将不产生任何效果”。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问， 这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是内存对齐。&lt;br&gt;本文分享博主对内存对齐的一些理解。&lt;/p&gt;
    
    </summary>
    
      <category term="进阶" scheme="http://charsdavy.github.io/categories/advance/"/>
    
    
      <category term="硬件" scheme="http://charsdavy.github.io/tags/hardware/"/>
    
  </entry>
  
</feed>
