<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>iOS开发 - 成熟的夜间模式解决方案 - Chars&#39;s Tech Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="摘要：iOS夜间模式是我们在APP开发中经常会要提供的一个功能。然后，是否可以使用一些已经成熟的第三方框架呢，文章分享一个适用于夜间模式的框架 - DKNightVersion 。">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS开发 - 成熟的夜间模式解决方案">
<meta property="og:url" content="http://charsdavy.github.io/2016/06/20/ios-night-mode/index.html">
<meta property="og:site_name" content="Chars's Tech Blog">
<meta property="og:description" content="摘要：iOS夜间模式是我们在APP开发中经常会要提供的一个功能。然后，是否可以使用一些已经成熟的第三方框架呢，文章分享一个适用于夜间模式的框架 - DKNightVersion 。">
<meta property="og:image" content="http://o88e8any8.bkt.clouddn.com/DKNightVersion.gif?imageView/2/w/360">
<meta property="og:image" content="http://o88e8any8.bkt.clouddn.com/DKNightVersion.gif?imageView/2/w/360">
<meta property="og:updated_time" content="2016-08-03T12:21:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS开发 - 成熟的夜间模式解决方案">
<meta name="twitter:description" content="摘要：iOS夜间模式是我们在APP开发中经常会要提供的一个功能。然后，是否可以使用一些已经成熟的第三方框架呢，文章分享一个适用于夜间模式的框架 - DKNightVersion 。">
<meta name="twitter:image" content="http://o88e8any8.bkt.clouddn.com/DKNightVersion.gif?imageView/2/w/360">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-80507808-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">Chars</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/atom.xml">Rss</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://charsdavy.github.io"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer"><article id="post-ios-night-mode" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      iOS开发 - 成熟的夜间模式解决方案
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/06/20/ios-night-mode/" class="article-date">
  <time datetime="2016-06-20T05:03:03.000Z" itemprop="datePublished">2016-06-20</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

      
        <div class="article-comment-link-wrap">
          <a href="http://charsdavy.github.io/2016/06/20/ios-night-mode/#ds-thread" class="article-comment-link">Comments</a>
        </div>
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>摘要：iOS夜间模式是我们在APP开发中经常会要提供的一个功能。然后，是否可以使用一些已经成熟的第三方框架呢，文章分享一个适用于夜间模式的框架 - DKNightVersion 。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/DKNightVersion.gif?imageView/2/w/360" alt="效果图"></p>
<a id="more"></a>
<h1 id="方法调剂的版本"><a href="#方法调剂的版本" class="headerlink" title="方法调剂的版本"></a>方法调剂的版本</h1><p>如何在不改变原有的架构，甚至不改变原有的代码的基础上，为应用优雅地添加夜间模式成为很多开发者不得不面对的问题。这也是 1.0 时代的 DKNightVersion 想要实现的目标。</p>
<p>其核心思路就是使用方法调剂修改 backgroundColor 的存取方法。</p>
<h1 id="使用-nightBackgroundColor"><a href="#使用-nightBackgroundColor" class="headerlink" title="使用 nightBackgroundColor"></a>使用 nightBackgroundColor</h1><p>在思考之后，我想到，想要在不改动原有代码的基础上实现夜间模式只能通过在分类中添加 nightBackgroundColor 属性，并且使用方法调剂改变 backgroundColor 的 setter 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)hook_setBackgroundColor:(UIColor*)backgroundColor &#123;</span><br><span class="line">    if ([DKNightVersionManager currentThemeVersion] == DKThemeVersionNormal) &#123;</span><br><span class="line">        [self setNormalBackgroundColor:backgroundColor];</span><br><span class="line">    &#125;</span><br><span class="line">    [self hook_setBackgroundColor:backgroundColor];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在当前主题为 DKThemeVersionNormal 时，将颜色保存至 normalBackgroundColor 中，然后再调用原 backgroundColor 的 setter 方法，更新视图的颜色。</p>
<h1 id="DKNightVersionManager"><a href="#DKNightVersionManager" class="headerlink" title="DKNightVersionManager"></a>DKNightVersionManager</h1><p>这里只解决了颜色设置的问题，下面会说明，如果在主题改变时，实时更新颜色，而不用重新进入当前页面。</p>
<p>整个 DKNightVersion 都是由一个 DKNightVersionManager 的单例来管理的，而它的主要工作就是负责改变应用的主题、并在主题改变时通知其它视图更新颜色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)changeColor:(id &lt;DKNightVersionChangeColorProtocol&gt;)object &#123;</span><br><span class="line">    if ([object respondsToSelector:@selector(changeColor)]) &#123;</span><br><span class="line">        [object changeColor];</span><br><span class="line">    &#125;</span><br><span class="line">    if ([object respondsToSelector:@selector(subviews)]) &#123;</span><br><span class="line">        if (![object subviews]) &#123;</span><br><span class="line">            // Basic case, do nothing.</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (id subview in [object subviews]) &#123;</span><br><span class="line">                // recursive darken all the subviews of current view.</span><br><span class="line">                [self changeColor:subview];</span><br><span class="line">                if ([subview respondsToSelector:@selector(changeColor)]) &#123;</span><br><span class="line">                    [subview changeColor];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果主题更新，那么就会递归地调用 changeColor 方法，刷新全部的视图颜色，而这个方法的实现比较简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)changeColor &#123;</span><br><span class="line">    if ([DKNightVersionManager currentThemeVersion] == DKThemeVersionNormal) &#123;</span><br><span class="line">        self.backgroundColor = self.normalBackgroundColor;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        self.backgroundColor = self.nightBackgroundColor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是整个框架在 1.0 版本时的实现思路。不过这个版本的 DKNightVersion 在实际应用中会有比较多的问题：</p>
<ul>
<li>在高速滚动的 scrollView 上面来回切换夜间模式，会出现颜色错乱的问题</li>
<li>由于对 backgroundColor 属性进行不合适的方法调剂，其行为无法预测，比如：在设置颜色后，再取出，不一定与设置时传入的颜色相同</li>
<li>无法适配第三方 UI 控件</li>
</ul>
<h1 id="使用色表的版本"><a href="#使用色表的版本" class="headerlink" title="使用色表的版本"></a>使用色表的版本</h1><p>为了解决 1.0 中的各种问题，我决定在 2.0 版本中放弃对 nightBackgroundColor 的使用，并且重新设计底层的实现，转而使用更为稳定、安全的方法实现夜间模式，先看一下效果图：</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/DKNightVersion.gif?imageView/2/w/360" alt="效果图"></p>
<p>新的实现支持夜间模式，且支持多主题</p>
<h1 id="DKColorPicker"><a href="#DKColorPicker" class="headerlink" title="DKColorPicker"></a>DKColorPicker</h1><p>与上一个版本实现上的不同，在 2.0 中删除了全部的 nightBackgroundColor，使用一个名为 dk_backgroundColorPicker 的属性取代它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, copy) DKColorPicker dk_backgroundColorPicker;</span><br></pre></td></tr></table></figure>
<p>这个属性其实就是一个 block，它接收参数 DKThemeVersion <em>themeVersion，但是会返回一个 UIColor </em>：</p>
<p>在第一次传入 picker 或者每次主题改变时，都会将当前主题 DKThemeVersion 传入 picker 并执行，然后，将得到的 UIColor 赋值给对应的属性 backgroundColor 更新视图颜色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef UIColor *(^DKColorPicker)(DKThemeVersion *themeVersion);</span><br></pre></td></tr></table></figure>
<p>比如下面使用 DKColorPickerWithRGB 创建一个临时的 DKColorPicker：</p>
<ul>
<li>在 DKThemeVersionNormal 时返回 0xffffff</li>
<li>在 DKThemeVersionNight 时返回 0x343434</li>
<li>在自定义的主题下返回 0xfafafa （这里的顺序与色表中主题的顺序有关）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell.dk_backgroundColorPicker = DKColorPickerWithRGB(0xffffff, 0x343434, 0xfafafa);</span><br></pre></td></tr></table></figure>
<p>同时，每一个对象还持有一个 pickers 数组，来存储自己的全部 DKColorPicker：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject ()</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, DKColorPicker&gt; *pickers;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>在第一次使用这个属性时，当前对象注册为 DKNightVersionThemeChangingNotificaiton 通知的观察者。</p>
<p>在每次收到通知时，都会调用 night_update 方法，将当前主题传入 DKColorPicker，并再次执行，并将结果传入对应的属性 [self performSelector:sel withObject:result]。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)night_updateColor &#123;</span><br><span class="line">    [self.pickers enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull selector, DKColorPicker  _Nonnull picker, BOOL * _Nonnull stop) &#123;</span><br><span class="line">        SEL sel = NSSelectorFromString(selector);</span><br><span class="line">        id result = picker(self.dk_manager.themeVersion);</span><br><span class="line">        [UIView animateWithDuration:DKNightVersionAnimationDuration  animations:^&#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</span><br><span class="line">       [self performSelector:sel withObject:result];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">           &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，在每次改变主题的时候，都会发出通知。</p>
<h1 id="DKColorTable"><a href="#DKColorTable" class="headerlink" title="DKColorTable"></a>DKColorTable</h1><p>虽然我们在上面临时创建了一些 DKColorPicker。不过在 DKNightVersion 中，我更推荐使用色表，来减少相同的 DKColorPicker 的创建，并且能够更好地管理整个应用中的颜色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NORMAL   NIGHT    RED  </span><br><span class="line">#ffffff          #343434  #fafafa      BG</span><br><span class="line">#aaaaaa    #313131   #aaaaaa  SEP</span><br><span class="line">#0000ff      #ffffff          #fa0000   TINT</span><br><span class="line">#000000    #ffffff          #000000  TEXT</span><br><span class="line">#ffffff          #444444    #ffffff BAR</span><br></pre></td></tr></table></figure>
<p>上面就是默认色表文件 DKColorTable.txt 中的内容，其中，第一行表示主题，NORMAL 主题必须存在，而且必须为第一列，而最右面的 BG、SEP 就是对应 DKColorPicker 的 key。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.tableView.dk_backgroundColorPicker =  DKColorPickerWithKey(BG);</span><br></pre></td></tr></table></figure>
<p>在使用时，上面的代码就相当于返回了一个在 NORMAL 时返回 #ffffff、NIGHT 时返回 #343434 以及 RED 时返回 #fafafa 的 DKColorPicker。</p>
<h1 id="pickerify"><a href="#pickerify" class="headerlink" title="pickerify"></a>pickerify</h1><p>虽然说，我们使用色表以及 DKColorPicker 解决了，但是，到目前为止我们还没有解决第三方框架的问题。</p>
<p>比如我们使用了某个第三方框架，或者自己添加了某个 color 属性，比如说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface DKView ()</span><br><span class="line">@property (nonatomic, strong) UIColor *weirdColor;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>weirdColor 并没有对应的 DKColorPicker，但是，我们可以通过 pickerify 在想要使用 dk_weirdColorPicker 的地方生成这个对应的 picker：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@pickerify(DKView, weirdColor);</span><br></pre></td></tr></table></figure>
<p>然后，我们就可以使用 dk_weirdColorPicker 属性了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.dk_weirdColorPicker = DKColorPickerWithKey(BG);</span><br></pre></td></tr></table></figure>
<p>pickerify 其实是一个宏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#define pickerify(KLASS, PROPERTY) interface \</span><br><span class="line">    KLASS (Night) \</span><br><span class="line">    @property (nonatomic, copy, setter = dk_set ## PROPERTY ## Picker:) DKColorPicker dk_ ## PROPERTY ## Picker; \</span><br><span class="line">    @end \</span><br><span class="line">    @interface \</span><br><span class="line">    KLASS () \</span><br><span class="line">    @property (nonatomic, strong) NSMutableDictionary&lt;NSString *, DKColorPicker&gt; *pickers; \</span><br><span class="line">    @end \</span><br><span class="line">    @implementation \</span><br><span class="line">    KLASS (Night) \</span><br><span class="line">    - (DKColorPicker)dk_ ## PROPERTY ## Picker &#123; \</span><br><span class="line">        return objc_getAssociatedObject(self, @selector(dk_ ## PROPERTY ## Picker)); \</span><br><span class="line">    &#125; \</span><br><span class="line">    - (void)dk_set ## PROPERTY ## Picker:(DKColorPicker)picker &#123; \</span><br><span class="line">        objc_setAssociatedObject(self, @selector(dk_ ## PROPERTY ## Picker), picker, OBJC_ASSOCIATION_COPY_NONATOMIC); \</span><br><span class="line">        [self setValue:picker(self.dk_manager.themeVersion) forKeyPath:@keypath(self, PROPERTY)];\</span><br><span class="line">        [self.pickers setValue:[picker copy] forKey:_DKSetterWithPROPERTYerty(@#PROPERTY)]; \</span><br><span class="line">    &#125; \</span><br><span class="line">    @end</span><br></pre></td></tr></table></figure>
<p>这个宏根据传入的类和属性名，为我们生成了对应 picker 的存取方法，它也可以说是一种元编程的手段。</p>
<p>这里生成的 setter 方法不是标准意义上的驼峰命名法 dk_setweirdColorPicker:，因为我不知道怎么才能让大写首字母之后的属性添加到这里（如果各位读者有解决方案，欢迎提 PR 或者 issue）。</p>
<h1 id="嵌入式-Ruby"><a href="#嵌入式-Ruby" class="headerlink" title="嵌入式 Ruby"></a>嵌入式 Ruby</h1><p>由于框架中很多的代码，都是重复的，所以在这里使用了嵌入式 Ruby 模板来生成对应的文件 color.m.irb：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  &lt;%= klass.name %&gt;+Night.m</span><br><span class="line">//  &lt;%= klass.name %&gt;+Night</span><br><span class="line">//</span><br><span class="line">//  Copyright (c) 2015 Draveness. All rights reserved.</span><br><span class="line">//</span><br><span class="line">//  These files are generated by ruby script, if you want to modify code</span><br><span class="line">//  in this file, you are supposed to update the ruby code, run it and</span><br><span class="line">//  test it. And finally open a pull request.</span><br><span class="line">#import &quot;&lt;%= klass.name %&gt;+Night.h&quot;</span><br><span class="line">#import &quot;DKNightVersionManager.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">@interface &lt;%= klass.name %&gt; ()</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, DKColorPicker&gt; *pickers;</span><br><span class="line">@end</span><br><span class="line">@implementation &lt;%= klass.name %&gt; (Night)</span><br><span class="line">&lt;% klass.properties.each do |property| %&gt;&lt;%= &quot;&quot;&quot;  </span><br><span class="line">- (DKColorPicker)dk_#&#123;property.name&#125;Picker &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, @selector(dk_#&#123;property.name&#125;Picker));</span><br><span class="line">&#125;</span><br><span class="line">- (void)dk_set#&#123;property.cap_name&#125;Picker:(DKColorPicker)picker &#123;</span><br><span class="line">    objc_setAssociatedObject(self, @selector(dk_#&#123;property.name&#125;Picker), picker, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">    self.#&#123;property.name&#125; = picker(self.dk_manager.themeVersion);</span><br><span class="line">    [self.pickers setValue:[picker copy] forKey:@\&quot;#&#123;property.setter&#125;\&quot;];</span><br><span class="line">&#125;</span><br><span class="line">&quot;&quot;&quot; %&gt;&lt;% end %&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这部分的实现并不在这篇文章的讨论范围之内，如果，对这部分看兴趣，可以看一下仓库中的 generator 文件夹，其中包含了代码生成器的全部代码。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>如果你对 DKNightVersion 的使用有兴趣，可以查看仓库的 README 文件，有人会说不要在项目中 ObjC runtime，我个人觉得是没有问题，AFNetworking、 BlocksKit 也使用方法调剂来改变原有方法的实现，不能因为它强大就不使用它；正相反，有时候，使用 runtime 才能优雅地解决问题。</p>
<p>GitHub地址:<a href="https://github.com/draveness/iOS-Source-Code-Analyze">https://github.com/draveness/iOS-Source-Code-Analyze</a></p>
<p>原文地址：<a href="http://draveness.me/night">http://draveness.me/night</a></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UI/">UI</a></li></ul>

      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/06/24/hexo-extern-scroll-top/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          Hexo 博客功能扩展 - 添加回滚到顶部按钮
        
      </div>
    </a>
  
  
    <a href="/2016/06/17/ios-sdwebimage-code-reading/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">iOS 源代码分析 - SDWebImage&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>




<div class="share_addthis">
  <div class="sharing addthis_toolbox share">
    <a class="addthis_button_facebook_like"></a>
    <a class="addthis_button_tweet"></a>
    <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-560c64c35486b3d4" async="async"></script>
</div>






<section id="comments">
  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-ios-night-mode" data-title="iOS开发 - 成熟的夜间模式解决方案" data-url="http://charsdavy.github.io/2016/06/20/ios-night-mode/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
  var duoshuoQuery = {short_name:'charsdavy'};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] 
       || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
  <!-- 多说公共JS代码 end -->
</section>
</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Chars Davy&nbsp;
     </div>
  </div>
</footer>

    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>