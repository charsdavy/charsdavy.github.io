<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>iOS 源代码分析 - SDWebImage | Chars&#39;s Tech Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="摘要：世人都说阅读源代码对于功力的提升是十分显著的, 但是很多的著名开源框架源代码动辄上万行, 复杂度实在太高, 曾经试图读一些开源框架的源代码, 比如说 AFNetworking, SDWebImage, ReactiveCocoa 但是由于当时比较浮躁, 实在没法静下心来看, 而且有一些急功近利, 所以面对宝藏实在无力挖掘. 而最近, 由于时间比较充裕, 也终于能静下心来一段一段分析这些著名项">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS 源代码分析 - SDWebImage">
<meta property="og:url" content="http://charsdavy.github.io/2016/06/17/ios-sdwebimage-code-reading/index.html">
<meta property="og:site_name" content="Chars's Tech Blog">
<meta property="og:description" content="摘要：世人都说阅读源代码对于功力的提升是十分显著的, 但是很多的著名开源框架源代码动辄上万行, 复杂度实在太高, 曾经试图读一些开源框架的源代码, 比如说 AFNetworking, SDWebImage, ReactiveCocoa 但是由于当时比较浮躁, 实在没法静下心来看, 而且有一些急功近利, 所以面对宝藏实在无力挖掘. 而最近, 由于时间比较充裕, 也终于能静下心来一段一段分析这些著名项">
<meta property="og:image" content="http://o88e8any8.bkt.clouddn.com/sdwebimage-flow-chart.png?imageView/2/w/400">
<meta property="og:updated_time" content="2016-07-12T23:17:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS 源代码分析 - SDWebImage">
<meta name="twitter:description" content="摘要：世人都说阅读源代码对于功力的提升是十分显著的, 但是很多的著名开源框架源代码动辄上万行, 复杂度实在太高, 曾经试图读一些开源框架的源代码, 比如说 AFNetworking, SDWebImage, ReactiveCocoa 但是由于当时比较浮躁, 实在没法静下心来看, 而且有一些急功近利, 所以面对宝藏实在无力挖掘. 而最近, 由于时间比较充裕, 也终于能静下心来一段一段分析这些著名项">
<meta name="twitter:image" content="http://o88e8any8.bkt.clouddn.com/sdwebimage-flow-chart.png?imageView/2/w/400">
  
    <link rel="alternative" href="/atom.xml" title="Chars&#39;s Tech Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Chars Davy</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>About</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/charsdavy" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/u/3875245858/" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="/chars_d@126.com" title="mail">mail</a>
					        
								<a class="twitter" target="_blank" href="https://twitter.com/charsdavy" title="twitter">twitter</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/script/" style="font-size: 15px;">hexo</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/script/" style="font-size: 10px;">markdown</a> <a href="/tags/assistant/" style="font-size: 17.5px;">开发助手</a> <a href="/tags/framework/" style="font-size: 12.5px;">开源框架</a> <a href="/tags/Japanese/" style="font-size: 10px;">日语</a> <a href="/tags/script/" style="font-size: 10px;">正则表达式</a> <a href="/tags/hardware/" style="font-size: 10px;">硬件</a> <a href="/tags/algorithm/" style="font-size: 12.5px;">算法</a> <a href="/tags/网络/" style="font-size: 12.5px;">网络</a> <a href="/tags/design-pattern/" style="font-size: 15px;">设计模式</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jianshu.com/users/bd2336d8f946/latest_articles">Chars</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://casatwy.com/">casatwy</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://cenalulu.github.io/">cenalulu</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://developer.apple.com/swift/blog/">Swift_Blog</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">Chars @ ZAKER 立志成为全栈攻城狮。喜欢游泳，羽毛球。 爱好一个人静静写代码，看代码，看书。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Chars Davy</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/avatar.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Chars Davy</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/charsdavy" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/3875245858/" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="/chars_d@126.com" title="mail">mail</a>
			        
						<a class="twitter" target="_blank" href="https://twitter.com/charsdavy" title="twitter">twitter</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-ios-sdwebimage-code-reading" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/17/ios-sdwebimage-code-reading/" class="article-date">
  	<time datetime="2016-06-17T11:50:38.000Z" itemprop="datePublished">2016-06-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      iOS 源代码分析 - SDWebImage
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/framework/">开源框架</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/develop/">移动开发</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>摘要：世人都说阅读源代码对于功力的提升是十分显著的, 但是很多的著名开源框架源代码动辄上万行, 复杂度实在太高, 曾经试图读一些开源框架的源代码, 比如说 AFNetworking, SDWebImage, ReactiveCocoa 但是由于当时比较浮躁, 实在没法静下心来看, 而且有一些急功近利, 所以面对宝藏实在无力挖掘. 而最近, 由于时间比较充裕, 也终于能静下心来一段一段分析这些著名项目的源代码. 本文主要分享SDWebImage框架源代码的相关信息. </p>
<a id="more"></a>
<h1 id="简洁的接口"><a href="#简洁的接口" class="headerlink" title="简洁的接口"></a>简洁的接口</h1><p>首先来介绍一下这个 SDWebImage 这个著名开源框架, 这个开源框架的主要作用就是:</p>
<blockquote>
<p>Asynchronous image downloader with cache support with an UIImageView category.</p>
</blockquote>
<p>一个异步下载图片并且支持缓存的 UIImageView 分类.</p>
<p>就这么直译过来相信各位也能理解, 框架中最最常用的方法其实就是这个:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self.imageView sd_setImageWithURL:[NSURL URLWithString:@&quot;url&quot;]  placeholderImage:[UIImage imageNamed:@&quot;placeholder.png&quot;]];</span><br></pre></td></tr></table></figure>
<p>当然这个框架中还有 UIButton 的分类, 可以给 UIButton 异步加载图片, 不过这个并没有 UIImageView 分类中的这个方法常用.</p>
<p>这个框架的设计还是极其的优雅和简洁, 主要的功能就是这么一行代码, 而其中复杂的实现细节全部隐藏在这行代码之后, 正应了那句话:</p>
<blockquote>
<p>把简洁留给别人, 把复杂留给自己.</p>
</blockquote>
<p>我们已经看到了这个框架简洁的接口, 接下来我们看一下 SDWebImage 是用什么样的方式优雅地实现异步加载图片和缓存的功能呢?</p>
<h1 id="复杂的实现"><a href="#复杂的实现" class="headerlink" title="复杂的实现"></a>复杂的实现</h1><p>其实复杂只是相对于简洁而言的, 并不是说 SDWebImage 的实现就很糟糕, 相反, 它的实现还是非常 amazing 的.</p>
<p>UIImageView+WebCache 和 UIButton+WebCache 直接为表层的 UIKit 框架提供接口, 而 SDWebImageManger 负责处理和协调 SDWebImageDownloader 和 SDWebImageCache. 并与 UIKit 层进行交互, 而底层的一些类为更高层级的抽象提供支持.</p>
<p>在这里我们会忽略很多的实现细节, 并不会对每一行源代码逐一解读.</p>
<h1 id="UIImageView-WebCache"><a href="#UIImageView-WebCache" class="headerlink" title="UIImageView+WebCache"></a>UIImageView+WebCache</h1><p>接下来我们就以 UIImageView+WebCache 中的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(NSURL *)url  placeholderImage:(UIImage *)placeholder;</span><br></pre></td></tr></table></figure>
<p>这一方法为入口研究一下 SDWebImage 是怎样工作的. 我们打开上面这段方法的实现代码 UIImageView+WebCache.m</p>
<p>当然你也可以<code>git clone git@github.com:rs/SDWebImage.git</code>到本地来查看.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(NSURL *)url </span><br><span class="line">          placeholderImage:(UIImage *)placeholder &#123;</span><br><span class="line">    [self sd_setImageWithURL:url </span><br><span class="line">            placeholderImage:placeholder </span><br><span class="line">             options:0 </span><br><span class="line">             progress:nil </span><br><span class="line">             completed:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段方法唯一的作用就是调用了另一个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self sd_setImageWithURL:placeholderImage:options:progress:completed:]</span><br></pre></td></tr></table></figure>
<p>在这个文件中, 你会看到很多的<code>sd_setImageWithURL......</code>方法, 它们最终都会调用上面这个方法, 只是根据需要传入不同的参数, 这在很多的开源项目中乃至我们平时写的项目中都是很常见的. 而这个方法也是 UIImageView+WebCache 中的核心方法.</p>
<p>这里就不再复制出这个方法的全部实现了.</p>
<h1 id="操作的管理"><a href="#操作的管理" class="headerlink" title="操作的管理"></a>操作的管理</h1><p>这是这个方法的第一行代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// UIImageView+WebCache</span><br><span class="line">// sd_setImageWithURL:placeholderImage:options:progress:completed: #1</span><br><span class="line">[self sd_cancelCurrentImageLoad];</span><br></pre></td></tr></table></figure>
<p>这行看似简单的代码最开始是被我忽略的, 我后来才发现蕴藏在这行代码之后的思想, 也就是 SDWebImage 管理操作的办法.</p>
<p>框架中的所有操作实际上都是通过一个 operationDictionary 来管理, 而这个字典实际上是动态的添加到 UIView 上的一个属性, 至于为什么添加到 UIView 上, 主要是因为这个 operationDictionary 需要在 UIButton 和 UIImageView 上重用, 所以需要添加到它们的根类上.</p>
<p>这行代码是要保证没有当前正在进行的异步下载操作, 不会与即将进行的操作发生冲突, 它会调用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// UIImageView+WebCache</span><br><span class="line">// sd_cancelCurrentImageLoad #1</span><br><span class="line">[self sd_cancelImageLoadOperationWithKey:@&quot;UIImageViewImageLoad&quot;]</span><br></pre></td></tr></table></figure>
<p>而这个方法会使当前 UIImageView 中的所有操作都被 cancel. 不会影响之后进行的下载操作.</p>
<h1 id="占位图的实现"><a href="#占位图的实现" class="headerlink" title="占位图的实现"></a>占位图的实现</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// UIImageView+WebCache</span><br><span class="line">// sd_setImageWithURL:placeholderImage:options:progress:completed: #4</span><br><span class="line">if (!(options &amp; SDWebImageDelayPlaceholder)) &#123;  </span><br><span class="line">    self.image = placeholder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果传入的 options 中没有 SDWebImageDelayPlaceholder(默认情况下 options == 0), 那么就会为 UIImageView 添加一个临时的 image, 也就是占位图.</p>
<h1 id="获取图片"><a href="#获取图片" class="headerlink" title="获取图片"></a>获取图片</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// UIImageView+WebCache</span><br><span class="line">// sd_setImageWithURL:placeholderImage:options:progress:completed: #8</span><br><span class="line">if (url)</span><br></pre></td></tr></table></figure>
<p>接下来会检测传入的 url 是否非空, 如果非空那么一个全局的 SDWebImageManager 就会调用以下的方法获取图片:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[SDWebImageManager.sharedManager downloadImageWithURL:options:progress:completed:]</span><br></pre></td></tr></table></figure>
<p>下载完成后会调用 (SDWebImageCompletionWithFinishedBlock)completedBlock 为 UIImageView.image 赋值, 添加上最终所需要的图片.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// UIImageView+WebCache</span><br><span class="line">// sd_setImageWithURL:placeholderImage:options:progress:completed: #10</span><br><span class="line">dispatch_main_sync_safe(^&#123;  </span><br><span class="line">    if (!wself) return;</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        wself.image = image;</span><br><span class="line">        [wself setNeedsLayout];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if ((options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">            wself.image = placeholder;</span><br><span class="line">            [wself setNeedsLayout];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (completedBlock &amp;&amp; finished) &#123;</span><br><span class="line">        completedBlock(image, error, cacheType, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="dispatch-main-sync-safe-宏定义"><a href="#dispatch-main-sync-safe-宏定义" class="headerlink" title="dispatch_main_sync_safe 宏定义"></a>dispatch_main_sync_safe 宏定义</h1><p>上述代码中的 dispatch_main_sync_safe 是一个宏定义, 点进去一看发现宏是这样定义的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define dispatch_main_sync_safe(block)\</span><br><span class="line">    if ([NSThread isMainThread]) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>相信这个宏的名字已经讲他的作用解释的很清楚了: 因为图像的绘制只能在主线程完成, 所以, dispatch_main_sync_safe 就是为了保证 block 能在主线程中执行.</p>
<p>而最后, 在<code>[SDWebImageManager.sharedManager downloadImageWithURL:options:progress:completed:]</code>返回 operation 的同时, 也会向 operationDictionary 中添加一个键值对, 来表示操作的正在进行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// UIImageView+WebCache</span><br><span class="line">// sd_setImageWithURL:placeholderImage:options:progress:completed: #28</span><br><span class="line">[self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;];</span><br></pre></td></tr></table></figure>
<p>它将 opertion 存储到 operationDictionary 中方便以后的 cancel.</p>
<p>到此为止我们已经对 SDWebImage 框架中的这一方法分析完了, 接下来我们将要分析 SDWebImageManager 中的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[SDWebImageManager.sharedManager downloadImageWithURL:options:progress:completed:]</span><br></pre></td></tr></table></figure>
<h1 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h1><p>在 SDWebImageManager.h 中你可以看到关于 SDWebImageManager 的描述:</p>
<blockquote>
<p>The SDWebImageManager is the class behind the UIImageView+WebCache category and likes. It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache). You can use this class directly to benefit from web image downloading with caching in another context than a UIView.</p>
</blockquote>
<p>这个类就是隐藏在 UIImageView+WebCache 背后, 用于处理异步下载和图片缓存的类, 当然你也可以直接使用 SDWebImageManager 的上述方法 <code>downloadImageWithURL:options:progress:completed:</code>来直接下载图片.</p>
<p>可以看到, 这个类的主要作用就是为 UIImageView+WebCache 和 SDWebImageDownloader, SDImageCache 之间构建一个桥梁, 使它们能够更好的协同工作, 我们在这里分析这个核心方法的源代码, 它是如何协调异步下载和图片缓存的.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SDWebImageManager</span><br><span class="line">// downloadImageWithURL:options:progress:completed: #6</span><br><span class="line">if ([url isKindOfClass:NSString.class]) &#123;  </span><br><span class="line">    url = [NSURL URLWithString:(NSString *)url];</span><br><span class="line">&#125;</span><br><span class="line">if (![url isKindOfClass:NSURL.class]) &#123;  </span><br><span class="line">    url = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这块代码的功能是确定 url 是否被正确传入, 如果传入参数的是 NSString 类型就会被转换为 NSURL. 如果转换失败, 那么 url 会被赋值为空, 这个下载的操作就会出错.</p>
<h1 id="SDWebImageCombinedOperation"><a href="#SDWebImageCombinedOperation" class="headerlink" title="SDWebImageCombinedOperation"></a>SDWebImageCombinedOperation</h1><p>当 url 被正确传入之后, 会实例一个非常奇怪的 “operation”, 它其实是一个遵循 SDWebImageOperation 协议的 NSObject 的子类. 而这个协议也非常的简单:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@protocol SDWebImageOperation &lt;NSObject&gt;</span><br><span class="line">- (void)cancel;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这里仅仅是将这个 SDWebImageOperation 类包装成一个看着像 NSOperation 其实并不是 NSOperation 的类, 而这个类唯一与 NSOperation 的相同之处就是它们都可以响应 cancel 方法. </p>
<p>而调用这个类的存在实际是为了使代码更加的简洁, 因为调用这个类的 cancel 方法, 会使得它持有的两个 operation 都被 cancel.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SDWebImageCombinedOperation</span><br><span class="line">// cancel #1</span><br><span class="line">- (void)cancel &#123;</span><br><span class="line">    self.cancelled = YES;</span><br><span class="line">    if (self.cacheOperation) &#123;</span><br><span class="line">        [self.cacheOperation cancel];</span><br><span class="line">        self.cacheOperation = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.cancelBlock) &#123;</span><br><span class="line">        self.cancelBlock();</span><br><span class="line">        _cancelBlock = nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个类, 应该是为了实现更简洁的 cancel 操作而设计出来的. 既然我们获取了 url, 再通过 url 获取对应的 key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *key = [self cacheKeyForURL:url];</span><br></pre></td></tr></table></figure>
<p>下一步是使用 key 在缓存中查找以前是否下载过相同的图片.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">operation.cacheOperation = [self.imageCache  </span><br><span class="line">queryDiskCacheForKey:key </span><br><span class="line">done:^(UIImage *image, SDImageCacheType cacheType) &#123; ... &#125;];</span><br></pre></td></tr></table></figure>
<p>这里调用 SDImageCache 的实例方法 queryDiskCacheForKey:done: 来尝试在缓存中获取图片的数据. 而这个方法返回的就是货真价实的 NSOperation.</p>
<p>如果我们在缓存中查找到了对应的图片, 那么我们直接调用 completedBlock 回调块结束这一次的图片下载操作.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SDWebImageManager</span><br><span class="line">// downloadImageWithURL:options:progress:completed: #47</span><br><span class="line">dispatch_main_sync_safe(^&#123;  </span><br><span class="line">    completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果我们没有找到图片, 那么就会调用 SDWebImageDownloader 的实例方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id &lt;SDWebImageOperation&gt; subOperation =  </span><br><span class="line"> [self.imageDownloader </span><br><span class="line">    downloadImageWithURL:url </span><br><span class="line">    options:downloaderOptions </span><br><span class="line">    progress:progressBlock </span><br><span class="line">    completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) &#123; ... &#125;];</span><br></pre></td></tr></table></figure>
<p>如果这个方法返回了正确的 downloadedImage, 那么我们就会在全局的缓存中存储这个图片的数据:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self.imageCache </span><br><span class="line">    storeImage:downloadedImage </span><br><span class="line">    recalculateFromImage:NO </span><br><span class="line">    imageData:data </span><br><span class="line">    forKey:key </span><br><span class="line">    toDisk:cacheOnDisk];</span><br></pre></td></tr></table></figure>
<p>并调用 completedBlock 对 UIImageView 或者 UIButton 添加图片, 或者进行其它的操作.<br>最后, 我们将这个 subOperation 的 cancel 操作添加到 operation.cancelBlock 中. 方便操作的取消.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">operation.cancelBlock = ^&#123;  </span><br><span class="line">    [subOperation cancel];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="SDWebImageCache"><a href="#SDWebImageCache" class="headerlink" title="SDWebImageCache"></a>SDWebImageCache</h1><p>SDWebImageCache.h 这个类在源代码中有这样的注释:</p>
<blockquote>
<p>SDImageCache maintains a memory cache and an optional disk cache.</p>
</blockquote>
<p>它维护了一个内存缓存和一个可选的磁盘缓存, 我们先来看一下在上一阶段中没有解读的两个方法, 首先是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSOperation *)queryDiskCacheForKey:(NSString *)key </span><br><span class="line">    done:(SDWebImageQueryCompletedBlock)doneBlock;</span><br></pre></td></tr></table></figure>
<p>这个方法的主要功能是异步的查询图片缓存. 因为图片的缓存可能在两个地方, 而该方法首先会在内存中查找是否有图片的缓存.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SDWebImageCache</span><br><span class="line">// queryDiskCacheForKey:done: #9</span><br><span class="line">UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br></pre></td></tr></table></figure>
<p>这个 imageFromMemoryCacheForKey 方法会在 SDWebImageCache 维护的缓存 memCache 中查找是否有对应的数据, 而 memCache 就是一个 NSCache.</p>
<p>如果在内存中并没有找到图片的缓存的话, 就需要在磁盘中寻找了, 这个就比较麻烦了..</p>
<p>在这里会调用一个方法 diskImageForKey 这个方法的具体实现我在这里就不介绍了, 涉及到很多底层 Core Foundation 框架的知识, 不过这里文件名字的存储使用 MD5 处理过后的文件名.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SDImageCache</span><br><span class="line">// cachedFileNameForKey: #6</span><br><span class="line">CC_MD5(str, (CC_LONG)strlen(str), r);</span><br></pre></td></tr></table></figure>
<p>对于其它的实现细节也就不多说了…<br>如果在磁盘中查找到对应的图片, 我们会将它复制到内存中, 以便下次的使用.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SDImageCache</span><br><span class="line">// queryDiskCacheForKey:done: #24</span><br><span class="line">UIImage *diskImage = [self diskImageForKey:key];  </span><br><span class="line">if (diskImage) &#123;  </span><br><span class="line">    CGFloat cost = diskImage.size.height * diskImage.size.width * diskImage.scale;</span><br><span class="line">    [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些就是 SDImageCache 的核心内容了, 而接下来将介绍如果缓存没有命中, 图片是如何被下载的.</p>
<h1 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h1><p>按照之前的惯例, 我们先来看一下 SDWebImageDownloader.h 中对这个类的描述.</p>
<blockquote>
<p>Asynchronous downloader dedicated and optimized for image loading.</p>
</blockquote>
<p>专用的并且优化的图片异步下载器.</p>
<p>这个类的核心功能就是下载图片, 而核心方法就是上面提到的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url </span><br><span class="line">    options:(SDWebImageDownloaderOptions)options </span><br><span class="line">    progress:(SDWebImageDownloaderProgressBlock)progressBlock </span><br><span class="line">    completed:(SDWebImageDownloaderCompletedBlock)completedBlock;</span><br></pre></td></tr></table></figure>
<p>回调<br>这个方法直接调用了另一个关键的方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock </span><br><span class="line">    andCompletedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock </span><br><span class="line">    forURL:(NSURL *)url </span><br><span class="line">    createCallback:(SDWebImageNoParamsBlock)createCallback</span><br></pre></td></tr></table></figure>
<p>它为这个下载的操作添加回调的块, 在下载进行时, 或者在下载结束时执行一些操作, 先来阅读一下这个方法的源代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SDWebImageDownloader</span><br><span class="line">// addProgressCallback:andCompletedBlock:forURL:createCallback: #10</span><br><span class="line">BOOL first = NO;  </span><br><span class="line">if (!self.URLCallbacks[url]) &#123;  </span><br><span class="line">    self.URLCallbacks[url] = [NSMutableArray new];</span><br><span class="line">    first = YES;</span><br><span class="line">&#125;</span><br><span class="line">// Handle single download of simultaneous download request for the same URL</span><br><span class="line">NSMutableArray *callbacksForURL = self.URLCallbacks[url];  </span><br><span class="line">NSMutableDictionary *callbacks = [NSMutableDictionary new];  </span><br><span class="line">if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];  </span><br><span class="line">if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];  </span><br><span class="line">[callbacksForURL addObject:callbacks];</span><br><span class="line">self.URLCallbacks[url] = callbacksForURL;</span><br><span class="line">if (first) &#123;  </span><br><span class="line">    createCallback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法会先查看这个 url 是否有对应的 callback, 使用的是 downloader 持有的一个字典 URLCallbacks.</p>
<p>如果是第一次添加回调的话, 就会执行 first = YES, 这个赋值非常的关键, 因为 first 不为 YES 那么 HTTP 请求就不会被初始化, 图片也无法被获取.</p>
<p>然后, 在这个方法中会重新修正在 URLCallbacks 中存储的回调块.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableArray *callbacksForURL = self.URLCallbacks[url];  </span><br><span class="line">NSMutableDictionary *callbacks = [NSMutableDictionary new];  </span><br><span class="line">if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];  </span><br><span class="line">if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];  </span><br><span class="line">[callbacksForURL addObject:callbacks];</span><br><span class="line">self.URLCallbacks[url] = callbacksForURL;</span><br></pre></td></tr></table></figure>
<p>如果是第一次添加回调块, 那么就会直接运行这个 createCallback 这个 block, 而这个 block, 就是我们在前一个方法 downloadImageWithURL:options:progress:completed: 中传入的回调块.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SDWebImageDownloader</span><br><span class="line">// downloadImageWithURL:options:progress:completed: #4</span><br><span class="line">[self addProgressCallback:progressBlock andCompletedBlock:completedBlock forURL:url createCallback:^&#123; ... &#125;];</span><br></pre></td></tr></table></figure>
<p>我们下面来分析这个传入的无参数的代码. 首先这段代码初始化了一个 NSMutableURLRequest:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SDWebImageDownloader</span><br><span class="line">// downloadImageWithURL:options:progress:completed: #11</span><br><span class="line">NSMutableURLRequest *request = [[NSMutableURLRequest alloc]  </span><br><span class="line">    initWithURL:url </span><br><span class="line">    cachePolicy:...</span><br><span class="line">    timeoutInterval:timeoutInterval];</span><br></pre></td></tr></table></figure>
<p>这个 request 就用于在之后发送 HTTP 请求.</p>
<p>在初始化了这个 request 之后, 又初始化了一个 SDWebImageDownloaderOperation 的实例, 这个实例, 就是用于请求网络资源的操作. 它是一个 NSOperation 的子类,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SDWebImageDownloader</span><br><span class="line">// downloadImageWithURL:options:progress:completed: #20</span><br><span class="line">operation = [[SDWebImageDownloaderOperation alloc]  </span><br><span class="line">    initWithRequest:request</span><br><span class="line">    options:options</span><br><span class="line">    progress:...</span><br><span class="line">    completed:...</span><br><span class="line">    cancelled:...&#125;];</span><br></pre></td></tr></table></figure>
<p>但是在初始化之后, 这个操作并不会开始(NSOperation 实例只有在调用 start 方法或者加入 NSOperationQueue 才会执行), 我们需要将这个操作加入到一个 NSOperationQueue 中.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SDWebImageDownloader</span><br><span class="line">// downloadImageWithURL:options:progress:completed: #59</span><br><span class="line">[wself.downloadQueue addOperation:operation];</span><br></pre></td></tr></table></figure>
<p>只有将它加入到这个下载队列中, 这个操作才会执行.</p>
<h1 id="SDWebImageDownloaderOperation"><a href="#SDWebImageDownloaderOperation" class="headerlink" title="SDWebImageDownloaderOperation"></a>SDWebImageDownloaderOperation</h1><p>这个类就是处理 HTTP 请求, URL 连接的类, 当这个类的实例被加入队列之后, start 方法就会被调用, 而 start 方法首先就会产生一个 NSURLConnection.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SDWebImageDownloaderOperation</span><br><span class="line">// start #1</span><br><span class="line">@synchronized (self) &#123;</span><br><span class="line">    if (self.isCancelled) &#123;</span><br><span class="line">        self.finished = YES;</span><br><span class="line">        [self reset];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    self.executing = YES;</span><br><span class="line">    self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];</span><br><span class="line">    self.thread = [NSThread currentThread];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而接下来这个 connection 就会开始运行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SDWebImageDownloaderOperation</span><br><span class="line">// start #29</span><br><span class="line">[self.connection start];</span><br></pre></td></tr></table></figure>
<p>它会发出一个 SDWebImageDownloadStartNotification 通知</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// SDWebImageDownloaderOperation</span><br><span class="line">// start #35</span><br><span class="line">[[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self];</span><br></pre></td></tr></table></figure>
<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>在 start 方法调用之后, 就是 NSURLConnectionDataDelegate 中代理方法的调用.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response;</span><br><span class="line">- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response;</span><br><span class="line">- (void)connectionDidFinishLoading:(NSURLConnection *)aConnection;</span><br></pre></td></tr></table></figure>
<p>在这三个代理方法中的前两个会不停回调 progressBlock 来提示下载的进度.</p>
<p>而最后一个代理方法会在图片下载完成之后调用 completionBlock 来完成最后 UIImageView.image 的更新.</p>
<p>而这里调用的 progressBlock completionBlock cancelBlock 都是在之前存储在 URLCallbacks 字典中的.</p>
<p>到目前为止, 我们就基本解析了 SDWebImage 中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self.imageView </span><br><span class="line">    sd_setImageWithURL:[NSURL URLWithString:@&quot;url&quot;]</span><br><span class="line">    placeholderImage:[UIImage imageNamed:@&quot;placeholder.png&quot;]];</span><br></pre></td></tr></table></figure>
<p>这个方法执行的全部过程了.</p>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="http://o88e8any8.bkt.clouddn.com/sdwebimage-flow-chart.png?imageView/2/w/400" alt="流程图"></p>
<p>我们使用一个流程图来表示上述方法所执行的全过程.<br>这段流程图展示了上述方法调用中大部分重要方法的调用.</p>
<p>SDWebImage 如何为 UIImageView 添加图片(面试回答)</p>
<p>SDWebImage 中为 UIView 提供了一个分类叫做 WebCache, 这个分类中有一个最常用的接口, <code>sd_setImageWithURL:placeholderImage:</code>, 这个分类同时提供了很多类似的方法, 这些方法最终会调用一个同时具有 option progressBlock completionBlock 的方法, 而在这个类最终被调用的方法首先会检查是否传入了 placeholderImage 以及对应的参数, 并设置 placeholderImage.</p>
<p>然后会获取 SDWebImageManager 中的单例调用一个 <code>downloadImageWithURL:...</code> 的方法来获取图片, 而这个 manager 获取图片的过程有大体上分为两部分, 它首先会在 SDWebImageCache 中寻找图片是否有对应的缓存, 它会以 url 作为数据的索引先在内存中寻找是否有对应的缓存, 如果缓存未命中就会在磁盘中利用 MD5 处理过的 key 来继续查询对应的数据, 如果找到了, 就会把磁盘中的缓存备份到内存中.</p>
<p>然而, 假设我们在内存和磁盘缓存中都没有命中, 那么 manager 就会调用它持有的一个 SDWebImageDownloader 对象的方法 <code>downloadImageWithURL:...</code> 来下载图片, 这个方法会在执行的过程中调用另一个方法 <code>addProgressCallback:andCompletedBlock:fotURL:createCallback:</code> 来存储下载过程中和下载完成的回调, 当回调块是第一次添加的时候, 方法会实例化一个 NSMutableURLRequest 和 SDWebImageDownloaderOperation, 并将后者加入 downloader 持有的下载队列开始图片的异步下载.</p>
<p>而在图片下载完成之后, 就会在主线程设置 image 属性, 完成整个图像的异步下载和配置.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>SDWebImage 的图片加载过程其实很符合我们的直觉:</p>
<p>查看缓存</p>
<ul>
<li>缓存命中<ul>
<li>返回图片</li>
<li>更新 UIImageView</li>
</ul>
</li>
<li>缓存未命中<ul>
<li>异步下载图片</li>
<li>加入缓存</li>
<li>更新 UIImageView</li>
</ul>
</li>
</ul>
<p>只要有足够的耐心, 阅读这个开源项目的源代码也是没有太多困难的.</p>
<p>原文地址：<a href="http://dravenes.me/ios-yuan-dai-ma-jie-xi-sdwebimage">http://dravenes.me/ios-yuan-dai-ma-jie-xi-sdwebimage</a></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/06/20/ios-night-mode/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          iOS开发 - 成熟的夜间模式解决方案
        
      </div>
    </a>
  
  
    <a href="/2016/06/15/ios-network-encrypt/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">简单聊聊 iOS 中的网络加密</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>




<div class="share_addthis">
  <div class="sharing addthis_toolbox share">
    <a class="addthis_button_facebook_like"></a>
    <a class="addthis_button_tweet"></a>
    <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-560c64c35486b3d4" async="async"></script>
</div>






<section id="comments">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'charstechblog'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>

</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Chars Davy
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>

<script language="javascript" type="text/javascript" src="http://js.users.51.la/18878021.js"></script>
<noscript><a href="http://www.51.la/?18878021" target="_blank"><img alt="&#x6211;&#x8981;&#x5566;&#x514D;&#x8D39;&#x7EDF;&#x8BA1;" src="http://img.users.51.la/18878021.asp" style="border:none" /></a></noscript>

<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<div id="totop" style="position:fixed;bottom:50px;right:30px;cursor: pointer;">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<script src="/js/totop.js"></script>

  </div>
</body>
</html>