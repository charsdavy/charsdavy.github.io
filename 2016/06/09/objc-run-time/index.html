<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Objective-C 运行时编程 - Chars&#39;s Tech Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="摘要：Objective-C语言将决定尽可能的从编译和链接时推迟到运行时。只要有可能，Objective-C总是使用动态的方式来解决问题。这意味着Objective-C语言不仅需要一个编译器，同时也需要一个运行时系统来执行编译好的代码。这里的运行时系统扮演的角色类似于Objective-C语言的操作系统，Objective-C基于该系统来工作。本文章将具体介绍NSObject类以及Objectiv">
<meta property="og:type" content="article">
<meta property="og:title" content="Objective-C 运行时编程">
<meta property="og:url" content="https://charsdavy.github.io/2016/06/09/objc-run-time/index.html">
<meta property="og:site_name" content="Chars's Tech Blog">
<meta property="og:description" content="摘要：Objective-C语言将决定尽可能的从编译和链接时推迟到运行时。只要有可能，Objective-C总是使用动态的方式来解决问题。这意味着Objective-C语言不仅需要一个编译器，同时也需要一个运行时系统来执行编译好的代码。这里的运行时系统扮演的角色类似于Objective-C语言的操作系统，Objective-C基于该系统来工作。本文章将具体介绍NSObject类以及Objectiv">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1492739-f237a0b62cb32d9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1492739-f060df75ab9be460.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2016-08-03T12:21:16.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Objective-C 运行时编程">
<meta name="twitter:description" content="摘要：Objective-C语言将决定尽可能的从编译和链接时推迟到运行时。只要有可能，Objective-C总是使用动态的方式来解决问题。这意味着Objective-C语言不仅需要一个编译器，同时也需要一个运行时系统来执行编译好的代码。这里的运行时系统扮演的角色类似于Objective-C语言的操作系统，Objective-C基于该系统来工作。本文章将具体介绍NSObject类以及Objectiv">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1492739-f237a0b62cb32d9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-80507808-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">Chars</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
          <a class="main-nav-link" href="/atom.xml">Rss</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://charsdavy.github.io"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer"><article id="post-objc-run-time" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Objective-C 运行时编程
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/06/09/objc-run-time/" class="article-date">
  <time datetime="2016-06-09T02:21:31.000Z" itemprop="datePublished">2016-06-09</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

<!--
      
        <div class="article-comment-link-wrap">
          <a href="https://charsdavy.github.io/2016/06/09/objc-run-time/#ds-thread" class="article-comment-link">Comments</a>
        </div>
      
-->
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>摘要：Objective-C语言将决定尽可能的从编译和链接时推迟到运行时。只要有可能，Objective-C总是使用动态的方式来解决问题。这意味着Objective-C语言不仅需要一个编译器，同时也需要一个运行时系统来执行编译好的代码。这里的运行时系统扮演的角色类似于Objective-C语言的操作系统，Objective-C基于该系统来工作。本文章将具体介绍NSObject类以及Objective-C程序是如何与运行时系统交互的。特别地，本文章还给出来怎样在运行时动态地加载新类和将消息转发给其它对象的范例，同时也给出了怎样在程序运行时获取对象信息的方法。</p>
<a id="more"></a>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><p>Objective-C语言将决定尽可能的从编译和链接时推迟到运行时。只要有可能，Objective-C总是使用动态的方式来解决问题。这意味着Objective-C语言不仅需要一个编译器，同时也需要一个运行时系统来执行编译好的代码。这里的运行时系统扮演的角色类似于 Objective-C语言的操作系统，Objective-C基于该系统来工作。 </p>
<p>本文章将具体介绍NSObject类以及Objective-C程序是如何与运行时系统交互的。特别地，本文章还给出来怎样在运行时动态地加载新类和将消息转发给其它对象的范例，同时也给出了怎样在程序运行时获取对象信息的方法。 </p>
<p>通常，如果仅仅写一个Cocoa 程序，程序员不需要知道和理解Objective-C运行时系统的底层细节，但这篇文章仍然值得推荐阅读，以了解 Objective-C运行时系统的原理，并能更好的利用 Objective-C的优点。</p>
<h1 id="2-参考"><a href="#2-参考" class="headerlink" title="2 参考"></a>2 参考</h1><p>《Objective-C 2.0 运行时系统参考库》描述了Objective-C运行库的数据结构和函数接口。程序可以通过这些接口来和Objective-C运行时系统交互。例如，您可以增加一个类或者方法，或者获得所有类的定义列表等。</p>
<p>《Objective-C 2.0 程序设计语言》介绍了Objective-C语言本身。</p>
<p>《Objective-C 版本说明》给出了在最近版本的Mac OS X系统中关于Objective-C运行时系统的一些改动。</p>
<h1 id="3-运行时系统的版本和平台"><a href="#3-运行时系统的版本和平台" class="headerlink" title="3 运行时系统的版本和平台"></a>3 运行时系统的版本和平台</h1><p>在不同的平台上Objective-C运行时系统的版本也不相同。</p>
<h2 id="3-1-早期版本和现行版本"><a href="#3-1-早期版本和现行版本" class="headerlink" title="3.1 早期版本和现行版本"></a>3.1 早期版本和现行版本</h2><p>Objective-C运行时系统有两个已知版本：早期版本和现行版本。</p>
<p>现行版本主要是Objective-C 2.0 及与其相关的新特性。早期版本的编程接口见《Objective-C 1运行时系统参考库》；现行版本的编程接口见《Objective-C 2.0  运行时系统参考库》。</p>
<p>在现行版本中，最显著的新特性就是实例变量是“健壮（non-fragile ）的”：</p>
<p>1）在早期版本中，如果您改变类中实例变量的布局，您必须重新编译该类的所有子类。</p>
<p>2）在现行版本中，如果您改变类中实例变量的布局，您无需重新编译该类的任何子类。</p>
<p>此外，现行版本支持声明property 的synthesis属性（参考《Objective-C 2.0 程序设计语言》的“属性”一节）。</p>
<h2 id="3-2-平台"><a href="#3-2-平台" class="headerlink" title="3.2 平台"></a>3.2 平台</h2><p>iPhone 程序和Mac OS X 10.5及以后的系统中的64位程序使用的都是Objective-C运行时系统的现行版本。</p>
<p>其它情况（Mac OS X系统中的32位程序）使用的是早期版本。</p>
<h1 id="4-和运行时系统的交互"><a href="#4-和运行时系统的交互" class="headerlink" title="4 和运行时系统的交互"></a>4 和运行时系统的交互</h1><p>Objective-C程序有三种途径和运行时系统交互：</p>
<p>1）通过 Objective-C源代码；</p>
<p>2）通过 Foundation框架中类NSObject的方法；</p>
<p>3）通过直接调用运行时系统的函数。</p>
<h2 id="4-1-通过Objective-C源代码"><a href="#4-1-通过Objective-C源代码" class="headerlink" title="4.1 通过Objective-C源代码"></a>4.1 通过Objective-C源代码</h2><p>大部分情况下，运行时系统在后台自动运行，您只需编写和编译Objective-C源代码。 </p>
<p>当您编译Objective-C类和方法时，编译器为实现语言动态特性将自动创建一些数据结构和函数。</p>
<p>这些数据结构包含类定义和协议类定义中的信息，如在《Objective-C 2.0 程序设计语言》中“定义类”和“协议类”一节所讨论的类的对象和协议类的对象，方法选标，实例变量模板，以及其它来自于源代码的信息。运行时系统的主要功能就是根据源代码中的表达式发送消息，如“消息”一节所述。</p>
<h2 id="4-2-通过类NSObject的方法"><a href="#4-2-通过类NSObject的方法" class="headerlink" title="4.2 通过类NSObject的方法"></a>4.2 通过类NSObject的方法</h2><p>Cocoa 程序中绝大部分类都是NSObject类的子类，所以大部分都继承了NSObject类的方法，因而继承了NSObject的行为。（NSProxy类是个例外；更多细节参考“消息转发”一节。）然而，某些情况下，NSObject类仅仅定义了完成某件事情的模板，而没有提供所有需要的代码。</p>
<p>例如，NSObject类定义了description 方法，返回该类内容的字符串表示。这主要是用来调试程序——GDB中的print-object方法就是直接打印出该方法返回的字符串。NSObject类中该方法的实现并不知道子类中的内容，所以它只是返回类的名字和对象的地址。NSObject的子类可以重新实现该方法以提供更多的信息。例如，NSArray 类改写了该方法来返回NSArray 类包含的每个对象的内容。</p>
<p>某些NSObject的方法只是简单地从运行时系统中获得信息，从而允许对象进行一定程度的自我检查。例如，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class 返回对象的类；</span><br><span class="line">isKindOfClass:和isMemberOfClass:检查对象是否在指定的类继承体系中；</span><br><span class="line">respondsToSelector:检查对象能否响应指定的消息；</span><br><span class="line">conformsToProtocol:检查对象是否实现了指定协议类的方法；</span><br><span class="line">methodForSelector:返回指定方法实现的地址。</span><br></pre></td></tr></table></figure>
<h2 id="4-3-通过运行时系统的函数"><a href="#4-3-通过运行时系统的函数" class="headerlink" title="4.3 通过运行时系统的函数"></a>4.3 通过运行时系统的函数</h2><p>运行时系统是一个有公开接口的动态库，由一些数据结构和函数的集合组成，这些数据结构和函数的声明头文件在/usr/include/objc 中。这些函数支持用纯 C 的函数来实现Objective-C同样的功能。还有一些函数构成了NSObject类方法的基础。这些函数使得访问运行时系统接口和提供开发工具成为可能。尽管大部分情况下它们在 Objective-C程序不是必须的，但是有时候对于 Objecitve-C程序来说某些函数是非常有用的。</p>
<p>这些函数的文档参见《Objective-C 2.0 运行时系统参考库》。</p>
<h1 id="5-消息"><a href="#5-消息" class="headerlink" title="5 消息"></a>5 消息</h1><p>本章节描述了代码的消息表达式如何转换为对objc_msgSend函数的调用，如何通过名字来指定一个方法，以及如何使用objc_msgSend函数。</p>
<h2 id="5-1-获得方法地址"><a href="#5-1-获得方法地址" class="headerlink" title="5.1 获得方法地址"></a>5.1 获得方法地址</h2><p>避免动态绑定的唯一办法就是取得方法的地址，并且直接像函数调用一样调用它。当一个方法会被连续调用很多次，而且您希望节省每次调用方法都要发送消息的开销时，使用方法地址来调用方法就显得很有效。</p>
<p>利用NSObject类中的methodForSelector:方法，您可以获得一个指向方法实现的指针，并可以使用该指针直接调用方法实现。methodForSelector:返回的指针和赋值的变量类型必须完全一致，包括方法的参数类型和返回值类型都在类型识别的考虑范围中。</p>
<p>下面的例子展示了怎么使用指针来调用setFilled:的方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void (*setter)(id, SEL, BOOL); </span><br><span class="line">int i; </span><br><span class="line"></span><br><span class="line">setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];</span><br><span class="line">for ( i = 0; i &lt; 1000, i++ ) </span><br><span class="line">    setter(targetList[i], @selector(setFilled:), YES);</span><br></pre></td></tr></table></figure>
<p>方法指针的第一个参数是接收消息的对象（self），第二个参数是方法选标（_cmd）。这两个参数在方法中是隐藏参数，但使用函数的形式来调用方法时必须显示的给出。</p>
<p>使用methodForSelector:来避免动态绑定将减少大部分消息的开销，但是这只有在指定的消息被重复发送很多次时才有意义，例如上面的for 循环。</p>
<p><strong>注意：</strong>methodForSelector:是Cocoa 运行时系统的提供的功能，而不是Objective-C语言本身的功能。</p>
<h2 id="5-2-objc-msgSend函数"><a href="#5-2-objc-msgSend函数" class="headerlink" title="5.2 objc_msgSend函数"></a>5.2 objc_msgSend函数</h2><p>在Objective-C中，消息是直到运行的时候才和方法实现绑定的。编译器会把一个消息表达式，</p>
<p><code>[receiver message]</code></p>
<p>转换成一个对消息函数objc_msgSend的调用。该函数有两个主要参数：消息接收者和消息对应的方法名字——也就是方法选标：</p>
<p><code>objc_msgSend(receiver, selector)</code></p>
<p>同时接收消息中的任意数目的参数：</p>
<p><code>objc_msgSend(receiver, selector, arg1, arg2, ...)</code></p>
<p>该消息函数做了动态绑定所需要的一切：</p>
<p>1）它首先找到选标所对应的方法实现。因为不同的类对同一方法可能会有不同的实现，所以找到的方法实现依赖于消息接收者的类型。</p>
<p>2）然后将消息接收者对象（指向消息接收者对象的指针）以及方法中指定的参数传给找到的方法实现。</p>
<p>3）最后，将方法实现的返回值作为该函数的返回值返回。</p>
<p><strong>注意：</strong>编译器将自动插入调用该消息函数的代码。您无须在代码中显示调用该消息函数。</p>
<p>消息机制的关键在于编译器为类和对象生成的结构。每个类的结构中至少包括两个基本元素：</p>
<p>1）指向父类的指针。</p>
<p>2）类的方法表。方法表将方法选标和该类的方法实现的地址关联起来。例如，setOrigin::的方法选标和setOrigin::的方法实现的地址关联，display  的方法选标和display 的方法实现的地址关联，等等。</p>
<p>当新的对象被创建时，其内存同时被分配，实例变量也同时被初始化。对象的第一个实例变量是一个指向该对象的类结构的指针，叫做isa。通过该指针，对象可以访问它对应的类以及相应的父类。</p>
<p><strong>注意：</strong>尽管严格来说这并不是 Obective-C 语言的一部分，但是在Objective-C运行时系统中对象需要有isa 指针。对象和结构体struct objc_object（在objc/objc.h 中定义）必须“一致”。然而，您很少需要创建您自己的根对象，因为从 NSObject或者NSProxy 继承的对象都自动包括isa 变量。</p>
<p>类和对象的结构如下图所示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1492739-f237a0b62cb32d9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>当对象收到消息时，消息函数首先根据该对象的 isa 指针找到该对象所对应的类的方法表，并从表中寻找该消息对应的方法选标。如果找不到，objc_msgSend将继续从父类中寻找，直到 NSObject类。一旦找到了方法选标， objc_msgSend则以消息接收者对象为参数调用，调用该选标对应的方法实现。</p>
<p>这就是在运行时系统中选择方法实现的方式。在面向对象编程中，一般称作方法和消息动态绑定的过程。</p>
<p>为了加快消息的处理过程，运行时系统通常会将使用过的方法选标和方法实现的地址放入缓存中。每个类都有一个独立的缓存，同时包括继承的方法和在该类中定义的方法。消息函数会首先检查消息接收者对象对应的类的缓存（理论上，如果一个方法被使用过一次，那么它很可能被再次使用）。如果在缓存中已经有需要的方法选标，则消息仅仅比函数调用慢一点点。如果程序运行了足够长的时间，几乎每个消息都能在缓存中找到方法实现。程序运行时，缓存也将随着新的消息的增加而增加。</p>
<h2 id="5-3-使用隐藏的参数"><a href="#5-3-使用隐藏的参数" class="headerlink" title="5.3 使用隐藏的参数"></a>5.3 使用隐藏的参数</h2><p>当objc_msgSend找到方法对应的实现时，它将直接调用该方法实现，并将消息中所有的参数都传递给方法实现，同时，它还将传递两个隐藏的参数：</p>
<p>1）接收消息的对象</p>
<p>2）方法选标</p>
<p>这些参数帮助方法实现获得了消息表达式的信息。它们被认为是“隐藏”的原因是它们并没有在定义方法的源代码中声明，而是在代码编译时是插入方法的实现中的。</p>
<p>尽管这些参数没有被显示声明，但在源代码中仍然可以引用它们（就像可以引用消息接收者对象的实例变量一样）。在方法中可以通过 self来引用消息接收者对象，通过选标_cmd来引用方法本身。</p>
<p>在下面的例子中，_cmd指的是strange 方法，self指的收到strange 消息的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- strange  &#123;</span><br><span class="line">    id  target = getTheReceiver();</span><br><span class="line">    SEL method = getTheMethod();</span><br><span class="line"></span><br><span class="line">    if ( target == self || method == _cmd )</span><br><span class="line">        return nil;</span><br><span class="line"></span><br><span class="line">    return [target performSelector:method];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这两个参数中，self更有用一些。实际上，它是在方法实现中访问消息接收者对象的实例变量的途径。 </p>
<h1 id="6-动态方法解析"><a href="#6-动态方法解析" class="headerlink" title="6 动态方法解析"></a>6 动态方法解析</h1><p>本章节将描述怎样动态地提供一个方法的实现。</p>
<h2 id="6-1-动态方法解析"><a href="#6-1-动态方法解析" class="headerlink" title="6.1 动态方法解析"></a>6.1 动态方法解析</h2><p>有时候，程序员需要动态地提供一个方法的实现。例如，Objective-C中属性（Property ）（ 参考《Objective-C 2.0 程序设计语言》中“属性”小节）前的修饰符@dynamic</p>
<p><code>@dynamic propertyName;</code></p>
<p>表示编译器须动态地生成该属性对应地方法。</p>
<p>程序员可以通过实现<code>resolveInstanceMethod:和resolveClassMethod:</code>来动态地实现给定选标的对象方法或者类方法。</p>
<p>Objective-C方法可以认为是至少有两个参数self和_cmd的C 函数。您可以通过class_addMethod 方法将一个函数加入到类的方法中。例如，有如下的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</span><br><span class="line">    // implementation ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序员可以通过resolveInstanceMethod:将它作为类方法resolveThisMethodDynamically的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@implementation MyClass</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL  &#123;</span><br><span class="line">    if (aSEL == @selector(resolveThisMethodDynamically)) &#123;</span><br><span class="line">          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class="line"></span><br><span class="line">          return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>通常消息转发（见 “消息转发”）和动态方法解析是互不相干的。在进入消息转发机制之前，respondsToSelector:和instancesRespondToSelector:  会被首先调用。您可以在这两个方法中为传进来的选标提供一个IMP 。如果您实现了resolveInstanceMethod:方法，但是仍然希望正常的消息转发机制进行，您只需要返回NO即可。 </p>
<h2 id="6-2-动态加载"><a href="#6-2-动态加载" class="headerlink" title="6.2 动态加载"></a>6.2 动态加载</h2><p>Objective-C程序可以在运行时链接和载入新的类和范畴类。新载入的类和在程序启动时载入的类并没有区别。 </p>
<p>动态加载可以用在很多地方。例如，系统配置中的模块就是被动态加载的。<br>在Cocoa 环境中，动态加载一般被用来对应用程序进行定制。您的程序可以在运行时加载其他程序员编写的模块——和Interface Build 载入定制的调色板以及系统配置程序载入定制的模块的类似。这些模块通过您许可的方式扩展您的程序，而您无需自己来定义或者实现。您提供了框架，而其它的程序员提供了实现。 </p>
<p>尽管已经有一个运行时系统的函数来动态加载Mach-O文件中的Objective-C模块（objc_loadModules，在objc/objc-load.h中定义），Cocoa 的NSBundle类为动态加载提供了一个更方便的接口——一个面向对象的，已经和相关服务集成的接口。关于NSBundle类的更多相关信息请参考Foundation 框架中关于NSBundle类的文档。关于Mach-O文件的有关信息请参考《Mac OS X ABI Mach-O  文件格式参考库》。</p>
<h1 id="7-消息转发"><a href="#7-消息转发" class="headerlink" title="7 消息转发"></a>7 消息转发</h1><p>通常，给一个对象发送它不能处理的消息会得到出错提示，然而，Objective-C运行时系统在抛出错误之前，会给消息接收对象发送一条特别的消息来通知该对象。</p>
<h2 id="7-1-消息转发"><a href="#7-1-消息转发" class="headerlink" title="7.1 消息转发"></a>7.1 消息转发</h2><p>如果一个对象收到一条无法处理的消息，运行时系统会在抛出错误前，给该对象发送一条forwardInvocation:消息，该消息的唯一参数是个NSInvocation类型的对象——该对象封装了原始的消息和消息的参数。</p>
<p>程序员可以实现forwardInvocation:方法来对不能处理的消息做一些默认的处理，也可以以其它的某种方式来避免错误被抛出。如forwardInvocation:的名字所示，它通常用来将消息转发给其它的对象。 </p>
<p>关于消息转发的作用，您可以考虑如下情景：假设，需要设计一个能够响应negotiate 消息的对象，并且能够包括其它类型的对象对消息的响应。通过在negotiate 方法的实现中将negotiate 消息转发给其它的对象这种方式可以很容易的达到这一目的。</p>
<p>更进一步，假设您希望您的对象和另外一个类的对象对 negotiate 的消息的响应完全一致。一种可能的方式就是让您的类继承其它类的方法实现。然而，有时候这种方式不可行，因为您的类和其它类可能需要在不同的继承体系中响应negotiate 消息。</p>
<p>虽然您的类无法继承其它类的negotiate 方法，您仍然可以提供一个方法实现，这个方法实现只是简单的将negotiate 消息转发给其他类的对象，就好像从其它类那里“借”来的实现一样。如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- negotiate &#123;</span><br><span class="line">    if ( [someOtherObject respondsTo:@selector(negotiate)] )</span><br><span class="line">        return [someOtherObject negotiate];</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式显得有欠灵活，特别是有很多消息您都希望传递给其它对象时，您必须为每一种消息提供方法实现。此外，这种方式不能处理未知的消息。当您写下代码时，所有您需要转发的消息的集合也必须确定。然而，实际上，这个集合会随着运行时事件的发生，新方法或者新类的定义而变化。</p>
<p>forwardInvocation:消息给这个问题提供了一个更特别的，动态的解决方案：当一个对象由于没有相应的方法实现而无法响应某消息时，运行时系统将通过 forwardInvocation:消息通知该对象。每个对象都从NSObject类中继承了forwardInvocation:方法。然而，NSObject中的方法实现只是简单地调用了doesNotRecognizeSelector:。通过实现您自己的forwardInvocation:方法，您可以在该方法实现中将消息转发给其它对象。</p>
<p>要转发消息给其它对象，forwardInvocation:方法所必须做的有：</p>
<p>1）决定将消息转发给谁，并且 </p>
<p>2）将消息和原来的参数一块转发出去 </p>
<p>消息可以通过invokeWithTarget:方法来转发：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    if ([someOtherObject respondsToSelector: [anInvocation selector]])</span><br><span class="line">        [anInvocation invokeWithTarget:someOtherObject];</span><br><span class="line">    else</span><br><span class="line">        [super forwardInvocation:anInvocation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转发消息后的返回值将返回给原来的消息发送者。返回值可以是任何类型的，包括：id，结构体，浮点数等。</p>
<p>forwardInvocation:方法就像一个不能识别的消息的分发中心，将这些消息转发给不同接收对象。或者它也可以像一个运输站将所有的消息都发送给同一个接收对象。它可以将一个消息翻译成另外一个消息，或者简单的“吃掉”某些消息，因此没有响应也没有错误。forwardInvocation:方法也可以对不同的消息提供同样的响应，这一切都取决于方法的具体实现。该方法所提供的是将不同的对象链接到消息链的能力。</p>
<p><strong>注意：</strong>forwardInvocation: 方法只有在消息接收对象中无法正常响应消息时才会被调用。所以，如果您希望您的对象将negotiate 消息转发给其它对象，您的对象不能有negotiate 方法。否则，forwardInvocation:将不可能会被调用。</p>
<p>更多消息转发的信息，参考Foundation框架参考库中NSInvocation类的文档。</p>
<h2 id="7-2-消息转发和多重继承"><a href="#7-2-消息转发和多重继承" class="headerlink" title="7.2 消息转发和多重继承"></a>7.2 消息转发和多重继承</h2><p>消息转发很像继承，并且可以用来在Objective-C程序中模拟多重继承。如下图所示，  一个对象通过转发来响应消息，看起来就像该对象从别的类那借来了或者“继承”了方法实现一样。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1492739-f060df75ab9be460.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在上图中，Warrior类的一个对象实例将negotiate 消息转发给Diplomat 类的一个实例。看起来，Warrior类似乎和Diplomat 类一样，响应negotiate消息，并且行为和Diplomat 一样（尽管实际上是Diplomat类响应了该消息）。</p>
<p>转发消息的对象看起来有两个继承体系分支——自己的和响应消息的对象的。在上面的例子中，Warrior看起来同时继承自Diplomat 和自己的父类。</p>
<p>消息转发提供了多重继承的很多特性。然而，两者有很大的不同：多重继承是将不同的行为封装到单个的对象中，有可能导致庞大的，复杂的对象。而消息转发是将问题分解到更小的对象中，但是又以一种对消息发送对象来说完全透明的方式将这些对象联系起来。</p>
<h2 id="7-3-消息代理对象"><a href="#7-3-消息代理对象" class="headerlink" title="7.3 消息代理对象"></a>7.3 消息代理对象</h2><p>消息转发不仅和继承很像，它也使得以一个轻量级的对象（消息代理对象）代表更多的对象进行消息处理成为可能。</p>
<p>《Objective-C 2.0 程序设计语言》中“远程消息”一节中的代理类就是这样一个代理对象。代理类负责将消息转发给远程消息接收对象的管理细节，保证消息参数的传输等等。但是消息类没有进一步的复制远程对象的功能，它只是将远程对象映射到一个本地地址上，从而能够接收其它应用程序的消息。 </p>
<p>同时也存在着其它类型的消息代理对象。例如，假设您有个对象需要操作大量的数据——它可能需要创建一个复杂的图片或者需要从磁盘上读一个文件的内容。创建一个这样的对象是很费时的，您可能希望能推迟它的创建时间——直到它真正需要时，或者系统资源空闲时。同时，您又希望至少有一个预留的对象和程序中其它对象交互。</p>
<p>在这种情况下，您可以为该对象创建一个轻量的代理对象。该代理对象可以有一些自己的功能，例如响应数据查询消息，但是它主要的功能是代表某个对象，当时间到来时，将消息转发给被代表的对象。当代理对象的forwardInvocation:方法收到需要转发给被代表的对象的消息时，代理对象会保证所代表的对象已经存在，否则就创建它。所有发到被代表的对象的消息都要经过代理对象，对程序来说，代理对象和被代表的对象是一样的。</p>
<h2 id="7-4-消息转发和类继承"><a href="#7-4-消息转发和类继承" class="headerlink" title="7.4 消息转发和类继承"></a>7.4 消息转发和类继承</h2><p>尽管消息转发很“像”继承，但它不是继承。例如在NSObject类中，方法respondsToSelector:和isKindOfClass:只会出现在继承链中，而不是消息转发链中。例如，如果向一个 Warrior类的对象询问它能否响应negotiate 消息，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ( [aWarrior respondsToSelector:@selector(negotiate)] )</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>返回值是NO，尽管该对象能够接收和响应negotiate。</p>
<p>大部分情况下，NO是正确的响应。但不是所有时候都是的。例如，如果您使用消息转发来创建一个代理对象以扩展某个类的能力，这里的消息转发必须和继承一样，尽可能的对用户透明。如果您希望您的代理对象看起来就像是继承自它代表的对象一样，您需要重新实现respondsToSelector:和isKindOfClass:方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector &#123;</span><br><span class="line">    if ( [super respondsToSelector:aSelector] )</span><br><span class="line">        return YES;</span><br><span class="line">    else &#123;</span><br><span class="line">        /* Here, test whether the aSelector message can     *</span><br><span class="line">         * be forwarded to another object and whether that  *</span><br><span class="line">         * object can respond to it. Return YES if it can.  */</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了respondsToSelector:和isKindOfClass:方法外，instancesRespondToSelector:方法也必须重新实现。如果您使用的是协议类，需要重新实现的还有conformsToProtocol:方法。类似地，如果对象需要转发远程消息，则 methodSignatureForSelector:方法必须能够返回实际响应消息的方法的描述。例如，如果对象需要将消息转发给它所代表的对象，您可能需要如下的methodSignatureForSelector:实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector &#123;</span><br><span class="line">    NSMethodSignature* signature = [super methodSignatureForSelector:selector];</span><br><span class="line">    if (!signature) &#123;</span><br><span class="line">       signature = [surrogate methodSignatureForSelector:selector];</span><br><span class="line">    &#125;</span><br><span class="line">    return signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您也可以将消息转发的部分放在一段私有的代码里，然后从forwardInvocation:调用它。<br>注意：消息转发是一个比较高级的技术，仅适用于没有其它更好的解决办法的情况。它并不是用来代替继承的。如果您必须使用该技术，请确定您已经完全理解了转发消息的类和接收转发消息的类的行为。</p>
<p>本节中涉及的方法在Foundation框架参考库中的NSObject类的文档中都有描述。关于invokeWithTarget:的具体信息，请参考Foundation框架参考库中NSInvocation类的文档。</p>
<h1 id="8-属性声明"><a href="#8-属性声明" class="headerlink" title="8 属性声明"></a>8 属性声明</h1><p>当编译器遇到一个属性（Property ）声明时（参考《Objective-C 2.0 程序设计语言》中的“属性”小节），编译器将产生一些描述性的元数据与属性所在的类或者协议类关联。您可以通过函数访问元数据，这些函数支持在类或者协议类中通过名字来查找，通过@encode获得属性的类型编码，将属性的特征（Attribute ）作为C字符串的数组返回等。每个类或者协议类都维护了一个声明了的属性列表。</p>
<h2 id="8-1-属性类型和相关函数"><a href="#8-1-属性类型和相关函数" class="headerlink" title="8.1 属性类型和相关函数"></a>8.1 属性类型和相关函数</h2><p>属性（Property ）类型定义了对描述属性的结构体objc_property 的不透明的句柄。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_property *Property;</span><br></pre></td></tr></table></figure>
<p>您可以使用函数class_copyPropertyList和protocol_copyPropertyList 来获得类（包括范畴类）或者协议类中的属性列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)</span><br><span class="line">objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount)</span><br></pre></td></tr></table></figure>
<p>例如，有如下的类声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface Lender : NSObject &#123; float alone;&#125;@property float alone;@end</span><br></pre></td></tr></table></figure>
<p>可以像这样获得它的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id LenderClass = objc_getClass(&quot;Lender&quot;);unsigned int outCount;</span><br><span class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</span><br></pre></td></tr></table></figure>
<p>还可以通过property_getName函数获得属性的名字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char *property_getName(objc_property_t property)</span><br></pre></td></tr></table></figure>
<p>函数class_getProperty 和protocol_getProperty则在类或者协议类中返回具有给定名字的属性的引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_property_t class_getProperty(Class cls, const char *name)</span><br><span class="line">objc_property_t protocol_getProperty(Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty)</span><br></pre></td></tr></table></figure>
<p>通过property_getAttributes函数可以获得属性的名字和@encode编码。关于类型编码的更多细节，参考“类型编码”一节；关于属性的类型编码，见“属性类型编码”及“属性特征的描述范例”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char *property_getAttributes(objc_property_t property)</span><br></pre></td></tr></table></figure>
<p>综合起来，您可以通过下面的代码得到一个类中所有的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id LenderClass = objc_getClass(&quot;Lender&quot;);</span><br><span class="line">unsigned int outCount, i;</span><br><span class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</span><br><span class="line">for (i = 0; i &lt; outCount; i++) &#123;</span><br><span class="line">    objc_property_t property = properties[i];</span><br><span class="line">    fprintf(stdout,  &quot;%s  %s\n&quot;,  property_getName(property), property_getAttributes(property));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-2-属性类型编码"><a href="#8-2-属性类型编码" class="headerlink" title="8.2 属性类型编码"></a>8.2 属性类型编码</h2><p>property_getAttributes函数将返回属性（Property）的名字，@encode 编码，以及其它特征（Attribute ）。</p>
<p>1）property_getAttributes返回的字符串以字母T 开始，接着是@encode 编码和逗号。</p>
<p>2）如果属性有readonly修饰，则字符串中含有R 和逗号。 </p>
<p>3）如果属性有copy或者retain修饰，则字符串分别含有C 或者&amp;，然后是逗号。 </p>
<p>4）如果属性定义有定制的getter 和setter 方法，则字符串中有G 或者S 跟着相应的方法名以及逗号（例如，GcustomGetter，ScustomSetter:，，）。</p>
<p>如果属性是只读的，且有定制的get 访问方法，则描述到此为止。</p>
<p>5）字符串以V 然后是属性的名字结束。</p>
<p>范例请参考 “属性特征的描述范例” 一节。</p>
<h2 id="8-3-属性特征的描述范例"><a href="#8-3-属性特征的描述范例" class="headerlink" title="8.3 属性特征的描述范例"></a>8.3 属性特征的描述范例</h2><p>给定如下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum FooManChu &#123; FOO, MAN, CHU &#125;;</span><br><span class="line">struct YorkshireTeaStruct &#123; int pot; char lady; &#125;;</span><br><span class="line">typedef struct YorkshireTeaStruct YorkshireTeaStructType;</span><br><span class="line">union MoneyUnion &#123; float alone; double down; &#125;;</span><br></pre></td></tr></table></figure>
<p>下表给出了属性（Property ）声明以及property_getAttributes返回的相应的字符串：</p>
<table>
<thead>
<tr>
<th>属性声明</th>
<th>属性描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>@property char charDefault;</td>
<td>Tc,VcharDefault</td>
</tr>
<tr>
<td>@property double doubleDefault;</td>
<td>Td,VdoubleDefault</td>
</tr>
<tr>
<td>@property enum FooManChuenumDefault;</td>
<td>Ti,VenumDefault</td>
</tr>
<tr>
<td>@property float floatDefault;</td>
<td>Tf,VfloatDefault</td>
</tr>
<tr>
<td>@property int intDefault;</td>
<td>Ti,VintDefault</td>
</tr>
<tr>
<td>@property long longDefault;</td>
<td>Tl,VlongDefault</td>
</tr>
<tr>
<td>@property short shortDefault;</td>
<td>Ts,VshortDefault</td>
</tr>
<tr>
<td>@property singed singedDefault;</td>
<td>Ti,VsingedDefault</td>
</tr>
<tr>
<td>@property struct YorkshireTeaStruct structDefault;</td>
<td>T{ YorkshireTeaStruct =”pot”i”lady”c},VstructDefault</td>
</tr>
<tr>
<td>@property YorkshireTeaStructType typedefDefault;</td>
<td>T{ YorkshireTeaStruct =”pot”i”lady”c},VtypedefDefault</td>
</tr>
<tr>
<td>@property union MoneyUnion unionDefault;</td>
<td>T(MoneyUnion=”alone”f”down”d),VunionDefault</td>
</tr>
<tr>
<td>@property unsigned unsignedDefault;</td>
<td>TI,VunsignedDefault</td>
</tr>
<tr>
<td>@property int (<em>functionPointerDefault)(char </em>);</td>
<td>T^?,VfunctionPointerDefault</td>
</tr>
<tr>
<td>@property void *voidPointerDefault;</td>
<td>T^v,VvoidPointerDefault</td>
</tr>
<tr>
<td>@property id idDefault;</td>
<td>T@,VidDefault</td>
</tr>
<tr>
<td>@property int *intPointer;</td>
<td>T^i,VintPointer</td>
</tr>
<tr>
<td>@property int intSynthEquals;In the implementation block: @synthesize intSynthEquals = _intSynthEquals;</td>
<td>Ti,V_intSynthEquals</td>
</tr>
<tr>
<td>@property (getter=intGetFoo, setter=intSetFoo:) int intSetterGetter;</td>
<td>Ti,GintGetFoo,SintSetFoo:,VintSetterGetter</td>
</tr>
<tr>
<td>@property (readonly)  int intReadonly;</td>
<td>Ti,R,VintReadonly</td>
</tr>
<tr>
<td>@property (getter=isIntReadOnlyGetter,  readonly)  int intReadonlyGetter;</td>
<td>Ti,R,GisIntReadOnlyGetter</td>
</tr>
<tr>
<td>@property (readwrite)  int intReadwrite;</td>
<td>Ti,VintReadwrite</td>
</tr>
<tr>
<td>@property (assign)  int intAssign;</td>
<td>Ti,VintAssign</td>
</tr>
<tr>
<td>@property (retain)  id idRetain;</td>
<td>T@,&amp;,VidRetain</td>
</tr>
<tr>
<td>@property (copy) id idCopy;</td>
<td>T@,C,VidCopy</td>
</tr>
<tr>
<td>@property (nonatomic)  int intNonatomic;</td>
<td>Ti,VintNonatomic</td>
</tr>
<tr>
<td>@property(nonatomic, readonly,  copy)  id idReadonlyCopyNonatomic;</td>
<td>T@,R,C,VidReadonlyCopyNonatomic</td>
</tr>
<tr>
<td>@property(nonatomic, readonly,  retain)  id idReadonlyRetainNonatomic;</td>
<td>T@,R,&amp;,VidReadonlyRetainNonatomic</td>
</tr>
</tbody>
</table>
<h1 id="9-类型编码"><a href="#9-类型编码" class="headerlink" title="9 类型编码"></a>9 类型编码</h1><p>为了和运行时系统协作，编译器将方法的返回类型和参数类型都编码成一个字符串，并且和方法选标关联在一起。这些编码在别的上下文环境中同样有用，所以您可以直接使@encode()编译指令来得到具体的编码。给定一个类型， @encode()将返回该类型的编码字符串。类型可以是基本类型例如整形，指针，结构体或者联合体，也可以是一个类，就和 C 语言中的sizeof()操作符的参数一样，可以是任何类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *buf1 = @encode(int **);</span><br><span class="line">char *buf2 = @encode(struct key);</span><br><span class="line">char *buf3 = @encode(Rectangle);</span><br></pre></td></tr></table></figure>
<p>下表列出了这些类型编码。注意，它们可能很多和您使用的对象编码有一些重合。然而，这里列出来的有些编码是您写编码器的时候不会使用的，也有一些不是@encode()产生的，但是在您写编码器的时候是会使用的。（关于对象编码的更多信息，请参考Foundation框架参考库中的NSCoder类文档。）</p>
<p>Objective-C类型编码</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>char</td>
</tr>
<tr>
<td>i</td>
<td>int</td>
</tr>
<tr>
<td>s</td>
<td>short</td>
</tr>
<tr>
<td>l</td>
<td>long，在64位程序中，l为32位</td>
</tr>
<tr>
<td>q</td>
<td>long long</td>
</tr>
<tr>
<td>C</td>
<td>unsigned char</td>
</tr>
<tr>
<td>I</td>
<td>unsigned int</td>
</tr>
<tr>
<td>S</td>
<td>unsigned short</td>
</tr>
<tr>
<td>L</td>
<td>unsigned long</td>
</tr>
<tr>
<td>Q</td>
<td>unsigned long long</td>
</tr>
<tr>
<td>f</td>
<td>float</td>
</tr>
<tr>
<td>d</td>
<td>double</td>
</tr>
<tr>
<td>B</td>
<td>C++标准的bool或者C99标准的_Bool</td>
</tr>
<tr>
<td>v</td>
<td>void</td>
</tr>
<tr>
<td>*</td>
<td>字符串（char *）</td>
</tr>
<tr>
<td>@</td>
<td>对象（无论是静态指定的还是通过id引用的）</td>
</tr>
<tr>
<td>#</td>
<td>类（Class）</td>
</tr>
<tr>
<td>:</td>
<td>方法选标（SEL）</td>
</tr>
<tr>
<td>[array type]</td>
<td>数组</td>
</tr>
<tr>
<td>{name=type…}</td>
<td>结构体</td>
</tr>
<tr>
<td>(name=type…)</td>
<td>联合体</td>
</tr>
<tr>
<td>bnum</td>
<td>num个bit的位域</td>
</tr>
<tr>
<td>^type</td>
<td>type类型的指针</td>
</tr>
<tr>
<td>?</td>
<td>未知类型（其他时候，一般用来指函数指针）</td>
</tr>
</tbody>
</table>
<p><strong>重要：</strong> Objective-C 不支持long double 类型。@encode(long double)和double 一样，返回的字符串都是d。</p>
<p>数组的类型编码以方括号来表示，紧接着左方括号的是数组元素的数量，然后是数据元素的类型。例如，一个12个浮点数（floats）指针的数组可以表示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[12^f]</span><br></pre></td></tr></table></figure>
<p>结构体和联合体分别用大括号和小括号表示。括号中首先是结构体标签，然后是一个“=”符号，接着是结构体中各个成员的编码。例如，结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct example &#123;</span><br><span class="line">    id   anObject;</span><br><span class="line">    char *aString;</span><br><span class="line">    int  anInt;</span><br><span class="line">&#125; Example;</span><br></pre></td></tr></table></figure>
<p>的编码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;example=@*i&#125;</span><br></pre></td></tr></table></figure>
<p>定义的类型名（Example）和结构体标签（example）有同样的编码结果。指向结构体类型的指针的编码同样也包含了结构体内部数据成员的编码信息，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^&#123;example=@*i&#125;</span><br></pre></td></tr></table></figure>
<p>然而，更高层次的间接关联就没有了内部数据成员的编码信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^^&#123;example&#125;</span><br></pre></td></tr></table></figure>
<p>对象的编码类似结构体。例如， @encode()对NSObject编码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;NSObject=#&#125;</span><br></pre></td></tr></table></figure>
<p>NSObject类仅声明了一个Class 类型的实例变量，isa。</p>
<p><strong>注意：</strong>尽管有一些编码无法从 @encode()的结果中直接得到，但是运行时系统会使用它们来表示协议类中方法的修饰符，这些编码如表所示。</p>
<p>Objective-C方法编码</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>const</td>
</tr>
<tr>
<td>n</td>
<td>in</td>
</tr>
<tr>
<td>N</td>
<td>inout</td>
</tr>
<tr>
<td>o</td>
<td>out</td>
</tr>
<tr>
<td>O</td>
<td>bycopy</td>
</tr>
<tr>
<td>R</td>
<td>byref</td>
</tr>
<tr>
<td>V</td>
<td>oneway</td>
</tr>
</tbody>
</table>
<h1 id="10-附言"><a href="#10-附言" class="headerlink" title="10 附言"></a>10 附言</h1><p>在此，运行时机制相关问题已经全部阐述。消息发送和转发是Runtime的强大之处，通过它，您可以为程序增加很多动态的行为，虽然在实际开发中很少直接使用这些机制（如直接调用objc_msgSend），但了解它们有助于您更多地去了解底层的实现。其实在实际的编码过程中，您也可以灵活地使用这些机制，去实现一些特殊的功能，如hook操作等。</p>
<p>原文：<a href="http://www.apple.com.cn/developer/Documentation/index.html">http://www.apple.com.cn/developer/Documentation/index.html</a></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Objective-C/">Objective-C</a></li></ul>

      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/06/10/state-pattern/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          State 模式
        
      </div>
    </a>
  
  
    <a href="/2016/06/05/git-using-remote/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Git 使用 - 远程操作&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>




<div class="share_addthis">
  <div class="sharing addthis_toolbox share">
    <a class="addthis_button_facebook_like"></a>
    <a class="addthis_button_tweet"></a>
    <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-560c64c35486b3d4" async="async"></script>
</div>






<section id="comments">
  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-objc-run-time" data-title="Objective-C 运行时编程" data-url="https://charsdavy.github.io/2016/06/09/objc-run-time/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
  var duoshuoQuery = {short_name:'charsdavy'};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0] 
       || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
  <!-- 多说公共JS代码 end -->
</section>
</section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Chars Davy&nbsp;
     </div>
  </div>
</footer>

    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<div id="totop" style="position:fixed;bottom:30px;right:30px;cursor: pointer;">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>
<script src="/js/totop.js"></script>

  </div>
</body>
</html>