<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <!-- JQuery (used for bootstrap and jekyll search) -->
    <script src="/assets/js/jquery-3.2.1.min.js" ></script>
    
    <!-- Main JS (navbar.js and katex_init.js)-->
    <script defer=true src="/assets/js/main.min.js"></script>
    
    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css">

    <!--Favicon-->
    <link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

    <!-- Canonical -->
    <link rel="canonical" href="http://chars.tech/algorithm/2017/06/14/binary-tree-guide.html">

    <!-- RSS -->
    <link rel="alternate" type="application/atom+xml" title="Chars" href="http://chars.tech///feed.xml"/>

    <!-- Font Awesome -->
    <!-- <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"> -->
    <link rel="stylesheet" type="text/css" href="/assets/css/font-awesome.min.css">

    <!-- Google Fonts -->
    
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css"> 
    

    <!-- KaTeX 0.8.3 -->
    
    <!--<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js"></script> -->
    <link rel="stylesheet" type="text/css" href="/assets/css/katex.min.css">
    <script src="/assets/js/katex.min.js">
    </script>
    

    <!-- Google Analytics -->
    
    <script>
        (function(i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r;
            i[r] = i[r] || function() {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o),
                m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m)
        })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

        ga('create', 'UA-80507808-1', 'auto');
        ga('send', 'pageview');

    </script>
    
    
    <!-- seo tags -->
    <!-- Begin Jekyll SEO tag v2.4.0 -->
<title>二叉树的那些使用</title>
<meta name="generator" content="Jekyll v3.7.2" />
<meta property="og:title" content="二叉树的那些使用" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支(不存在分支度大于2的节点)的树结构。通常分支被称作“左子树”和“右子树”。二叉树的分支具有左右次序，不能颠倒。" />
<meta property="og:description" content="在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支(不存在分支度大于2的节点)的树结构。通常分支被称作“左子树”和“右子树”。二叉树的分支具有左右次序，不能颠倒。" />
<link rel="canonical" href="http://chars.tech/algorithm/2017/06/14/binary-tree-guide.html" />
<meta property="og:url" content="http://chars.tech/algorithm/2017/06/14/binary-tree-guide.html" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-06-14T07:30:22+08:00" />
<script type="application/ld+json">
{"description":"在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支(不存在分支度大于2的节点)的树结构。通常分支被称作“左子树”和“右子树”。二叉树的分支具有左右次序，不能颠倒。","@type":"BlogPosting","url":"http://chars.tech/algorithm/2017/06/14/binary-tree-guide.html","headline":"二叉树的那些使用","dateModified":"2017-06-14T07:30:22+08:00","datePublished":"2017-06-14T07:30:22+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://chars.tech/algorithm/2017/06/14/binary-tree-guide.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <!-- Manual seo tags -->
    <!--
    <title>二叉树的那些使用 | Chars</title>
    <meta name="description" content="在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支(不存在分支度大于2的节点)的树结构。通常分支被称作“左子树”和“右子树”。二叉树的分支具有左右次序，不能颠倒。">
    -->
</head>

  <body>
    <header class="site-header">
    
    <!-- Logo and title -->
	<div class="branding">
		<a href="/">
			<img class="avatar" src="/assets/img/avatar.png" alt=""/>
		</a>

		<h1 class="site-title">
			<a href="/">Chars</a>
		</h1>
	</div>
    
    <!-- Toggle menu -->
    <nav class="clear">
    <a id="pull" class="toggle" href="#">
    <i class="fa fa-bars fa-lg"></i>
    </a>
    
    <!-- Menu -->
    <ul>
        
        
        
        
        <li>
            <a class="clear" href="/about/">
                About
            </a>
        </li>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
         
        
        
        <li>
            <a class="clear" href="http://chars.tech/hobby">
                Hobby
            </a>
        </li>
        
        
        <li>
            <a class="clear" href="http://chars.tech/search">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
        </li>
        
        
        <li>
            <a class="clear" href="http://chars.tech/tags">
                <i class="fa fa-tags" aria-hidden="true"></i>
            </a>
        </li>
        
        
    </ul>
        
	</nav>
</header>

    <div class="content">
      <article >
  <header id="main" style="background-image: url('/')">
    <h1 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BD%BF%E7%94%A8" class="title">二叉树的那些使用</h1>
    <p class="meta">
    June 14, 2017
    
    </p>
  </header>
  <section class="post-content"><p>在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支(不存在分支度大于2的节点)的树结构。通常分支被称作“左子树”和“右子树”。二叉树的分支具有左右次序，不能颠倒。</p>

<p>二叉树的第i层至多拥有 2^(i-1) 个节点数；深度为k的二叉树至多总共有 2^(k+1) - 1 个节点数，而总计拥有节点数匹配的，称为“满二叉树”；深度为k有n个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度k的满二叉树，序号为1到n的节点一对一对应时，称为“完全二叉树”。对任何一棵非空的二叉树T，如果其叶片(终端节点)数为n0，分支度为2的节点数为n2，则n0 = n2 + 1。</p>

<p>与普通树不同，普通树的节点个数至少为1，而二叉树的节点个数可以为0；普通树节点的最大分支度没有限制，而二叉树节点的最大分支度为2；普通树的节点无左、右次序之分，而二叉树的节点有左、右次序之分。</p>

<p>二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉查找树和二元堆积，并应用于高效率的搜索和排序。</p>

<p>相对于普通二叉树，还有一些特殊二叉树，它们诞生于特殊的场景需求。例如，二叉搜索树就是因搜索需求而诞生的一种特殊的树。</p>

<p>具体可以参见
<a href="/2017/06/10/binary-search-tree/">《聊聊「二叉搜索树」的那些事儿》</a></p>

<p>本文初衷是因为Homebrew 的作者<a href="https://twitter.com/mxcl/status/608682016205344768">@Max Howell</a>的一条twitter</p>
<blockquote>
  <p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.</p>
</blockquote>

<h2 id="类型">类型</h2>

<h3 id="1完全二叉树">(1)完全二叉树</h3>
<p>若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的节点数都达到最大个数，第h层有叶子节点，并且叶子节点都是从左到右依次排布，这就是完全二叉树。</p>
<h3 id="2满二叉树">(2)满二叉树</h3>
<p>除了叶节点外每一个节点都有左右子叶且叶子节点都处在最底层的二叉树。</p>
<h3 id="3平衡二叉树">(3)平衡二叉树</h3>
<p>平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>

<h2 id="相关术语">相关术语</h2>
<p>树的节点：包含一个数据元素及若干指向子树的分支。</p>

<p>孩子节点：节点的子树的根称为该节点的孩子。</p>

<p>双亲节点：B 节点是A 节点的孩子，则A节点是B 节点的双亲。</p>

<p>兄弟节点：同一双亲的孩子节点；</p>

<p>堂兄节点：同一层上节点。</p>

<p>祖先节点: 从根到该节点的所经分支上的所有节点。</p>

<p>子孙节点：以某节点为根的子树中任一节点都称为该节点的子孙。</p>

<p>节点层：根节点的层定义为1；根的孩子为第二层节点，依此类推。</p>

<p>树的深度：树中最大的节点层。</p>

<p>节点的度：节点子树的个数。</p>

<p>树的度： 树中最大的节点度。</p>

<p>叶子节点：也叫终端节点，是度为 0 的节点。</p>

<p>分支节点：度不为0的节点。</p>

<p>有序树：子树有序的树，如：家族树。</p>

<p>无序树：不考虑子树的顺序。</p>

<h2 id="树的结构">树的结构</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#import &lt;Foundation/Foundation.h&gt;

/** 二叉树节点 */
@interface DDBinaryTreeNode : NSObject

/** 值 */
@property (nonatomic, assign) NSInteger value;
/** 左节点 */
@property (nonatomic, strong) DDBinaryTreeNode *leftNode;
/** 右节点 */
@property (nonatomic, strong) DDBinaryTreeNode *rightNode;

@end
</code></pre></div></div>

<h2 id="树的遍历">树的遍历</h2>

<p>遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有节点，使每一个节点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个节点转换成为一个线性序列来表示。</p>

<p>设L、D、R分别表示遍历左子树、访问根节点和遍历右子树， 则对一棵二叉树的遍历有三种情况：DLR（称为先序遍历），LDR（称为中序遍历），LRD （称为后序遍历）。</p>

<h3 id="先序遍历">先序遍历</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+ (void)preOrderTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler {
    if (!rootNode) {
        return;
    }
    
    if (handler) {
        handler(rootNode);
    }
    [self preOrderTraverseTree:rootNode.leftNode handler:handler];
    [self preOrderTraverseTree:rootNode.rightNode handler:handler];
}

</code></pre></div></div>

<h3 id="中序遍历">中序遍历</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+ (void)inOrderTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void (^)(DDBinaryTreeNode *treeNode))handler
{
    if (!rootNode) {
        return;
    }
    [self inOrderTraverseTree:rootNode.leftNode handler:handler];
    if (handler) {
        handler(rootNode);
    }
    [self inOrderTraverseTree:rootNode.rightNode handler:handler];
}
</code></pre></div></div>

<h3 id="后序遍历">后序遍历</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+ (void)postOrderTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler {
    if (!rootNode) {
        return;
    }
    [self postOrderTraverseTree:rootNode.leftNode handler:handler];
    [self postOrderTraverseTree:rootNode.rightNode handler:handler];
    if (handler) {
        handler(rootNode);
    }
}
</code></pre></div></div>

<h3 id="广度优先遍历breadth-first-search">广度优先遍历(Breadth First Search)</h3>

<p>从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。
按照从上到下、从左到右的次序进行遍历。先遍历完一层，再遍历下一层。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+ (void)levelTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler {
    if (!rootNode) {
        return;
    }
    NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列
    [queueArray addObject:rootNode]; //压入根节点
    while (queueArray.count &gt; 0) {
        DDBinaryTreeNode *node = [queueArray firstObject];
        if (handler) {
            handler(node);
        }
        [queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先出原则
        if (node.leftNode) {
            [queueArray addObject:node.leftNode]; //压入左节点
        }
        if (node.rightNode) {
            [queueArray addObject:node.rightNode]; //压入右节点
        }
    }
}
</code></pre></div></div>

<h3 id="深度优先遍历depth-first-search">深度优先遍历(Depth First Search)</h3>

<p>DFS是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。
当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。
如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+ (void)depthTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler
{
    if (!rootNode) {
        return;
    }
    
    if (handler) {
        handler(rootNode);
    }
    
    [self depthTraverseTree:rootNode.leftNode handler:handler];
    [self depthTraverseTree:rootNode.rightNode handler:handler];
}
</code></pre></div></div>

<h2 id="树的翻转">树的翻转</h2>

<p>翻转二叉树，又叫求二叉树的镜像，就是把二叉树的左右子树对调。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+ (DDBinaryTreeNode *)invertBinaryTree:(DDBinaryTreeNode *)rootNode {
    if (!rootNode) {
        return nil;
    }
    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) {
        return rootNode;
    }
    [self invertBinaryTree:rootNode.leftNode];
    [self invertBinaryTree:rootNode.rightNode];
    DDBinaryTreeNode *tempNode = rootNode.leftNode;
    rootNode.leftNode = rootNode.rightNode;
    rootNode.rightNode = tempNode;
    return rootNode;
}
</code></pre></div></div>

<h2 id="树的查找">树的查找</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+ (DDBinaryTreeNode *)searchTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode
{
    if (!rootNode) {
        return nil;
    }
    
    if (rootNode.value == value) {
        return rootNode;
    }
    
    if (value &lt; rootNode.value) {
        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.leftNode];
    } else {
        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.rightNode];
    }
}
</code></pre></div></div>

<p>相关链接：
<a href="http://www.cocoachina.com/programmer/20151015/13687.html">《百度的校园招聘面试经历》</a></p>

<p><a href="http://blog.devtang.com/2015/06/16/talk-about-tech-interview/">《你会翻转二叉树吗》</a></p>
</section>
   
   <!-- Tag list -->
  
  


    <footer>
        <div class="tag-list">
        
          <div class="meta">Tags</div>
        
            
        
          <a class="button" href="/tags#objc">
            <p><i class="fa fa-tag fa-fw"></i> objc</p>
          </a>
        
          <a class="button" href="/tags#tree">
            <p><i class="fa fa-tag fa-fw"></i> tree</p>
          </a>
        
          <a class="button" href="/tags#二叉树">
            <p><i class="fa fa-tag fa-fw"></i> 二叉树</p>
          </a>
        
        </div>
    </footer>
  

    
</article>

<!-- comment -->

<div class="comments">
  <!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid=MTAyMC8zMzY4My8xMDIzOA==>
<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
</script>
<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
</div>


<!-- Post navigation -->

  <div id="post-nav">
  
  <div id="previous-post" class="post-nav-post">
      <p>Previous</p>
      <a href="/algorithm/2017/06/10/binary-search-tree.html">
        聊聊「二叉搜索树」的那些事儿
      </a>
  </div>
  
  
  <div id="next-post" class="post-nav-post">
      <p>Next</p>
      <a href="/pieces/2017/07/03/ios-corner-radius.html">
        从iOS的图片圆角想到渲染
      </a>
  </div>
  
</div>

    </div>
    
<footer class="site-footer">
    <p class="text"></p>
    <p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a>. Theme by <a href="https://github.com/charsdavy/Type-on-Strap">Type-on-Strap</a>. &copy; 2016 - 2018 </p>
            <div class="footer-icons">
                <ul>
                <!-- Social icons from Font Awesome, if enabled -->
                
<li>
	<a href="http://chars.tech////feed.xml" title="Follow RSS feed">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>



<li>
	<a href="mailto:chars.davy@gmail.com" title="Email">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>









<li>
	<a href="https://www.facebook.com/wei.deng.1460" title="Follow on Facebook">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>





<li>
	<a href="https://github.com/charsdavy" title="Follow on GitHub">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-github fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>

























<li>
	<a href="https://twitter.com/charsdavy" title="Follow on Twitter" class="type">
        <span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>



<li>
    <a href="https://weibo.com/u/3875245858" title="Follow on Weibo" class="type">
        <span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
        </span>
    </a>
</li>








                </ul>
            </div>
</footer>




  </body>
</html>
