<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>毕业论文摘要的书写方法和技巧</title>
    <url>/2013-01-18-college-thesis-summary-skill/</url>
    <content><![CDATA[<p>摘要也就是内容提要，是论文中不可缺少的一部分。论文摘要是一篇具有独立性的短文，有其特别的地方。它是建立在对论文进行总结的基础之上，用简单、明确、易懂、精辟的语言对全文内容加以概括，留主干去枝叶，提取论文的主要信息。作者的观点、论文的主要内容、研究成果、独到的见解，这些都应该在摘要中体现出来。好的摘要便于索引与查找，易于收录到大型资料库中并为他人提供信息。因此摘要在资料交流方面承担着至关重要的作用。</p>
<span id="more"></span>

<p><strong>书写摘要的基本规范和原则</strong> </p>
<p>（1）论文摘要分为中文摘要和外文（一般为英文）摘要。摘要在篇幅方面的限定，不同的学校和机构有不同的要求，通常中文摘要不超过300字，英文摘要不超过250个实词，中英文摘要应一致。毕业论文摘要可适当增加篇幅。 </p>
<p>（2）多向指导教师请教，并根据提供的意见及时修改，以期达到更高水平。 </p>
<p>（3）摘要是完整的短文，具有独立性，可以单独使用。即使不看论文全文的内容，仍然可以理解论文的主要内容、作者的新观点和想法、课题所要实现的目的、采取的方法、研究的结果与结论。 </p>
<p>（4）叙述完整，突出逻辑性，短文结构要合理。 </p>
<p>（5）要求文字简明扼要，不容赘言，提取重要内容，不含前言、背景等细节部分，去掉旧结论、原始数据，不加评论和注释。采用直接表述的方法，删除不必要的文学修饰。摘要中不应包括作者将来的计划以及与此课题无关的内容，做到用最少的文字提供最大的信息量。 </p>
<p>（6）摘要中不使用特殊字符，也不使用图表和化学结构式，以及由特殊字符组成的数学表达式，不列举例证。 </p>
<p><strong>摘要的四要素</strong> </p>
<p>目的、方法、结果和结论称为摘要的四要素。 </p>
<p>（1）目的：指出研究的范围、目的、重要性、任务和前提条件，不是主题的简单重复。 </p>
<p>（2）方法：简述课题的工作流程，研究了哪些主要内容，在这个过程中都做了哪些工作，包括对象、原理、条件、程序、手段等。 </p>
<p>（3）结果：陈述研究之后重要的新发现、新成果及价值，包括通过调研、实验、观察取得的数据和结果，并剖析其不理想的局限部分。 </p>
<p>（4）结论：通过对这个课题的研究所得出的重要结论，包括从中取得证实的正确观点，进行分析研究，比较预测其在实际生活中运用的意义，理论与实际相结合的价值。 </p>
<p><strong>撰写步骤</strong> </p>
<p>摘要作为一种特殊的陈述性短文，书写的步骤也与普通类型的文章有所不同。摘要的写作时间通常在论文的完成之后，但也可以采用提早写的方式，然后再边写论文边修改摘要。首先，从摘要的四要素出发，通读论文全文，仔细将文中的重要内容一一列出，特别是每段的主题句和论文结尾的归纳总结，保留梗概与精华部分，提取用于编写摘要的关键信息。然后，看这些信息能否完全、准确的回答摘要的四要素所涉及的问题，并要求语句精炼。若不足以回答这些问题，则重新阅读论文，摘录相应的内容进行补充。最后，将这些零散信息，组成符合语法规则和逻辑规则的完整句子，再进一步组成通畅的短文，通读此短文，反复修改，达到摘要的要求。 </p>
<p><strong>关于英文摘要</strong> </p>
<p>（1）英文摘要的写作方法要依据公认的写作规范。 </p>
<p>（2）尽量使用简单句，避免句型单调，表达要求准确完整。 </p>
<p>（3）正确使用冠词。 </p>
<p>（4）使用标准英语书写，避免使用口语，应使用易于理解的常用词，不用生僻词汇。 </p>
<p>（5）作者所做工作用过去时，结论用现在时。 </p>
<p>（6）多使用主动语态。 </p>
<p><strong>关键词</strong> </p>
<p>关键词是为了文献标引工作从报告、论文中选出来用以表示全文主题内容信息目的单词术语。每篇报告、论文选取3～8个词作为关键词，以显著的字符另起一行，排在摘要的左方。如有可能，尽量用《汉语主题词表》等词表提供的规范词。为了国际交流，应标注与中文对应的英文关键词。 </p>
<p>关键词是主题词中的一类。主题词是一种新型检索词汇，多用于计算机网络检索。 </p>
<p>关键词分为中文关键词和与之对应的英文关键词，分别置于中文摘要和英文摘要之下。为便于他人的检索，不能使用过于宽泛的词语。选择关键词既可以从论文的各级标题入手，也可以从论文本身的内容选取，将选出的关键词按照所涉及领域的范围从大到小顺序列出。</p>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Server 错误代码和解释 (中篇)</title>
    <url>/2013-01-21-sql-server-state-code-list-2/</url>
    <content><![CDATA[<p>承接<a href="/blog/sql-server-state-code-list-1">《上篇》</a>继续罗列分享SQL Server状态码。</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>错误码</th>
<th>错误原因说明</th>
</tr>
</thead>
<tbody><tr>
<td>2001</td>
<td>指定的驱动程序无效。</td>
</tr>
<tr>
<td>2002</td>
<td>窗口样式或类别属性对此操作无效。</td>
</tr>
<tr>
<td>2003</td>
<td>不支持请求的图元操作。</td>
</tr>
<tr>
<td>2004</td>
<td>不支持请求的变换操作。</td>
</tr>
<tr>
<td>2005</td>
<td>不支持请求的剪切操作。</td>
</tr>
<tr>
<td>2010</td>
<td>指定的颜色管理模块无效。</td>
</tr>
<tr>
<td>2011</td>
<td>制定的颜色文件配置无效。</td>
</tr>
<tr>
<td>2012</td>
<td>找不到指定的标识。</td>
</tr>
<tr>
<td>2013</td>
<td>找不到所需的标识。</td>
</tr>
<tr>
<td>2014</td>
<td>指定的标识已经存在。</td>
</tr>
<tr>
<td>2015</td>
<td>指定的颜色文件配置与任何设备都不相关。</td>
</tr>
<tr>
<td>2016</td>
<td>找不到该指定的颜色文件配置</td>
</tr>
<tr>
<td>2017</td>
<td>指定的颜色空间无效。</td>
</tr>
<tr>
<td>2018</td>
<td>图像颜色管理没有启动。</td>
</tr>
<tr>
<td>2019</td>
<td>在删除该颜色传输时有一个错误。</td>
</tr>
<tr>
<td>2020</td>
<td>该指定的颜色传输无效。</td>
</tr>
<tr>
<td>2021</td>
<td>该指定的变换与位图的颜色空间不匹配。</td>
</tr>
<tr>
<td>2022</td>
<td>该指定的命名颜色索引在配置文件中不存在。</td>
</tr>
<tr>
<td>2102</td>
<td>没有安装工作站驱动程序。</td>
</tr>
<tr>
<td>2103</td>
<td>无法定位服务器。</td>
</tr>
<tr>
<td>2104</td>
<td>发生内部错误，网络无法访问共享内存段。</td>
</tr>
<tr>
<td>2105</td>
<td>网络资源不足。</td>
</tr>
<tr>
<td>2106</td>
<td>工作站不支持这项操作。</td>
</tr>
<tr>
<td>2107</td>
<td>设备没有连接。</td>
</tr>
<tr>
<td>2108</td>
<td>网络连接已成功，但需要提示用户输入一个不同于原始指定的密码。</td>
</tr>
<tr>
<td>2114</td>
<td>没有启动服务器服务。</td>
</tr>
<tr>
<td>2115</td>
<td>队列空。</td>
</tr>
<tr>
<td>2116</td>
<td>设备或目录不存在。</td>
</tr>
<tr>
<td>2117</td>
<td>无法在重定向的资源上执行这项操作。</td>
</tr>
<tr>
<td>2118</td>
<td>名称已经共享。</td>
</tr>
<tr>
<td>2119</td>
<td>服务器当前无法提供所需的资源。</td>
</tr>
<tr>
<td>2121</td>
<td>额外要求的项目超过允许的上限。</td>
</tr>
<tr>
<td>2122</td>
<td>对等服务只支持两个同时操作的用户 。</td>
</tr>
<tr>
<td>2123</td>
<td>API 返回缓冲区太小。</td>
</tr>
<tr>
<td>2127</td>
<td>远程 API 错误。</td>
</tr>
<tr>
<td>2131</td>
<td>打开或读取配置文件时出错。</td>
</tr>
<tr>
<td>2136</td>
<td>发生一般网络错误。</td>
</tr>
<tr>
<td>2137</td>
<td>工作站服务的状态不一致。重新启动工作站服务之前，请先重新启动计算机。</td>
</tr>
<tr>
<td>2138</td>
<td>工作站服务没有启动。</td>
</tr>
<tr>
<td>2139</td>
<td>所需信息不可用。</td>
</tr>
<tr>
<td>2140</td>
<td>发生 Windows 2000 内部错误。</td>
</tr>
<tr>
<td>2141</td>
<td>服务器没有设置事务处理。</td>
</tr>
<tr>
<td>2142</td>
<td>远程服务器不支持请求的 API。</td>
</tr>
<tr>
<td>2143</td>
<td>事件名无效。</td>
</tr>
<tr>
<td>2144</td>
<td>网络上已经有此计算机名。请更名后重新启动。</td>
</tr>
<tr>
<td>2146</td>
<td>配置信息中找不到指定的组件。</td>
</tr>
<tr>
<td>2147</td>
<td>配置信息中找不到指定的参数。</td>
</tr>
<tr>
<td>2149</td>
<td>配置文件中有一个命令行太长。</td>
</tr>
<tr>
<td>2150</td>
<td>打印机不存在。</td>
</tr>
<tr>
<td>2151</td>
<td>打印作业不存在。</td>
</tr>
<tr>
<td>2152</td>
<td>打印机目标找不到。</td>
</tr>
<tr>
<td>2153</td>
<td>打印机目标已经存在。</td>
</tr>
<tr>
<td>2154</td>
<td>打印机队列已经存在。</td>
</tr>
<tr>
<td>2155</td>
<td>无法添加其它的打印机。</td>
</tr>
<tr>
<td>2156</td>
<td>无法添加其它的打印作业。</td>
</tr>
<tr>
<td>2157</td>
<td>无法添加其它的打印机目标。</td>
</tr>
<tr>
<td>2158</td>
<td>此打印机目标处于空闲中，不接受控制操作。</td>
</tr>
<tr>
<td>2159</td>
<td>此“打印机目标请求”包含无效的控制函数。</td>
</tr>
<tr>
<td>2160</td>
<td>打印处理程序没有响应。</td>
</tr>
<tr>
<td>2161</td>
<td>后台处理程序没有运行。</td>
</tr>
<tr>
<td>2162</td>
<td>打印目标当前的状况，无法执行这项操作。</td>
</tr>
<tr>
<td>2163</td>
<td>打印机队列当前的状况，无法执行这项操作。</td>
</tr>
<tr>
<td>2164</td>
<td>打印作业当前的状况，无法执行这项操作。</td>
</tr>
<tr>
<td>2165</td>
<td>无法为后台处理程序分配内存。</td>
</tr>
<tr>
<td>2166</td>
<td>设备驱动程序不存在。</td>
</tr>
<tr>
<td>2167</td>
<td>打印处理程序不支持这种数据类型。</td>
</tr>
<tr>
<td>2168</td>
<td>没有安装打印处理程序。</td>
</tr>
<tr>
<td>2180</td>
<td>锁定服务数据库。</td>
</tr>
<tr>
<td>2181</td>
<td>服务表已满。</td>
</tr>
<tr>
<td>2182</td>
<td>请求的服务已经启动。</td>
</tr>
<tr>
<td>2183</td>
<td>这项服务没有响应控制操作。</td>
</tr>
<tr>
<td>2184</td>
<td>服务仍未启动。</td>
</tr>
<tr>
<td>2185</td>
<td>服务名无效。</td>
</tr>
<tr>
<td>2186</td>
<td>服务没有响应控制功能。</td>
</tr>
<tr>
<td>2187</td>
<td>服务控制处于忙碌状态。</td>
</tr>
<tr>
<td>2188</td>
<td>配置文件包含无效的服务程序名。</td>
</tr>
<tr>
<td>2189</td>
<td>在当前的状况下无法控制服务。</td>
</tr>
<tr>
<td>2190</td>
<td>服务异常终止。</td>
</tr>
<tr>
<td>2191</td>
<td>这项服务无法接受请求的 “暂停” 或 “停止” 操作。</td>
</tr>
<tr>
<td>2192</td>
<td>服务控制“计划程序”在“计划表”中找不到服务名。</td>
</tr>
<tr>
<td>2193</td>
<td>无法读取服务控制计划程序管道。</td>
</tr>
<tr>
<td>2194</td>
<td>无法创建新服务的线程。</td>
</tr>
<tr>
<td>2200</td>
<td>此工作站已经登录到局域网。</td>
</tr>
<tr>
<td>2201</td>
<td>工作站没有登录到局域网。</td>
</tr>
<tr>
<td>2202</td>
<td>指定的用户名无效。</td>
</tr>
<tr>
<td>2203</td>
<td>密码参数无效。</td>
</tr>
<tr>
<td>2204</td>
<td>登录处理器没有添加消息别名。</td>
</tr>
<tr>
<td>2205</td>
<td>登录处理器没有添加消息别名。</td>
</tr>
<tr>
<td>2206</td>
<td>注销处理器没有删除消息别名。</td>
</tr>
<tr>
<td>2207</td>
<td>注销处理器没有删除消息别名。</td>
</tr>
<tr>
<td>2209</td>
<td>暂停网络登录。</td>
</tr>
<tr>
<td>2210</td>
<td>中心登录服务器发生冲突。</td>
</tr>
<tr>
<td>2211</td>
<td>服务器没有设置正确的用户路径。</td>
</tr>
<tr>
<td>2212</td>
<td>加载或运行登录脚本时出错。</td>
</tr>
<tr>
<td>2214</td>
<td>没有指定登录服务器，计算机的登录状态是单机操作。</td>
</tr>
<tr>
<td>2215</td>
<td>登录服务器找不到。</td>
</tr>
<tr>
<td>2216</td>
<td>此计算机已经有一个登录域。</td>
</tr>
<tr>
<td>2217</td>
<td>登录服务器无法验证登录。</td>
</tr>
<tr>
<td>2219</td>
<td>安全数据库找不到。</td>
</tr>
<tr>
<td>2220</td>
<td>组名找不到。</td>
</tr>
<tr>
<td>2221</td>
<td>用户名找不到。</td>
</tr>
<tr>
<td>2222</td>
<td>资源名找不到。</td>
</tr>
<tr>
<td>2223</td>
<td>组已经存在。</td>
</tr>
<tr>
<td>2224</td>
<td>帐户已经存在。</td>
</tr>
<tr>
<td>2225</td>
<td>资源使用权限清单已经存在。</td>
</tr>
<tr>
<td>2226</td>
<td>此操作只能在该域的主域控制器上执行。</td>
</tr>
<tr>
<td>2227</td>
<td>安全数据库没有启动。</td>
</tr>
<tr>
<td>2228</td>
<td>用户帐户数据库中的名称太多。</td>
</tr>
<tr>
<td>2229</td>
<td>磁盘 I&#x2F;O 失败。</td>
</tr>
<tr>
<td>2230</td>
<td>已经超过每个资源 64 个项目的限制。</td>
</tr>
<tr>
<td>2231</td>
<td>不得删除带会话的用户。</td>
</tr>
<tr>
<td>2232</td>
<td>上层目录找不到。</td>
</tr>
<tr>
<td>2233</td>
<td>无法添加到安全数据库会话高速缓存段。</td>
</tr>
<tr>
<td>2234</td>
<td>这项操作不能在此特殊的组上执行。</td>
</tr>
<tr>
<td>2235</td>
<td>用户帐户数据库会话高速缓存没有记录此用户。</td>
</tr>
<tr>
<td>2236</td>
<td>用户已经属于此组。</td>
</tr>
<tr>
<td>2237</td>
<td>用户不属于此组。</td>
</tr>
<tr>
<td>2238</td>
<td>此用户帐户尚未定义。</td>
</tr>
<tr>
<td>2239</td>
<td>此用户帐户已过期。</td>
</tr>
<tr>
<td>2240</td>
<td>此用户不得从此工作站登录网络。</td>
</tr>
<tr>
<td>2241</td>
<td>这时候不允许用户登录网络。</td>
</tr>
<tr>
<td>2242</td>
<td>此用户的密码已经过期。</td>
</tr>
<tr>
<td>2243</td>
<td>此用户的密码无法更改。</td>
</tr>
<tr>
<td>2244</td>
<td>现在无法使用此密码。</td>
</tr>
<tr>
<td>2245</td>
<td>密码不满足密码策略的需要。检查最小密码长度、密码复杂性和密码历史的需求。</td>
</tr>
<tr>
<td>2246</td>
<td>此用户的密码最近才启用，现在不能更改。</td>
</tr>
<tr>
<td>2247</td>
<td>安全数据库已损坏。</td>
</tr>
<tr>
<td>2248</td>
<td>不需要更新此副本复制的网络&#x2F;本地安全数据库。</td>
</tr>
<tr>
<td>2249</td>
<td>此副本复制的数据库已过时；请同步处理其中的数据。</td>
</tr>
<tr>
<td>2250</td>
<td>此网络连接不存在。</td>
</tr>
<tr>
<td>2251</td>
<td>此 asg_type 无效。</td>
</tr>
<tr>
<td>2252</td>
<td>此设备当前正在共享中。</td>
</tr>
<tr>
<td>2270</td>
<td>计算机名无法作为消息别名添加。网络上可能已经有此名称。</td>
</tr>
<tr>
<td>2271</td>
<td>信使服务已经启动。</td>
</tr>
<tr>
<td>2272</td>
<td>信使服务启动失败。</td>
</tr>
<tr>
<td>2273</td>
<td>网络上找不到此消息别名。</td>
</tr>
<tr>
<td>2274</td>
<td>此消息别名已经转发出去。</td>
</tr>
<tr>
<td>2275</td>
<td>已经添加了此消息别名，但是仍被转发。</td>
</tr>
<tr>
<td>2276</td>
<td>此消息别名已在本地存在。</td>
</tr>
<tr>
<td>2277</td>
<td>添加的消息别名已经超过数目上限。</td>
</tr>
<tr>
<td>2278</td>
<td>无法删除计算机名。</td>
</tr>
<tr>
<td>2279</td>
<td>消息无法转发回到同一个工作站。</td>
</tr>
<tr>
<td>2280</td>
<td>域消息处理器出错。</td>
</tr>
<tr>
<td>2281</td>
<td>消息已经发送出去，但是收件者已经暂停信使服务。</td>
</tr>
<tr>
<td>2282</td>
<td>消息已经发送出去，但尚未收到。</td>
</tr>
<tr>
<td>2283</td>
<td>消息别名当前正在使用中。请稍候片刻再试。</td>
</tr>
<tr>
<td>2284</td>
<td>信使服务尚未启动。</td>
</tr>
<tr>
<td>2285</td>
<td>该名称不在本地计算机上。</td>
</tr>
<tr>
<td>2286</td>
<td>网络上找不到转发的消息别名。</td>
</tr>
<tr>
<td>2287</td>
<td>远程通讯站的消息别名表已经满了。</td>
</tr>
<tr>
<td>2288</td>
<td>此别名的消息当前没有在转发中。</td>
</tr>
<tr>
<td>2289</td>
<td>广播的消息被截断。</td>
</tr>
<tr>
<td>2294</td>
<td>设备名无效。</td>
</tr>
<tr>
<td>2295</td>
<td>写入出错。</td>
</tr>
<tr>
<td>2297</td>
<td>网络上的消息别名重复。</td>
</tr>
<tr>
<td>2298</td>
<td>此消息别名会在稍后删除。</td>
</tr>
<tr>
<td>2299</td>
<td>没有从所有的网络删除消息别名。</td>
</tr>
<tr>
<td>2300</td>
<td>这项操作无法在使用多种网络的计算机上执行。</td>
</tr>
<tr>
<td>2310</td>
<td>此共享的资源不存在。</td>
</tr>
<tr>
<td>2311</td>
<td>设备没有共享。</td>
</tr>
<tr>
<td>2312</td>
<td>带此计算机名的会话不存在。</td>
</tr>
<tr>
<td>2314</td>
<td>没有用此识别号打开的文件。</td>
</tr>
<tr>
<td>2315</td>
<td>执行远程管理命令失败。</td>
</tr>
<tr>
<td>2316</td>
<td>打开远程临时文件失败。</td>
</tr>
<tr>
<td>2317</td>
<td>从远程管理命令返回的数据已经被截断成 64K。</td>
</tr>
<tr>
<td>2318</td>
<td>此设备无法同时共享为后台处理资源和非后台处理资源。</td>
</tr>
<tr>
<td>2319</td>
<td>服务器清单中的信息可能不正确</td>
</tr>
<tr>
<td>2320</td>
<td>计算机在此域未处于活动状态</td>
</tr>
<tr>
<td>2321</td>
<td>在删除共享之前，需要将该共享从分布式文件系统中删除。</td>
</tr>
<tr>
<td>2331</td>
<td>无法在此设备执行这项操作</td>
</tr>
<tr>
<td>2332</td>
<td>此设备无法共享。</td>
</tr>
<tr>
<td>2333</td>
<td>此设备未打开。</td>
</tr>
<tr>
<td>2334</td>
<td>此设备名清单无效。</td>
</tr>
<tr>
<td>2335</td>
<td>队列优先级无效。</td>
</tr>
<tr>
<td>2337</td>
<td>没有任何共享的通讯设备。</td>
</tr>
<tr>
<td>2338</td>
<td>指定的队列不存在。</td>
</tr>
<tr>
<td>2340</td>
<td>此设备清单无效。</td>
</tr>
<tr>
<td>2341</td>
<td>请求的设备无效。</td>
</tr>
<tr>
<td>2342</td>
<td>后台处理程序正在使用此设备。</td>
</tr>
<tr>
<td>2343</td>
<td>此设备已经被当成通讯设备来使用。</td>
</tr>
<tr>
<td>2351</td>
<td>此计算机名无效。</td>
</tr>
<tr>
<td>2354</td>
<td>指定的字符串及前缀太长。</td>
</tr>
<tr>
<td>2356</td>
<td>此路径组成部分无效。</td>
</tr>
<tr>
<td>2357</td>
<td>无法判断输入类型。</td>
</tr>
<tr>
<td>2362</td>
<td>类型缓冲区不够大。</td>
</tr>
<tr>
<td>2370</td>
<td>配置文件不得超过 64K。</td>
</tr>
<tr>
<td>2371</td>
<td>初始偏移量越界。</td>
</tr>
<tr>
<td>2372</td>
<td>系统无法删除当前到网络资源的连接。</td>
</tr>
<tr>
<td>2373</td>
<td>系统无法分析此文件中的命令行。</td>
</tr>
<tr>
<td>2374</td>
<td>加载配置文件时出错。</td>
</tr>
<tr>
<td>2375</td>
<td>保存配置文件时出错，只部份地保存了配置文件。</td>
</tr>
<tr>
<td>2378</td>
<td>此日志文件在前后两次读取之间已经发生变化。</td>
</tr>
<tr>
<td>2380</td>
<td>资源路径不可以是目录。</td>
</tr>
<tr>
<td>2381</td>
<td>资源路径无效。</td>
</tr>
<tr>
<td>2382</td>
<td>目标路径无效。</td>
</tr>
<tr>
<td>2383</td>
<td>源路径及目标路径分属不同的服务器。</td>
</tr>
<tr>
<td>2385</td>
<td>请求的 Run 服务器现在暂停。</td>
</tr>
<tr>
<td>2389</td>
<td>与 Run 服务器通讯时出错。</td>
</tr>
<tr>
<td>2391</td>
<td>启动后台处理时出错。</td>
</tr>
<tr>
<td>2392</td>
<td>找不到您连接的共享资源。</td>
</tr>
<tr>
<td>2400</td>
<td>LAN 适配器号码无效。</td>
</tr>
<tr>
<td>2401</td>
<td>此网络连接有文件打开或请求挂起。</td>
</tr>
<tr>
<td>2402</td>
<td>使用中的连接仍存在。</td>
</tr>
<tr>
<td>2403</td>
<td>此共享名或密码无效。</td>
</tr>
<tr>
<td>2404</td>
<td>设备正由活动进程使用，无法断开。</td>
</tr>
<tr>
<td>2405</td>
<td>此驱动器号已在本地使用。</td>
</tr>
<tr>
<td>2430</td>
<td>指定的客户已经在指定的事件注册。</td>
</tr>
<tr>
<td>2431</td>
<td>警报表已满。</td>
</tr>
<tr>
<td>2432</td>
<td>发出的警报名称无效或不存在。</td>
</tr>
<tr>
<td>2433</td>
<td>警报接收者无效。</td>
</tr>
<tr>
<td>2434</td>
<td>用户的登录时间长短不再合法。 所以已经删除用户与该服务器的会话。</td>
</tr>
<tr>
<td>2440</td>
<td>日志文件中没有请求的记录号。</td>
</tr>
<tr>
<td>2450</td>
<td>用户帐户数据库没有正确配置。</td>
</tr>
<tr>
<td>2451</td>
<td>当 Netlogon 服务正在运行时，不允许执行这项操作。</td>
</tr>
<tr>
<td>2452</td>
<td>这项操作无法在最后的管理帐户上执行。</td>
</tr>
<tr>
<td>2453</td>
<td>找不到此域的域控制器。</td>
</tr>
<tr>
<td>2454</td>
<td>无法设置此用户的登录信息。</td>
</tr>
<tr>
<td>2455</td>
<td>Netlogon 服务尚未启动。</td>
</tr>
<tr>
<td>2456</td>
<td>无法添加到用户帐户数据库。</td>
</tr>
<tr>
<td>2457</td>
<td>此服务器的时钟与主域控制器的时钟不一致。</td>
</tr>
<tr>
<td>2458</td>
<td>检测到密码不匹配。</td>
</tr>
<tr>
<td>2460</td>
<td>服务器识别码没有指定有效的服务器。</td>
</tr>
<tr>
<td>2461</td>
<td>会话标识没有指定有效的会话。</td>
</tr>
<tr>
<td>2462</td>
<td>连接识别码没有指定有效的连接。</td>
</tr>
<tr>
<td>2463</td>
<td>可用服务器表中无法再加上其它项。</td>
</tr>
<tr>
<td>2464</td>
<td>服务器已经到了支持的会话数目上限。</td>
</tr>
<tr>
<td>2465</td>
<td>服务器已经到了支持的连接数目上限。</td>
</tr>
<tr>
<td>2466</td>
<td>服务器打开的文件到了上限，无法打开更多文件。</td>
</tr>
<tr>
<td>2467</td>
<td>这台服务器没有登记替换的服务器。</td>
</tr>
<tr>
<td>2470</td>
<td>请用低级的 API (远程管理协议)。</td>
</tr>
<tr>
<td>2480</td>
<td>UPS 服务无法访问 UPS 驱动程序。</td>
</tr>
<tr>
<td>2481</td>
<td>UPS 服务设置错误。</td>
</tr>
<tr>
<td>2482</td>
<td>UPS 服务无法访问指定通讯端口 (Comm Port)。</td>
</tr>
<tr>
<td>2483</td>
<td>UPS 显示线路中断或电池不足，服务没有启动。</td>
</tr>
<tr>
<td>2484</td>
<td>UPS 服务无法执行系统关机的操作。</td>
</tr>
<tr>
<td>2500</td>
<td>下面的程序返回一个 MS-DOS 错误码。</td>
</tr>
<tr>
<td>2501</td>
<td>下面的程序需要更多的内存。</td>
</tr>
<tr>
<td>2502</td>
<td>下面程序调用了不支持的 MS-DOS 函数。</td>
</tr>
<tr>
<td>2503</td>
<td>工作站无法启动。</td>
</tr>
<tr>
<td>2504</td>
<td>下面的文件已损坏。</td>
</tr>
<tr>
<td>2505</td>
<td>启动块定义文件中没有指定引导程序。</td>
</tr>
<tr>
<td>2506</td>
<td>NetBIOS 返回错误: NCB 及 SMB 数据转储。</td>
</tr>
<tr>
<td>2507</td>
<td>磁盘 I&#x2F;O 错误。</td>
</tr>
<tr>
<td>2508</td>
<td>无法替换映像参数。</td>
</tr>
<tr>
<td>2509</td>
<td>跨越磁盘扇区范围的映像参数太多。</td>
</tr>
<tr>
<td>2510</td>
<td>不是从用 &#x2F;S 格式化的 MS-DOS软盘产生的映像。</td>
</tr>
<tr>
<td>2511</td>
<td>稍后会从远程重新启动。</td>
</tr>
<tr>
<td>2512</td>
<td>无法调用远程启动服务器。</td>
</tr>
<tr>
<td>2513</td>
<td>无法连接到远程启动服务器。</td>
</tr>
<tr>
<td>2514</td>
<td>无法打开远程启动服务器上的映像文件。</td>
</tr>
<tr>
<td>2515</td>
<td>正在连接到远程启动服务器…</td>
</tr>
<tr>
<td>2516</td>
<td>正在连接到远程启动服务器…</td>
</tr>
<tr>
<td>2517</td>
<td>远程启动服务已经停止，请检测错误记录文件，查明出错的原因。</td>
</tr>
<tr>
<td>2518</td>
<td>远程启动失败，请检查错误日志文件，查明出错的原因。</td>
</tr>
<tr>
<td>2519</td>
<td>不允许第二个远程启动 (Remoteboot) 资源连接。</td>
</tr>
<tr>
<td>2550</td>
<td>浏览服务设置成 MaintainServerList&#x3D;No。</td>
</tr>
<tr>
<td>2610</td>
<td>因为没有网卡与这项服务一起启动，所以无法启动服务。</td>
</tr>
<tr>
<td>2611</td>
<td>因为注册表中的启动信息不正确，所以无法启动服务。</td>
</tr>
<tr>
<td>2612</td>
<td>无法启动服务，原因是它的数据库找不到或损坏。</td>
</tr>
<tr>
<td>2613</td>
<td>因为找不到 RPLFILES 共享的资源，所以无法启动服务。</td>
</tr>
<tr>
<td>2614</td>
<td>因为找不到 RPLUSER 组，所以无法启动服务。</td>
</tr>
<tr>
<td>2615</td>
<td>无法枚举服务记录。</td>
</tr>
<tr>
<td>2616</td>
<td>工作站记录信息已损坏。</td>
</tr>
<tr>
<td>2617</td>
<td>工作站记录找不到。</td>
</tr>
<tr>
<td>2618</td>
<td>其它的工作站正在使用此工作站名。</td>
</tr>
<tr>
<td>2619</td>
<td>配置文件记录已损坏。</td>
</tr>
<tr>
<td>2620</td>
<td>配置文件记录找不到。</td>
</tr>
<tr>
<td>2621</td>
<td>其它的配置文件正在使用此名称。</td>
</tr>
<tr>
<td>2622</td>
<td>有很多工作站正在使用此配置文件。</td>
</tr>
<tr>
<td>2623</td>
<td>配置记录已损坏。</td>
</tr>
<tr>
<td>2624</td>
<td>配置记录找不到。</td>
</tr>
<tr>
<td>2625</td>
<td>适配器识别记录已损坏。</td>
</tr>
<tr>
<td>2626</td>
<td>内部服务出错。</td>
</tr>
<tr>
<td>2627</td>
<td>供应商识别记录已损坏。</td>
</tr>
<tr>
<td>2628</td>
<td>启动块记录已损坏。</td>
</tr>
<tr>
<td>2629</td>
<td>找不到此工作站的用户帐户记录。</td>
</tr>
<tr>
<td>2630</td>
<td>RPLUSER 本地组找不到。</td>
</tr>
<tr>
<td>2631</td>
<td>找不到启动块记录。</td>
</tr>
<tr>
<td>2632</td>
<td>所选的配置文件与此工作站不兼容。</td>
</tr>
<tr>
<td>2633</td>
<td>其它的工作站正在使用所选的网卡。</td>
</tr>
<tr>
<td>2634</td>
<td>有些配置文件正在使用此配置。</td>
</tr>
<tr>
<td>2635</td>
<td>有数个工作站、配置文件或配置正在使用此启动块。</td>
</tr>
<tr>
<td>2636</td>
<td>服务无法制作远程启动数据库的备份。</td>
</tr>
<tr>
<td>2637</td>
<td>找不到适配器记录。</td>
</tr>
<tr>
<td>2638</td>
<td>找不到供应商记录。</td>
</tr>
<tr>
<td>2639</td>
<td>其它供应商记录正在使用此供应商名称。</td>
</tr>
<tr>
<td>2640</td>
<td>其它的启动区记录正在使用启动名称或供应商识别记录。</td>
</tr>
<tr>
<td>2641</td>
<td>其它的配置正在使用此配置名称。</td>
</tr>
<tr>
<td>2660</td>
<td>由 Dfs 服务所维护的内部数据库已损坏</td>
</tr>
<tr>
<td>2661</td>
<td>内部数据库中的一条记录已 损坏</td>
</tr>
<tr>
<td>2662</td>
<td>输入项路径与卷路径不匹配</td>
</tr>
<tr>
<td>2663</td>
<td>给定卷名已存在</td>
</tr>
<tr>
<td>2664</td>
<td>指定的服务器共享已在 Dfs 中共享</td>
</tr>
<tr>
<td>2665</td>
<td>所显示的服务器共享不支持所显示的 Dfs 卷</td>
</tr>
<tr>
<td>2666</td>
<td>此操作在非叶卷上无效。</td>
</tr>
<tr>
<td>2667</td>
<td>此操作在叶卷上无效。</td>
</tr>
<tr>
<td>2668</td>
<td>此操作不明确，因为该卷存在多服务器。</td>
</tr>
<tr>
<td>2669</td>
<td>无法创建连接点</td>
</tr>
<tr>
<td>2670</td>
<td>该服务器不是 Dfs 可识别的</td>
</tr>
<tr>
<td>2671</td>
<td>指定的重命名目标路径无效。</td>
</tr>
<tr>
<td>2672</td>
<td>指定 Dfs 卷脱线</td>
</tr>
<tr>
<td>2673</td>
<td>指定的服务器不为此卷服务</td>
</tr>
<tr>
<td>2674</td>
<td>检测到 Dfs 名中的环路</td>
</tr>
<tr>
<td>2675</td>
<td>在基于服务器的 Dfs 上不支持该操作</td>
</tr>
<tr>
<td>2676</td>
<td>这个卷已经受该指定服务器共享支持</td>
</tr>
<tr>
<td>2677</td>
<td>无法删除这个卷的上一个服务器共享支持</td>
</tr>
<tr>
<td>2678</td>
<td>Inter-Dfs 卷不支持该操作</td>
</tr>
<tr>
<td>2679</td>
<td>Dfs 服务的内部状态已经变得不一致</td>
</tr>
<tr>
<td>2680</td>
<td>Dfs 服务已经安装在指定的服务器上</td>
</tr>
<tr>
<td>2681</td>
<td>被协调的 Dfs 数据是一样的</td>
</tr>
<tr>
<td>2682</td>
<td>无法删除 Dfs 根目录卷 - 如需要请卸载 Dfs</td>
</tr>
<tr>
<td>2683</td>
<td>该共享的子目录或父目录已经存在在一个 Dfs 中</td>
</tr>
<tr>
<td>2690</td>
<td>Dfs 内部错误</td>
</tr>
<tr>
<td>2691</td>
<td>这台机器已经加入域 。</td>
</tr>
<tr>
<td>2692</td>
<td>这个机器目前未加入域。</td>
</tr>
<tr>
<td>2693</td>
<td>这台机器是域控制器，而且无法从域中退出。</td>
</tr>
<tr>
<td>2694</td>
<td>目标域控制器不支持在 OU 中创建的机器帐户。</td>
</tr>
<tr>
<td>2695</td>
<td>指定的工作组名无效</td>
</tr>
<tr>
<td>2696</td>
<td>指定的计算机名与域控制器上使用的默认语言不兼容。</td>
</tr>
<tr>
<td>2697</td>
<td>找不到指定的计算机帐户。</td>
</tr>
<tr>
<td>2999</td>
<td>这是 NERR 范围内的最后一个错误。</td>
</tr>
<tr>
<td>3000</td>
<td>指定了未知的打印监视器。</td>
</tr>
<tr>
<td>3001</td>
<td>指定的打印机驱动程序当前正在使用。</td>
</tr>
<tr>
<td>3002</td>
<td>找不到缓冲文件。</td>
</tr>
<tr>
<td>3003</td>
<td>未发送 StartDocPrinter 调用。</td>
</tr>
<tr>
<td>3004</td>
<td>未发送 AddJob 调用。</td>
</tr>
<tr>
<td>3005</td>
<td>指定的打印处理器已经安装。</td>
</tr>
<tr>
<td>3006</td>
<td>指定的打印监视器已经安装。</td>
</tr>
<tr>
<td>3007</td>
<td>该指定的打印监视器不具备所要求的功能。</td>
</tr>
<tr>
<td>3008</td>
<td>该指定的打印监视器正在使用中。</td>
</tr>
<tr>
<td>3009</td>
<td>当打印机有作业排成队列时此操作请求是不允许的。</td>
</tr>
<tr>
<td>3010</td>
<td>请求的操作成功。直到重新启动系统前更改将不会生效。</td>
</tr>
<tr>
<td>3011</td>
<td>请求的操作成功。直到重新启动服务前更改将不会生效。</td>
</tr>
<tr>
<td>3012</td>
<td>找不到打印机。</td>
</tr>
<tr>
<td>3023</td>
<td>用户指定的关机命令文件，它的配置有问题。 不过 UPS 服务已经启动。</td>
</tr>
<tr>
<td>3029</td>
<td>因为用户帐户数据库 (NET.ACC) 找不到或损坏， 而且也没有可用的备份数据库， 所以不能启动本地安全机制。 系统不安全！</td>
</tr>
<tr>
<td>3037</td>
<td>@I *登录小时数</td>
</tr>
<tr>
<td>3039</td>
<td>已经超过一个目录中文件的副本复制的限制。</td>
</tr>
<tr>
<td>3040</td>
<td>已经超过副本复制的目录树深度限制。</td>
</tr>
<tr>
<td>3046</td>
<td>无法登录。用户当前已经登录，同时参数 TRYUSER 设置为 NO。</td>
</tr>
<tr>
<td>3052</td>
<td>命令行或配置文件中 没有提供必要的参数。</td>
</tr>
<tr>
<td>3054</td>
<td>无法满足资源的请求。</td>
</tr>
<tr>
<td>3055</td>
<td>系统配置有问题。</td>
</tr>
<tr>
<td>3056</td>
<td>系统出错。</td>
</tr>
<tr>
<td>3057</td>
<td>发生内部一致性的错误。</td>
</tr>
<tr>
<td>3058</td>
<td>配置文件或命令行的选项不明确。</td>
</tr>
<tr>
<td>3059</td>
<td>配置文件或命令行的参数重复。</td>
</tr>
<tr>
<td>3060</td>
<td>服务没有响应控制， DosKillProc 函数已经停止服务。</td>
</tr>
<tr>
<td>3061</td>
<td>运行服务程序时出错。</td>
</tr>
<tr>
<td>3062</td>
<td>无法启动次级服务。</td>
</tr>
<tr>
<td>3064</td>
<td>文件有问题。</td>
</tr>
<tr>
<td>3070</td>
<td>内存</td>
</tr>
<tr>
<td>3071</td>
<td>磁盘空间</td>
</tr>
<tr>
<td>3072</td>
<td>线程</td>
</tr>
<tr>
<td>3073</td>
<td>过程</td>
</tr>
<tr>
<td>3074</td>
<td>安全性失败。</td>
</tr>
<tr>
<td>3075</td>
<td>LAN Manager 根目录不正确或找不到。</td>
</tr>
<tr>
<td>3076</td>
<td>未安装网络软件。</td>
</tr>
<tr>
<td>3077</td>
<td>服务器未启动。</td>
</tr>
<tr>
<td>3078</td>
<td>服务器无法访问用户帐户数据库 (NET.ACC)。</td>
</tr>
<tr>
<td>3079</td>
<td>LANMAN 树中安装的文件不兼容。</td>
</tr>
<tr>
<td>3080</td>
<td>LANMAN\LOGS 目录无效。</td>
</tr>
<tr>
<td>3081</td>
<td>指定的域无法使用。</td>
</tr>
<tr>
<td>3082</td>
<td>另一计算机正将此计算机名当作消息别名使用。</td>
</tr>
<tr>
<td>3083</td>
<td>宣布服务器名失败。</td>
</tr>
<tr>
<td>3084</td>
<td>用户帐户数据库没有正确配置。</td>
</tr>
<tr>
<td>3085</td>
<td>服务器没有运行用户级安全功能。</td>
</tr>
<tr>
<td>3087</td>
<td>工作站设置不正确。</td>
</tr>
<tr>
<td>3088</td>
<td>查看您的错误日志文件以了解详细信息。</td>
</tr>
<tr>
<td>3089</td>
<td>无法写入此文件。</td>
</tr>
<tr>
<td>3090</td>
<td>ADDPAK 文件损坏。请删除 LANMAN\NETPROG\ADDPAK.SER 后重新应用所有的 ADDPAK。</td>
</tr>
<tr>
<td>3091</td>
<td>因为没有运行 CACHE.EXE，所以无法启动 LM386 服务器。</td>
</tr>
<tr>
<td>3092</td>
<td>安全数据库中找不到这台计算机的帐户。</td>
</tr>
<tr>
<td>3093</td>
<td>这台计算机不是 SERVERS 组的成员。</td>
</tr>
<tr>
<td>3094</td>
<td>SERVERS 组没有在本地安全数据库中。</td>
</tr>
<tr>
<td>3095</td>
<td>此 Windows NT 计算机被设置为某个组的成员， 并不是域的成员。 此种配置下不需要运行 Netlogon 服务。</td>
</tr>
<tr>
<td>3096</td>
<td>找不到此域的 Windows NT 域控制器。</td>
</tr>
<tr>
<td>3098</td>
<td>服务无法与主域控制器进行验证。</td>
</tr>
<tr>
<td>3099</td>
<td>安全数据库文件创建日期或序号有问题。</td>
</tr>
<tr>
<td>3100</td>
<td>因为网络软件出错，所以无法执行操作。</td>
</tr>
<tr>
<td>3102</td>
<td>这项服务无法长期锁定网络控制块 (NCB) 的段。 错误码就是相关数据。</td>
</tr>
<tr>
<td>3103</td>
<td>这项服务无法解除网络控制块 (NCB) 段的长期锁定。 错误码就是相关数据。</td>
</tr>
<tr>
<td>3106</td>
<td>收到意外的网络控制块 (NCB)。NCB 就是相关数据。</td>
</tr>
<tr>
<td>3107</td>
<td>网络没有启动。</td>
</tr>
<tr>
<td>3108</td>
<td>NETWKSTA.SYS 的 DosDevIoctl 或 DosFsCtl 调用失败。 显示的数据为以下格式: DWORD 值代表调用 Ioctl 或 FsCtl 的 CS:IP WORD 错误代码 WORD Ioctl 或 FsCtl 号</td>
</tr>
<tr>
<td>3111</td>
<td>发生意外的 NetBIOS 错误。 错误码就是相关数据。</td>
</tr>
<tr>
<td>3112</td>
<td>收到的服务器消息块 (SMB) 无效。 SMB 就是相关数据。</td>
</tr>
<tr>
<td>3114</td>
<td>因为缓冲区溢出， 所以错误日志文件中部份的项目丢失。</td>
</tr>
<tr>
<td>3120</td>
<td>控制网络缓冲区以外资源用量的初始化参数被设置大小， 因此需要的内存太多。</td>
</tr>
<tr>
<td>3121</td>
<td>服务器无法增加内存段的大小。</td>
</tr>
<tr>
<td>3124</td>
<td>服务器启动失败。三个 chdev 参数必须同时为零或者同时不为零。</td>
</tr>
<tr>
<td>3129</td>
<td>服务器无法更新 AT 计划文件。 文件损坏。</td>
</tr>
<tr>
<td>3130</td>
<td>服务器调用 NetMakeLMFileName 时出错。 错误码就是相关数据。</td>
</tr>
<tr>
<td>3132</td>
<td>无法长期锁定服务器缓冲区。 请检查交换磁盘的可用空间，然后重新启动系统以启动服务器。</td>
</tr>
<tr>
<td>3140</td>
<td>因为多次连续出现网络控制块 (NCB) 错误，所以停止服务。 最后一个坏的 NCB 以原始数据形式出现。</td>
</tr>
<tr>
<td>3141</td>
<td>因为消息服务器共享的数据段被锁住， 所以消息服务器已经停止运行。</td>
</tr>
<tr>
<td>3151</td>
<td>因为 VIO 调用出错，所以无法弹出显示消息。 错误码就是相关数据。</td>
</tr>
<tr>
<td>3152</td>
<td>收到的服务器消息块 (SMB) 无效。SMB 就是相关数据。</td>
</tr>
<tr>
<td>3160</td>
<td>工作站信息段大于 64K。 大小如下(以 DWORD 值的格式):</td>
</tr>
<tr>
<td>3161</td>
<td>工作站无法取得计算机的名称号码。</td>
</tr>
<tr>
<td>3162</td>
<td>工作站无法初始化 Async NetBIOS 线程。 错误码就是相关数据。</td>
</tr>
<tr>
<td>3163</td>
<td>工作站无法打开最前面的共享段。 错误码就是相关数据。</td>
</tr>
<tr>
<td>3164</td>
<td>工作站主机表已满。</td>
</tr>
<tr>
<td>3165</td>
<td>收到的邮筒服务器消息块 (SMB) 有问题，SMB 就是相关数据。</td>
</tr>
<tr>
<td>3166</td>
<td>工作站启动用户帐户数据库时出错。 错误码就是相关数据。</td>
</tr>
<tr>
<td>3167</td>
<td>工作站响应 SSI 重新验证请求时出错。 函数码及错误码就是相关数据。</td>
</tr>
<tr>
<td>3174</td>
<td>服务器无法读取 AT 计划文件。</td>
</tr>
<tr>
<td>3175</td>
<td>服务器发现错误的 AT 计划记录。</td>
</tr>
<tr>
<td>3176</td>
<td>服务器找不到 AT 计划文件，所以创建一个计划文件。</td>
</tr>
<tr>
<td>3185</td>
<td>因为用户帐户数据库 (NET.ACC) 找不到或损坏， 而且也没有可用的备份数据库， 所以不能启动本地安全机制。 系统不安全！</td>
</tr>
<tr>
<td>3204</td>
<td>服务器无法创建线程。 CONFIG.SYS 中的 THREADS 参数必须加大。</td>
</tr>
<tr>
<td>3213</td>
<td>已经超过一个目录中文件的副本复制的限制。</td>
</tr>
<tr>
<td>3214</td>
<td>已经超过副本复制的目录树深度限制。</td>
</tr>
<tr>
<td>3215</td>
<td>邮筒中收到的消息无法识别。</td>
</tr>
<tr>
<td>3217</td>
<td>无法登录。用户当前已经登录，同时参数 TRYUSER 设置为 NO。</td>
</tr>
<tr>
<td>3230</td>
<td>检测到服务器的电源中断。</td>
</tr>
<tr>
<td>3231</td>
<td>UPS 服务已经关掉服务器。</td>
</tr>
<tr>
<td>3232</td>
<td>UPS 服务没有完成执行用户指定的 关机命令文件。</td>
</tr>
<tr>
<td>3233</td>
<td>无法打开 UPS 驱动程序。 错误码就是相关数据。</td>
</tr>
<tr>
<td>3234</td>
<td>电源已经恢复。</td>
</tr>
<tr>
<td>3235</td>
<td>用户指定的关机命令文件 有问题。</td>
</tr>
<tr>
<td>3256</td>
<td>该项服务的动态链接库 发生无法修复的错误。</td>
</tr>
<tr>
<td>3257</td>
<td>系统返回意外的错误码。 错误码就是相关数据。</td>
</tr>
<tr>
<td>3258</td>
<td>容错错误日志文件 - LANROOT\LOGS\FT.LOG 超过 64K。</td>
</tr>
<tr>
<td>3259</td>
<td>容错错误日志文件 - LANROOT\LOGS\FT.LOG，在被打开时就已设置 更新进度位，这表示上次使用错误日志时， 系统死机。</td>
</tr>
<tr>
<td>3301</td>
<td>Remote IPC</td>
</tr>
<tr>
<td>3302</td>
<td>Remote Admin</td>
</tr>
<tr>
<td>3303</td>
<td>Logon server share</td>
</tr>
<tr>
<td>3304</td>
<td>网络出错。</td>
</tr>
<tr>
<td>3400</td>
<td>内存不足，无法启动工作站服务。</td>
</tr>
<tr>
<td>3401</td>
<td>读取 LAMAN.INI 文件的 NETWORKS 项目出错。</td>
</tr>
<tr>
<td>3404</td>
<td>LAMAN.INI 文件中的 NETWORKS 项目太多。</td>
</tr>
<tr>
<td>3408</td>
<td>程序无法用在此操作系统。</td>
</tr>
<tr>
<td>3409</td>
<td>已经安装转发程序。</td>
</tr>
<tr>
<td>3411</td>
<td>安装 NETWKSTA.SYS 时出错。 请按 ENTER 继续。</td>
</tr>
<tr>
<td>3412</td>
<td>求解程序链接问题。</td>
</tr>
<tr>
<td>3419</td>
<td>您已经打开文件或设备， 强制断开会造成数据丢失。</td>
</tr>
<tr>
<td>3420</td>
<td>内部用的默认共享</td>
</tr>
<tr>
<td>3421</td>
<td>信使服务</td>
</tr>
<tr>
<td>3500</td>
<td>命令成功完成。</td>
</tr>
<tr>
<td>3501</td>
<td>使用的选项无效。</td>
</tr>
<tr>
<td>3503</td>
<td>命令包含无效的参数个数。</td>
</tr>
<tr>
<td>3504</td>
<td>命令运行完毕，但发生一个或多个错误。</td>
</tr>
<tr>
<td>3505</td>
<td>使用的选项数值不正确。</td>
</tr>
<tr>
<td>3510</td>
<td>命令使用了冲突的选项。</td>
</tr>
<tr>
<td>3512</td>
<td>软件需要新版的 操作系统。</td>
</tr>
<tr>
<td>3513</td>
<td>数据多于 Windows 2000 所能够返回的。</td>
</tr>
<tr>
<td>3515</td>
<td>此命令只能用在 Windows 2000 域控制器。</td>
</tr>
<tr>
<td>3516</td>
<td>这个指令不能用于一个 Windows 2000 域控制器。</td>
</tr>
<tr>
<td>3520</td>
<td>已经启动以下 Windows 2000 服务:</td>
</tr>
<tr>
<td>3525</td>
<td>停止工作站服务也会同时停止服务器服务 。</td>
</tr>
<tr>
<td>3526</td>
<td>工作站有打开的文件。</td>
</tr>
<tr>
<td>3533</td>
<td>服务正在启动或停止中，请稍候片刻后再试一次。</td>
</tr>
<tr>
<td>3534</td>
<td>服务没有报告任何错误。</td>
</tr>
<tr>
<td>3535</td>
<td>正在控制设备时出错。</td>
</tr>
<tr>
<td>3660</td>
<td>这些工作站在这台服务器上有会话:</td>
</tr>
<tr>
<td>3661</td>
<td>这些工作站有会话打开了此台服务器上的文件:</td>
</tr>
<tr>
<td>3666</td>
<td>消息别名已经转发出去。</td>
</tr>
<tr>
<td>3670</td>
<td>您有以下的远程连接:</td>
</tr>
<tr>
<td>3671</td>
<td>继续运行会取消连接。</td>
</tr>
<tr>
<td>3676</td>
<td>会记录新的网络连接。</td>
</tr>
<tr>
<td>3677</td>
<td>不记录新的网络连接。</td>
</tr>
<tr>
<td>3678</td>
<td>保存配置文件时出错，原先记录的网络连接状态没有更改。</td>
</tr>
<tr>
<td>3679</td>
<td>读取配置文件时出错。</td>
</tr>
<tr>
<td>3682</td>
<td>没有启动任何网络服务。</td>
</tr>
<tr>
<td>3683</td>
<td>清单是空的。</td>
</tr>
<tr>
<td>3689</td>
<td>工作站服务已经在运行中，Windows 2000 会忽略工作站的命令选项。</td>
</tr>
<tr>
<td>3694</td>
<td>在打印作业正在后台处理到队列时，无法删除共享的队列。</td>
</tr>
<tr>
<td>3710</td>
<td>打开帮助文件时出错。</td>
</tr>
<tr>
<td>3711</td>
<td>帮助文件是空的。</td>
</tr>
<tr>
<td>3712</td>
<td>帮助文件已经损坏。</td>
</tr>
<tr>
<td>3714</td>
<td>这是专为那些安装旧版软件的系统 提供的操作。</td>
</tr>
<tr>
<td>3716</td>
<td>设备类型未知。</td>
</tr>
<tr>
<td>3717</td>
<td>日志文件已经损坏。</td>
</tr>
<tr>
<td>3718</td>
<td>程序文件名后必须以 .EXE 结束。</td>
</tr>
<tr>
<td>3719</td>
<td>找不到匹配的共享，因此没有删除。</td>
</tr>
<tr>
<td>3720</td>
<td>用户记录中的 “单位&#x2F;星期” 的值不正确。</td>
</tr>
<tr>
<td>3725</td>
<td>删除共享时出错。</td>
</tr>
<tr>
<td>3726</td>
<td>用户名无效。</td>
</tr>
<tr>
<td>3727</td>
<td>密码无效。</td>
</tr>
<tr>
<td>3728</td>
<td>密码不匹配。</td>
</tr>
<tr>
<td>3729</td>
<td>永久连接没有完全还原。</td>
</tr>
<tr>
<td>3730</td>
<td>计算机名或域名错误。</td>
</tr>
<tr>
<td>3732</td>
<td>无法设置该资源的默认权限。</td>
</tr>
<tr>
<td>3734</td>
<td>没有输入正确的密码。</td>
</tr>
<tr>
<td>3735</td>
<td>没有输入正确的名称。</td>
</tr>
<tr>
<td>3736</td>
<td>该资源无法共享。</td>
</tr>
<tr>
<td>3737</td>
<td>权限字符串包含无效的权限。</td>
</tr>
<tr>
<td>3738</td>
<td>您只能在打印机或通讯设备上执行这项操作。</td>
</tr>
<tr>
<td>3743</td>
<td>服务器没有设置远程管理的功能。</td>
</tr>
<tr>
<td>3752</td>
<td>这台服务器上没有用户的会话。</td>
</tr>
<tr>
<td>3756</td>
<td>响应无效。</td>
</tr>
<tr>
<td>3757</td>
<td>没有提供有效的响应。</td>
</tr>
<tr>
<td>3758</td>
<td>提供的目标清单与打印机队列目标清单不匹配。</td>
</tr>
<tr>
<td>3761</td>
<td>指定的时间范围中结束的时间比开始的时间早。</td>
</tr>
<tr>
<td>3764</td>
<td>提供的时间不是整点。</td>
</tr>
<tr>
<td>3765</td>
<td>12 与 24 小时格式不能混用。</td>
</tr>
<tr>
<td>3767</td>
<td>提供的日期格式无效。</td>
</tr>
<tr>
<td>3768</td>
<td>提供的日期范围无效。</td>
</tr>
<tr>
<td>3769</td>
<td>提供的时间范围无效。</td>
</tr>
<tr>
<td>3770</td>
<td>NET USER 的参数无效。请检查最短的密码长度 和&#x2F;或提供参数。</td>
</tr>
<tr>
<td>3771</td>
<td>ENABLESCRIPT 的值必须是 YES。</td>
</tr>
<tr>
<td>3773</td>
<td>提供的国家(地区)代码无效。</td>
</tr>
<tr>
<td>3774</td>
<td>用户已经创建成功，但是无法添加到 USERS 本地组中。</td>
</tr>
<tr>
<td>3775</td>
<td>提供的用户上下文无效。</td>
</tr>
<tr>
<td>3777</td>
<td>文件发送功能已不再支持。</td>
</tr>
<tr>
<td>3778</td>
<td>您可能没有指定 ADMIN$ 及 IPC$ 共享的路径。</td>
</tr>
<tr>
<td>3784</td>
<td>只有磁盘共享可以标记为可以缓存。</td>
</tr>
<tr>
<td>3802</td>
<td>此计划日期无效。</td>
</tr>
<tr>
<td>3803</td>
<td>LANMAN 根目录无法使用。</td>
</tr>
<tr>
<td>3804</td>
<td>SCHED.LOG 文件无法打开。</td>
</tr>
<tr>
<td>3805</td>
<td>服务器服务尚未启动。</td>
</tr>
<tr>
<td>3806</td>
<td>AT 作业标识不存在。</td>
</tr>
<tr>
<td>3807</td>
<td>AT 计划文件已损坏。</td>
</tr>
<tr>
<td>3808</td>
<td>因为 AT 计划文件发生问题，所以无法运行删除操作。</td>
</tr>
<tr>
<td>3809</td>
<td>命令行不得超过 259 个字符。</td>
</tr>
<tr>
<td>3810</td>
<td>因为磁盘已满，所以 AT 计划文件无法更新。</td>
</tr>
<tr>
<td>3812</td>
<td>AT 计划文件无效。请删除此文件并创建新的文件。</td>
</tr>
<tr>
<td>3813</td>
<td>AT 计划文件已经删除。</td>
</tr>
<tr>
<td>3814</td>
<td>此命令的语法是: AT [id] [&#x2F;Delete] AT 时间 [&#x2F;EVERY:日期</td>
</tr>
<tr>
<td>3815</td>
<td>AT 命令已经超时。 请稍后再试一次。</td>
</tr>
<tr>
<td>3816</td>
<td>用户帐户的密码使用最短期限不得 大于密码最长使用期限。</td>
</tr>
<tr>
<td>3817</td>
<td>指定的数值与安装下层软件的服务器不兼容。 请指定较小的值。</td>
</tr>
<tr>
<td>3902</td>
<td>意外到达消息的结尾</td>
</tr>
<tr>
<td>3905</td>
<td>请按 ESC 退出</td>
</tr>
<tr>
<td>3912</td>
<td>找不到时间服务器。</td>
</tr>
<tr>
<td>3915</td>
<td>无法判断用户的主目录。</td>
</tr>
<tr>
<td>3916</td>
<td>没有指定用户的主目录。</td>
</tr>
<tr>
<td>3920</td>
<td>已经没有可用的驱动器号。</td>
</tr>
<tr>
<td>3936</td>
<td>这台计算机目前没有配置成使用一个指定的 SNTP 服务器。</td>
</tr>
<tr>
<td>3953</td>
<td>语法错误。</td>
</tr>
<tr>
<td>3960</td>
<td>指定的文件号码无效。</td>
</tr>
<tr>
<td>3961</td>
<td>指定的打印作业号码无效。</td>
</tr>
<tr>
<td>3963</td>
<td>指定的用户或组帐户找不到。</td>
</tr>
<tr>
<td>3965</td>
<td>已添加用户，但 NetWare 的文件和打印服务无法启用。</td>
</tr>
<tr>
<td>3966</td>
<td>没有安装 NetWare 的文件和打印服务。</td>
</tr>
<tr>
<td>3967</td>
<td>无法为 NetWare 的文件和打印服务设置用户属性。</td>
</tr>
<tr>
<td>3969</td>
<td>NetWare 兼容登录</td>
</tr>
<tr>
<td>4000</td>
<td>WINS 在处理命令时遇到错误。</td>
</tr>
<tr>
<td>4001</td>
<td>本地的 WINS 不能删除。</td>
</tr>
<tr>
<td>4002</td>
<td>文件导入操作失败。</td>
</tr>
<tr>
<td>4003</td>
<td>备份操作失败。是否先前已作过完整备份?</td>
</tr>
<tr>
<td>4004</td>
<td>备份操作失败。请检查您备份数据库的目录。</td>
</tr>
<tr>
<td>4005</td>
<td>WINS 数据库中没有这个名称。</td>
</tr>
<tr>
<td>4006</td>
<td>不允许复制一个尚未配置的伙伴。</td>
</tr>
<tr>
<td>4100</td>
<td>DHCP 客户获得一个在网上已被使用的 IP 地址。 直到 DHCP 客户可以获得新的地址前，本地接口将被禁用。</td>
</tr>
<tr>
<td>4200</td>
<td>无法识别传来的 GUID 是否为有效的 WMI 数据提供程序。</td>
</tr>
<tr>
<td>4201</td>
<td>无法识别传来的实例名是否为有效的 WMI 数据提供程序。</td>
</tr>
<tr>
<td>4202</td>
<td>无法识别传来的数据项目标识符是否为有效的 WMI 数据提供程序。</td>
</tr>
<tr>
<td>4203</td>
<td>无法完成 WMI 请求，应该重试一次。</td>
</tr>
<tr>
<td>4204</td>
<td>找不到 WMI 数据提供程序。</td>
</tr>
<tr>
<td>4205</td>
<td>WMI 数据提供程序引用到一个未注册的实例组。</td>
</tr>
<tr>
<td>4206</td>
<td>WMI 数据块或事件通知已启用。</td>
</tr>
<tr>
<td>4207</td>
<td>WMI 数据块不再可用。</td>
</tr>
<tr>
<td>4208</td>
<td>WMI 数据服务无法使用。</td>
</tr>
<tr>
<td>4209</td>
<td>WMI 数据提供程序无法完成要求。</td>
</tr>
<tr>
<td>4210</td>
<td>WMI MOF 信息无效。</td>
</tr>
<tr>
<td>4211</td>
<td>WMI 注册信息无效。</td>
</tr>
<tr>
<td>4212</td>
<td>WMI 数据块或事件通知已禁用。</td>
</tr>
<tr>
<td>4213</td>
<td>WMI 数据项目或数据块为只读。</td>
</tr>
<tr>
<td>4214</td>
<td>WMI 数据项目或数据块不能更改。</td>
</tr>
<tr>
<td>4300</td>
<td>媒体标识符没有表示一个有效的媒体。</td>
</tr>
<tr>
<td>4301</td>
<td>库标识符没有表示一个有效的库。</td>
</tr>
<tr>
<td>4302</td>
<td>媒体缓冲池标识符没有表示一个有效的媒体缓冲池。</td>
</tr>
<tr>
<td>4303</td>
<td>驱动器和媒体不兼容或位于不同的库中。</td>
</tr>
<tr>
<td>4304</td>
<td>媒体目前在脱机库中，您必须联机才能运行这个操作。</td>
</tr>
<tr>
<td>4305</td>
<td>操作无法在脱机库中运行。</td>
</tr>
<tr>
<td>4306</td>
<td>库、驱动器或媒体缓冲池是空的。</td>
</tr>
<tr>
<td>4307</td>
<td>库、磁盘或媒体缓冲池必须是空的，才能运行这个操作。</td>
</tr>
<tr>
<td>4308</td>
<td>在这个媒体缓冲池或库中目前没有可用的媒体。</td>
</tr>
<tr>
<td>4309</td>
<td>这个操作所需的资源已禁用。</td>
</tr>
<tr>
<td>4310</td>
<td>媒体标识符没有表示一个有效的清洗器。</td>
</tr>
<tr>
<td>4311</td>
<td>无法清洗驱动器或不支持清洗。</td>
</tr>
<tr>
<td>4312</td>
<td>对象标识符没有表示一个有效的对象。</td>
</tr>
<tr>
<td>4313</td>
<td>无法读取或写入数据库。</td>
</tr>
<tr>
<td>4314</td>
<td>数据库已满。</td>
</tr>
<tr>
<td>4315</td>
<td>媒体与设备或媒体缓冲池不兼容。</td>
</tr>
<tr>
<td>4316</td>
<td>这个操作所需的资源不存在。</td>
</tr>
<tr>
<td>4317</td>
<td>操作标识符不正确。</td>
</tr>
<tr>
<td>4318</td>
<td>媒体未被安装，或未就绪。</td>
</tr>
<tr>
<td>4319</td>
<td>设备未就绪。</td>
</tr>
<tr>
<td>4320</td>
<td>操作员或系统管理员拒绝了请求。</td>
</tr>
<tr>
<td>4321</td>
<td>驱动器标识符不代表一个有效的驱动器。</td>
</tr>
<tr>
<td>4322</td>
<td>程序库已满。没有可使用的插槽。</td>
</tr>
<tr>
<td>4323</td>
<td>传输程序不能访问媒体。</td>
</tr>
<tr>
<td>4324</td>
<td>无法将媒体加载到驱动器中。</td>
</tr>
<tr>
<td>4325</td>
<td>无法检索有关驱动器的状态。</td>
</tr>
<tr>
<td>4326</td>
<td>无法检索有关插槽的状态。</td>
</tr>
<tr>
<td>4327</td>
<td>无法检索传输的状态。</td>
</tr>
<tr>
<td>4328</td>
<td>因为传输已在使用中，所以无法使用。</td>
</tr>
<tr>
<td>4329</td>
<td>无法打开或关闭弹入&#x2F;弹出端口。</td>
</tr>
<tr>
<td>4330</td>
<td>因为媒体在驱动器中，无法将其弹出。</td>
</tr>
<tr>
<td>4331</td>
<td>清洗器插槽已被保留。</td>
</tr>
<tr>
<td>4332</td>
<td>没有保留清洗器插槽。</td>
</tr>
<tr>
<td>4333</td>
<td>清洗器墨盒已进行了最大次数的驱动器清洗。</td>
</tr>
<tr>
<td>4334</td>
<td>意外媒体标识号。</td>
</tr>
<tr>
<td>4335</td>
<td>在这个组或源中最后剩下的项目不能被删除。</td>
</tr>
<tr>
<td>4336</td>
<td>提供的消息超过了这个参数所允许的最大尺寸。</td>
</tr>
<tr>
<td>4337</td>
<td>该卷含有系统和页面文件。</td>
</tr>
<tr>
<td>4338</td>
<td>由于库中至少有一个驱动器可以支持该媒体类型，不能从库中删除媒体类型。</td>
</tr>
<tr>
<td>4339</td>
<td>由于没有可以使用的已被启动的驱动器，无法将该脱机媒体装入这个系统。</td>
</tr>
<tr>
<td>4350</td>
<td>远程存储服务无法撤回文件。</td>
</tr>
<tr>
<td>4351</td>
<td>远程存储服务此时不可操作。</td>
</tr>
<tr>
<td>4352</td>
<td>远程存储服务遇到一个媒体错误。</td>
</tr>
<tr>
<td>4354</td>
<td>请键入密码</td>
</tr>
<tr>
<td>4358</td>
<td>请键入用户的密码</td>
</tr>
<tr>
<td>4359</td>
<td>请键入共享资源的密码</td>
</tr>
<tr>
<td>4360</td>
<td>请键入您的密码</td>
</tr>
<tr>
<td>4361</td>
<td>请再键入一次密码以便确认</td>
</tr>
<tr>
<td>4362</td>
<td>请键入用户的旧密码</td>
</tr>
<tr>
<td>4363</td>
<td>请键入用户的新密码</td>
</tr>
<tr>
<td>4364</td>
<td>请键入您的新密码</td>
</tr>
<tr>
<td>4365</td>
<td>请键入复制器服务密码</td>
</tr>
<tr>
<td>4368</td>
<td>请键入您的用户名</td>
</tr>
<tr>
<td>4372</td>
<td>打印作业详细信息</td>
</tr>
<tr>
<td>4378</td>
<td>控制下列正在运行的服务</td>
</tr>
<tr>
<td>4379</td>
<td>统计数据可用于正在运行的下列服务</td>
</tr>
<tr>
<td>4381</td>
<td>此命令的语法是</td>
</tr>
<tr>
<td>4382</td>
<td>此命令的选项是</td>
</tr>
<tr>
<td>4383</td>
<td>请键入主域控制器的名称</td>
</tr>
<tr>
<td>4385</td>
<td>Sunday</td>
</tr>
<tr>
<td>4386</td>
<td>Monday</td>
</tr>
<tr>
<td>4387</td>
<td>Tuesday</td>
</tr>
<tr>
<td>4388</td>
<td>Wednesday</td>
</tr>
<tr>
<td>4389</td>
<td>Thursday</td>
</tr>
<tr>
<td>4390</td>
<td>此文件或目录不是一个重解析点。</td>
</tr>
<tr>
<td>4391</td>
<td>重解析点的属性不能被设置，因为它与已有的属性冲突。</td>
</tr>
<tr>
<td>4392</td>
<td>在重解析点缓冲区中的数据无效。</td>
</tr>
<tr>
<td>4393</td>
<td>在重解析点缓冲区中的标签无效。</td>
</tr>
<tr>
<td>4394</td>
<td>请求中指定的标签和重解析点中的不匹配。</td>
</tr>
<tr>
<td>4395</td>
<td>W</td>
</tr>
<tr>
<td>4396</td>
<td>Th</td>
</tr>
<tr>
<td>4397</td>
<td>F</td>
</tr>
<tr>
<td>4398</td>
<td>S</td>
</tr>
<tr>
<td>4399</td>
<td>Sa</td>
</tr>
<tr>
<td>4401</td>
<td>组名</td>
</tr>
<tr>
<td>4402</td>
<td>注释</td>
</tr>
<tr>
<td>4403</td>
<td>成员</td>
</tr>
<tr>
<td>4406</td>
<td>别名</td>
</tr>
<tr>
<td>4407</td>
<td>注释</td>
</tr>
<tr>
<td>4408</td>
<td>成员</td>
</tr>
<tr>
<td>4411</td>
<td>用户名</td>
</tr>
<tr>
<td>4412</td>
<td>全名</td>
</tr>
<tr>
<td>4413</td>
<td>注释</td>
</tr>
<tr>
<td>4414</td>
<td>用户的注释</td>
</tr>
<tr>
<td>4415</td>
<td>参数</td>
</tr>
<tr>
<td>4416</td>
<td>国家(地区)代码</td>
</tr>
<tr>
<td>4417</td>
<td>权限等级</td>
</tr>
<tr>
<td>4418</td>
<td>操作员权限</td>
</tr>
<tr>
<td>4419</td>
<td>帐户启用</td>
</tr>
<tr>
<td>4420</td>
<td>帐户到期</td>
</tr>
<tr>
<td>4421</td>
<td>上次设置密码</td>
</tr>
<tr>
<td>4422</td>
<td>密码到期</td>
</tr>
<tr>
<td>4423</td>
<td>密码可更改</td>
</tr>
<tr>
<td>4424</td>
<td>允许的工作站</td>
</tr>
<tr>
<td>4425</td>
<td>磁盘空间上限</td>
</tr>
<tr>
<td>4426</td>
<td>无限制</td>
</tr>
<tr>
<td>4427</td>
<td>本地组会员</td>
</tr>
<tr>
<td>4428</td>
<td>域控制器</td>
</tr>
<tr>
<td>4429</td>
<td>登录脚本</td>
</tr>
<tr>
<td>4430</td>
<td>上次登录</td>
</tr>
<tr>
<td>4431</td>
<td>全局组成员</td>
</tr>
<tr>
<td>4432</td>
<td>可允许的登录小时数</td>
</tr>
<tr>
<td>4433</td>
<td>全部</td>
</tr>
<tr>
<td>4434</td>
<td>无</td>
</tr>
<tr>
<td>4436</td>
<td>主目录</td>
</tr>
<tr>
<td>4437</td>
<td>需要密码</td>
</tr>
<tr>
<td>4438</td>
<td>用户可以更改密码</td>
</tr>
<tr>
<td>4439</td>
<td>用户配置文件</td>
</tr>
<tr>
<td>4440</td>
<td>已锁定</td>
</tr>
<tr>
<td>4450</td>
<td>计算机名</td>
</tr>
<tr>
<td>4451</td>
<td>用户名</td>
</tr>
<tr>
<td>4452</td>
<td>软件版本</td>
</tr>
<tr>
<td>4453</td>
<td>工作站活动在</td>
</tr>
<tr>
<td>4454</td>
<td>Windows NT 根目录</td>
</tr>
<tr>
<td>4455</td>
<td>工作站域</td>
</tr>
<tr>
<td>4456</td>
<td>登录域</td>
</tr>
<tr>
<td>4457</td>
<td>其它域</td>
</tr>
<tr>
<td>4458</td>
<td>COM 打开超时 (秒)</td>
</tr>
<tr>
<td>4459</td>
<td>COM 发送计数 (字节)</td>
</tr>
<tr>
<td>4460</td>
<td>COM 发送超时 (毫秒)</td>
</tr>
<tr>
<td>4461</td>
<td>DOS 会话打印超时 (秒)</td>
</tr>
<tr>
<td>4462</td>
<td>错误日志文件大小上限 (K)</td>
</tr>
<tr>
<td>4463</td>
<td>高速缓存上限 (K)</td>
</tr>
<tr>
<td>4464</td>
<td>网络缓冲区数</td>
</tr>
<tr>
<td>4465</td>
<td>字符缓冲区数</td>
</tr>
<tr>
<td>4466</td>
<td>域缓冲区大小</td>
</tr>
<tr>
<td>4467</td>
<td>字符缓冲区大小</td>
</tr>
<tr>
<td>4468</td>
<td>计算机全名</td>
</tr>
<tr>
<td>4469</td>
<td>工作站域 DNS 名称</td>
</tr>
<tr>
<td>4470</td>
<td>Windows 2000</td>
</tr>
<tr>
<td>4481</td>
<td>服务器名称</td>
</tr>
<tr>
<td>4482</td>
<td>服务器注释</td>
</tr>
<tr>
<td>4483</td>
<td>发送管理警报到</td>
</tr>
<tr>
<td>4484</td>
<td>软件版本</td>
</tr>
<tr>
<td>4485</td>
<td>对等服务器</td>
</tr>
<tr>
<td>4486</td>
<td>Windows NT</td>
</tr>
<tr>
<td>4487</td>
<td>服务器等级</td>
</tr>
<tr>
<td>4488</td>
<td>Windows NT Server</td>
</tr>
<tr>
<td>4489</td>
<td>服务器正运行于</td>
</tr>
<tr>
<td>4492</td>
<td>服务器已隐藏</td>
</tr>
<tr>
<td>4500</td>
<td>零备份存储在这个卷上不可用。</td>
</tr>
<tr>
<td>4506</td>
<td>登录的用户数量上限</td>
</tr>
<tr>
<td>4507</td>
<td>同时可并存的管理员数量上限</td>
</tr>
<tr>
<td>4508</td>
<td>资源共享数量上限</td>
</tr>
<tr>
<td>4509</td>
<td>资源连接数量上限</td>
</tr>
<tr>
<td>4510</td>
<td>服务器打开的文件数量上限</td>
</tr>
<tr>
<td>4511</td>
<td>每个会话打开的文件数量上限</td>
</tr>
<tr>
<td>4512</td>
<td>文件锁定数量上限</td>
</tr>
<tr>
<td>4520</td>
<td>空闲的会话时间 (分)</td>
</tr>
<tr>
<td>4526</td>
<td>共享等级</td>
</tr>
<tr>
<td>4527</td>
<td>用户等级</td>
</tr>
<tr>
<td>4530</td>
<td>未限制的服务器</td>
</tr>
<tr>
<td>4570</td>
<td>强制用户在时间到期之后多久必须注销?:</td>
</tr>
<tr>
<td>4571</td>
<td>多少次密码不正确后锁住帐户?:</td>
</tr>
<tr>
<td>4572</td>
<td>密码最短使用期限 (天):</td>
</tr>
<tr>
<td>4573</td>
<td>密码最长使用期限 (天):</td>
</tr>
<tr>
<td>4574</td>
<td>密码长度下限:</td>
</tr>
<tr>
<td>4575</td>
<td>保持的密码历史记录长度:</td>
</tr>
<tr>
<td>4576</td>
<td>计算机角色:</td>
</tr>
<tr>
<td>4577</td>
<td>工作站域的主域控制器:</td>
</tr>
<tr>
<td>4578</td>
<td>锁定阈值:</td>
</tr>
<tr>
<td>4579</td>
<td>锁定持续时间(分):</td>
</tr>
<tr>
<td>4580</td>
<td>锁定观测窗口(分):</td>
</tr>
<tr>
<td>4600</td>
<td>统计开始于</td>
</tr>
<tr>
<td>4601</td>
<td>接受的会话</td>
</tr>
<tr>
<td>4602</td>
<td>会话超时</td>
</tr>
<tr>
<td>4603</td>
<td>会话出错</td>
</tr>
<tr>
<td>4604</td>
<td>发送的 KB</td>
</tr>
<tr>
<td>4605</td>
<td>接收的 KB</td>
</tr>
<tr>
<td>4606</td>
<td>平均响应时间 (毫秒)</td>
</tr>
<tr>
<td>4607</td>
<td>网络错误</td>
</tr>
<tr>
<td>4608</td>
<td>访问的文件</td>
</tr>
<tr>
<td>4609</td>
<td>后台处理的打印作业</td>
</tr>
<tr>
<td>4610</td>
<td>系统出错</td>
</tr>
<tr>
<td>4611</td>
<td>密码违规</td>
</tr>
<tr>
<td>4612</td>
<td>权限违规</td>
</tr>
<tr>
<td>4613</td>
<td>访问的通讯设备</td>
</tr>
<tr>
<td>4614</td>
<td>会话已启动</td>
</tr>
<tr>
<td>4615</td>
<td>重新连接的会话</td>
</tr>
<tr>
<td>4616</td>
<td>会话启动失败</td>
</tr>
<tr>
<td>4617</td>
<td>断开的会话</td>
</tr>
<tr>
<td>4618</td>
<td>网络 I&#x2F;O 执行</td>
</tr>
<tr>
<td>4619</td>
<td>文件及管道被访问</td>
</tr>
<tr>
<td>4620</td>
<td>时间缓冲区耗尽</td>
</tr>
<tr>
<td>4621</td>
<td>大缓冲区</td>
</tr>
<tr>
<td>4622</td>
<td>请求缓冲区</td>
</tr>
<tr>
<td>4626</td>
<td>已做连接</td>
</tr>
<tr>
<td>4627</td>
<td>连接失败</td>
</tr>
<tr>
<td>4630</td>
<td>接收的字节数</td>
</tr>
<tr>
<td>4631</td>
<td>接收的服务器消息块 (SMB)</td>
</tr>
<tr>
<td>4632</td>
<td>传输的字节数</td>
</tr>
<tr>
<td>4633</td>
<td>传输的服务器消息块 (SMB)</td>
</tr>
<tr>
<td>4634</td>
<td>读取操作</td>
</tr>
<tr>
<td>4635</td>
<td>写入操作</td>
</tr>
<tr>
<td>4636</td>
<td>拒绝原始读取</td>
</tr>
<tr>
<td>4637</td>
<td>拒绝原始写入</td>
</tr>
<tr>
<td>4638</td>
<td>网络错误</td>
</tr>
<tr>
<td>4639</td>
<td>已做连接</td>
</tr>
<tr>
<td>4640</td>
<td>重新连接</td>
</tr>
<tr>
<td>4641</td>
<td>服务器断开</td>
</tr>
<tr>
<td>4642</td>
<td>会话已启动</td>
</tr>
<tr>
<td>4643</td>
<td>会话挂起</td>
</tr>
<tr>
<td>4644</td>
<td>失败的会话</td>
</tr>
<tr>
<td>4645</td>
<td>操作失败</td>
</tr>
<tr>
<td>4646</td>
<td>使用计数</td>
</tr>
<tr>
<td>4647</td>
<td>使用计数失败</td>
</tr>
<tr>
<td>4655</td>
<td>消息名称转发已经取消。</td>
</tr>
<tr>
<td>4661</td>
<td>密码已经更改成功。</td>
</tr>
<tr>
<td>4664</td>
<td>消息已经发给网络上所有的用户。</td>
</tr>
<tr>
<td>4666</td>
<td>消息已经送到此服务器上的所有用户。</td>
</tr>
<tr>
<td>4696</td>
<td>Windows NT Server</td>
</tr>
<tr>
<td>4697</td>
<td>Windows NT Workstation</td>
</tr>
<tr>
<td>4698</td>
<td>MS-DOS 增强型工作站</td>
</tr>
<tr>
<td>4700</td>
<td>服务器名称 注释</td>
</tr>
<tr>
<td>4701</td>
<td>资源共享名 类型 用途 注释</td>
</tr>
<tr>
<td>4706</td>
<td>其它可用的网络</td>
</tr>
<tr>
<td>4710</td>
<td>Disk</td>
</tr>
<tr>
<td>4711</td>
<td>Print</td>
</tr>
<tr>
<td>4712</td>
<td>Comm</td>
</tr>
<tr>
<td>4713</td>
<td>IPC</td>
</tr>
<tr>
<td>4714</td>
<td>状态 本地 远程 网络</td>
</tr>
<tr>
<td>4715</td>
<td>OK</td>
</tr>
<tr>
<td>4716</td>
<td>休止</td>
</tr>
<tr>
<td>4717</td>
<td>已暂停</td>
</tr>
<tr>
<td>4718</td>
<td>断开</td>
</tr>
<tr>
<td>4719</td>
<td>错误</td>
</tr>
<tr>
<td>4720</td>
<td>正在连接</td>
</tr>
<tr>
<td>4721</td>
<td>正在重新连接</td>
</tr>
<tr>
<td>4722</td>
<td>状态</td>
</tr>
<tr>
<td>4723</td>
<td>本地名称</td>
</tr>
<tr>
<td>4724</td>
<td>远程名称</td>
</tr>
<tr>
<td>4725</td>
<td>资源类型</td>
</tr>
<tr>
<td>4726</td>
<td>打开</td>
</tr>
<tr>
<td>4727</td>
<td>连接</td>
</tr>
<tr>
<td>4728</td>
<td>不可用</td>
</tr>
<tr>
<td>4730</td>
<td>共享名 资源 注释</td>
</tr>
<tr>
<td>4731</td>
<td>共享名</td>
</tr>
<tr>
<td>4732</td>
<td>资源</td>
</tr>
<tr>
<td>4733</td>
<td>后台处理</td>
</tr>
<tr>
<td>4734</td>
<td>权限</td>
</tr>
<tr>
<td>4735</td>
<td>最多用户</td>
</tr>
<tr>
<td>4736</td>
<td>无限制</td>
</tr>
<tr>
<td>4737</td>
<td>用户</td>
</tr>
<tr>
<td>4740</td>
<td>识别码 路径 用户名 # 锁定</td>
</tr>
<tr>
<td>4741</td>
<td>文件识别码</td>
</tr>
<tr>
<td>4742</td>
<td>锁定</td>
</tr>
<tr>
<td>4743</td>
<td>权限</td>
</tr>
<tr>
<td>4750</td>
<td>计算机 用户名 客户类型 打开空闲时间</td>
</tr>
<tr>
<td>4751</td>
<td>计算机</td>
</tr>
<tr>
<td>4752</td>
<td>会话时间</td>
</tr>
<tr>
<td>4753</td>
<td>空闲时间</td>
</tr>
<tr>
<td>4754</td>
<td>资源共享名 类型 # 打开</td>
</tr>
<tr>
<td>4755</td>
<td>客户类型</td>
</tr>
<tr>
<td>4756</td>
<td>来宾登录</td>
</tr>
<tr>
<td>4770</td>
<td>脱机缓存被启用:手动恢复</td>
</tr>
<tr>
<td>4771</td>
<td>脱机缓存被启用:自动恢复</td>
</tr>
<tr>
<td>4772</td>
<td>脱机缓存被启用:用户之间没有共享</td>
</tr>
<tr>
<td>4773</td>
<td>脱机缓存被停用</td>
</tr>
<tr>
<td>4774</td>
<td>自动</td>
</tr>
<tr>
<td>4775</td>
<td>手动</td>
</tr>
<tr>
<td>4800</td>
<td>名称</td>
</tr>
<tr>
<td>4801</td>
<td>转发到</td>
</tr>
<tr>
<td>4802</td>
<td>已经从下列位置转发给您</td>
</tr>
<tr>
<td>4803</td>
<td>这台服务器的用户</td>
</tr>
<tr>
<td>4804</td>
<td>用户已经按 Ctrl+Break 中断网络发送。</td>
</tr>
<tr>
<td>4810</td>
<td>名称 作业编号 大小 状态</td>
</tr>
<tr>
<td>4811</td>
<td>作业</td>
</tr>
<tr>
<td>4812</td>
<td>打印</td>
</tr>
<tr>
<td>4815</td>
<td>大小</td>
</tr>
<tr>
<td>4816</td>
<td>状态</td>
</tr>
<tr>
<td>4817</td>
<td>分隔文件</td>
</tr>
<tr>
<td>4818</td>
<td>注释</td>
</tr>
<tr>
<td>4819</td>
<td>优先级</td>
</tr>
<tr>
<td>4820</td>
<td>打印后于</td>
</tr>
<tr>
<td>4821</td>
<td>打印直到</td>
</tr>
<tr>
<td>4822</td>
<td>打印处理程序</td>
</tr>
<tr>
<td>4823</td>
<td>附加信息</td>
</tr>
<tr>
<td>4824</td>
<td>参数</td>
</tr>
<tr>
<td>4825</td>
<td>打印设备</td>
</tr>
<tr>
<td>4826</td>
<td>打印机活动中</td>
</tr>
<tr>
<td>4827</td>
<td>打印机搁置</td>
</tr>
<tr>
<td>4828</td>
<td>打印机出错</td>
</tr>
<tr>
<td>4829</td>
<td>正在删除打印机</td>
</tr>
<tr>
<td>4830</td>
<td>打印机状态未知</td>
</tr>
<tr>
<td>4842</td>
<td>正在提交用户</td>
</tr>
<tr>
<td>4843</td>
<td>通知</td>
</tr>
<tr>
<td>4844</td>
<td>作业数据类型</td>
</tr>
<tr>
<td>4845</td>
<td>作业参数</td>
</tr>
<tr>
<td>4846</td>
<td>正在等候</td>
</tr>
<tr>
<td>4847</td>
<td>搁置于队列</td>
</tr>
<tr>
<td>4848</td>
<td>正在后台处理</td>
</tr>
<tr>
<td>4849</td>
<td>已暂停</td>
</tr>
<tr>
<td>4850</td>
<td>脱机</td>
</tr>
<tr>
<td>4851</td>
<td>错误</td>
</tr>
<tr>
<td>4852</td>
<td>缺纸</td>
</tr>
<tr>
<td>4853</td>
<td>需要干预</td>
</tr>
<tr>
<td>4854</td>
<td>正在打印</td>
</tr>
<tr>
<td>4855</td>
<td>on</td>
</tr>
<tr>
<td>4862</td>
<td>驱动程序</td>
</tr>
<tr>
<td>4930</td>
<td>用户名 类型 日期</td>
</tr>
<tr>
<td>4931</td>
<td>锁定</td>
</tr>
<tr>
<td>4932</td>
<td>服务</td>
</tr>
<tr>
<td>4933</td>
<td>服务器</td>
</tr>
<tr>
<td>4934</td>
<td>服务器已启动</td>
</tr>
<tr>
<td>4935</td>
<td>服务器已暂停</td>
</tr>
<tr>
<td>4936</td>
<td>服务器已继续操作</td>
</tr>
<tr>
<td>4937</td>
<td>服务器已停止</td>
</tr>
<tr>
<td>4938</td>
<td>会话</td>
</tr>
<tr>
<td>4939</td>
<td>登录来宾</td>
</tr>
<tr>
<td>4940</td>
<td>登录用户</td>
</tr>
<tr>
<td>4941</td>
<td>登录管理员</td>
</tr>
<tr>
<td>4942</td>
<td>正常注销</td>
</tr>
<tr>
<td>4943</td>
<td>登录</td>
</tr>
<tr>
<td>4944</td>
<td>注销错误</td>
</tr>
<tr>
<td>4945</td>
<td>注销自动断开</td>
</tr>
<tr>
<td>4946</td>
<td>注销管理员断开</td>
</tr>
<tr>
<td>4947</td>
<td>注销受登录限制</td>
</tr>
<tr>
<td>4948</td>
<td>服务</td>
</tr>
<tr>
<td>4957</td>
<td>帐户</td>
</tr>
<tr>
<td>4964</td>
<td>已修改帐户系统设置</td>
</tr>
<tr>
<td>4965</td>
<td>登录限制</td>
</tr>
<tr>
<td>4966</td>
<td>超过限制: 未知</td>
</tr>
<tr>
<td>4967</td>
<td>超过限制: 登录时间</td>
</tr>
<tr>
<td>4968</td>
<td>超过限制: 帐户过期</td>
</tr>
<tr>
<td>4969</td>
<td>超过限制: 工作站识别码无效</td>
</tr>
<tr>
<td>4970</td>
<td>超过限制: 帐户停用</td>
</tr>
<tr>
<td>4971</td>
<td>超过限制: 帐户已删除</td>
</tr>
<tr>
<td>4972</td>
<td>资源</td>
</tr>
<tr>
<td>4978</td>
<td>密码不正确</td>
</tr>
<tr>
<td>4979</td>
<td>需要管理员特权</td>
</tr>
<tr>
<td>4980</td>
<td>访问</td>
</tr>
<tr>
<td>4984</td>
<td>拒绝访问</td>
</tr>
<tr>
<td>4985</td>
<td>未知</td>
</tr>
<tr>
<td>4986</td>
<td>其它</td>
</tr>
<tr>
<td>4987</td>
<td>持续时间:</td>
</tr>
<tr>
<td>4988</td>
<td>持续时间: 无效</td>
</tr>
<tr>
<td>4989</td>
<td>持续时间: 1 秒以下</td>
</tr>
<tr>
<td>4994</td>
<td>访问结束</td>
</tr>
<tr>
<td>4995</td>
<td>登录到网络</td>
</tr>
<tr>
<td>4996</td>
<td>拒绝登录</td>
</tr>
<tr>
<td>4997</td>
<td>程序 消息 时间</td>
</tr>
<tr>
<td>4999</td>
<td>管理员已解除帐户的锁定状态</td>
</tr>
<tr>
<td>5000</td>
<td>注销网络</td>
</tr>
</tbody></table>
<p>更多错误编码请参看 <a href="/blog/sql-server-state-code-list-3">《下篇》</a>。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Server 错误代码和解释 (下篇)</title>
    <url>/2013-01-22-sql-server-state-code-list-3/</url>
    <content><![CDATA[<p>承接<a href="/blog/sql-server-state-code-list-2">《中篇》</a>继续罗列分享SQL Server状态码。</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>错误码</th>
<th>错误原因说明</th>
</tr>
</thead>
<tbody><tr>
<td>5001</td>
<td>因为其它资源需要它，不能将群集资源移到另一个组。</td>
</tr>
<tr>
<td>5002</td>
<td>找不到此群集资源的依存。</td>
</tr>
<tr>
<td>5003</td>
<td>因为已经处于依存状态，此群集资源不能依存于指定的资源。</td>
</tr>
<tr>
<td>5004</td>
<td>此群集资源未联机。</td>
</tr>
<tr>
<td>5005</td>
<td>此操作没有可用的群集节点。</td>
</tr>
<tr>
<td>5006</td>
<td>没有群集资源。</td>
</tr>
<tr>
<td>5007</td>
<td>找不到群集资源。</td>
</tr>
<tr>
<td>5008</td>
<td>正在关闭群集。</td>
</tr>
<tr>
<td>5009</td>
<td>因为联机，群集节点无法从群集中脱离。</td>
</tr>
<tr>
<td>5010</td>
<td>对象已存在。</td>
</tr>
<tr>
<td>5011</td>
<td>此对象已在列表中。</td>
</tr>
<tr>
<td>5012</td>
<td>新请求没有可用的群集组。</td>
</tr>
<tr>
<td>5013</td>
<td>找不到群集组。</td>
</tr>
<tr>
<td>5014</td>
<td>因为群集组未联机，此操作不能完成。</td>
</tr>
<tr>
<td>5015</td>
<td>群集节点不是此资源的所有者。</td>
</tr>
<tr>
<td>5016</td>
<td>群集节点不是此资源的所有者。</td>
</tr>
<tr>
<td>5017</td>
<td>群集资源不能在指定的资源监视器中创建。</td>
</tr>
<tr>
<td>5018</td>
<td>群集资源不能通过资源监视器来联机。</td>
</tr>
<tr>
<td>5019</td>
<td>因为群集资源联机，此操作不能完成。</td>
</tr>
<tr>
<td>5020</td>
<td>由于是仲裁资源，群集资源不能被删除或脱机。</td>
</tr>
<tr>
<td>5021</td>
<td>由于没有能力成为仲裁资源，此群集不能使指定资源成为仲裁资源。</td>
</tr>
<tr>
<td>5022</td>
<td>群集软件正关闭。</td>
</tr>
<tr>
<td>5023</td>
<td>组或资源的状态不是执行请求操作的正确状态。</td>
</tr>
<tr>
<td>5024</td>
<td>属性已被存储，但在下次资源联机前，不是所有的修改将生效。</td>
</tr>
<tr>
<td>5025</td>
<td>由于不属于共享存储类别，群集不能使指定资源成为仲裁资源。</td>
</tr>
<tr>
<td>5026</td>
<td>由于是内核资源，无法删除群集资源。</td>
</tr>
<tr>
<td>5027</td>
<td>仲裁资源联机失败。</td>
</tr>
<tr>
<td>5028</td>
<td>无法成功创建或装入仲裁日志。</td>
</tr>
<tr>
<td>5029</td>
<td>群集日志损坏。</td>
</tr>
<tr>
<td>5030</td>
<td>由于该日志已超出最大限量，无法将记录写入群集日志。</td>
</tr>
<tr>
<td>5031</td>
<td>群集日志已超出最大限量。</td>
</tr>
<tr>
<td>5032</td>
<td>群集日志没有发现检查点记录。</td>
</tr>
<tr>
<td>5033</td>
<td>不满足日志所需的最小磁盘空间。</td>
</tr>
<tr>
<td>5034</td>
<td>群集节点未能控制仲裁资源，因为它被另一个活动节点拥有。</td>
</tr>
<tr>
<td>5035</td>
<td>这个操作的群集网络无效。</td>
</tr>
<tr>
<td>5036</td>
<td>此操作没有可用的群集节点。</td>
</tr>
<tr>
<td>5037</td>
<td>所有群集节点都必须运行才能执行这个操作。</td>
</tr>
<tr>
<td>5038</td>
<td>群集资源失败。</td>
</tr>
<tr>
<td>5039</td>
<td>该群集节点无效。</td>
</tr>
<tr>
<td>5040</td>
<td>该群集节点已经存在。</td>
</tr>
<tr>
<td>5041</td>
<td>一个节点正在加入该群集。</td>
</tr>
<tr>
<td>5042</td>
<td>找不到群集节点。</td>
</tr>
<tr>
<td>5043</td>
<td>找不到群集本地节点信息。</td>
</tr>
<tr>
<td>5044</td>
<td>群集网络已经存在。</td>
</tr>
<tr>
<td>5045</td>
<td>找不到群集网络。</td>
</tr>
<tr>
<td>5046</td>
<td>群集网络界面已经存在。</td>
</tr>
<tr>
<td>5047</td>
<td>找不到群集网络界面。</td>
</tr>
<tr>
<td>5048</td>
<td>群集请求在这个对象中无效。</td>
</tr>
<tr>
<td>5049</td>
<td>群集网络提供程序无效。</td>
</tr>
<tr>
<td>5050</td>
<td>群集节点坏了。</td>
</tr>
<tr>
<td>5051</td>
<td>无法连接到群集节点。</td>
</tr>
<tr>
<td>5052</td>
<td>该群集节点不是群集的一个成员。</td>
</tr>
<tr>
<td>5053</td>
<td>群集加入操作正在进行中。</td>
</tr>
<tr>
<td>5054</td>
<td>该群集网络无效。</td>
</tr>
<tr>
<td>5055</td>
<td>Mar</td>
</tr>
<tr>
<td>5056</td>
<td>该群集节点可以使用。</td>
</tr>
<tr>
<td>5057</td>
<td>该群集 IP 地址已在使用中。</td>
</tr>
<tr>
<td>5058</td>
<td>该群集节点没有中止。</td>
</tr>
<tr>
<td>5059</td>
<td>没有有效的群集安全上下文。</td>
</tr>
<tr>
<td>5060</td>
<td>该群集网络不是为内部群集通讯配置的。</td>
</tr>
<tr>
<td>5061</td>
<td>群集节点已经开始。</td>
</tr>
<tr>
<td>5062</td>
<td>群集节点已经坏了。</td>
</tr>
<tr>
<td>5063</td>
<td>群集网络已经联机。</td>
</tr>
<tr>
<td>5064</td>
<td>群集网络已经脱机。</td>
</tr>
<tr>
<td>5065</td>
<td>群集节点已经是该群集的成员。</td>
</tr>
<tr>
<td>5066</td>
<td>该群集网络是唯一个为两个或更多活动群集节点进行内部群集通讯的配置。不能从网络上删除内部通讯能力。</td>
</tr>
<tr>
<td>5067</td>
<td>一个或更多的群集资源依靠网络来向客户提供服务。不能从网络上删除客户访问能力。</td>
</tr>
<tr>
<td>5068</td>
<td>该操作不能在群集资源上作为仲裁资源执行。您不能将仲裁资源脱机或修改它的所有者名单。</td>
</tr>
<tr>
<td>5069</td>
<td>该群集仲裁资源不允许有任何依存关系。</td>
</tr>
<tr>
<td>5070</td>
<td>该群集节点暂停。</td>
</tr>
<tr>
<td>5071</td>
<td>群集资源不能联机。所有者节点不能在这个资源上运行。</td>
</tr>
<tr>
<td>5072</td>
<td>群集节点没有准备好，不能执行所请求的操作。</td>
</tr>
<tr>
<td>5073</td>
<td>群集节点正在关闭。</td>
</tr>
<tr>
<td>5074</td>
<td>放弃群集节点加入操作。</td>
</tr>
<tr>
<td>5075</td>
<td>由于加入节点和支持者之间的软件版本不兼容，该群集加入操作失败。</td>
</tr>
<tr>
<td>5076</td>
<td>由于该群集已经到达其所能监督的资源限制，不能创建这个资源。</td>
</tr>
<tr>
<td>5077</td>
<td>系统配置在群集加入或形成操作时已更改。放弃加入或形成操作。</td>
</tr>
<tr>
<td>5078</td>
<td>找不到指定的资源种类。</td>
</tr>
<tr>
<td>5079</td>
<td>指定的节点不支持这种资源，这也许是由于版本不一致或是由于在这个节点上没有资源 DLL。</td>
</tr>
<tr>
<td>5080</td>
<td>该资源 DLL 不支持指定的资源名称。这可能是由于一个提供给源 DLL 名称是错误的(或经过更改的)。</td>
</tr>
<tr>
<td>5081</td>
<td>不能在 RPC 服务器上注册任何身份验证包。</td>
</tr>
<tr>
<td>5082</td>
<td>由于组的所有者不在组的首选列表中，不能将组联机。要改变组的所有者节点，请移动组。</td>
</tr>
<tr>
<td>5083</td>
<td>群集数据库的系列号已改变，或者与锁定程序节点不相容，因此加入操作没有成功。如果在加入操作期间群集数据库有任何改动，这都可能发生。</td>
</tr>
<tr>
<td>5084</td>
<td>资源在其当前状态下，资源监视器不允许执行失败操作。资源处于挂起状态时，这都可能发生。</td>
</tr>
<tr>
<td>5085</td>
<td>非锁定程序代码收到一个为全局更新保留锁定的请求。</td>
</tr>
<tr>
<td>5086</td>
<td>群集服务找不到仲裁磁盘。</td>
</tr>
<tr>
<td>5087</td>
<td>已备份的群集数据库可能已损坏。</td>
</tr>
<tr>
<td>5088</td>
<td>DFS 根目录已在这个群集节点中。</td>
</tr>
<tr>
<td>5089</td>
<td>由于与另一个现有属性冲突，未能修改资源属性。</td>
</tr>
<tr>
<td>5090</td>
<td>西班牙</td>
</tr>
<tr>
<td>5091</td>
<td>丹麦</td>
</tr>
<tr>
<td>5092</td>
<td>瑞典</td>
</tr>
<tr>
<td>5093</td>
<td>挪威</td>
</tr>
<tr>
<td>5094</td>
<td>德国</td>
</tr>
<tr>
<td>5095</td>
<td>澳大利亚</td>
</tr>
<tr>
<td>5096</td>
<td>日本</td>
</tr>
<tr>
<td>5097</td>
<td>韩国</td>
</tr>
<tr>
<td>5098</td>
<td>中国</td>
</tr>
<tr>
<td>5099</td>
<td>台湾</td>
</tr>
<tr>
<td>5100</td>
<td>亚洲</td>
</tr>
<tr>
<td>5101</td>
<td>葡萄牙</td>
</tr>
<tr>
<td>5102</td>
<td>芬兰</td>
</tr>
<tr>
<td>5103</td>
<td>阿拉伯</td>
</tr>
<tr>
<td>5104</td>
<td>希伯莱</td>
</tr>
<tr>
<td>5153</td>
<td>UPS 服务即将执行最后的关机操作。</td>
</tr>
<tr>
<td>5170</td>
<td>工作站必须用 NET START 才能启动。</td>
</tr>
<tr>
<td>5175</td>
<td>远程 IPC</td>
</tr>
<tr>
<td>5176</td>
<td>远程管理</td>
</tr>
<tr>
<td>5177</td>
<td>默认共享</td>
</tr>
<tr>
<td>5291</td>
<td>永不</td>
</tr>
<tr>
<td>5292</td>
<td>永不</td>
</tr>
<tr>
<td>5293</td>
<td>永不</td>
</tr>
<tr>
<td>5295</td>
<td>NETUS.HLP</td>
</tr>
<tr>
<td>5296</td>
<td>NET.HLP</td>
</tr>
<tr>
<td>5300</td>
<td>网络控制块 (NCB) 请求运行成功。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5301</td>
<td>SEND DATAGRAM、SEND BROADCAST、ADAPTER STATUS 或 SESSION STATUS 的网络控制块 (NCB) 缓冲区长度无效。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5302</td>
<td>网络控制块 (NCB) 指定的数据描述数组无效。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5303</td>
<td>网络控制块 (NCB) 指定的命令无效。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5304</td>
<td>网络控制块 (NCB) 指定的消息交换码无效。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5305</td>
<td>网络控制块 (NCB) 命令超时。会话可能异常终止。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5306</td>
<td>接收的网络控制块 (NCB) 消息不完整。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5307</td>
<td>网络控制块 (NCB) 指定的缓冲区无效。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5308</td>
<td>网络控制块 (NCB) 指定的会话号码没有作用。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5309</td>
<td>网卡没有任何资源可用。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。</td>
</tr>
<tr>
<td>5310</td>
<td>网络控制块 (NCB) 指定的会话已经关闭。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5311</td>
<td>网络控制块 (NCB) 命令已经取消。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5312</td>
<td>网络控制块 (NCB) 指定的消息块不合逻辑。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5313</td>
<td>该名称已经存在于本地适配器名称表中。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。</td>
</tr>
<tr>
<td>5314</td>
<td>网卡名称表已满。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。</td>
</tr>
<tr>
<td>5315</td>
<td>网络名称已经有活动的会话，现在取消注册。 网络控制块 (NCB) 命令运行完毕。NCB 是相关数据。</td>
</tr>
<tr>
<td>5316</td>
<td>先前发出的 Receive Lookahead 命令对此会话仍起作用。 网络控制块 (NCB) 命令被拒绝。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5317</td>
<td>本地会话表已满。网络控制块 (NCB) 请求被拒绝。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5318</td>
<td>拒绝打开网络控制块 (NCB) 会话，远程计算机上没有侦听命令在执行。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5319</td>
<td>网络控制块 (NCB) 指定的名称号码无效。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5320</td>
<td>网络控制块 (NCB) 中指定的调用名称找不到， 或者没有应答。NCB 是相关数据。</td>
</tr>
<tr>
<td>5321</td>
<td>网络控制块 (NCB) 中指定的名称找不到。无法将“*”或 00h 填入 NCB 名称。NCB 是相关数据。</td>
</tr>
<tr>
<td>5322</td>
<td>网络控制块 (NCB) 中指定的名称正用于远程适配器。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5323</td>
<td>网络控制块 (NCB) 中指定的名称已经删除。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5324</td>
<td>网络控制块 (NCB) 中指定的会话异常终止。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5325</td>
<td>网络协议在网络上检测两个或数个 相同的名称。 网络控制块 (NCB) 是相关数据。</td>
</tr>
<tr>
<td>5326</td>
<td>收到意外的协议数据包。 远程设备可能不兼容。网络控制块 (NCB) 是相关数据。</td>
</tr>
<tr>
<td>5333</td>
<td>NetBIOS 界面正忙。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。</td>
</tr>
<tr>
<td>5334</td>
<td>未完成的网络控制块 (NCB) 命令太多。 NCB 请求被拒绝。NCB 是相关数据。</td>
</tr>
<tr>
<td>5335</td>
<td>网络控制块 (NCB) 中指定的适配器号无效。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5336</td>
<td>网络控制块 (NCB) 命令在取消的同时运行完毕。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5337</td>
<td>网络控制块 (NCB) 指定的名称已经保留。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5338</td>
<td>网络控制块 (NCB) 命令无法取消。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5351</td>
<td>同一个会话有多个网络控制块 (NCB)。 NCB 请求被拒绝。NCB 是相关数据。</td>
</tr>
<tr>
<td>5352</td>
<td>网卡出错。 唯一可能发出的 NetBIOS 命令是 NCB RESET。 网络控制块 (NCB) 是相关数据。</td>
</tr>
<tr>
<td>5354</td>
<td>超过应用程序数目上限。 网络控制区 (NCB) 请求被拒绝，NCB 是相关数据。</td>
</tr>
<tr>
<td>5356</td>
<td>请求的资源无法使用。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。</td>
</tr>
<tr>
<td>5364</td>
<td>系统出错。 网络控制块 (NCB) 请求被拒绝。NCB 即为数据。</td>
</tr>
<tr>
<td>5365</td>
<td>“ROM 校验和”失败。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。</td>
</tr>
<tr>
<td>5366</td>
<td>RAM 测试失败。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。</td>
</tr>
<tr>
<td>5367</td>
<td>数字式环回失败。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。</td>
</tr>
<tr>
<td>5368</td>
<td>模拟式环回失败。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。</td>
</tr>
<tr>
<td>5369</td>
<td>界面失败。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。</td>
</tr>
<tr>
<td>5370</td>
<td>收到的网络控制块 (NCB) 返回码无法识别。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5380</td>
<td>网卡故障。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。</td>
</tr>
<tr>
<td>5381</td>
<td>网络控制块 (NCB) 命令仍然处于搁置状态。 NCB 是相关数据。</td>
</tr>
<tr>
<td>5509</td>
<td>Windows 2000 无法按指定的配置启动， 将换用先前可工作的配置。</td>
</tr>
<tr>
<td>5600</td>
<td>无法共享用户或脚本路径。</td>
</tr>
<tr>
<td>5601</td>
<td>计算机的密码在本地安全 数据库中找不到。</td>
</tr>
<tr>
<td>5602</td>
<td>访问计算机的本地或网络安全数据库时， 发生内部错误。</td>
</tr>
<tr>
<td>5705</td>
<td>Netlogon 服务用于记录数据库更改数据的 日志高速缓存已损坏。 Netlogon 服务正在复位更改日志文件。</td>
</tr>
<tr>
<td>5728</td>
<td>无法加载任何传输。</td>
</tr>
<tr>
<td>5739</td>
<td>此域的全局组数目超过可以复制到 LanMan BDC 的限制。 请删除部分的全局组或删除域中的 LanMan BDC。</td>
</tr>
<tr>
<td>5742</td>
<td>服务无法检索必要的消息，所以无法运行远程启动客户。</td>
</tr>
<tr>
<td>5743</td>
<td>服务发生严重的错误，无法从远程启动 3Com 3Start 远程启动客户。</td>
</tr>
<tr>
<td>5744</td>
<td>服务发生严重的系统错误，即将关机。</td>
</tr>
<tr>
<td>5760</td>
<td>服务在分析 RPL 配置时出错。</td>
</tr>
<tr>
<td>5761</td>
<td>服务在创建所有配置的 RPL 配置文件时出错。</td>
</tr>
<tr>
<td>5762</td>
<td>服务在访问注册表时出错。</td>
</tr>
<tr>
<td>5763</td>
<td>服务在替换可能过期的 RPLDISK.SYS 时出错。</td>
</tr>
<tr>
<td>5764</td>
<td>服务在添加安全帐户或设置文件权限时出错。 这些帐户是独立 RPL 工作站的 RPLUSER 本地组 以及用户帐户。.</td>
</tr>
<tr>
<td>5765</td>
<td>服务无法备份它的数据库。</td>
</tr>
<tr>
<td>5766</td>
<td>服务无法从它的数据库初始化。 数据库可能找不到或损坏。 服务会试图从备份数据库恢复该数据库。</td>
</tr>
<tr>
<td>5767</td>
<td>服务无法从备份数据库还原它的数据库。服务 将不启动。</td>
</tr>
<tr>
<td>5768</td>
<td>服务无法从备份数据库还原它的数据库。</td>
</tr>
<tr>
<td>5769</td>
<td>服务无法从它还原的数据库初始化。服务 将不启动。</td>
</tr>
<tr>
<td>5771</td>
<td>远程启动数据库采用 NT 3.5 &#x2F; NT 3.51 格式。NT 正在转换其为 NT 4.0 格式。完成转换后，JETCONV 转换器将写出应用事件日志。</td>
</tr>
<tr>
<td>5773</td>
<td>该 DC 的 DNS 服务器不支持动态 DNS。 将文件 ‘SystemRoot\System32\Config\netlogon.dns’ 中的 DNS 记录添加到伺服那个文件中引用的域的 DNS 服务器。</td>
</tr>
<tr>
<td>5781</td>
<td>由于没有可以使用的 DNS 服务器，一个或更多 DNS 记录的动态注册和注销未成功。</td>
</tr>
<tr>
<td>6000</td>
<td>无法加密指定的文件。</td>
</tr>
<tr>
<td>6001</td>
<td>指定的文件无法解密。</td>
</tr>
<tr>
<td>6002</td>
<td>指定的文件已加密，而且用户没有能力解密。</td>
</tr>
<tr>
<td>6003</td>
<td>这个系统没有有效的加密恢复策略配置。</td>
</tr>
<tr>
<td>6004</td>
<td>所需的加密驱动程序并未加载到系统中。</td>
</tr>
<tr>
<td>6005</td>
<td>文件加密所使用的加密驱动程序与目前加载的加密驱动程序不同。</td>
</tr>
<tr>
<td>6006</td>
<td>没有为用户定义的 EFS 关键字。</td>
</tr>
<tr>
<td>6007</td>
<td>指定的文件并未加密。</td>
</tr>
<tr>
<td>6008</td>
<td>指定的文件不是定义的 EFS 导出格式。</td>
</tr>
<tr>
<td>6009</td>
<td>指定的文件是只读文件。</td>
</tr>
<tr>
<td>6010</td>
<td>已为加密而停用目录。</td>
</tr>
<tr>
<td>6011</td>
<td>不信任服务器来进行远程加密操作。</td>
</tr>
<tr>
<td>6118</td>
<td>此工作组的服务器列表当前无法使用</td>
</tr>
<tr>
<td>6200</td>
<td>要正常运行，任务计划程序服务的配置必须在系统帐户中运行。单独的任务可以被配置成在其他帐户中运行。</td>
</tr>
<tr>
<td>7001</td>
<td>指定的会话名称无效。</td>
</tr>
<tr>
<td>7002</td>
<td>指定的协议驱动程序无效。</td>
</tr>
<tr>
<td>7003</td>
<td>在系统路径上找不到指定的协议驱动程序。</td>
</tr>
<tr>
<td>7004</td>
<td>在系统路径上找不到指定的终端连接。</td>
</tr>
<tr>
<td>7005</td>
<td>不能为这个会话创建一个事件日志的注册键。</td>
</tr>
<tr>
<td>7006</td>
<td>同名的一个服务已经在系统中存在。</td>
</tr>
<tr>
<td>7007</td>
<td>在会话上一个关闭操作挂起。</td>
</tr>
<tr>
<td>7008</td>
<td>没有可用的输出缓冲器。</td>
</tr>
<tr>
<td>7009</td>
<td>找不到 MODEM.INF 文件。</td>
</tr>
<tr>
<td>7010</td>
<td>在 MODEM.INF 中没有找到调制解调器名称。</td>
</tr>
<tr>
<td>7011</td>
<td>调制解调器没有接受发送给它的指令。验证配置的调制解调器与连接的调制解调器是否匹配。</td>
</tr>
<tr>
<td>7012</td>
<td>调制解调器没有接受发送给它的指令。验证该调制解调器是否接线正确并且打开了电源开关。</td>
</tr>
<tr>
<td>7013</td>
<td>运载工具检测失败或者由于断开连接，运载工具已被丢弃。</td>
</tr>
<tr>
<td>7014</td>
<td>在要求的时间内没有发现拨号音。 确定电话线连接正确并可使用。</td>
</tr>
<tr>
<td>7015</td>
<td>在远程站点回叫时检测到了占线信号。</td>
</tr>
<tr>
<td>7016</td>
<td>在回叫时远程站点上检测到了声音。</td>
</tr>
<tr>
<td>7017</td>
<td>传输驱动程序错误</td>
</tr>
<tr>
<td>7022</td>
<td>找不到指定的会话。</td>
</tr>
<tr>
<td>7023</td>
<td>指定的会话名称已处于使用中。</td>
</tr>
<tr>
<td>7024</td>
<td>由于终端连接目前正在忙于处理一个连接、断开连接、复位或删除操作，无法完成该请求的操作。</td>
</tr>
<tr>
<td>7025</td>
<td>试图连接到其视频模式不受当前客户支持的会话。</td>
</tr>
<tr>
<td>7035</td>
<td>应用程序尝试启动 DOS 图形模式。 不支持 DOS 图形模式。</td>
</tr>
<tr>
<td>7037</td>
<td>您的交互式登录权限已被禁用。 请与您的管理员联系。</td>
</tr>
<tr>
<td>7038</td>
<td>该请求的操作只能在系统控制台上执行。 这通常是一个驱动程序或系统 DLL 要求直接控制台访问的结果。</td>
</tr>
<tr>
<td>7040</td>
<td>客户未能对服务器连接消息作出响应。</td>
</tr>
<tr>
<td>7041</td>
<td>不支持断开控制台会话。</td>
</tr>
<tr>
<td>7042</td>
<td>不支持重新将一个断开的会话连接到控制台。</td>
</tr>
<tr>
<td>7044</td>
<td>远程控制另一个会话的请求被拒绝。</td>
</tr>
<tr>
<td>7045</td>
<td>拒绝请求的会话访问。</td>
</tr>
<tr>
<td>7049</td>
<td>指定的终端连接驱动程序无效。</td>
</tr>
<tr>
<td>7050</td>
<td>不能远程控制该请求的会话。 这也许是由于该会话被中断或目前没有一个用户登录。而且，您不能从该系统控制台远程控制一个会话或远程控制系统控制台。并且，您不能远程控制您自己的当前会话。</td>
</tr>
<tr>
<td>7051</td>
<td>该请求的会话没有配置成允许远程控制。</td>
</tr>
<tr>
<td>7052</td>
<td>拒绝连接到这个终端服务器。终端服务器客户许可证目前正在被另一个用户使用。 请与系统管理员联系，获取一份新的终端服务器客户，其许可证号码必须是有效的、唯一的。</td>
</tr>
<tr>
<td>7053</td>
<td>拒绝连接到这个终端服务器。还没有为这份终端服务器客户输入您的终端服务器客户许可证号码。 请与系统管理员联系，为该终端服务器客户输入一个有效的、唯一的许可证号码。</td>
</tr>
<tr>
<td>7054</td>
<td>系统已达到其授权的登录限制。 请以后再试一次。</td>
</tr>
<tr>
<td>7055</td>
<td>您正在使用的客户没有使用该系统的授权。您的登录请求被拒绝。</td>
</tr>
<tr>
<td>7056</td>
<td>系统许可证已过期。您的登录请求被拒绝。</td>
</tr>
<tr>
<td>8001</td>
<td>文件复制服务 API 被错误调用。</td>
</tr>
<tr>
<td>8002</td>
<td>无法启动文件复制服务。</td>
</tr>
<tr>
<td>8003</td>
<td>无法停止文件复制服务。</td>
</tr>
<tr>
<td>8004</td>
<td>文件复制服务 API 终止了请求。 事件日志可能有详细信息。</td>
</tr>
<tr>
<td>8005</td>
<td>该文件复制服务中断了该请求。 事件日志可能有详细信息。</td>
</tr>
<tr>
<td>8006</td>
<td>无法联系文件复制服务。 事件日志可能有详细信息。</td>
</tr>
<tr>
<td>8007</td>
<td>由于该用户没有足够特权，文件复制服务不能满足该请求。 事件日志可能有详细信息。</td>
</tr>
<tr>
<td>8008</td>
<td>由于验证的 RPC 无效，文件复制服务不能满足该请求。 事件日志可能有详细信息。</td>
</tr>
<tr>
<td>8009</td>
<td>由于该用户在域控制器上没有足够特权，文件复制服务不能满足该请求。 事件日志可能有详细信息。</td>
</tr>
<tr>
<td>8010</td>
<td>由于在域控制器上的验证的 RPC 无效，文件复制服务不能满足该请求。 事件日志可能有详细信息。</td>
</tr>
<tr>
<td>8011</td>
<td>该文件复制服务无法与在域控制器上的文件复制服务通讯。 事件日志可能有详细信息。</td>
</tr>
<tr>
<td>8012</td>
<td>在域控制器上的文件复制服务无法与这台计算机上的文件复制服务通讯。 事件日志可能有详细信息。</td>
</tr>
<tr>
<td>8013</td>
<td>由于内部错误，该文件复制服务不能进入该系统卷中。 事件日志可能有详细信息。</td>
</tr>
<tr>
<td>8014</td>
<td>由于内部超时，该文件复制服务不能进入该系统卷中。 事件日志可能有详细信息。</td>
</tr>
<tr>
<td>8015</td>
<td>该文件复制服务无法处理此请求。该系统卷仍在忙于前一个请求。</td>
</tr>
<tr>
<td>8016</td>
<td>由于内部错误，该文件复制服务无法停止复制该系统卷。 事件日志可能有详细信息。</td>
</tr>
<tr>
<td>8017</td>
<td>该文件复制服务检测到一个无效参数。</td>
</tr>
<tr>
<td>8200</td>
<td>在安装目录服务时出现一个错误。有关详细信息，请查看事件日志。</td>
</tr>
<tr>
<td>8201</td>
<td>目录服务在本地评估组成员身份。</td>
</tr>
<tr>
<td>8202</td>
<td>指定的目录服务属性或值不存在。</td>
</tr>
<tr>
<td>8203</td>
<td>指定给目录服务的属性语法无效。</td>
</tr>
<tr>
<td>8204</td>
<td>指定给目录服务的属性类型未定义。</td>
</tr>
<tr>
<td>8205</td>
<td>指定的目录服务属性或值已经存在。</td>
</tr>
<tr>
<td>8206</td>
<td>目录服务忙。</td>
</tr>
<tr>
<td>8207</td>
<td>该目录服务无效。</td>
</tr>
<tr>
<td>8208</td>
<td>目录服务无法分配相对标识号。</td>
</tr>
<tr>
<td>8209</td>
<td>目录服务已经用完了相对标识号池。</td>
</tr>
<tr>
<td>8210</td>
<td>由于目录服务不是该类操作的主控，未能执行操作。</td>
</tr>
<tr>
<td>8211</td>
<td>目录服务无法初始化分配相对标识号的子系统。</td>
</tr>
<tr>
<td>8212</td>
<td>该请求的操作没有满足一个或多个与该对象的类别相关的约束。</td>
</tr>
<tr>
<td>8213</td>
<td>目录服务只可以在一个页状对象上运行要求的操作。</td>
</tr>
<tr>
<td>8214</td>
<td>目录服务不能在一个对象的 RDN 属性上执行该请求的操作。</td>
</tr>
<tr>
<td>8215</td>
<td>目录服务检测出修改对象类别的尝试。</td>
</tr>
<tr>
<td>8216</td>
<td>不能执行请求的通过域的移动操作。</td>
</tr>
<tr>
<td>8217</td>
<td>无法联系全局编录服务器。</td>
</tr>
<tr>
<td>8218</td>
<td>策略对象是共享的并只可在根目录上修改。</td>
</tr>
<tr>
<td>8219</td>
<td>策略对象不存在。</td>
</tr>
<tr>
<td>8220</td>
<td>请求的策略信息只在目录服务中。</td>
</tr>
<tr>
<td>8221</td>
<td>域控制器升级目前正在使用中。</td>
</tr>
<tr>
<td>8222</td>
<td>域控制器升级目前不在使用中</td>
</tr>
<tr>
<td>8224</td>
<td>出现一个操作错误。</td>
</tr>
<tr>
<td>8225</td>
<td>出现一个协议错误。</td>
</tr>
<tr>
<td>8226</td>
<td>已经超过这个请求的时间限制。</td>
</tr>
<tr>
<td>8227</td>
<td>已经超过这个请求的大小限制。</td>
</tr>
<tr>
<td>8228</td>
<td>已经超过这个请求的管理限制。</td>
</tr>
<tr>
<td>8229</td>
<td>比较的响应为假。</td>
</tr>
<tr>
<td>8230</td>
<td>比较的响应为真。</td>
</tr>
<tr>
<td>8231</td>
<td>这个服务器不支持请求的身份验证方式。</td>
</tr>
<tr>
<td>8232</td>
<td>这台服务器需要一个更安全的身份验证方式。</td>
</tr>
<tr>
<td>8233</td>
<td>不适当的身份验证。</td>
</tr>
<tr>
<td>8234</td>
<td>未知的身份验证机制。</td>
</tr>
<tr>
<td>8235</td>
<td>从服务器返回了一个建议。</td>
</tr>
<tr>
<td>8236</td>
<td>该服务器不支持该请求的关键扩展。</td>
</tr>
<tr>
<td>8237</td>
<td>这个请求需要一个安全的连接。</td>
</tr>
<tr>
<td>8238</td>
<td>不恰当的匹配。</td>
</tr>
<tr>
<td>8239</td>
<td>出现一个约束冲突。</td>
</tr>
<tr>
<td>8240</td>
<td>在服务器上没有这样一个对象。</td>
</tr>
<tr>
<td>8241</td>
<td>有一个别名问题。</td>
</tr>
<tr>
<td>8242</td>
<td>指定了一个无效的 dn 语法。</td>
</tr>
<tr>
<td>8243</td>
<td>该对象为叶对象。</td>
</tr>
<tr>
<td>8244</td>
<td>有一个别名废弃问题。</td>
</tr>
<tr>
<td>8245</td>
<td>该服务器不愿意处理该请求。</td>
</tr>
<tr>
<td>8246</td>
<td>检查到一个循环。</td>
</tr>
<tr>
<td>8247</td>
<td>有一个命名冲突。</td>
</tr>
<tr>
<td>8248</td>
<td>结果设置太大。</td>
</tr>
<tr>
<td>8249</td>
<td>该操作会影响到多个 DSA。</td>
</tr>
<tr>
<td>8250</td>
<td>该服务器不可操作。</td>
</tr>
<tr>
<td>8251</td>
<td>出现一个本地错误。</td>
</tr>
<tr>
<td>8252</td>
<td>出现一个编码错误。</td>
</tr>
<tr>
<td>8253</td>
<td>出现一个解码错误。</td>
</tr>
<tr>
<td>8254</td>
<td>无法识别寻找筛选器。</td>
</tr>
<tr>
<td>8255</td>
<td>一个或多个参数非法。</td>
</tr>
<tr>
<td>8256</td>
<td>不支持指定的方式。</td>
</tr>
<tr>
<td>8257</td>
<td>没有返回结果。</td>
</tr>
<tr>
<td>8258</td>
<td>该服务器不支持该指定的控制。</td>
</tr>
<tr>
<td>8259</td>
<td>客户检测到一个参考循环。</td>
</tr>
<tr>
<td>8260</td>
<td>超过当前的参考限制。</td>
</tr>
<tr>
<td>8301</td>
<td>根目录对象必须是一个命名上下文的头。该根目录对象不能有实例父类。</td>
</tr>
<tr>
<td>8302</td>
<td>不能执行添加副本操作。名称上下文必须可写才能创建副本。</td>
</tr>
<tr>
<td>8303</td>
<td>出现一个对架构中未定义的一个属性的参考。</td>
</tr>
<tr>
<td>8304</td>
<td>超过了一个对象的最大尺寸。</td>
</tr>
<tr>
<td>8305</td>
<td>尝试向目录中添加一个已在使用中的名称的对象。</td>
</tr>
<tr>
<td>8306</td>
<td>尝试添加一个对象，该对象属于那类在架构中没有一个 RDN 定义的类别。</td>
</tr>
<tr>
<td>8307</td>
<td>尝试添加一个使用 RDN 的对象，但该 RDN 不是一个在架构中定义的 RDN 。</td>
</tr>
<tr>
<td>8308</td>
<td>在对象中找不到任何请求的属性。</td>
</tr>
<tr>
<td>8309</td>
<td>用户缓冲区太小。</td>
</tr>
<tr>
<td>8310</td>
<td>在操作中指定的属性不出现在对象上。</td>
</tr>
<tr>
<td>8311</td>
<td>修改操作非法。不允许该修改的某个方面。</td>
</tr>
<tr>
<td>8312</td>
<td>指定的对象太大。</td>
</tr>
<tr>
<td>8313</td>
<td>指定的实例类别无效。</td>
</tr>
<tr>
<td>8314</td>
<td>操作必须在主控 DSA 执行。</td>
</tr>
<tr>
<td>8315</td>
<td>必须指定对象类别属性。</td>
</tr>
<tr>
<td>8316</td>
<td>一个所需的属性丢失。</td>
</tr>
<tr>
<td>8317</td>
<td>尝试修改一个对象，将一个对该类别来讲是非法的属性包括进来。</td>
</tr>
<tr>
<td>8318</td>
<td>在对象上指定的属性已经存在。</td>
</tr>
<tr>
<td>8320</td>
<td>指定的属性不存在或没有值。</td>
</tr>
<tr>
<td>8321</td>
<td>为只有一个值的属性指定了多个值。</td>
</tr>
<tr>
<td>8322</td>
<td>属性值不在接受范围内。</td>
</tr>
<tr>
<td>8323</td>
<td>指定的值已存在。</td>
</tr>
<tr>
<td>8324</td>
<td>由于不存在于对象上，不能删除该属性。</td>
</tr>
<tr>
<td>8325</td>
<td>由于不存在于对象上，不能删除该属性值。</td>
</tr>
<tr>
<td>8326</td>
<td>指定的根对象不能是子参考。</td>
</tr>
<tr>
<td>8327</td>
<td>不允许链接。</td>
</tr>
<tr>
<td>8328</td>
<td>不允许链接的评估。</td>
</tr>
<tr>
<td>8329</td>
<td>由于对象的父类不是未实例化就是被删除了，所以不能执行操作。</td>
</tr>
<tr>
<td>8330</td>
<td>不允许有一个用别名的父类。别名是叶对象。</td>
</tr>
<tr>
<td>8331</td>
<td>对象和父类必须是同一种类，不是都是原件就是 都是副本。</td>
</tr>
<tr>
<td>8332</td>
<td>由于子对象存在，操作不能执行。这个操作只能在叶对象上执行。</td>
</tr>
<tr>
<td>8333</td>
<td>没有找到目录对象。</td>
</tr>
<tr>
<td>8334</td>
<td>别名对象丢失。</td>
</tr>
<tr>
<td>8335</td>
<td>对象名语法不对。</td>
</tr>
<tr>
<td>8336</td>
<td>不允许一个别名参考另一个别名。</td>
</tr>
<tr>
<td>8337</td>
<td>别名不能解除参考。</td>
</tr>
<tr>
<td>8338</td>
<td>操作超出范围。</td>
</tr>
<tr>
<td>8340</td>
<td>不能删除 DSA 对象。</td>
</tr>
<tr>
<td>8341</td>
<td>出现一个目录服务错误。</td>
</tr>
<tr>
<td>8342</td>
<td>操作只能在内部主控 DSA 对象上执行。</td>
</tr>
<tr>
<td>8343</td>
<td>对象必须为 DSA 类别。</td>
</tr>
<tr>
<td>8344</td>
<td>访问权不够不能执行该操作。</td>
</tr>
<tr>
<td>8345</td>
<td>由于父类不在可能的上级列表上，不能添加该对象。</td>
</tr>
<tr>
<td>8346</td>
<td>由于该属性处于“安全帐户管理器” (SAM)，不允许访问该属性。</td>
</tr>
<tr>
<td>8347</td>
<td>名称有太多部分。</td>
</tr>
<tr>
<td>8348</td>
<td>名称太长。</td>
</tr>
<tr>
<td>8349</td>
<td>名称值太长。</td>
</tr>
<tr>
<td>8350</td>
<td>目录服务遇到了一个错误分列名称。</td>
</tr>
<tr>
<td>8351</td>
<td>目录服务找不到一个名称的属性种类。</td>
</tr>
<tr>
<td>8352</td>
<td>该名称不能识别一个对象; 该名称识别一个幻象。</td>
</tr>
<tr>
<td>8353</td>
<td>安全描述符太短。</td>
</tr>
<tr>
<td>8354</td>
<td>安全描述符无效。</td>
</tr>
<tr>
<td>8355</td>
<td>为删除的对象创建名称失败。</td>
</tr>
<tr>
<td>8356</td>
<td>一个新子参考的父类必须存在。</td>
</tr>
<tr>
<td>8357</td>
<td>该对象必须是一个命名上下文。</td>
</tr>
<tr>
<td>8358</td>
<td>不允许添加一个不属于系统的属性。</td>
</tr>
<tr>
<td>8359</td>
<td>对象的类别必须是有结构的; 您不能实例化一个抽象的类别。</td>
</tr>
<tr>
<td>8360</td>
<td>找不到架构的对象。</td>
</tr>
<tr>
<td>8361</td>
<td>有这个 GUID (非活动的的或活动的)的本地对象已经存在。</td>
</tr>
<tr>
<td>8362</td>
<td>操作不能在一个后部链接上执行。</td>
</tr>
<tr>
<td>8363</td>
<td>找不到指定的命名上下文的互交参考。</td>
</tr>
<tr>
<td>8364</td>
<td>由于目录服务关闭，操作不能执行。</td>
</tr>
<tr>
<td>8365</td>
<td>目录服务请求无效。</td>
</tr>
<tr>
<td>8366</td>
<td>无法读取角色所有者属性。</td>
</tr>
<tr>
<td>8367</td>
<td>请求的 FSMO 操作失败。不能连接当前的 FSMO 盒。</td>
</tr>
<tr>
<td>8368</td>
<td>不允许跨过一个命名上下文修改 DN。</td>
</tr>
<tr>
<td>8369</td>
<td>由于属于系统，不能修改该属性。</td>
</tr>
<tr>
<td>8370</td>
<td>只有复制器可以执行这个功能。</td>
</tr>
<tr>
<td>8371</td>
<td>指定的类别没有定义。</td>
</tr>
<tr>
<td>8372</td>
<td>指定的类别不是一个子类别。</td>
</tr>
<tr>
<td>8373</td>
<td>名称参考无效。</td>
</tr>
<tr>
<td>8374</td>
<td>交叉参考已经存在。</td>
</tr>
<tr>
<td>8375</td>
<td>不允许删除一个主控交叉参考。</td>
</tr>
<tr>
<td>8376</td>
<td>只在 NC 头上支持子目录树通知。</td>
</tr>
<tr>
<td>8377</td>
<td>通知筛选器太复杂。</td>
</tr>
<tr>
<td>8378</td>
<td>架构更新失败: 重复的 RDN。</td>
</tr>
<tr>
<td>8379</td>
<td>架构更新失败: 重复的 OID。</td>
</tr>
<tr>
<td>8380</td>
<td>架构更新失败: 重复的 MAPI 识别符。</td>
</tr>
<tr>
<td>8381</td>
<td>架构更新失败: 复制架构 id GUID。</td>
</tr>
<tr>
<td>8382</td>
<td>架构更新失败: 重复的 LDAP 显示名称。</td>
</tr>
<tr>
<td>8383</td>
<td>架构更新失败: 范围下部少于范围上部。</td>
</tr>
<tr>
<td>8384</td>
<td>架构更新失败: 语法不匹配。</td>
</tr>
<tr>
<td>8385</td>
<td>架构更新失败: 属性在必须包含中使用。</td>
</tr>
<tr>
<td>8386</td>
<td>架构更新失败: 属性在可能包含中使用。</td>
</tr>
<tr>
<td>8387</td>
<td>架构更新失败: 可能包含中的属性不存在。</td>
</tr>
<tr>
<td>8388</td>
<td>架构更新失败:必须包含中的属性不存在。</td>
</tr>
<tr>
<td>8389</td>
<td>架构更新失败: 在辅助类别列表中的类别不存在或不是一个辅助类别。</td>
</tr>
<tr>
<td>8390</td>
<td>架构更新失败: poss-superior 中的类别不存在。</td>
</tr>
<tr>
<td>8391</td>
<td>架构更新失败: 在 subclassof 列表中的类别不存在或不能满足等级规则。</td>
</tr>
<tr>
<td>8392</td>
<td>架构更新失败: Rdn-Att-Id 语法不对。</td>
</tr>
<tr>
<td>8393</td>
<td>架构更新失败: 类别作为辅助类别使用。</td>
</tr>
<tr>
<td>8394</td>
<td>架构更新失败: 类别作为子类别使用。</td>
</tr>
<tr>
<td>8395</td>
<td>架构更新失败: 类别作为 poss superior 使用。</td>
</tr>
<tr>
<td>8396</td>
<td>架构更新在重新计算验证缓存时失败。</td>
</tr>
<tr>
<td>8397</td>
<td>目录树删除没有完成。要继续删除目录树，必须再次发出请求。</td>
</tr>
<tr>
<td>8398</td>
<td>不能执行请求的删除操作。</td>
</tr>
<tr>
<td>8399</td>
<td>不能读取架构记录管理类别识别符。</td>
</tr>
<tr>
<td>8400</td>
<td>属性架构语法不对。</td>
</tr>
<tr>
<td>8401</td>
<td>不能缓存属性。</td>
</tr>
<tr>
<td>8402</td>
<td>不能缓存类别。</td>
</tr>
<tr>
<td>8403</td>
<td>不能从缓存删除属性。</td>
</tr>
<tr>
<td>8404</td>
<td>无法从缓存中删除类别。</td>
</tr>
<tr>
<td>8405</td>
<td>无法读取特殊名称的属性。</td>
</tr>
<tr>
<td>8406</td>
<td>丢失一个所需的子参考。</td>
</tr>
<tr>
<td>8407</td>
<td>不能检索范例种类属性。</td>
</tr>
<tr>
<td>8408</td>
<td>出现一个内部错误。</td>
</tr>
<tr>
<td>8409</td>
<td>出现一个数据错误。</td>
</tr>
<tr>
<td>8410</td>
<td>丢失一个属性 GOVERNSID。</td>
</tr>
<tr>
<td>8411</td>
<td>丢失一个所需要的属性。</td>
</tr>
<tr>
<td>8412</td>
<td>指定的命名上下文丢失了一个交叉参考。</td>
</tr>
<tr>
<td>8413</td>
<td>出现一个安全检查错误。</td>
</tr>
<tr>
<td>8414</td>
<td>没有加载架构。</td>
</tr>
<tr>
<td>8415</td>
<td>架构分配失败。请检查机器内存是否不足。</td>
</tr>
<tr>
<td>8416</td>
<td>为属性架构获得所需语法失败。</td>
</tr>
<tr>
<td>8417</td>
<td>全局编录验证失败。全局编录无效或不支持操作。目录的某些部分目前无效。</td>
</tr>
<tr>
<td>8418</td>
<td>由于有关服务器之间的架构不匹配，复制操作失败。</td>
</tr>
<tr>
<td>8419</td>
<td>找不到 DSA 对象。</td>
</tr>
<tr>
<td>8420</td>
<td>找不到命名上下文。</td>
</tr>
<tr>
<td>8421</td>
<td>在缓存中找不到命名上下文。</td>
</tr>
<tr>
<td>8422</td>
<td>无法检索子对象。</td>
</tr>
<tr>
<td>8423</td>
<td>由于安全原因不允许修改。</td>
</tr>
<tr>
<td>8424</td>
<td>操作不能替换该隐藏的记录。</td>
</tr>
<tr>
<td>8425</td>
<td>等级无效。</td>
</tr>
<tr>
<td>8426</td>
<td>尝试建立等级表失败。</td>
</tr>
<tr>
<td>8427</td>
<td>目录配置参数在注册中丢失。</td>
</tr>
<tr>
<td>8428</td>
<td>尝试计算地址簿索引失败。</td>
</tr>
<tr>
<td>8429</td>
<td>等级表的分配失败。</td>
</tr>
<tr>
<td>8430</td>
<td>目录服务遇到一个内部失败。</td>
</tr>
<tr>
<td>8431</td>
<td>目录服务遇到一个未知失败。</td>
</tr>
<tr>
<td>8432</td>
<td>根对象需要一个 ‘top’ 类别。</td>
</tr>
<tr>
<td>8433</td>
<td>这个目录服务器已关闭，并且不能接受新上浮单一主机操作角色的所有权。</td>
</tr>
<tr>
<td>8434</td>
<td>目录服务没有必需的配置信息，并且不能决定新上浮单一主机操作角色的所有权。</td>
</tr>
<tr>
<td>8435</td>
<td>该目录服务无法将一个或多个上浮单一主机操作角色传送给其它服务器。</td>
</tr>
<tr>
<td>8436</td>
<td>复制操作失败。</td>
</tr>
<tr>
<td>8437</td>
<td>为这个复制操作指定了一个无效的参数。</td>
</tr>
<tr>
<td>8438</td>
<td>目录服务太忙，现在无法完成这个复制操作。</td>
</tr>
<tr>
<td>8439</td>
<td>为这个复制操作指定的单一名称无效。</td>
</tr>
<tr>
<td>8440</td>
<td>为这一个复制操作所指定的命名上下文无效。</td>
</tr>
<tr>
<td>8441</td>
<td>为这个复制操作指定的单一名称已经存在。</td>
</tr>
<tr>
<td>8442</td>
<td>复制系统遇到一个内部错误。</td>
</tr>
<tr>
<td>8443</td>
<td>复制操作遇到数据库不一致问题。</td>
</tr>
<tr>
<td>8444</td>
<td>不能连接到为这个复制操作指定的服务器上。</td>
</tr>
<tr>
<td>8445</td>
<td>复制操作遇到一个有无效范例类型的对象。</td>
</tr>
<tr>
<td>8446</td>
<td>复制操作无法分配内存。</td>
</tr>
<tr>
<td>8447</td>
<td>复制操作遇到一个邮件系统错误。</td>
</tr>
<tr>
<td>8448</td>
<td>目标服务器的复制参考信息已经存在。</td>
</tr>
<tr>
<td>8449</td>
<td>目标服务器的复制参考信息不存在。</td>
</tr>
<tr>
<td>8450</td>
<td>由于是由另一台服务器上复制的，因此不能删除命名上下文。</td>
</tr>
<tr>
<td>8451</td>
<td>复制操作遇到一个数据库错误。</td>
</tr>
<tr>
<td>8452</td>
<td>命名上下文要被删除或没有从指定的服务器上复制。</td>
</tr>
<tr>
<td>8453</td>
<td>复制访问被拒绝。</td>
</tr>
<tr>
<td>8454</td>
<td>这个版本的目录服务不支持请求的操作。</td>
</tr>
<tr>
<td>8455</td>
<td>取消复制远程过程呼叫。</td>
</tr>
<tr>
<td>8456</td>
<td>源服务器目前拒绝复制请求。</td>
</tr>
<tr>
<td>8457</td>
<td>目标服务器当前拒绝复制请求。</td>
</tr>
<tr>
<td>8458</td>
<td>由于对象名称冲突，复制操作失败。</td>
</tr>
<tr>
<td>8459</td>
<td>复制源已被重新安装。</td>
</tr>
<tr>
<td>8460</td>
<td>由于一个所需父对象丢失，复制操作失败。</td>
</tr>
<tr>
<td>8461</td>
<td>复制操作被抢先。</td>
</tr>
<tr>
<td>8462</td>
<td>由于缺乏更新，放弃复制同步尝试。</td>
</tr>
<tr>
<td>8463</td>
<td>由于系统正在关闭，复制操作被中断了。</td>
</tr>
<tr>
<td>8464</td>
<td>由于目标部分属性设置不是一个源部分属性设置的子设置，复制同步尝试失败。</td>
</tr>
<tr>
<td>8465</td>
<td>由于主复制尝试从部分复制同步，复制同步尝试失败。</td>
</tr>
<tr>
<td>8466</td>
<td>已经与为这个复制操作的指定的服务器联系，但是该服务器无法与完成这个操作所需的另外一个服务器联系。</td>
</tr>
<tr>
<td>8467</td>
<td>在副本安装时，检测到一个使用的源和内部版本之间的架构不匹配，不能安装该副本。</td>
</tr>
<tr>
<td>8468</td>
<td>架构更新失败: 有同一连接标识符的属性已经存在。</td>
</tr>
<tr>
<td>8469</td>
<td>名称翻译: 常见处理错误。</td>
</tr>
<tr>
<td>8470</td>
<td>名称翻译: 不能找到该名称或权限不够，不能看到名称。</td>
</tr>
<tr>
<td>8471</td>
<td>名称翻译: 输入名称映射到多个输出名称。</td>
</tr>
<tr>
<td>8472</td>
<td>名称翻译: 找到输出名称，但是找不到相应的输出格式。</td>
</tr>
<tr>
<td>8473</td>
<td>名称翻译: 不能完全解析，只找到了域。</td>
</tr>
<tr>
<td>8474</td>
<td>名称翻译: 不接到线上，无法在客户机上执行纯粹的语法映射。</td>
</tr>
<tr>
<td>8475</td>
<td>不允许一个构造 att 修改。</td>
</tr>
<tr>
<td>8476</td>
<td>指定的 OM-Object 类别对指定语法的一个属性是不正确的。</td>
</tr>
<tr>
<td>8477</td>
<td>复制请求已暂停; 等待回答。</td>
</tr>
<tr>
<td>8478</td>
<td>要求的操作需要一个目录服务，但没有可用的。</td>
</tr>
<tr>
<td>8479</td>
<td>类别或属性的 LDAP 显示名称含有非 ASCII 字符。</td>
</tr>
<tr>
<td>8480</td>
<td>请求的查找操作只支持基本查找。</td>
</tr>
<tr>
<td>8481</td>
<td>查找未能从数据库检索属性。</td>
</tr>
<tr>
<td>8482</td>
<td>架构更新操作试图添加一个反向链接，但该反向链接没有相应的正向链接。</td>
</tr>
<tr>
<td>8483</td>
<td>跨域移动的来源和目标在对象日期上不一致。或者是来源，或者是目标没有对象的最后一个版本。</td>
</tr>
<tr>
<td>8484</td>
<td>跨域移动的来源和目标在对象当前的名称上不一致。或者是来源，或者是目标没有对象的最后一个版本。</td>
</tr>
<tr>
<td>8485</td>
<td>域间移动的来源和目标是一样的。调用程序应该使用本地移动操作，而不是域间移动操作。</td>
</tr>
<tr>
<td>8486</td>
<td>域间移动的来源和目标与目录林中的命名上下文不一致。来源或目标没有分区容器的最近版本。</td>
</tr>
<tr>
<td>8487</td>
<td>跨域移动的目标不是目标命名上下文的权威。</td>
</tr>
<tr>
<td>8488</td>
<td>跨域移动的来源和目标提供的来源对象的身份不一样。 来源或目标没有来源对象的最近版本。</td>
</tr>
<tr>
<td>8489</td>
<td>跨域移动的对象应该已经被目标服务器删除。来源服务器没有来源对象的最近版本。</td>
</tr>
<tr>
<td>8490</td>
<td>要求对 PDC FSMO 的专门访问权的另一个操作正在进行中。</td>
</tr>
<tr>
<td>8491</td>
<td>跨域移动没有成功，导致被移动对象有两个版本 - 一个在来源域，一个在目标域。需要删除目标对象，将系统还原到一致状态。</td>
</tr>
<tr>
<td>8492</td>
<td>因为不允许这个类别的跨域移动，或者对象有一些特点，如: 信任帐户或防止移动的受限制的 RID；所以不能将该对象跨域移动。</td>
</tr>
<tr>
<td>8493</td>
<td>一旦移动，不能将带有成员身份的对象跨域移动，这会侵犯帐户组的成员身份条件。从帐户组成员身份删除对象，再试一次。</td>
</tr>
<tr>
<td>8494</td>
<td>命名上下文标题必须是另一个命名上下文标题的直接子标题，而不是一个内节点的子标题。</td>
</tr>
<tr>
<td>8495</td>
<td>因为目录没有提议的命名上下文上面的命名上下文的副本，所以无法验证所提议的命名上下文的名称。请保证充当域命名主机的服务器已配置成全局编录服务器，并且服务器及其复制伙伴是最新的。</td>
</tr>
<tr>
<td>8496</td>
<td>目标域必须在本机模式中。</td>
</tr>
<tr>
<td>8497</td>
<td>因为服务器在指定域中没有基础结构容器，所以无法执行操作。</td>
</tr>
<tr>
<td>8498</td>
<td>不允许跨域移动帐户组。</td>
</tr>
<tr>
<td>8499</td>
<td>不允许跨域移动资源组。</td>
</tr>
<tr>
<td>8500</td>
<td>属性的搜索标志无效。ANR 位只在 Unicode 或 Teletex 字符串的属性上有效。</td>
</tr>
<tr>
<td>8501</td>
<td>不允许在将 NC 头作为子体的对象开始删除目录树。</td>
</tr>
<tr>
<td>8502</td>
<td>因为目录树在使用中，目录服务未能为删除目录树而将其锁定。</td>
</tr>
<tr>
<td>8503</td>
<td>删除目录树时，目录服务未能识别要删除的对象列表。</td>
</tr>
<tr>
<td>8505</td>
<td>只有管理员才能修改管理组的成员列表。</td>
</tr>
<tr>
<td>8506</td>
<td>不能改变域控制器帐户的主要组 ID。</td>
</tr>
<tr>
<td>8507</td>
<td>试图修改基础架构。</td>
</tr>
<tr>
<td>8508</td>
<td>不允许进行下列操作: 为现有类别添加新的强制属性；从现有类别删除强制属性；为没有向回链接属性的特殊类别 “Top” 添加可选属性，向回链接属性指的是直接或通过继承。例如: 添加或删除附属类别。</td>
</tr>
<tr>
<td>8509</td>
<td>该域控制器上不允许架构更新。没有设置注册表项，或者 DC 不是架构 FSMO 角色所有者。</td>
</tr>
<tr>
<td>8510</td>
<td>无法在架构容器下创建这个类别的对象。在架构容器下，您只能创建属性架构和类别架构对象。</td>
</tr>
<tr>
<td>8511</td>
<td>副本&#x2F;子项安装未能获取源 DC 上的架构容器的 objectVersion 属性。架构容器上的属性不存在，或者提供的凭据没有读取属性的权限。</td>
</tr>
<tr>
<td>8512</td>
<td>副本&#x2F;子项安装未能读取 system32 目录中的文件 schema.ini 的 SCHEMA 段中的 objectVersion 属性。</td>
</tr>
<tr>
<td>8513</td>
<td>指定的组类型无效。</td>
</tr>
<tr>
<td>8514</td>
<td>如果域是安全启用的，在混合型域中不能嵌套全局组。</td>
</tr>
<tr>
<td>8515</td>
<td>如果域是安全启用的，在混合型域中不能嵌套本地组。</td>
</tr>
<tr>
<td>8516</td>
<td>全局组不能将本地组作为成员。</td>
</tr>
<tr>
<td>8517</td>
<td>全局组不能将通用组作为成员。</td>
</tr>
<tr>
<td>8518</td>
<td>通用组不能将本地组作为成员。</td>
</tr>
<tr>
<td>8519</td>
<td>全局组不能有跨域成员。</td>
</tr>
<tr>
<td>8520</td>
<td>本地组不能将另一个跨域本地组作为成员。</td>
</tr>
<tr>
<td>8521</td>
<td>包含主要成员的组不能改变为安全停用的组。</td>
</tr>
<tr>
<td>8522</td>
<td>架构缓冲加载未能转换类架构对象上的字符串默认值 SD。</td>
</tr>
<tr>
<td>8523</td>
<td>只有配置成全局编录服务器的 DSAs 才能充当域命名主机 FSMO 的角色。</td>
</tr>
<tr>
<td>8524</td>
<td>由于 DNS 查找故障，DSA 操作无法进行。</td>
</tr>
<tr>
<td>8525</td>
<td>处理一个对象的 DNS 主机名改动时，服务主要名称数值无法保持同步。</td>
</tr>
<tr>
<td>8526</td>
<td>未能读取安全描述符属性。</td>
</tr>
<tr>
<td>8527</td>
<td>没有找到请求的对象，但找到了具有那个密钥的对象。</td>
</tr>
<tr>
<td>8528</td>
<td>正在添加的链接属性的语法不正确。正向链接只能有语法 2.5.5.1、2.5.5.7 和 2.5.5.14，而反向链接只能有语法 2.5.5.1</td>
</tr>
<tr>
<td>8529</td>
<td>安全帐户管理员需要获得启动密码。</td>
</tr>
<tr>
<td>8530</td>
<td>安全帐户管理员需要从软盘获得启动密钥。</td>
</tr>
<tr>
<td>8531</td>
<td>目录服务无法启动。</td>
</tr>
<tr>
<td>8532</td>
<td>未能启动目录服务。</td>
</tr>
<tr>
<td>8533</td>
<td>客户和服务器之间的连接要求数据包保密性。</td>
</tr>
<tr>
<td>8534</td>
<td>来源域跟目标域不在同一个目录林中。</td>
</tr>
<tr>
<td>8535</td>
<td>目标域必须在目录林中。</td>
</tr>
<tr>
<td>8536</td>
<td>该操作要求启用目标域审核。</td>
</tr>
<tr>
<td>8537</td>
<td>该操作无法为来源域找到 DC。</td>
</tr>
<tr>
<td>8538</td>
<td>来源对象必须是一个组或用户。</td>
</tr>
<tr>
<td>8539</td>
<td>来源对象的 SID 已经在目标目录林中。</td>
</tr>
<tr>
<td>8540</td>
<td>来源对象和目标对象必须属于同一类型。</td>
</tr>
<tr>
<td>8542</td>
<td>在复制请求中不能包括架构信息。</td>
</tr>
<tr>
<td>8543</td>
<td>由于架构不兼容性，无法完成 复制操作。</td>
</tr>
<tr>
<td>8544</td>
<td>由于前一个架构的不兼容性，无法完成复制操作。</td>
</tr>
<tr>
<td>8545</td>
<td>因为源和目标都没有收到有关最近跨域启动操作的信息，所以无法应用复制更新。</td>
</tr>
<tr>
<td>8546</td>
<td>因为还有主控这个域的域控制器，所以无法删除请求的域。</td>
</tr>
<tr>
<td>8547</td>
<td>只能在全局编录服务器上执行请求的操作。</td>
</tr>
<tr>
<td>8548</td>
<td>本地组只能是同一个域中其他本地组的成员。</td>
</tr>
<tr>
<td>8549</td>
<td>外部安全主要成员不能是通用组的成员。</td>
</tr>
<tr>
<td>8550</td>
<td>出于安全，无法将属性复制到 GC。</td>
</tr>
<tr>
<td>8551</td>
<td>由于目前正在处理的修改太多，无法采取 PDC 的检查点。</td>
</tr>
<tr>
<td>8552</td>
<td>操作需要启用那个源域审核。</td>
</tr>
<tr>
<td>8553</td>
<td>安全主要对象仅能在域命名环境菜单中创建。</td>
</tr>
<tr>
<td>8554</td>
<td>服务主要名称(SPN) 无法建造，因为提供的主机名格式不适合。</td>
</tr>
<tr>
<td>8555</td>
<td>筛选器已传递建造的属性。</td>
</tr>
<tr>
<td>8556</td>
<td>unicodePwd 属性值必须括在双引号中。</td>
</tr>
<tr>
<td>8557</td>
<td>您的计算机无法加入域。已超出此域上允许创建的计算机帐户的最大值。请同系统管理员联系，复位或增加此限定值。</td>
</tr>
<tr>
<td>8558</td>
<td>由于安全原因，操作必须在目标 DC 上运行。</td>
</tr>
<tr>
<td>8559</td>
<td>由于安全原因，源 DC 必须是 Service Pack 4 或更新版本。</td>
</tr>
<tr>
<td>8560</td>
<td>在树目录删除的操作中不能删除“关键目录服务系统”对象。数目录删除操作可能只进行了一部分。</td>
</tr>
<tr>
<td>9001</td>
<td>DNS 服务器无法解释格式。</td>
</tr>
<tr>
<td>9002</td>
<td>DNS 服务器失败。</td>
</tr>
<tr>
<td>9003</td>
<td>DNS 名称不存在。</td>
</tr>
<tr>
<td>9004</td>
<td>名称服务器不支持 DNS 请求。</td>
</tr>
<tr>
<td>9005</td>
<td>拒绝 DNS 操作。</td>
</tr>
<tr>
<td>9006</td>
<td>不应该存在的 DNS 名称仍然存在。</td>
</tr>
<tr>
<td>9007</td>
<td>不应该存在的 DNS RR 集仍然存在。</td>
</tr>
<tr>
<td>9008</td>
<td>应该存在的 DNS RR 集不存在。</td>
</tr>
<tr>
<td>9009</td>
<td>DNS 服务器对区域没有权威。</td>
</tr>
<tr>
<td>9010</td>
<td>在更新或 prereq 中的 DNS 名称不在区域中。</td>
</tr>
<tr>
<td>9016</td>
<td>DNS 签名验证失败。</td>
</tr>
<tr>
<td>9017</td>
<td>DNS 不正确密钥。</td>
</tr>
<tr>
<td>9018</td>
<td>DNS 签名验证过期。</td>
</tr>
<tr>
<td>9501</td>
<td>为 DNS 查询找不到记录。</td>
</tr>
<tr>
<td>9502</td>
<td>无效 DNS 包。</td>
</tr>
<tr>
<td>9503</td>
<td>没有 DNS 包。</td>
</tr>
<tr>
<td>9504</td>
<td>DNS 错误，请检查 rcode。</td>
</tr>
<tr>
<td>9505</td>
<td>为保险的 DNS 包。</td>
</tr>
<tr>
<td>9551</td>
<td>无效的 DNS 种类。</td>
</tr>
<tr>
<td>9552</td>
<td>无效的 IP 地址。</td>
</tr>
<tr>
<td>9553</td>
<td>无效的属性。</td>
</tr>
<tr>
<td>9554</td>
<td>稍后再试一次 DNS 操作。</td>
</tr>
<tr>
<td>9555</td>
<td>给出的记录名称和种类不是单一的。</td>
</tr>
<tr>
<td>9556</td>
<td>DNS 名称不符合 RFC 说明。</td>
</tr>
<tr>
<td>9557</td>
<td>DNS 名称是一个完全合格的 DNS 名称。</td>
</tr>
<tr>
<td>9558</td>
<td>DNS 名称以“.”分隔(多标签)。</td>
</tr>
<tr>
<td>9559</td>
<td>DNS 名称是单一部分名称。</td>
</tr>
<tr>
<td>9560</td>
<td>DNS 名称含有无效字符。</td>
</tr>
<tr>
<td>9561</td>
<td>DNS 名称完全是数字的。</td>
</tr>
<tr>
<td>9601</td>
<td>DNS 区域不存在。</td>
</tr>
<tr>
<td>9602</td>
<td>DNS 区域信息无效。</td>
</tr>
<tr>
<td>9603</td>
<td>DNS 区域无效操作。</td>
</tr>
<tr>
<td>9604</td>
<td>无效 DNS 区域配置。</td>
</tr>
<tr>
<td>9605</td>
<td>DNS 区域没有颁发机构记录的开始(SOA)。</td>
</tr>
<tr>
<td>9606</td>
<td>DNS 区域没有“名称服务器” (NS)的记录。</td>
</tr>
<tr>
<td>9607</td>
<td>DNS 区域已锁定。</td>
</tr>
<tr>
<td>9608</td>
<td>DNS 区域创建失败。</td>
</tr>
<tr>
<td>9609</td>
<td>DNS 区域已经存在。</td>
</tr>
<tr>
<td>9610</td>
<td>DNS 自动区域已经存在。</td>
</tr>
<tr>
<td>9611</td>
<td>无效的 DNS 区域种类。</td>
</tr>
<tr>
<td>9612</td>
<td>次要 DNS 区域需要主 IP 地址。</td>
</tr>
<tr>
<td>9613</td>
<td>DNS 区域不是次要的。</td>
</tr>
<tr>
<td>9614</td>
<td>需要一个次要 IP 地址</td>
</tr>
<tr>
<td>9615</td>
<td>WINS 初始化失败。</td>
</tr>
<tr>
<td>9616</td>
<td>需要 WINS 服务器。</td>
</tr>
<tr>
<td>9617</td>
<td>NBTSTAT 初始化呼叫失败。</td>
</tr>
<tr>
<td>9618</td>
<td>颁发机构起始(SOA)删除无效</td>
</tr>
<tr>
<td>9651</td>
<td>主要 DNS 区域需要数据文件。</td>
</tr>
<tr>
<td>9652</td>
<td>DNS 区域的无效数据文件名称。</td>
</tr>
<tr>
<td>9653</td>
<td>为 DNS 区域打开数据文件失败。</td>
</tr>
<tr>
<td>9654</td>
<td>为 DNS 区域写数据文件失败。</td>
</tr>
<tr>
<td>9655</td>
<td>为 DNS 区域读取数据文件时失败。</td>
</tr>
<tr>
<td>9701</td>
<td>DNS 记录不存在。</td>
</tr>
<tr>
<td>9702</td>
<td>DNS 记录格式错误。</td>
</tr>
<tr>
<td>9703</td>
<td>DNS 中节点创建失败。</td>
</tr>
<tr>
<td>9704</td>
<td>未知 DNS 记录类型。</td>
</tr>
<tr>
<td>9705</td>
<td>DNS 记录超时。</td>
</tr>
<tr>
<td>9706</td>
<td>名称不在 DNS 区域。</td>
</tr>
<tr>
<td>9707</td>
<td>检测到 CNAME 循环。</td>
</tr>
<tr>
<td>9708</td>
<td>节点为一个 CNAME DNS 记录。</td>
</tr>
<tr>
<td>9709</td>
<td>指定名称的 CNAME 记录已经存在。</td>
</tr>
<tr>
<td>9710</td>
<td>记录不在 DNS 区域根目录。</td>
</tr>
<tr>
<td>9711</td>
<td>DNS 记录已经存在。</td>
</tr>
<tr>
<td>9712</td>
<td>次要 DNS 区域数据错误。</td>
</tr>
<tr>
<td>9713</td>
<td>不能创建 DNS 缓存数据。</td>
</tr>
<tr>
<td>9714</td>
<td>DNS 名称不存在。</td>
</tr>
<tr>
<td>9715</td>
<td>不能创建指针(PTR)记录。</td>
</tr>
<tr>
<td>9716</td>
<td>DNS 域没有被删除。</td>
</tr>
<tr>
<td>9717</td>
<td>该目录服务无效。</td>
</tr>
<tr>
<td>9718</td>
<td>DNS 区域已经在目录服务中存在。</td>
</tr>
<tr>
<td>9719</td>
<td>DNS 服务器没有为目录服务集合 DNS 区域创建或读取启动文件。</td>
</tr>
<tr>
<td>9751</td>
<td>完成 DNS AXFR (区域复制)。</td>
</tr>
<tr>
<td>9752</td>
<td>DNS 区域复制失败。</td>
</tr>
<tr>
<td>9753</td>
<td>添加了本地 WINS 服务器。</td>
</tr>
<tr>
<td>9801</td>
<td>安全更新呼叫需要继续更新请求。</td>
</tr>
<tr>
<td>9851</td>
<td>TCP&#x2F;IP 没有安装网络协议。</td>
</tr>
<tr>
<td>9852</td>
<td>没有为本地系统配置 DNS 服务器。</td>
</tr>
<tr>
<td>10004</td>
<td>一个封锁操作被对 WSACancelBlockingCall 的调用中断。</td>
</tr>
<tr>
<td>10009</td>
<td>提供的文件句柄无效。</td>
</tr>
<tr>
<td>10013</td>
<td>以一种访问权限不允许的方式做了一个访问套接字的尝试。</td>
</tr>
<tr>
<td>10014</td>
<td>系统检测到在一个调用中尝试使用指针参数时的无效指针地址。</td>
</tr>
<tr>
<td>10022</td>
<td>提供了一个无效的参数。</td>
</tr>
<tr>
<td>10024</td>
<td>打开的套接字太多。</td>
</tr>
<tr>
<td>10035</td>
<td>无法立即完成一个非阻挡性套接字操作。</td>
</tr>
<tr>
<td>10036</td>
<td>目前正在执行一个阻挡性操作。</td>
</tr>
<tr>
<td>10037</td>
<td>在一个非阻挡套接字上尝试了一个已经在进行的操作。</td>
</tr>
<tr>
<td>10038</td>
<td>在一个非套接字上尝试了一个操作。</td>
</tr>
<tr>
<td>10039</td>
<td>请求的地址在一个套接字中从操作中忽略。</td>
</tr>
<tr>
<td>10040</td>
<td>一个在数据报套接字上发送的消息大于内部消息缓冲器或其它一些网络限制，或该用户用于接收数据报的缓冲器比数据报小。</td>
</tr>
<tr>
<td>10041</td>
<td>在套接字函数调用中指定的一个协议不支持请求的套接字类别的语法。</td>
</tr>
<tr>
<td>10042</td>
<td>在 getsockopt 或 setsockopt 调用中指定的一个未知的、无效的或不受支持的选项或层次。</td>
</tr>
<tr>
<td>10043</td>
<td>请求的协议还没有在系统中配置，或者没有它存在的迹象。</td>
</tr>
<tr>
<td>10044</td>
<td>在这个地址家族中不存在对指定的插槽种类的支持。</td>
</tr>
<tr>
<td>10045</td>
<td>参考的对象种类不支持尝试的操作。</td>
</tr>
<tr>
<td>10046</td>
<td>协议家族尚未配置到系统中或没有它的存在迹象。</td>
</tr>
<tr>
<td>10047</td>
<td>使用了与请求的协议不兼容的地址。</td>
</tr>
<tr>
<td>10048</td>
<td>通常每个套接字地址 (协议&#x2F;网络地址&#x2F;端口) 只允许使用一次。</td>
</tr>
<tr>
<td>10049</td>
<td>在其上下文中，该请求的地址无效。</td>
</tr>
<tr>
<td>10050</td>
<td>套接字操作遇到了一个已死的网络。</td>
</tr>
<tr>
<td>10051</td>
<td>向一个无法连接的网络尝试了一个套接字操作。</td>
</tr>
<tr>
<td>10052</td>
<td>当该操作在进行中，由于保持活动的操作检测到一个故障，该连接中断。</td>
</tr>
<tr>
<td>10053</td>
<td>您的主机中的软件放弃了一个已建立的连接。</td>
</tr>
<tr>
<td>10054</td>
<td>远程主机强迫关闭了一个现有的连接。</td>
</tr>
<tr>
<td>10055</td>
<td>由于系统缓冲区空间不足或列队已满，不能执行套接字上的操作。</td>
</tr>
<tr>
<td>10056</td>
<td>在一个已经连接的套接字上做了一个连接请求。</td>
</tr>
<tr>
<td>10057</td>
<td>由于套接字没有连接并且 (当使用一个 sendto 调用发送数据报套接字时) 没有提供地址，发送或接收数据的请求没有被接受。</td>
</tr>
<tr>
<td>10058</td>
<td>由于以前的关闭调用，套接字在那个方向已经关闭，发送或接收数据的请求没有被接受。</td>
</tr>
<tr>
<td>10059</td>
<td>对某个内核对象的引用过多。</td>
</tr>
<tr>
<td>10060</td>
<td>由于连接方在一段时间后没有正确的答复或连接的主机没有反应，连接尝试失败。</td>
</tr>
<tr>
<td>10061</td>
<td>不能做任何连接，因为目标机器积极地拒绝它。</td>
</tr>
<tr>
<td>10062</td>
<td>无法翻译名称。</td>
</tr>
<tr>
<td>10063</td>
<td>名称组件或名称太长。</td>
</tr>
<tr>
<td>10064</td>
<td>由于目标主机坏了，套接字操作失败。</td>
</tr>
<tr>
<td>10065</td>
<td>套接字操作尝试一个无法连接的主机。</td>
</tr>
<tr>
<td>10066</td>
<td>不能删除目录，除非它是空的。</td>
</tr>
<tr>
<td>10067</td>
<td>一个 Windows 套接字操作可能在可以同时使用的应用程序数目上有限制。</td>
</tr>
<tr>
<td>10068</td>
<td>超过限额。</td>
</tr>
<tr>
<td>10069</td>
<td>超过磁盘限额。</td>
</tr>
<tr>
<td>10070</td>
<td>文件句柄引用不再有效。</td>
</tr>
<tr>
<td>10071</td>
<td>项目在本地不可用。</td>
</tr>
<tr>
<td>10091</td>
<td>因为它使用提供网络服务的系统目前无效，WSAStartup 目前不能正常工作。</td>
</tr>
<tr>
<td>10092</td>
<td>不支持请求的 Windows 套接字版本</td>
</tr>
<tr>
<td>10093</td>
<td>应用程序没有调用 WSAStartup，或者 WSAStartup 失败。</td>
</tr>
<tr>
<td>10101</td>
<td>由 WSARecv 或 WSARecvFrom 返回表示远程方面已经开始了关闭步骤。</td>
</tr>
<tr>
<td>10102</td>
<td>WSALookupServiceNext 不能返回更多的结果。</td>
</tr>
<tr>
<td>10103</td>
<td>在处理这个调用时，就开始调用 WSALookupServiceEnd。该调用被删除。</td>
</tr>
<tr>
<td>10104</td>
<td>过程调用无效。</td>
</tr>
<tr>
<td>10105</td>
<td>请求的服务提供程序无效。</td>
</tr>
<tr>
<td>10106</td>
<td>没有加载或初始化请求的服务提供程序。</td>
</tr>
<tr>
<td>10107</td>
<td>从来不应失败的系统调用失败了。</td>
</tr>
<tr>
<td>10108</td>
<td>没有已知的此服务。在指定的名称空间中找不这个服务。</td>
</tr>
<tr>
<td>10109</td>
<td>找不到指定的类别。</td>
</tr>
<tr>
<td>10110</td>
<td>WSALookupServiceNext 不能返回更多的结果。</td>
</tr>
<tr>
<td>10111</td>
<td>在处理这个调用时，就开始调用 WSALookupServiceEnd。该调用被删除。</td>
</tr>
<tr>
<td>10112</td>
<td>由于被拒绝，数据查询失败。</td>
</tr>
</tbody></table>
<p>更多错误编码请参看 <a href="/blog/sql-server-state-code-list-1">《上篇》</a>。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>VC++6.0 MFC编程心得小结</title>
    <url>/2013-01-18-vc-6-mfc-develop-summary/</url>
    <content><![CDATA[<p>作为一个正经的科班出身软件工程专业者，想必都知道什么是VC++6.0。这个充满神奇的工具。而作为专业教学课的首选编程IDE，它有着不可撼动的地位。博主不知道别家院系使用何种启蒙工具，反正博主就是这个工具启蒙的。对它，有着又爱又恨得情怀。</p>
<span id="more"></span>

<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>一个程序的最基本功能有输入、查询、修改、删除、保存、打印，均与数据库有关。而对数据库的基本操作使用最频繁，以Access 为例：</p>
<p>1、用程序创建Access 数据库文件：</p>
<p>手工创建数据文件的方法大家并不陌生，如果用程序创建有时候也需要，下面就是其中一种方法，可以使用ADOX::CatalogPtr来创建mdb文件。用下面“配置设置文件”文件方法设置数据库的参数，配置数据文件的名称、密码、ID和路径，在有安装程序的情况下需要它。</p>
<p>ADOX的建库，它是在没有数据库文件的情况下，用ADOX的目录指针CatalogPtr来创建ACCESS数据库文件，如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CRecord::UseADOXCatalogPtrCreatAccessDB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">       CString str=DBPath + DBName;         <span class="comment">//数据库的路径和名称</span></span><br><span class="line"></span><br><span class="line">       CString strPassword=DBPasswd;         <span class="comment">//数据库的密码</span></span><br><span class="line"></span><br><span class="line">       CString strcnn=_T(<span class="string">&quot;Provider=Microsoft.JET.OLEDB.4.0;Data source =&quot;</span>+str+<span class="string">&quot;;\</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">              Jet OLEDB:DatabasePassword=&quot;</span>+strPassword); <span class="comment">//数据库的字串</span></span><br><span class="line"></span><br><span class="line">             </span><br><span class="line"></span><br><span class="line">       <span class="comment">//使用ADOX::CatalogPtr来创建mdb文件：</span></span><br><span class="line"></span><br><span class="line">       HRESULT hr = S_OK;</span><br><span class="line"></span><br><span class="line">       hr=::<span class="built_in">CoInitialize</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">SUCCEEDED</span>(hr))</span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">              HRESULT hr = S_OK;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">try</span></span><br><span class="line"></span><br><span class="line">              &#123;</span><br><span class="line"></span><br><span class="line">                     ADOX::_CatalogPtrm_pCatalog = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">                     hr=m_pCatalog.<span class="built_in">CreateInstance</span>(__uuidof(ADOX::Catalog));</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span>(<span class="built_in">FAILED</span>(hr))</span><br><span class="line"></span><br><span class="line">                     &#123;</span><br><span class="line"></span><br><span class="line">                            _com_issue_error(hr);</span><br><span class="line"></span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                            m_pCatalog-&gt;<span class="built_in">Create</span>(<span class="type">_bstr_t</span>(strcnn));<span class="comment">//Create MDB</span></span><br><span class="line"></span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">              &#125;<span class="built_in">catch</span>(_com_error e)  <span class="comment">//异常处理</span></span><br><span class="line"></span><br><span class="line">			&#123;<span class="comment">//错误显示&#125;</span></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ::<span class="built_in">CoUninitialize</span>();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、用程序在系统中创建Access的数据源名称DSN：</p>
<p>手工配置ODBC的数据源名称，大家也不陌生。而通过程序动态建立ODBC的DSN，在有安装程序的情况下也需要它。它是在已有数据库文件的情况下建立数据源名称。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CRecord::CreatAccessDSN</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">              CString DBID ,lpszFile=DBPath+DBName;</span><br><span class="line"></span><br><span class="line">              <span class="type">int</span> mlen;</span><br><span class="line"></span><br><span class="line">              <span class="type">char</span>* szDesc=<span class="keyword">new</span> <span class="type">char</span>[<span class="number">512</span>];</span><br><span class="line"></span><br><span class="line">              <span class="built_in">sprintf</span>(szDesc,<span class="string">&quot;DSN=%s?UID=%s?;PWD=%s?;DESCRIPTION=;?DBQ=%s?\</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">FIL=MicrosoftAccess?DEFAULTDIR=%s??&quot;</span>\</span><br><span class="line"></span><br><span class="line">                     ,DBName,DBID,DBPasswd,lpszFile,DBPath);</span><br><span class="line"></span><br><span class="line">              mlen=<span class="built_in">strlen</span>(szDesc);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;mlen;i++)</span><br><span class="line"></span><br><span class="line">              &#123;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span>(szDesc[i]==<span class="string">&#x27;?&#x27;</span>)    szDesc[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(<span class="built_in">SQLConfigDataSource</span>(<span class="literal">NULL</span>,ODBC_ADD_DSN,<span class="string">&quot;MicrosoftAccess\</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                    Driver (*.mdb)\0&quot;</span>, (LPCSTR)szDesc)) <span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">              ……</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、动态建数据库表</p>
<p>一种方法可以通过一个配置数据库表的txt文件，它包括创建数据表的SQL语句，程序读入该文件的，并分析该文件的内容，得到一SQL字串，进行创建，这种方法建表比较灵活；另一种方法也可以通过有包括创建Access数据表SQL语句的程序代码创建。两种创建方法都要注意在字段名与它的字段类型之间必需用tab键隔开。如下，采用后者：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">      VARIANT* RecordsAffected=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      CString strSQL=\</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;CREATE TABLE accesstable(ID  longinteger ID ENTITY(1,1) not null,&quot;</span>;</span><br><span class="line"></span><br><span class="line">      strPSW=strPSW+<span class="string">&quot;name        text(10)not null,&quot;</span>;</span><br><span class="line"></span><br><span class="line">      strPSW=strPSW+<span class="string">&quot;cash  DOUBLE,remark   text(100));&quot;</span>;   <span class="comment">//SQL字串</span></span><br><span class="line"></span><br><span class="line">      m_pCon-&gt;<span class="built_in">Execute</span>((<span class="type">_bstr_t</span>)(LPCTSTR)strSQL,<span class="literal">NULL</span>,adExecuteNoRecords);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">catch</span>(_com_error&amp;e)    &#123; …… &#125;</span><br></pre></td></tr></table></figure>

<p>用VC++程序来动态建库很多数据类型不支持，但表名、字段名可以是变量。</p>
<p>4、数据库的连接和关闭</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CRecordSonPrg::CreatConnect</span><span class="params">()</span>   <span class="comment">//数据库的连接</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">CString str=<span class="string">&quot;Provider=MSDASQL.1;Password=&#x27;&quot;</span>+DBPasswd+<span class="string">&quot;&#x27;;\</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">              PersistSecurity Info=True;Data Source=&quot;</span>+DBName;  <span class="comment">//连接字串</span></span><br><span class="line"></span><br><span class="line">              <span class="keyword">try</span></span><br><span class="line"></span><br><span class="line">              &#123;</span><br><span class="line"></span><br><span class="line">                     m_pCon.<span class="built_in">CreateInstance</span>(__uuidof(Connection));</span><br><span class="line"></span><br><span class="line">                     m_strConnection = _T(str);  </span><br><span class="line"></span><br><span class="line">                     intbCon=m_pCon-&gt;<span class="built_in">Open</span>(<span class="type">_bstr_t</span>(m_strConnection),<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,adConnectUnspecified);</span><br><span class="line"></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="built_in">catch</span>(_com_error &amp;e)    &#123; ……    &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CRecordSonPrg::CloseConnect</span><span class="params">()</span>  <span class="comment">//数据库的关闭</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span></span><br><span class="line"></span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line">              m_pCon-&gt;<span class="built_in">Close</span>();  <span class="comment">//关闭连接</span></span><br><span class="line"></span><br><span class="line">              m_pCon.<span class="built_in">Release</span>(); <span class="comment">//释放</span></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">catch</span>(_com_error &amp;e)&#123; ……       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、用ADO对数据库记录的增、删、改、存、查、排序、过滤、打印</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打开一个数据表DBtable</span></span><br><span class="line"></span><br><span class="line">m_pRs.<span class="built_in">CreateInstance</span>(__uuidof(Recordset));</span><br><span class="line"></span><br><span class="line">m_strCmdText= _T(<span class="string">&quot;DBtable&quot;</span>);</span><br><span class="line"></span><br><span class="line">m_pRs-&gt;<span class="built_in">Open</span>((LPCTSTR)m_strCmdText,(LPCTSTR)m_strConnection,adOpenStatic,adLockOptimistic,adCmdTable);</span><br></pre></td></tr></table></figure>

<p>①增加记录：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(!m_pRs-&gt;<span class="built_in">Supports</span>(adAddNew))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      m_pRs-&gt;<span class="built_in">AddNew</span>();</span><br><span class="line"></span><br><span class="line">m_pRs-&gt;Fields-&gt;<span class="built_in">GetItem</span>(<span class="string">&quot;user&quot;</span>)-&gt;Value=(<span class="type">_variant_t</span>)strm_newuser;</span><br><span class="line"></span><br><span class="line">      ……</span><br><span class="line"></span><br><span class="line">     m_pRs-&gt;<span class="built_in">Update</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②删除记录：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line"></span><br><span class="line">&#123;    </span><br><span class="line"></span><br><span class="line">      m_pRs-&gt;<span class="built_in">Delete</span>(adAffectCurrent );      <span class="comment">//删除当前记录</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③改动、保存记录：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CRsCgDlg::SaveModifiedRecord</span><span class="params">()</span>       <span class="comment">//记录修改后保存</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">      ……       <span class="comment">//拷贝对话框数据到ADOC++ 绑定成员</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//调用ADO数据绑定更新模式的接口</span></span><br><span class="line"></span><br><span class="line">      HRESULT hr = m_piAdoRecordBinding-&gt;<span class="built_in">Update</span>( (CADORecordBinding*)<span class="keyword">this</span> );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④查找记录：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString temp =<span class="string">&quot;user=&#x27;&quot;</span>+m_FindUserName+<span class="string">&quot;&#x27;&quot;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//查找字串</span></span><br><span class="line"></span><br><span class="line">_bstr_ttemp1=(<span class="type">_bstr_t</span>)temp;                                  </span><br><span class="line"></span><br><span class="line"><span class="comment">//类型转换为_bstr_t</span></span><br><span class="line"></span><br><span class="line">m_pRs-&gt;<span class="built_in">Find</span>(temp1,<span class="number">0</span>,adSearchForward,<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>⑤排序记录：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CString temp=<span class="string">&quot;’user,&quot;</span>+m_FindUserName+<span class="string">&quot;&#x27;&quot;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//排序字串</span></span><br><span class="line"></span><br><span class="line">_bstr_ttemp1=(<span class="type">_bstr_t</span>)temp;                                  </span><br><span class="line"></span><br><span class="line"><span class="comment">//类型转换为_bstr_t</span></span><br><span class="line"></span><br><span class="line">m_pRs-&gt;Sort=(temp1);</span><br><span class="line"></span><br><span class="line">m_pRs-&gt;Sort=(<span class="string">&quot;&quot;</span>);                                          </span><br><span class="line"></span><br><span class="line"><span class="comment">//取消排序</span></span><br></pre></td></tr></table></figure>

<p>⑥过滤记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CString strfilter = _T(&quot;name = &#x27;&quot;+m_strFilter+&quot;&#x27;&quot;);    </span><br><span class="line"></span><br><span class="line">//过滤字串</span><br><span class="line"></span><br><span class="line">m_pRs-&gt;Filter= (_variant_t)strfilter;</span><br><span class="line"></span><br><span class="line">m_pRs-&gt;Filter= (long) adFilterNone;        </span><br><span class="line"></span><br><span class="line">//取消过滤</span><br></pre></td></tr></table></figure>

<p>⑦打印记录：</p>
<p>打印记录可以采用CDocument类的serialize()文档类的方式，也可以借助显示控件实现。这里是用FlexGrid控件编写的打印代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void CMyApp::PrintToText()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">      CString cFilePath = &quot;C:\\Documents and Settings\\Administrator\\&quot;;</span><br><span class="line"></span><br><span class="line">      CString cFileName = &quot;打印统计表.txt&quot;;</span><br><span class="line"></span><br><span class="line">      CString cFile = cFilePath+cFileName;</span><br><span class="line"></span><br><span class="line">CStdioFile file; </span><br><span class="line"></span><br><span class="line">//CStdioFile类是CFile类的派生类,它是以流方式操作文本</span><br><span class="line"></span><br><span class="line">      file.Open(cFile,CFile::modeCreate|CFile::modeWrite|CFile::typeText)</span><br><span class="line"></span><br><span class="line">CString str;</span><br><span class="line"></span><br><span class="line">      str.Format(&quot;%s\n\n&quot;,cFileName);      </span><br><span class="line"></span><br><span class="line">//格式化文件主题</span><br><span class="line"></span><br><span class="line">      file.WriteString(str);                   </span><br><span class="line"></span><br><span class="line">//写入文件主题</span><br><span class="line"></span><br><span class="line">      int RowCount = m_MSFGrid.GetRows();   </span><br><span class="line"></span><br><span class="line">//从FlexGrid控件表取行数</span><br><span class="line"></span><br><span class="line">      int ColCount = m_MSFGrid.GetCol();       </span><br><span class="line"></span><br><span class="line">//从FlexGrid控件表取列数</span><br><span class="line"></span><br><span class="line">      for(long r=0;r&lt;RowCount;r++)     //行循环</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line"></span><br><span class="line">             for(long c=0;c&lt;ColCount;c++)     //列循环</span><br><span class="line"></span><br><span class="line">             &#123;</span><br><span class="line"></span><br><span class="line">                    CString Matrix =m_MSFGrid.GetTextMatrix(r,c);</span><br><span class="line"></span><br><span class="line">//得到r行c列的文本</span><br><span class="line"></span><br><span class="line">                    switch(c)</span><br><span class="line"></span><br><span class="line">                    &#123; str.Format( …… );//产生打印格式 &#125;</span><br><span class="line"></span><br><span class="line">                    file.WriteString(str);</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      file.SetLength(file.GetPosition());     </span><br><span class="line"></span><br><span class="line">//设置文件长度</span><br><span class="line"></span><br><span class="line">      file.Close();                      </span><br><span class="line"></span><br><span class="line">//关闭文件</span><br><span class="line"></span><br><span class="line">      str=&quot;notepad &quot;+cFile;</span><br><span class="line"></span><br><span class="line">      WinExec(str,SW_SHOW);            </span><br><span class="line"></span><br><span class="line">//利用记事本打开生成的文本文件</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、配置设置文件：</p>
<p>为了增加程序的灵活性，对配置文件的读、写也是必要的。Windows操作系统专门为此提供了6个API函数来对配置设置文件进行读、写：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GetPrivateProfileInt()               </span><br><span class="line"></span><br><span class="line">//从私有初始化文件获取整型数值  </span><br><span class="line"></span><br><span class="line">GetPrivateProfileString()  </span><br><span class="line"></span><br><span class="line">//从私有初始化文件获取字符串型值  </span><br><span class="line"></span><br><span class="line">GetProfileInt                    </span><br><span class="line"></span><br><span class="line">//从win.ini获取整数值  </span><br><span class="line"></span><br><span class="line">GetProfileString                      </span><br><span class="line"></span><br><span class="line">//从win.ini获取字符串值  </span><br><span class="line"></span><br><span class="line">WritePrivateProfileString  </span><br><span class="line"></span><br><span class="line">//写字符串到私有初始化文件  </span><br><span class="line"></span><br><span class="line">WriteProfileString      </span><br><span class="line"></span><br><span class="line">//写字符串到win.ini </span><br></pre></td></tr></table></figure>

<p>下面采用私有初始化文件获取或写入字符串型值的函数来读写配置文件：</p>
<p>读文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CString <span class="title">CMyApp::GetOneIniData</span><span class="params">(CString sFilePath)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">      CString str;</span><br><span class="line"></span><br><span class="line">      <span class="type">char</span> buf[<span class="number">256</span>] =<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      len = <span class="built_in">GetPrivateProfileString</span>(</span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;Custom&quot;</span>,      <span class="comment">//节名</span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;UserName&quot;</span>   <span class="comment">//项名</span></span><br><span class="line"></span><br><span class="line">             <span class="string">&quot;No&quot;</span>,             <span class="comment">//没找到此项时的返回值</span></span><br><span class="line"></span><br><span class="line">             buf,               <span class="comment">//目标缓冲区地址</span></span><br><span class="line"></span><br><span class="line">             <span class="number">256</span>,               <span class="comment">//目标缓冲区长度</span></span><br><span class="line"></span><br><span class="line">             sFilePath        <span class="comment">//配置文件的准确路径</span></span><br><span class="line"></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      str=buf;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CKaApp::WriteIniData</span><span class="params">(CString cstr,CString strUserName)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">       CString sFile = cstr;</span><br><span class="line"></span><br><span class="line">       CFileStatus status;  </span><br><span class="line"></span><br><span class="line">       BOOL RetUser=<span class="built_in">WritePrivateProfileString</span>(</span><br><span class="line"></span><br><span class="line">              <span class="string">&quot;Custom&quot;</span>,             <span class="comment">//节名</span></span><br><span class="line"></span><br><span class="line">              <span class="string">&quot;UserName&quot;</span>,         <span class="comment">//项名</span></span><br><span class="line"></span><br><span class="line">              strUserName,         <span class="comment">//内容</span></span><br><span class="line"></span><br><span class="line">              sFile                            <span class="comment">//配置文件的准确路径</span></span><br><span class="line"></span><br><span class="line">              );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于SQL Server的操作类似。</p>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Server 错误代码和解释 (上篇)</title>
    <url>/2013-01-20-sql-server-state-code-list-1/</url>
    <content><![CDATA[<p>SQL Server 是高校专业在教学数据库时一定会选用的案例之一，这个数据库是结合微软产品一起使用的，不仅贵，而且不好用。这是在使用之后的心得体会。在代码层面来说，这个是很难使用的。但是，老师说这个以后工作了都会使用到，所以，还是要好好学的。</p>
<span id="more"></span>

<p>文中罗列了各种状态码的解释，这些对调试SQL Server数据库程序是很有帮助的。</p>
<table>
<thead>
<tr>
<th>错误码</th>
<th>错误原因说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>操作成功完成。</td>
</tr>
<tr>
<td>1</td>
<td>功能错误。</td>
</tr>
<tr>
<td>2</td>
<td>系统找不到指定的文件。</td>
</tr>
<tr>
<td>3</td>
<td>系统找不到指定的路径。</td>
</tr>
<tr>
<td>4</td>
<td>系统无法打开文件。</td>
</tr>
<tr>
<td>5</td>
<td>拒绝访问。</td>
</tr>
<tr>
<td>6</td>
<td>句柄无效。</td>
</tr>
<tr>
<td>7</td>
<td>存储控制块被损坏。</td>
</tr>
<tr>
<td>8</td>
<td>存储空间不足，无法处理此命令。</td>
</tr>
<tr>
<td>9</td>
<td>存储控制块地址无效。</td>
</tr>
<tr>
<td>10</td>
<td>环境错误。</td>
</tr>
<tr>
<td>11</td>
<td>试图加载格式错误的程序。</td>
</tr>
<tr>
<td>12</td>
<td>访问码无效。</td>
</tr>
<tr>
<td>13</td>
<td>数据无效。</td>
</tr>
<tr>
<td>14</td>
<td>存储器不足，无法完成此操作。</td>
</tr>
<tr>
<td>15</td>
<td>系统找不到指定的驱动器。</td>
</tr>
<tr>
<td>16</td>
<td>无法删除目录。</td>
</tr>
<tr>
<td>17</td>
<td>系统无法将文件移到不同的驱动器。</td>
</tr>
<tr>
<td>18</td>
<td>没有更多文件。</td>
</tr>
<tr>
<td>19</td>
<td>介质受写入保护。</td>
</tr>
<tr>
<td>20</td>
<td>系统找不到指定的设备。</td>
</tr>
<tr>
<td>21</td>
<td>设备未就绪。</td>
</tr>
<tr>
<td>22</td>
<td>设备不识别此命令。</td>
</tr>
<tr>
<td>23</td>
<td>数据错误 (循环冗余检查)。</td>
</tr>
<tr>
<td>24</td>
<td>程序发出命令，但命令长度不正确。</td>
</tr>
<tr>
<td>25</td>
<td>驱动器无法找出磁盘上特定区域或磁道的位置。</td>
</tr>
<tr>
<td>26</td>
<td>无法访问指定的磁盘或软盘。</td>
</tr>
<tr>
<td>27</td>
<td>驱动器找不到请求的扇区。</td>
</tr>
<tr>
<td>28</td>
<td>打印机缺纸。</td>
</tr>
<tr>
<td>29</td>
<td>系统无法写入指定的设备。</td>
</tr>
<tr>
<td>30</td>
<td>系统无法从指定的设备上读取。</td>
</tr>
<tr>
<td>31</td>
<td>连到系统上的设备没有发挥作用。</td>
</tr>
<tr>
<td>32</td>
<td>进程无法访问文件，因为另一个程序正在使用此文件。</td>
</tr>
<tr>
<td>33</td>
<td>进程无法访问文件，因为另一个程序已锁定文件的一部分。</td>
</tr>
<tr>
<td>36</td>
<td>用来共享的打开文件过多。</td>
</tr>
<tr>
<td>38</td>
<td>到达文件结尾。</td>
</tr>
<tr>
<td>39</td>
<td>磁盘已满。</td>
</tr>
<tr>
<td>50</td>
<td>不支持网络请求。</td>
</tr>
<tr>
<td>51</td>
<td>远程计算机不可用 。</td>
</tr>
<tr>
<td>52</td>
<td>在网络上已有重复的名称。</td>
</tr>
<tr>
<td>53</td>
<td>找不到网络路径。</td>
</tr>
<tr>
<td>54</td>
<td>网络忙。</td>
</tr>
<tr>
<td>55</td>
<td>指定的网络资源或设备不再可用。</td>
</tr>
<tr>
<td>56</td>
<td>已到达网络 BIOS 命令限制。</td>
</tr>
<tr>
<td>57</td>
<td>网络适配器硬件出错。</td>
</tr>
<tr>
<td>58</td>
<td>指定的服务器无法运行请求的操作。</td>
</tr>
<tr>
<td>59</td>
<td>发生意外的网络错误。</td>
</tr>
<tr>
<td>60</td>
<td>远程适配器不兼容。</td>
</tr>
<tr>
<td>61</td>
<td>打印机队列已满。</td>
</tr>
<tr>
<td>62</td>
<td>无法在服务器上获得用于保存待打印文件的空间。</td>
</tr>
<tr>
<td>63</td>
<td>删除等候打印的文件。</td>
</tr>
<tr>
<td>64</td>
<td>指定的网络名不再可用。</td>
</tr>
<tr>
<td>65</td>
<td>拒绝网络访问。</td>
</tr>
<tr>
<td>66</td>
<td>网络资源类型错误。</td>
</tr>
<tr>
<td>67</td>
<td>找不到网络名。</td>
</tr>
<tr>
<td>68</td>
<td>超过本地计算机网卡的名称限制。</td>
</tr>
<tr>
<td>69</td>
<td>超出网络 BIOS 会话限制。</td>
</tr>
<tr>
<td>70</td>
<td>远程服务器已暂停，或正在启动过程中。</td>
</tr>
<tr>
<td>71</td>
<td>当前已无法再同此远程计算机连接，因为已达到计算机的连接数目极限。</td>
</tr>
<tr>
<td>72</td>
<td>已暂停指定的打印机或磁盘设备。</td>
</tr>
<tr>
<td>80</td>
<td>文件存在。</td>
</tr>
<tr>
<td>82</td>
<td>无法创建目录或文件。</td>
</tr>
<tr>
<td>83</td>
<td>INT 24 失败。</td>
</tr>
<tr>
<td>84</td>
<td>无法取得处理此请求的存储空间。</td>
</tr>
<tr>
<td>85</td>
<td>本地设备名已在使用中。</td>
</tr>
<tr>
<td>86</td>
<td>指定的网络密码错误。</td>
</tr>
<tr>
<td>87</td>
<td>参数错误。</td>
</tr>
<tr>
<td>88</td>
<td>网络上发生写入错误。</td>
</tr>
<tr>
<td>89</td>
<td>系统无法在此时启动另一个进程。</td>
</tr>
<tr>
<td>100</td>
<td>无法创建另一个系统信号灯。</td>
</tr>
<tr>
<td>101</td>
<td>另一个进程拥有独占的信号灯。</td>
</tr>
<tr>
<td>102</td>
<td>已设置信号灯且无法关闭。</td>
</tr>
<tr>
<td>103</td>
<td>无法再设置信号灯。</td>
</tr>
<tr>
<td>104</td>
<td>无法在中断时请求独占的信号灯。</td>
</tr>
<tr>
<td>105</td>
<td>此信号灯的前一个所有权已结束。</td>
</tr>
<tr>
<td>107</td>
<td>程序停止，因为替代的软盘未插入。</td>
</tr>
<tr>
<td>108</td>
<td>磁盘在使用中，或被另一个进程 锁定。</td>
</tr>
<tr>
<td>109</td>
<td>管道已结束。</td>
</tr>
<tr>
<td>110</td>
<td>系统无法打开指定的 设备或文件。</td>
</tr>
<tr>
<td>111</td>
<td>文件名太长。</td>
</tr>
<tr>
<td>112</td>
<td>磁盘空间不足。</td>
</tr>
<tr>
<td>113</td>
<td>无法再获得内部文件的标识。</td>
</tr>
<tr>
<td>114</td>
<td>目标内部文件的标识不正确。</td>
</tr>
<tr>
<td>117</td>
<td>应用程序制作的 IOCTL 调用错误。</td>
</tr>
<tr>
<td>118</td>
<td>验证写入的切换参数值错误。</td>
</tr>
<tr>
<td>119</td>
<td>系统不支持请求的命令。</td>
</tr>
<tr>
<td>120</td>
<td>此功能只被此系统支持。</td>
</tr>
<tr>
<td>121</td>
<td>信号灯超时时间已到。</td>
</tr>
<tr>
<td>122</td>
<td>传递到系统调用的数据区太小。</td>
</tr>
<tr>
<td>123</td>
<td>文件名、目录名或卷标语法不正确。</td>
</tr>
<tr>
<td>124</td>
<td>系统调用级别错误。</td>
</tr>
<tr>
<td>125</td>
<td>磁盘没有卷标。</td>
</tr>
<tr>
<td>126</td>
<td>找不到指定的模块。</td>
</tr>
<tr>
<td>127</td>
<td>找不到指定的程序。</td>
</tr>
<tr>
<td>128</td>
<td>没有等候的子进程。</td>
</tr>
<tr>
<td>130</td>
<td>试图使用操作(而非原始磁盘 I&#x2F;O)的已打开磁盘分区的文件句柄。</td>
</tr>
<tr>
<td>131</td>
<td>试图移动文件指针到文件开头之前。</td>
</tr>
<tr>
<td>132</td>
<td>无法在指定的设备或文件上设置文件指针。</td>
</tr>
<tr>
<td>133</td>
<td>包含先前加入驱动器的驱动器无法使用 JOIN 或 SUBST 命令。</td>
</tr>
<tr>
<td>134</td>
<td>试图在已被合并的驱动器上使用 JOIN 或 SUBST 命令。</td>
</tr>
<tr>
<td>135</td>
<td>试图在已被合并的驱动器上使用 JOIN 或 SUBST 命令。</td>
</tr>
<tr>
<td>136</td>
<td>系统试图解除未合并驱动器的 JOIN。</td>
</tr>
<tr>
<td>137</td>
<td>系统试图解除未替代驱动器的 SUBST。</td>
</tr>
<tr>
<td>138</td>
<td>系统试图将驱动器合并到合并驱动器上的目录。</td>
</tr>
<tr>
<td>139</td>
<td>系统试图将驱动器替代为替代驱动器上的目录。</td>
</tr>
<tr>
<td>140</td>
<td>系统试图将驱动器合并到替代驱动器上的目录。</td>
</tr>
<tr>
<td>141</td>
<td>系统试图替代驱动器为合并驱动器上的目录。</td>
</tr>
<tr>
<td>142</td>
<td>系统无法在此时运行 JOIN 或 SUBST。</td>
</tr>
<tr>
<td>143</td>
<td>系统无法将驱动器合并到或替代为相同驱动器上的目录。</td>
</tr>
<tr>
<td>144</td>
<td>目录并非根目录下的子目录。</td>
</tr>
<tr>
<td>145</td>
<td>目录非空。</td>
</tr>
<tr>
<td>146</td>
<td>指定的路径已在替代中使用。</td>
</tr>
<tr>
<td>147</td>
<td>资源不足，无法处理此命令。</td>
</tr>
<tr>
<td>148</td>
<td>指定的路径无法在此时使用。</td>
</tr>
<tr>
<td>149</td>
<td>企图将驱动器合并或替代为驱动器上目录是上一个替代的目标的驱动器。</td>
</tr>
<tr>
<td>150</td>
<td>系统跟踪信息未在 CONFIG.SYS 文件中指定，或不允许跟踪。</td>
</tr>
<tr>
<td>151</td>
<td>为 DosMuxSemWait 指定的信号灯事件个数错误。</td>
</tr>
<tr>
<td>152</td>
<td>DosMuxSemWait 不可运行。已设置过多的信号灯。</td>
</tr>
<tr>
<td>153</td>
<td>DosMuxSemWait 清单错误。</td>
</tr>
<tr>
<td>154</td>
<td>输入的卷标超过目标文件系统的 长度限制</td>
</tr>
<tr>
<td>155</td>
<td>无法创建另一个线程。</td>
</tr>
<tr>
<td>156</td>
<td>接收进程已拒绝此信号。</td>
</tr>
<tr>
<td>157</td>
<td>段已被放弃且无法锁定。</td>
</tr>
<tr>
<td>158</td>
<td>段已解除锁定。</td>
</tr>
<tr>
<td>159</td>
<td>线程标识的地址错误。</td>
</tr>
<tr>
<td>160</td>
<td>传递到 DosExecPgm 的参数字符串错误。</td>
</tr>
<tr>
<td>161</td>
<td>指定的路径无效。</td>
</tr>
<tr>
<td>162</td>
<td>信号已暂停。</td>
</tr>
<tr>
<td>164</td>
<td>无法在系统中创建更多的线程。</td>
</tr>
<tr>
<td>167</td>
<td>无法锁定文件区域。</td>
</tr>
<tr>
<td>170</td>
<td>请求的资源在使用中。</td>
</tr>
<tr>
<td>173</td>
<td>对于提供取消区域进行锁定的请求不明显。</td>
</tr>
<tr>
<td>174</td>
<td>文件系统不支持锁定类型的最小单元更改。</td>
</tr>
<tr>
<td>180</td>
<td>系统检测出错误的段号。</td>
</tr>
<tr>
<td>183</td>
<td>当文件已存在时，无法创建该文件。</td>
</tr>
<tr>
<td>186</td>
<td>传递的标志错误。</td>
</tr>
<tr>
<td>187</td>
<td>找不到指定的系统信号灯名称。</td>
</tr>
<tr>
<td>196</td>
<td>操作系统无法运行此应用程序。</td>
</tr>
<tr>
<td>197</td>
<td>操作系统当前的配置不能运行此应用程序。</td>
</tr>
<tr>
<td>199</td>
<td>操作系统无法运行此应用程序。</td>
</tr>
<tr>
<td>200</td>
<td>代码段不可大于或等于 64K。</td>
</tr>
<tr>
<td>203</td>
<td>操作系统找不到已输入的 环境选项。</td>
</tr>
<tr>
<td>205</td>
<td>命令子树中的进程 没有信号处理程序。</td>
</tr>
<tr>
<td>206</td>
<td>文件名或扩展名太长。</td>
</tr>
<tr>
<td>207</td>
<td>第 2 环堆栈已被占用。</td>
</tr>
<tr>
<td>208</td>
<td>没有正确输入文件名通配符 * 或 ?，或指定过多的文件名通配符。</td>
</tr>
<tr>
<td>209</td>
<td>正在发送的信号错误。</td>
</tr>
<tr>
<td>210</td>
<td>无法设置信号处理程序。</td>
</tr>
<tr>
<td>212</td>
<td>段已锁定且无法重新分配。</td>
</tr>
<tr>
<td>214</td>
<td>连到该程序或动态链接模块的动态链接模块太多。</td>
</tr>
<tr>
<td>215</td>
<td>无法嵌套调用 LoadModule。</td>
</tr>
<tr>
<td>230</td>
<td>管道状态无效。</td>
</tr>
<tr>
<td>231</td>
<td>所有的管道实例都在使用中。</td>
</tr>
<tr>
<td>232</td>
<td>管道正在关闭中。</td>
</tr>
<tr>
<td>233</td>
<td>管道的另一端上无任何进程。</td>
</tr>
<tr>
<td>234</td>
<td>更多数据可用。</td>
</tr>
<tr>
<td>240</td>
<td>取消会话。</td>
</tr>
<tr>
<td>254</td>
<td>指定的扩展属性名无效。</td>
</tr>
<tr>
<td>255</td>
<td>扩展属性不一致。</td>
</tr>
<tr>
<td>258</td>
<td>等待的操作过时。</td>
</tr>
<tr>
<td>259</td>
<td>没有可用的数据了。</td>
</tr>
<tr>
<td>266</td>
<td>无法使用复制功能。</td>
</tr>
<tr>
<td>267</td>
<td>目录名无效。</td>
</tr>
<tr>
<td>275</td>
<td>扩展属性在缓冲区中不适用。</td>
</tr>
<tr>
<td>276</td>
<td>装在文件系统上的扩展属性文件已损坏。</td>
</tr>
<tr>
<td>277</td>
<td>扩展属性表格文件已满。</td>
</tr>
<tr>
<td>278</td>
<td>指定的扩展属性句柄无效。</td>
</tr>
<tr>
<td>282</td>
<td>装入的文件系统不支持扩展属性。</td>
</tr>
<tr>
<td>288</td>
<td>企图释放并非呼叫方所拥有的多用户终端运行程序。</td>
</tr>
<tr>
<td>298</td>
<td>发向信号灯的请求过多。</td>
</tr>
<tr>
<td>299</td>
<td>仅完成部分的 ReadProcessMemoty 或 WriteProcessMemory 请求。</td>
</tr>
<tr>
<td>300</td>
<td>操作锁定请求被拒绝。</td>
</tr>
<tr>
<td>301</td>
<td>系统接收了一个无效的操作锁定确认。</td>
</tr>
<tr>
<td>487</td>
<td>试图访问无效的地址。</td>
</tr>
<tr>
<td>534</td>
<td>算术结果超过 32 位。</td>
</tr>
<tr>
<td>535</td>
<td>管道的另一端有一进程。</td>
</tr>
<tr>
<td>536</td>
<td>等候打开管道另一端的进程。</td>
</tr>
<tr>
<td>994</td>
<td>拒绝访问扩展属性。</td>
</tr>
<tr>
<td>995</td>
<td>由于线程退出或应用程序请求，已放弃 I&#x2F;O 操作。</td>
</tr>
<tr>
<td>996</td>
<td>重叠 I&#x2F;O 事件不在信号状态中。</td>
</tr>
<tr>
<td>997</td>
<td>重叠 I&#x2F;O 操作在进行中。</td>
</tr>
<tr>
<td>998</td>
<td>内存分配访问无效。</td>
</tr>
<tr>
<td>999</td>
<td>错误运行页内操作。</td>
</tr>
<tr>
<td>1001</td>
<td>递归太深；栈溢出。</td>
</tr>
<tr>
<td>1002</td>
<td>窗口无法在已发送的消息上操作。</td>
</tr>
<tr>
<td>1003</td>
<td>无法完成此功能。</td>
</tr>
<tr>
<td>1004</td>
<td>无效标志。</td>
</tr>
<tr>
<td>1005</td>
<td>此卷不包含可识别的文件系统。 请确定所有请求的文件系统驱动程序已加载，且此卷未损坏。</td>
</tr>
<tr>
<td>1006</td>
<td>文件所在的卷已被外部改变，因此打开的文件不再有效。</td>
</tr>
<tr>
<td>1007</td>
<td>无法在全屏幕模式下运行请求的操作。</td>
</tr>
<tr>
<td>1008</td>
<td>试图引用不存在的令牌。</td>
</tr>
<tr>
<td>1009</td>
<td>配置注册表数据库损坏。</td>
</tr>
<tr>
<td>1010</td>
<td>配置注册表项无效。</td>
</tr>
<tr>
<td>1011</td>
<td>无法打开配置注册表项。</td>
</tr>
<tr>
<td>1012</td>
<td>无法读取配置注册表项。</td>
</tr>
<tr>
<td>1013</td>
<td>无法写入配置注册表项。</td>
</tr>
<tr>
<td>1014</td>
<td>注册表数据库中的某一文件必须使用记录或替代复制来恢复。恢复成功完成。</td>
</tr>
<tr>
<td>1015</td>
<td>注册表损坏。包含注册表数据的某一文件结构损坏，或系统的文件内存映像损坏，或因为替代副本、日志缺少或损坏而无法恢复文件。</td>
</tr>
<tr>
<td>1016</td>
<td>由注册表启动的 I&#x2F;O 操作恢复失败。注册表无法读入、写出或清除任意一个包含注册表系统映像的文件。</td>
</tr>
<tr>
<td>1017</td>
<td>系统试图加载或还原文件到注册表，但指定的文件并非注册表文件格式。</td>
</tr>
<tr>
<td>1018</td>
<td>试图在标记为删除的注册表项上运行不合法的操作。</td>
</tr>
<tr>
<td>1019</td>
<td>系统无法配置注册表日志中所请求的空间。</td>
</tr>
<tr>
<td>1020</td>
<td>无法在已有子项或值的注册表项中创建符号链接。</td>
</tr>
<tr>
<td>1021</td>
<td>无法在易变父项下创建稳定子项。</td>
</tr>
<tr>
<td>1022</td>
<td>通知更改请求正在完成中，且信息并未返回到呼叫方的缓冲区中。当前呼叫方必须枚举文件来查找更改。</td>
</tr>
<tr>
<td>1051</td>
<td>已发送停止控制到服务，该服务被其它正在运行的服务所依赖。</td>
</tr>
<tr>
<td>1052</td>
<td>请求的控件对此服务无效</td>
</tr>
<tr>
<td>1053</td>
<td>服务并未及时响应启动或控制请求。</td>
</tr>
<tr>
<td>1054</td>
<td>无法创建此服务的线程。</td>
</tr>
<tr>
<td>1055</td>
<td>锁定服务数据库。</td>
</tr>
<tr>
<td>1056</td>
<td>服务的实例已在运行中。</td>
</tr>
<tr>
<td>1057</td>
<td>帐户名无效或不存在，或者密码对于指定的帐户名无效。</td>
</tr>
<tr>
<td>1058</td>
<td>无法启动服务，原因可能是它被禁用或与它相关联的设备没有启动。</td>
</tr>
<tr>
<td>1059</td>
<td>指定了循环服务依存。</td>
</tr>
<tr>
<td>1060</td>
<td>指定的服务并未以已安装的服务存在。</td>
</tr>
<tr>
<td>1061</td>
<td>服务无法在此时接受控制信息。</td>
</tr>
<tr>
<td>1062</td>
<td>服务未启动。</td>
</tr>
<tr>
<td>1063</td>
<td>服务进程无法连接到服务控制器上。</td>
</tr>
<tr>
<td>1064</td>
<td>当处理控制请求时，在服务中发生异常。</td>
</tr>
<tr>
<td>1065</td>
<td>指定的数据库不存在。</td>
</tr>
<tr>
<td>1066</td>
<td>服务已返回特定的服务错误码。</td>
</tr>
<tr>
<td>1067</td>
<td>进程意外终止。</td>
</tr>
<tr>
<td>1068</td>
<td>依存服务或组无法启动。</td>
</tr>
<tr>
<td>1069</td>
<td>由于登录失败而无法启动服务。</td>
</tr>
<tr>
<td>1070</td>
<td>启动后，服务停留在启动暂停状态。</td>
</tr>
<tr>
<td>1071</td>
<td>指定的服务数据库锁定无效。</td>
</tr>
<tr>
<td>1072</td>
<td>指定的服务已标记为删除。</td>
</tr>
<tr>
<td>1073</td>
<td>指定的服务已存在。</td>
</tr>
<tr>
<td>1074</td>
<td>系统当前以最新的有效配置运行。</td>
</tr>
<tr>
<td>1075</td>
<td>依存服务不存在，或已被标记为删除。</td>
</tr>
<tr>
<td>1076</td>
<td>已接受使用当前引导作为最后的有效控制设置。</td>
</tr>
<tr>
<td>1077</td>
<td>上次启动之后，仍未尝试引导服务。</td>
</tr>
<tr>
<td>1078</td>
<td>名称已用作服务名或服务显示名。</td>
</tr>
<tr>
<td>1079</td>
<td>此服务的帐户不同于运行于同一进程上的其它服务的帐户。</td>
</tr>
<tr>
<td>1080</td>
<td>只能为 Win32 服务设置失败操作，不能为驱动程序设置。</td>
</tr>
<tr>
<td>1081</td>
<td>这个服务所运行的处理和服务控制管理器相同。 所以，如果服务处理程序意外中止的话，服务控制管理器无法进行任何操作。</td>
</tr>
<tr>
<td>1082</td>
<td>这个服务尚未设置恢复程序。</td>
</tr>
<tr>
<td>1083</td>
<td>配置成在该可执行程序中运行的这个服务不能执行该服务。</td>
</tr>
<tr>
<td>1100</td>
<td>已达磁带的实际结尾。</td>
</tr>
<tr>
<td>1101</td>
<td>磁带访问已达文件标记。</td>
</tr>
<tr>
<td>1102</td>
<td>已达磁带或磁盘分区的开头。</td>
</tr>
<tr>
<td>1103</td>
<td>磁带访问已达一组文件的结尾。</td>
</tr>
<tr>
<td>1104</td>
<td>磁带上不再有任何数据。</td>
</tr>
<tr>
<td>1105</td>
<td>磁带无法分区。</td>
</tr>
<tr>
<td>1106</td>
<td>在访问多卷分区的新磁带时，当前的块大小不正确。</td>
</tr>
<tr>
<td>1107</td>
<td>当加载磁带时，找不到分区信息。</td>
</tr>
<tr>
<td>1108</td>
<td>无法锁定媒体弹出功能。</td>
</tr>
<tr>
<td>1109</td>
<td>无法卸载介质。</td>
</tr>
<tr>
<td>1110</td>
<td>驱动器中的介质可能已更改。</td>
</tr>
<tr>
<td>1111</td>
<td>复位 I&#x2F;O 总线。</td>
</tr>
<tr>
<td>1112</td>
<td>驱动器中没有媒体。</td>
</tr>
<tr>
<td>1113</td>
<td>在多字节的目标代码页中，没有此 Unicode 字符可以映射到的字符。</td>
</tr>
<tr>
<td>1114</td>
<td>动态链接库 (DLL) 初始化例程失败。</td>
</tr>
<tr>
<td>1115</td>
<td>系统关机正在进行。</td>
</tr>
<tr>
<td>1116</td>
<td>因为没有任何进行中的关机过程，所以无法中断系统关机。</td>
</tr>
<tr>
<td>1117</td>
<td>因为 I&#x2F;O 设备错误，所以无法运行此项请求。</td>
</tr>
<tr>
<td>1118</td>
<td>没有串行设备被初始化成功。串行驱动程序将卸载。</td>
</tr>
<tr>
<td>1119</td>
<td>无法打开正在与其他设备共享中断请求(IRQ)的设备。至少有一个使用该 IRQ 的其他设备已打开。</td>
</tr>
<tr>
<td>1120</td>
<td>序列 I&#x2F;O 操作已由另一个串行口的写入完成。 (IOCTL_SERIAL_XOFF_COUNTER 已达零。)</td>
</tr>
<tr>
<td>1121</td>
<td>因为已过超时时间，所以串行 I&#x2F;O 操作完成。 (IOCTL_SERIAL_XOFF_COUNTER 未达零。)</td>
</tr>
<tr>
<td>1122</td>
<td>在软盘上找不到 ID 地址标记。</td>
</tr>
<tr>
<td>1123</td>
<td>软盘扇区 ID 字符域与软盘控制器磁道地址不相符。</td>
</tr>
<tr>
<td>1124</td>
<td>软盘控制器报告软盘驱动程序不能识别的错误。</td>
</tr>
<tr>
<td>1125</td>
<td>软盘控制器返回与其寄存器中不一致的结果。</td>
</tr>
<tr>
<td>1126</td>
<td>当访问硬盘时，重新校准操作失败，重试仍然失败。</td>
</tr>
<tr>
<td>1127</td>
<td>当访问硬盘时，磁盘操作失败，重试仍然失败。</td>
</tr>
<tr>
<td>1128</td>
<td>当访问硬盘时，即使失败，仍须复位磁盘控制器。</td>
</tr>
<tr>
<td>1129</td>
<td>已达磁带结尾。</td>
</tr>
<tr>
<td>1130</td>
<td>服务器存储空间不足，无法处理此命令。</td>
</tr>
<tr>
<td>1131</td>
<td>检测出潜在的死锁状态。</td>
</tr>
<tr>
<td>1132</td>
<td>指定的基址或文件偏移量没有适当对齐。</td>
</tr>
<tr>
<td>1140</td>
<td>改变系统供电状态的尝试被另一应用程序或驱动程序否决。</td>
</tr>
<tr>
<td>1141</td>
<td>系统 BIOS 改变系统供电状态的尝试失败。</td>
</tr>
<tr>
<td>1142</td>
<td>试图在一文件上创建超过系统允许数额的链接。</td>
</tr>
<tr>
<td>1150</td>
<td>指定程序要求更新的 Windows 版本。</td>
</tr>
<tr>
<td>1151</td>
<td>指定程序不是 Windows 或 MS-DOS 程序。</td>
</tr>
<tr>
<td>1152</td>
<td>只能启动该指定程序的一个实例。</td>
</tr>
<tr>
<td>1153</td>
<td>该指定程序适用于旧的 Windows 版本。</td>
</tr>
<tr>
<td>1154</td>
<td>执行该应用程序所需的库文件之一被损坏。</td>
</tr>
<tr>
<td>1155</td>
<td>没有应用程序与此操作的指定文件有关联。</td>
</tr>
<tr>
<td>1156</td>
<td>在输送指令到应用程序的过程中出现错误。</td>
</tr>
<tr>
<td>1157</td>
<td>执行该应用程序所需的库文件之一无法找到。</td>
</tr>
<tr>
<td>1158</td>
<td>当前程序已使用了 Window 管理器对象的系统允许的所有句柄。</td>
</tr>
<tr>
<td>1159</td>
<td>消息只能与同步操作一起使用。</td>
</tr>
<tr>
<td>1160</td>
<td>指出的源元素没有媒体。</td>
</tr>
<tr>
<td>1161</td>
<td>指出的目标元素已包含媒体。</td>
</tr>
<tr>
<td>1162</td>
<td>指出的元素不存在。</td>
</tr>
<tr>
<td>1163</td>
<td>指出的元素是未显示的存储资源的一部分。</td>
</tr>
<tr>
<td>1164</td>
<td>显示设备需要重新初始化，因为硬件有错误。</td>
</tr>
<tr>
<td>1165</td>
<td>设备显示在尝试进一步操作之前需要清除。</td>
</tr>
<tr>
<td>1166</td>
<td>设备显示它的门仍是打开状态。</td>
</tr>
<tr>
<td>1167</td>
<td>设备没有连接。</td>
</tr>
<tr>
<td>1168</td>
<td>找不到元素。</td>
</tr>
<tr>
<td>1169</td>
<td>索引中没有同指定项相匹配的项。</td>
</tr>
<tr>
<td>1170</td>
<td>在对象上不存在指定的属性集。</td>
</tr>
<tr>
<td>1171</td>
<td>传递到 GetMouseMovePoints 的点不在缓冲区中。</td>
</tr>
<tr>
<td>1172</td>
<td>跟踪(工作站)服务没运行。</td>
</tr>
<tr>
<td>1173</td>
<td>找不到卷 ID。</td>
</tr>
<tr>
<td>1175</td>
<td>无法删除要被替换的文件。</td>
</tr>
<tr>
<td>1176</td>
<td>无法将替换文件移到要被替换的文件。要被替换的文件保持原来的名称。</td>
</tr>
<tr>
<td>1177</td>
<td>无法将替换文件移到要被替换的文件。要被替换的文件已被重新命名为备份名称。</td>
</tr>
<tr>
<td>1178</td>
<td>卷更改记录被删除。</td>
</tr>
<tr>
<td>1179</td>
<td>卷更改记录服务不处于活动中。</td>
</tr>
<tr>
<td>1180</td>
<td>找到一份文件，但是可能不是正确的文件。</td>
</tr>
<tr>
<td>1181</td>
<td>日志项从日志中被删除。</td>
</tr>
<tr>
<td>1200</td>
<td>指定的设备名无效。</td>
</tr>
<tr>
<td>1201</td>
<td>设备当前未连接上，但其为一个记录连接。</td>
</tr>
<tr>
<td>1202</td>
<td>企图记录先前已被记录的设备。</td>
</tr>
<tr>
<td>1203</td>
<td>无任何网络提供程序接受指定的网络路径。</td>
</tr>
<tr>
<td>1204</td>
<td>指定的网络提供程序名称无效。</td>
</tr>
<tr>
<td>1205</td>
<td>无法打开网络连接配置文件。</td>
</tr>
<tr>
<td>1206</td>
<td>网络连接配置文件损坏。</td>
</tr>
<tr>
<td>1207</td>
<td>无法枚举空载体。</td>
</tr>
<tr>
<td>1208</td>
<td>发生扩展错误。</td>
</tr>
<tr>
<td>1209</td>
<td>指定的组名格式无效。</td>
</tr>
<tr>
<td>1210</td>
<td>指定的计算机名格式无效。</td>
</tr>
<tr>
<td>1211</td>
<td>指定的事件名格式无效。</td>
</tr>
<tr>
<td>1212</td>
<td>指定的域名格式无效。</td>
</tr>
<tr>
<td>1213</td>
<td>指定的服务名格式无效。</td>
</tr>
<tr>
<td>1214</td>
<td>指定的网络名格式无效。</td>
</tr>
<tr>
<td>1215</td>
<td>指定的共享名格式无效。</td>
</tr>
<tr>
<td>1216</td>
<td>指定的密码格式无效。</td>
</tr>
<tr>
<td>1217</td>
<td>指定的消息名格式无效。</td>
</tr>
<tr>
<td>1218</td>
<td>指定的消息目标格式无效。</td>
</tr>
<tr>
<td>1219</td>
<td>提供的凭据与已存在的凭据集冲突。</td>
</tr>
<tr>
<td>1220</td>
<td>企图创建网络服务器的会话，但已对该服务器创建过多的会话。</td>
</tr>
<tr>
<td>1221</td>
<td>工作组或域名已由网络上的另一部计算机使用。</td>
</tr>
<tr>
<td>1222</td>
<td>网络未连接或启动。</td>
</tr>
<tr>
<td>1223</td>
<td>操作已被用户取消。</td>
</tr>
<tr>
<td>1224</td>
<td>请求的操作无法在使用用户映射区域打开的文件上执行。</td>
</tr>
<tr>
<td>1225</td>
<td>远程系统拒绝网络连接。</td>
</tr>
<tr>
<td>1226</td>
<td>网络连接已被适当地关闭了。</td>
</tr>
<tr>
<td>1227</td>
<td>网络传输终结点已有与其关联的地址。</td>
</tr>
<tr>
<td>1228</td>
<td>地址仍未与网络终结点关联。</td>
</tr>
<tr>
<td>1229</td>
<td>企图在不存在的网络连接上进行操作。</td>
</tr>
<tr>
<td>1230</td>
<td>企图在使用中的网络连接上进行无效的操作。</td>
</tr>
<tr>
<td>1231</td>
<td>不能访问网络位置。有关网络排除故障的信息，请参阅 Windows 帮助。</td>
</tr>
<tr>
<td>1232</td>
<td>不能访问网络位置。有关网络排除故障的信息，请参阅 Windows 帮助。</td>
</tr>
<tr>
<td>1233</td>
<td>不能访问网络位置。有关网络排除故障的信息，请参阅 Windows 帮助。</td>
</tr>
<tr>
<td>1234</td>
<td>没有任何服务正在远程系统上的目标网络终结点上操作。</td>
</tr>
<tr>
<td>1235</td>
<td>请求被终止。</td>
</tr>
<tr>
<td>1236</td>
<td>由本地系统终止网络连接。</td>
</tr>
<tr>
<td>1237</td>
<td>操作无法完成。应该重试。</td>
</tr>
<tr>
<td>1238</td>
<td>因为已达到此帐户的最大同时连接数限制，所以无法连接服务器。</td>
</tr>
<tr>
<td>1239</td>
<td>试图在这个帐户未被授权的时间内登录。</td>
</tr>
<tr>
<td>1240</td>
<td>此帐户并未得到从这个工作站登录的授权。</td>
</tr>
<tr>
<td>1241</td>
<td>请求的操作不能使用这个网络地址。</td>
</tr>
<tr>
<td>1242</td>
<td>服务器已经注册。</td>
</tr>
<tr>
<td>1243</td>
<td>指定的服务不存在。</td>
</tr>
<tr>
<td>1244</td>
<td>因为用户还未被验证，不能执行所要求的操作。</td>
</tr>
<tr>
<td>1245</td>
<td>因为用户还未登录网络，不能执行所要求的操作。 指定的服务不存在。</td>
</tr>
<tr>
<td>1246</td>
<td>正在继续工作。</td>
</tr>
<tr>
<td>1247</td>
<td>试图进行初始操作，但是初始化已完成。</td>
</tr>
<tr>
<td>1248</td>
<td>没有更多的本地设备。</td>
</tr>
<tr>
<td>1249</td>
<td>指定的站点不存在。</td>
</tr>
<tr>
<td>1250</td>
<td>具有指定名称的域控制器已经存在。</td>
</tr>
<tr>
<td>1251</td>
<td>只有连接到服务器上时，该操作才受支持。</td>
</tr>
<tr>
<td>1252</td>
<td>即使没有改动，组策略框架也应该调用扩展。</td>
</tr>
<tr>
<td>1253</td>
<td>指定的用户没有一个有效的配置文件。</td>
</tr>
<tr>
<td>1254</td>
<td>Microsoft Small Business Server 不支持此操作。</td>
</tr>
<tr>
<td>1300</td>
<td>并非所有被引用的特权都指派给呼叫方。</td>
</tr>
<tr>
<td>1301</td>
<td>帐户名和安全标识间的某些映射未完成。</td>
</tr>
<tr>
<td>1302</td>
<td>没有为该帐户特别设置系统配额限制。</td>
</tr>
<tr>
<td>1303</td>
<td>没有可用的加密密钥。返回了一个已知加密密钥。</td>
</tr>
<tr>
<td>1304</td>
<td>密码太复杂，无法转换成 LAN Manager 密码。返回的 LAN Manager 密码为空字符串。</td>
</tr>
<tr>
<td>1305</td>
<td>修订级别未知。</td>
</tr>
<tr>
<td>1306</td>
<td>表明两个修订级别是不兼容的。</td>
</tr>
<tr>
<td>1307</td>
<td>这个安全标识不能指派为此对象的所有者。</td>
</tr>
<tr>
<td>1308</td>
<td>这个安全标识不能指派为对象的主要组。</td>
</tr>
<tr>
<td>1309</td>
<td>当前并未模拟客户的线程试图操作模拟令牌。</td>
</tr>
<tr>
<td>1310</td>
<td>组可能未被禁用。</td>
</tr>
<tr>
<td>1311</td>
<td>当前没有可用的登录服务器来服务登录请求。</td>
</tr>
<tr>
<td>1312</td>
<td>指定的登录会话不存在。可能已被终止。</td>
</tr>
<tr>
<td>1313</td>
<td>指定的特权不存在。</td>
</tr>
<tr>
<td>1314</td>
<td>客户没有所需的特权。</td>
</tr>
<tr>
<td>1315</td>
<td>提供的名称并非正确的帐户名形式。</td>
</tr>
<tr>
<td>1316</td>
<td>指定的用户已存在。</td>
</tr>
<tr>
<td>1317</td>
<td>指定的用户不存在。</td>
</tr>
<tr>
<td>1318</td>
<td>指定的组已存在。</td>
</tr>
<tr>
<td>1319</td>
<td>指定的组不存在。</td>
</tr>
<tr>
<td>1320</td>
<td>指定的用户帐户已是指定组的成员，或是因为组包含成员所以无法删除指定的组。</td>
</tr>
<tr>
<td>1321</td>
<td>指定的用户帐户不是指定组帐户的成员。</td>
</tr>
<tr>
<td>1322</td>
<td>无法禁用或删除最后剩余的系统管理帐户。</td>
</tr>
<tr>
<td>1323</td>
<td>无法更新密码。提供作为当前密码的值不正确。</td>
</tr>
<tr>
<td>1324</td>
<td>无法更新密码。提供给新密码的值包含密码中不允许的值。</td>
</tr>
<tr>
<td>1325</td>
<td>无法更新密码。为新密码提供的值不符合字符域的长度、复杂性或历史要求。</td>
</tr>
<tr>
<td>1326</td>
<td>登录失败: 未知的用户名或错误密码。</td>
</tr>
<tr>
<td>1327</td>
<td>登录失败: 用户帐户限制。</td>
</tr>
<tr>
<td>1328</td>
<td>登录失败: 违反帐户登录时间限制。</td>
</tr>
<tr>
<td>1329</td>
<td>登录失败: 不允许用户登录到此计算机。</td>
</tr>
<tr>
<td>1330</td>
<td>登录失败: 指定的帐户密码已过期。</td>
</tr>
<tr>
<td>1331</td>
<td>登录失败: 禁用当前的帐户。</td>
</tr>
<tr>
<td>1332</td>
<td>帐户名与安全标识间无任何映射完成。</td>
</tr>
<tr>
<td>1333</td>
<td>一次请求过多的本地用户标识符(LUIDs)。</td>
</tr>
<tr>
<td>1334</td>
<td>无更多可用的本地用户标识符(LUIDs)。</td>
</tr>
<tr>
<td>1335</td>
<td>对于该特别用法，安全 ID 的次级授权部分无效。</td>
</tr>
<tr>
<td>1336</td>
<td>访问控制列表(ACL)结构无效。</td>
</tr>
<tr>
<td>1337</td>
<td>安全 ID 结构无效。</td>
</tr>
<tr>
<td>1338</td>
<td>安全描述符结构无效。</td>
</tr>
<tr>
<td>1340</td>
<td>无法创建固有的访问控制列表(ACL)或访问控制项目(ACE)。</td>
</tr>
<tr>
<td>1341</td>
<td>服务器当前已禁用。</td>
</tr>
<tr>
<td>1342</td>
<td>服务器当前已启用。</td>
</tr>
<tr>
<td>1343</td>
<td>提供给识别代号颁发机构的值为无效值。</td>
</tr>
<tr>
<td>1344</td>
<td>无更多可用的内存以更新安全信息。</td>
</tr>
<tr>
<td>1345</td>
<td>指定属性无效，或与整个群体的属性不兼容。</td>
</tr>
<tr>
<td>1346</td>
<td>指定的模拟级别无效， 或所提供的模拟级别无效。</td>
</tr>
<tr>
<td>1347</td>
<td>无法打开匿名级安全令牌。</td>
</tr>
<tr>
<td>1348</td>
<td>请求的验证信息类别无效。</td>
</tr>
<tr>
<td>1349</td>
<td>令牌的类型对其尝试使用的方法不适当。</td>
</tr>
<tr>
<td>1350</td>
<td>无法在与安全性无关联的对象上运行安全性操作。</td>
</tr>
<tr>
<td>1351</td>
<td>未能从域控制器读取配置信息，或者是因为机器不可使用，或者是访问被拒绝。</td>
</tr>
<tr>
<td>1352</td>
<td>安全帐户管理器(SAM)或本地安全颁发机构(LSA)服务器处于运行安全操作的错误状态。</td>
</tr>
<tr>
<td>1353</td>
<td>域处于运行安全操作的错误状态。</td>
</tr>
<tr>
<td>1354</td>
<td>此操作只对域的主要域控制器可行。</td>
</tr>
<tr>
<td>1355</td>
<td>指定的域不存在，或无法联系。</td>
</tr>
<tr>
<td>1356</td>
<td>指定的域已存在。</td>
</tr>
<tr>
<td>1357</td>
<td>试图超出每服务器域个数的限制。</td>
</tr>
<tr>
<td>1358</td>
<td>无法完成请求操作，因为磁盘上的严重介质失败或数据结构损坏。</td>
</tr>
<tr>
<td>1359</td>
<td>出现了内部错误。</td>
</tr>
<tr>
<td>1360</td>
<td>通用访问类型包含于已映射到非通用类型的访问掩码中。</td>
</tr>
<tr>
<td>1361</td>
<td>安全描述符格式不正确 (绝对或自相关的)。</td>
</tr>
<tr>
<td>1362</td>
<td>请求操作只限制在登录进程中使用。调用进程未注册为一个登录进程。</td>
</tr>
<tr>
<td>1363</td>
<td>无法使用已在使用中的标识启动新的会话。</td>
</tr>
<tr>
<td>1364</td>
<td>未知的指定验证数据包。</td>
</tr>
<tr>
<td>1365</td>
<td>登录会话并非处于与请求操作一致的状态中。</td>
</tr>
<tr>
<td>1366</td>
<td>登录会话标识已在使用中。</td>
</tr>
<tr>
<td>1367</td>
<td>登录请求包含无效的登录类型值。</td>
</tr>
<tr>
<td>1368</td>
<td>在使用命名管道读取数据之前，无法经由该管道模拟。</td>
</tr>
<tr>
<td>1369</td>
<td>注册表子树的事务处理状态与请求状态不一致。</td>
</tr>
<tr>
<td>1370</td>
<td>安全性数据库内部出现损坏。</td>
</tr>
<tr>
<td>1371</td>
<td>无法在内置帐户上运行此操作。</td>
</tr>
<tr>
<td>1372</td>
<td>无法在内置特殊组上运行此操作。</td>
</tr>
<tr>
<td>1373</td>
<td>无法在内置特殊用户上运行此操作。</td>
</tr>
<tr>
<td>1374</td>
<td>无法从组中删除用户，因为当前组为用户的主要组。</td>
</tr>
<tr>
<td>1375</td>
<td>令牌已作为主要令牌使用。</td>
</tr>
<tr>
<td>1376</td>
<td>指定的本地组不存在。</td>
</tr>
<tr>
<td>1377</td>
<td>指定的帐户名不是本地组的成员。</td>
</tr>
<tr>
<td>1378</td>
<td>指定的帐户名已是本地组的成员。</td>
</tr>
<tr>
<td>1379</td>
<td>指定的本地组已存在。</td>
</tr>
<tr>
<td>1380</td>
<td>登录失败: 未授予用户在此计算机上的请求登录类型。</td>
</tr>
<tr>
<td>1381</td>
<td>已超过在单一系统中可保存机密的最大个数。</td>
</tr>
<tr>
<td>1382</td>
<td>机密的长度超过允许的最大长度。</td>
</tr>
<tr>
<td>1383</td>
<td>本地安全颁发机构数据库内部包含不一致性。</td>
</tr>
<tr>
<td>1384</td>
<td>在尝试登录的过程中，用户的安全上下文积累了过多的安全标识。</td>
</tr>
<tr>
<td>1385</td>
<td>登录失败: 未授予用户在此计算机上的请求登录类型。</td>
</tr>
<tr>
<td>1386</td>
<td>更改用户密码时需要交叉加密密码。</td>
</tr>
<tr>
<td>1387</td>
<td>由于成员不存在，无法将成员添加到本地组中，也无法从本地组将其删除。</td>
</tr>
<tr>
<td>1388</td>
<td>无法将新成员加入到本地组中，因为成员的帐户类型错误。</td>
</tr>
<tr>
<td>1389</td>
<td>已指定过多的安全标识。</td>
</tr>
<tr>
<td>1390</td>
<td>更改此用户密码时需要交叉加密密码。</td>
</tr>
<tr>
<td>1391</td>
<td>表明 ACL 未包含任何可承继的组件。</td>
</tr>
<tr>
<td>1392</td>
<td>文件或目录损坏且无法读取。</td>
</tr>
<tr>
<td>1393</td>
<td>磁盘结构损坏且无法读取。</td>
</tr>
<tr>
<td>1394</td>
<td>无任何指定登录会话的用户会话项。</td>
</tr>
<tr>
<td>1395</td>
<td>正在访问的服务有连接数目标授权限制。 这时候已经无法再连接，原因是已经到达可接受的连接数目上限。</td>
</tr>
<tr>
<td>1396</td>
<td>登录失败: 该目标帐户名称不正确。</td>
</tr>
<tr>
<td>1397</td>
<td>相互身份验证失败。该服务器在域控制器的密码过期。</td>
</tr>
<tr>
<td>1398</td>
<td>在客户机和服务器之间有一个时间差。</td>
</tr>
<tr>
<td>1400</td>
<td>无效的窗口句柄。</td>
</tr>
<tr>
<td>1401</td>
<td>无效的菜单句柄。</td>
</tr>
<tr>
<td>1402</td>
<td>无效的光标句柄。</td>
</tr>
<tr>
<td>1403</td>
<td>无效的加速器表句柄。</td>
</tr>
<tr>
<td>1404</td>
<td>无效的挂钩句柄。</td>
</tr>
<tr>
<td>1405</td>
<td>无效的多重窗口位置结构句柄。</td>
</tr>
<tr>
<td>1406</td>
<td>无法创建最上层子窗口。</td>
</tr>
<tr>
<td>1407</td>
<td>找不到窗口类别。</td>
</tr>
<tr>
<td>1408</td>
<td>无效窗口；它属于另一线程。</td>
</tr>
<tr>
<td>1409</td>
<td>热键已注册。</td>
</tr>
<tr>
<td>1410</td>
<td>类别已存在。</td>
</tr>
<tr>
<td>1411</td>
<td>类别不存在。</td>
</tr>
<tr>
<td>1412</td>
<td>类别仍有打开的窗口。</td>
</tr>
<tr>
<td>1413</td>
<td>无效索引。</td>
</tr>
<tr>
<td>1414</td>
<td>无效的图标句柄。</td>
</tr>
<tr>
<td>1415</td>
<td>使用专用 DIALOG 窗口字。</td>
</tr>
<tr>
<td>1416</td>
<td>找不到列表框标识。</td>
</tr>
<tr>
<td>1417</td>
<td>找不到通配字符。</td>
</tr>
<tr>
<td>1418</td>
<td>线程没有打开的剪贴板。</td>
</tr>
<tr>
<td>1419</td>
<td>没有注册热键。</td>
</tr>
<tr>
<td>1420</td>
<td>窗口不是合法的对话窗口。</td>
</tr>
<tr>
<td>1421</td>
<td>找不到控件 ID。</td>
</tr>
<tr>
<td>1422</td>
<td>因为没有编辑控制，所以组合框的消息无效。</td>
</tr>
<tr>
<td>1423</td>
<td>窗口不是组合框。</td>
</tr>
<tr>
<td>1424</td>
<td>高度必须小于 256。</td>
</tr>
<tr>
<td>1425</td>
<td>无效的设备上下文(DC)句柄。</td>
</tr>
<tr>
<td>1426</td>
<td>无效的挂接程序类型。</td>
</tr>
<tr>
<td>1427</td>
<td>无效的挂接程序。</td>
</tr>
<tr>
<td>1428</td>
<td>没有模块句柄无法设置非本机的挂接。</td>
</tr>
<tr>
<td>1429</td>
<td>此挂接程序只可整体设置。</td>
</tr>
<tr>
<td>1430</td>
<td>Journal Hook 程序已安装。</td>
</tr>
<tr>
<td>1431</td>
<td>挂接程序尚未安装。</td>
</tr>
<tr>
<td>1432</td>
<td>单一选择列表框的无效消息。</td>
</tr>
<tr>
<td>1433</td>
<td>LB_SETCOUNT 发送到非被动的列表框。</td>
</tr>
<tr>
<td>1434</td>
<td>此列表框不支持 Tab 键宽度。</td>
</tr>
<tr>
<td>1435</td>
<td>无法毁坏由另一个线程创建的对象。</td>
</tr>
<tr>
<td>1436</td>
<td>子窗口没有菜单。</td>
</tr>
<tr>
<td>1437</td>
<td>窗口没有系统菜单。</td>
</tr>
<tr>
<td>1438</td>
<td>无效的消息对话框样式。</td>
</tr>
<tr>
<td>1439</td>
<td>无效的系统范围内的 (SPI_*) 参数。</td>
</tr>
<tr>
<td>1440</td>
<td>已锁定屏幕。</td>
</tr>
<tr>
<td>1441</td>
<td>多重窗口位置结构中窗口的所有句柄必须具有相同的上层。</td>
</tr>
<tr>
<td>1442</td>
<td>窗口不是子窗口。</td>
</tr>
<tr>
<td>1443</td>
<td>无效的 GW_* 命令。</td>
</tr>
<tr>
<td>1444</td>
<td>无效的线程标识。</td>
</tr>
<tr>
<td>1445</td>
<td>无法处理非多重文档界面 (MDI) 窗口中的消息。</td>
</tr>
<tr>
<td>1446</td>
<td>弹出式菜单已经激活。</td>
</tr>
<tr>
<td>1447</td>
<td>窗口没有滚动条。</td>
</tr>
<tr>
<td>1448</td>
<td>滚动条范围不可大于 MAXLONG。</td>
</tr>
<tr>
<td>1449</td>
<td>无法以指定的方式显示或删除窗口。</td>
</tr>
<tr>
<td>1450</td>
<td>系统资源不足，无法完成请求的服务。</td>
</tr>
<tr>
<td>1451</td>
<td>系统资源不足，无法完成请求的服务。</td>
</tr>
<tr>
<td>1452</td>
<td>系统资源不足，无法完成请求的服务。</td>
</tr>
<tr>
<td>1453</td>
<td>配额不足，无法完成请求的服务。</td>
</tr>
<tr>
<td>1454</td>
<td>配额不足，无法完成请求的服务。</td>
</tr>
<tr>
<td>1455</td>
<td>页面文件太小，无法完成操作。</td>
</tr>
<tr>
<td>1456</td>
<td>找不到菜单项。</td>
</tr>
<tr>
<td>1457</td>
<td>键盘布局句柄无效。</td>
</tr>
<tr>
<td>1458</td>
<td>不允许使用挂钩类型。</td>
</tr>
<tr>
<td>1459</td>
<td>该操作需要交互式窗口工作站。</td>
</tr>
<tr>
<td>1460</td>
<td>由于超时时间已过，该操作返回。</td>
</tr>
<tr>
<td>1461</td>
<td>无效监视器句柄。</td>
</tr>
<tr>
<td>1500</td>
<td>事件日志文件损坏。</td>
</tr>
<tr>
<td>1501</td>
<td>无法打开事件日志文件，事件日志服务没有启动。</td>
</tr>
<tr>
<td>1502</td>
<td>事件日志文件已满。</td>
</tr>
<tr>
<td>1503</td>
<td>事件日志文件已在读取间更改。</td>
</tr>
<tr>
<td>1601</td>
<td>无法访问 Windows 安装服务。请与技术支持人员联系，确认 Windows 安装服务是否注册正确。</td>
</tr>
<tr>
<td>1602</td>
<td>用户取消了安装。</td>
</tr>
<tr>
<td>1603</td>
<td>安装时发生严重错误</td>
</tr>
<tr>
<td>1604</td>
<td>安装已挂起，未完成。</td>
</tr>
<tr>
<td>1605</td>
<td>这个操作只对当前安装的产品有效。</td>
</tr>
<tr>
<td>1606</td>
<td>功能 ID 未注册。</td>
</tr>
<tr>
<td>1607</td>
<td>组件 ID 并未注册。</td>
</tr>
<tr>
<td>1608</td>
<td>未知属性。</td>
</tr>
<tr>
<td>1609</td>
<td>句柄处于不正确的状态。</td>
</tr>
<tr>
<td>1610</td>
<td>这个产品的配置数据已损坏。请与技术支持人员联系。</td>
</tr>
<tr>
<td>1611</td>
<td>组件限制语不存在。</td>
</tr>
<tr>
<td>1612</td>
<td>这个产品的安装来源无法使用。请验证来源是否存在，是否可以访问。</td>
</tr>
<tr>
<td>1613</td>
<td>Windows 安装服务无法安装这个安装程序包。您必须安装含有 Windows 安装服务新版本的 Windows Service Park。</td>
</tr>
<tr>
<td>1614</td>
<td>没有卸载产品。</td>
</tr>
<tr>
<td>1615</td>
<td>SQL 查询语法不正确或不被支持。</td>
</tr>
<tr>
<td>1616</td>
<td>记录字符域不存在。</td>
</tr>
<tr>
<td>1617</td>
<td>设备已被删除.</td>
</tr>
<tr>
<td>1618</td>
<td>正在进行另一个安装操作。请在继续这个安装操作之前完成那个操作。</td>
</tr>
<tr>
<td>1619</td>
<td>未能打开这个安装程序包。请验证程序包是否存在，是否可以访问；或者与应用程序供应商联系，验证这是否是有效的 Windows 安装服务程序包。</td>
</tr>
<tr>
<td>1620</td>
<td>未能打开这个安装程序包。请与应用程序供应商联系，验证这是否是有效的 Windows 安装服务程序包。</td>
</tr>
<tr>
<td>1621</td>
<td>启动 Windows 安装服务用户界面时有错误。请与技术支持人员联系。</td>
</tr>
<tr>
<td>1622</td>
<td>打开安装日志文件的错误。请验证指定的日志文件位置是否存在，是否可以写入。</td>
</tr>
<tr>
<td>1623</td>
<td>安装程序包的语言不受系统支持。</td>
</tr>
<tr>
<td>1624</td>
<td>应用变换时的错误。请验证指定的变换路径是否有效。</td>
</tr>
<tr>
<td>1625</td>
<td>系统策略禁止这个安装。请与系统管理员联系。</td>
</tr>
<tr>
<td>1626</td>
<td>无法执行函数。</td>
</tr>
<tr>
<td>1627</td>
<td>执行期间，函数出了问题。</td>
</tr>
<tr>
<td>1628</td>
<td>指定了无效的或未知的表格。</td>
</tr>
<tr>
<td>1629</td>
<td>提供的数据类型不对。</td>
</tr>
<tr>
<td>1630</td>
<td>这个类型的数据不受支持。</td>
</tr>
<tr>
<td>1631</td>
<td>Windows 安装服务未能启动。请与技术支持人员联系。</td>
</tr>
<tr>
<td>1632</td>
<td>临时文件夹已满或无法使用。请验证临时文件夹是否存在，是否可以写入。</td>
</tr>
<tr>
<td>1633</td>
<td>这个处理器类型不支持该安装程序包。请与产品供应商联系。</td>
</tr>
<tr>
<td>1634</td>
<td>组件没有在这台计算机上使用。</td>
</tr>
<tr>
<td>1635</td>
<td>无法打开修补程序包。请验证修补程序包是否存在，是否可以访问；或者与应用程序供应商联系，验证这是否是 Windows 安装服务的修补程序包。</td>
</tr>
<tr>
<td>1636</td>
<td>无法打开修补程序包。请与应用程序供应商联系，验证这是否是 Windows 安装服务的修补程序包。</td>
</tr>
<tr>
<td>1637</td>
<td>Windows 安装服务无法处理这个插入程序包。您必须安装含有 Windows 安装服务新版本的 Windows Service Pack。</td>
</tr>
<tr>
<td>1638</td>
<td>已安装这个产品的另一个版本。这个版本的安装无法继续。要配置或删除这个产品的现有版本，请用“控制面板”上的“添加&#x2F;删除程序”。</td>
</tr>
<tr>
<td>1639</td>
<td>无效的命令行参数。有关详细的命令行帮助，请查阅 Windows 安装服务的 SDK。</td>
</tr>
<tr>
<td>1640</td>
<td>在终端服务远程会话期间，只有管理员有添加、删除或配置服务器软件的权限。如果您要在服务器上安装或配置软件，请与网络管理员联系。</td>
</tr>
<tr>
<td>1641</td>
<td>要求的操作已成功结束。要使改动生效，必须重新启动系统。</td>
</tr>
<tr>
<td>1642</td>
<td>Windows 安装服务无法安装升级修补程序，因为被升级的程序可能会丢失或是升级修补程序可能更新此程序的一个不同版本。请确认要被升级的程序在您的计算机上且您的升级修补程序是正确的。</td>
</tr>
<tr>
<td>1700</td>
<td>串绑定无效。</td>
</tr>
<tr>
<td>1701</td>
<td>绑定句柄类型不正确。</td>
</tr>
<tr>
<td>1702</td>
<td>绑定句柄无效。</td>
</tr>
<tr>
<td>1703</td>
<td>不支持 RPC 协议序列。</td>
</tr>
<tr>
<td>1704</td>
<td>RPC 协议序列无效。</td>
</tr>
<tr>
<td>1705</td>
<td>字符串通用唯一标识 (UUID) 无效。</td>
</tr>
<tr>
<td>1706</td>
<td>终结点格式无效。</td>
</tr>
<tr>
<td>1707</td>
<td>网络地址无效。</td>
</tr>
<tr>
<td>1708</td>
<td>找不到终结点。</td>
</tr>
<tr>
<td>1709</td>
<td>超时值无效。</td>
</tr>
<tr>
<td>1710</td>
<td>找不到对象通用唯一标识(UUID)。</td>
</tr>
<tr>
<td>1711</td>
<td>对象通用唯一标识 (UUID)已注册。</td>
</tr>
<tr>
<td>1712</td>
<td>类型通用唯一标识(UUID)已注册。</td>
</tr>
<tr>
<td>1713</td>
<td>RPC 服务器已在侦听。</td>
</tr>
<tr>
<td>1714</td>
<td>未登记任何协议序列。</td>
</tr>
<tr>
<td>1715</td>
<td>RPC 服务器未在侦听。</td>
</tr>
<tr>
<td>1716</td>
<td>未知的管理器类型。</td>
</tr>
<tr>
<td>1717</td>
<td>未知的界面。</td>
</tr>
<tr>
<td>1718</td>
<td>没有任何链接。</td>
</tr>
<tr>
<td>1719</td>
<td>无任何协议顺序。</td>
</tr>
<tr>
<td>1720</td>
<td>无法创建终结点。</td>
</tr>
<tr>
<td>1721</td>
<td>资源不足，无法完成此操作。</td>
</tr>
<tr>
<td>1722</td>
<td>RPC 服务器不可用。</td>
</tr>
<tr>
<td>1723</td>
<td>RPC 服务器过忙以致无法完成此操作。</td>
</tr>
<tr>
<td>1724</td>
<td>网络选项无效。</td>
</tr>
<tr>
<td>1725</td>
<td>在此线程中，没有使用中的远程过程调用。</td>
</tr>
<tr>
<td>1726</td>
<td>远程过程调用失败。</td>
</tr>
<tr>
<td>1727</td>
<td>远程过程调用失败且未运行。</td>
</tr>
<tr>
<td>1728</td>
<td>远程过程调用(RPC)协议出错。</td>
</tr>
<tr>
<td>1730</td>
<td>RPC 服务器不支持传送语法。</td>
</tr>
<tr>
<td>1732</td>
<td>不支持通用唯一标识(UUID)类型。</td>
</tr>
<tr>
<td>1733</td>
<td>标记无效。</td>
</tr>
<tr>
<td>1734</td>
<td>数组边界无效。</td>
</tr>
<tr>
<td>1735</td>
<td>链接不包含项目名称。</td>
</tr>
<tr>
<td>1736</td>
<td>名称语法无效。</td>
</tr>
<tr>
<td>1737</td>
<td>不支持名称语法。</td>
</tr>
<tr>
<td>1739</td>
<td>没有可用来创建通用唯一标识 (UUID)的网络地址。</td>
</tr>
<tr>
<td>1740</td>
<td>终结点是一份备份。</td>
</tr>
<tr>
<td>1741</td>
<td>未知的验证类型。</td>
</tr>
<tr>
<td>1742</td>
<td>调用的最大个数太小。</td>
</tr>
<tr>
<td>1743</td>
<td>字符串太长。</td>
</tr>
<tr>
<td>1744</td>
<td>找不到 RPC 协议顺序。</td>
</tr>
<tr>
<td>1745</td>
<td>过程号超出范围。</td>
</tr>
<tr>
<td>1746</td>
<td>绑定不包含任何验证信息。</td>
</tr>
<tr>
<td>1747</td>
<td>未知的验证服务。</td>
</tr>
<tr>
<td>1748</td>
<td>未知的验证级别。</td>
</tr>
<tr>
<td>1749</td>
<td>安全上下文无效。</td>
</tr>
<tr>
<td>1750</td>
<td>未知的授权服务。</td>
</tr>
<tr>
<td>1751</td>
<td>项目无效。</td>
</tr>
<tr>
<td>1752</td>
<td>服务器终结点无法运行操作。</td>
</tr>
<tr>
<td>1753</td>
<td>终结点映射表中无更多的可用终结点。</td>
</tr>
<tr>
<td>1754</td>
<td>未导出任何界面。</td>
</tr>
<tr>
<td>1755</td>
<td>项目名称不完整。</td>
</tr>
<tr>
<td>1756</td>
<td>版本选项无效。</td>
</tr>
<tr>
<td>1757</td>
<td>没有其他成员。</td>
</tr>
<tr>
<td>1758</td>
<td>没有内容未导出。</td>
</tr>
<tr>
<td>1759</td>
<td>接口没有找到。</td>
</tr>
<tr>
<td>1760</td>
<td>项目已存在。</td>
</tr>
<tr>
<td>1761</td>
<td>找不到项目。</td>
</tr>
<tr>
<td>1762</td>
<td>无可用的名称服务。</td>
</tr>
<tr>
<td>1763</td>
<td>网络地址族无效。</td>
</tr>
<tr>
<td>1764</td>
<td>不支持请求的操作。</td>
</tr>
<tr>
<td>1765</td>
<td>无可用的安全上下文以允许模拟。</td>
</tr>
<tr>
<td>1766</td>
<td>远程过程调用(RPC)中发生内部错误。</td>
</tr>
<tr>
<td>1767</td>
<td>RPC 服务器试图以零除整数。</td>
</tr>
<tr>
<td>1768</td>
<td>RPC 服务器中发生地址错误。</td>
</tr>
<tr>
<td>1769</td>
<td>RPC 服务器上的浮点操作导至以零做除数。</td>
</tr>
<tr>
<td>1770</td>
<td>RPC 服务器上发生浮点下溢。</td>
</tr>
<tr>
<td>1771</td>
<td>RPC 服务器上发生浮点上溢。</td>
</tr>
<tr>
<td>1772</td>
<td>自动句柄绑定的可用 RPC 服务器列表已用完。</td>
</tr>
<tr>
<td>1773</td>
<td>无法打开字符翻译表文件。</td>
</tr>
<tr>
<td>1774</td>
<td>包含字符翻译表的文件少于512 字节。</td>
</tr>
<tr>
<td>1775</td>
<td>在远程过程调用时，将空的上下文句柄从客户传递到主机。</td>
</tr>
<tr>
<td>1777</td>
<td>在远程过程调用时，上下文句柄已更改。</td>
</tr>
<tr>
<td>1778</td>
<td>传递到远程过程调用的绑定句柄不相符。</td>
</tr>
<tr>
<td>1779</td>
<td>承接体无法获得远程过程调用句柄。</td>
</tr>
<tr>
<td>1780</td>
<td>传递空引用指针到承接体。</td>
</tr>
<tr>
<td>1781</td>
<td>列举值超出范围。</td>
</tr>
<tr>
<td>1782</td>
<td>字节计数太小。</td>
</tr>
<tr>
<td>1783</td>
<td>承接体接收到坏数据。</td>
</tr>
<tr>
<td>1784</td>
<td>提供给请求操作的用户缓冲区无效。</td>
</tr>
<tr>
<td>1785</td>
<td>磁盘媒体无法识别。可能未被格式化。</td>
</tr>
<tr>
<td>1786</td>
<td>工作站没有信任机密。</td>
</tr>
<tr>
<td>1787</td>
<td>服务器上的安全数据库没有此工作站信任关系的计算机帐户。</td>
</tr>
<tr>
<td>1788</td>
<td>主域和受信域间的信任关系失败。</td>
</tr>
<tr>
<td>1789</td>
<td>此工作站和主域间的信任关系失败。</td>
</tr>
<tr>
<td>1790</td>
<td>网络登录失败。</td>
</tr>
<tr>
<td>1791</td>
<td>此线程的远程过程调用已在进行中。</td>
</tr>
<tr>
<td>1792</td>
<td>试图登录，但是网络登录服务没有启动。</td>
</tr>
<tr>
<td>1793</td>
<td>用户帐户到期。</td>
</tr>
<tr>
<td>1794</td>
<td>转发程序已被占用且无法卸载。</td>
</tr>
<tr>
<td>1795</td>
<td>指定的打印机驱动程序已安装。</td>
</tr>
<tr>
<td>1796</td>
<td>指定的端口未知。</td>
</tr>
<tr>
<td>1797</td>
<td>未知的打印机驱动程序。</td>
</tr>
<tr>
<td>1798</td>
<td>未知的打印机处理器。</td>
</tr>
<tr>
<td>1799</td>
<td>指定的分隔页文件无效。</td>
</tr>
<tr>
<td>1800</td>
<td>指定的优先级无效。</td>
</tr>
<tr>
<td>1801</td>
<td>打印机名无效。</td>
</tr>
<tr>
<td>1802</td>
<td>打印机已存在。</td>
</tr>
<tr>
<td>1803</td>
<td>打印机命令无效。</td>
</tr>
<tr>
<td>1804</td>
<td>指定的数据类型无效。</td>
</tr>
<tr>
<td>1805</td>
<td>指定的环境无效。</td>
</tr>
<tr>
<td>1806</td>
<td>没有更多的绑定。</td>
</tr>
<tr>
<td>1807</td>
<td>所用帐户为域间信任帐户。请使用您的全局用户帐户或本地用户帐户来访问这台服务器。</td>
</tr>
<tr>
<td>1808</td>
<td>所用帐户是一个计算机帐户。使用您的全局用户帐户或本地用户帐户来访问此服务器。</td>
</tr>
<tr>
<td>1809</td>
<td>已使用的帐户为服务器信任帐户。使用您的全局用户帐户或本地用户帐户来访问此服务器。</td>
</tr>
<tr>
<td>1810</td>
<td>指定域的名称或安全标识(SID)与该域的信任信息不一致。</td>
</tr>
<tr>
<td>1811</td>
<td>服务器在使用中且无法卸载。</td>
</tr>
<tr>
<td>1812</td>
<td>指定的映像文件不包含资源区域。</td>
</tr>
<tr>
<td>1813</td>
<td>找不到映像文件中指定的资源类型。</td>
</tr>
<tr>
<td>1814</td>
<td>找不到映像文件中指定的资源名。</td>
</tr>
<tr>
<td>1815</td>
<td>找不到映像文件中指定的资源语言标识。</td>
</tr>
<tr>
<td>1816</td>
<td>配额不足，无法处理此命令。</td>
</tr>
<tr>
<td>1817</td>
<td>未登记任何界面。</td>
</tr>
<tr>
<td>1818</td>
<td>远程过程调用被取消。</td>
</tr>
<tr>
<td>1819</td>
<td>绑定句柄不包含所有需要的信息。</td>
</tr>
<tr>
<td>1820</td>
<td>在远程过程调用过程中通讯失败。</td>
</tr>
<tr>
<td>1821</td>
<td>不支持请求的验证级别。</td>
</tr>
<tr>
<td>1822</td>
<td>未登记任何主名称。</td>
</tr>
<tr>
<td>1823</td>
<td>指定的错误不是有效的 Windows RPC 错误码。</td>
</tr>
<tr>
<td>1824</td>
<td>已配置一个只在这部计算机上有效的 UUID。</td>
</tr>
<tr>
<td>1825</td>
<td>发生一个安全包特有的错误。</td>
</tr>
<tr>
<td>1826</td>
<td>线程未取消。</td>
</tr>
<tr>
<td>1827</td>
<td>无效的编码&#x2F;解码句柄操作。</td>
</tr>
<tr>
<td>1828</td>
<td>序列化包装的版本不兼容。</td>
</tr>
<tr>
<td>1829</td>
<td>RPC 承接体的版本不兼容。</td>
</tr>
<tr>
<td>1830</td>
<td>RPC 管道对象无效或已损坏。</td>
</tr>
<tr>
<td>1831</td>
<td>试图在 RPC 管道物件上进行无效操作。</td>
</tr>
<tr>
<td>1832</td>
<td>不被支持的 RPC 管道版本。</td>
</tr>
<tr>
<td>1898</td>
<td>找不到该组成员。</td>
</tr>
<tr>
<td>1899</td>
<td>无法创建终结点映射表数据库项。</td>
</tr>
<tr>
<td>1900</td>
<td>对象通用唯一标识 (UUID) 为 nil UUID。</td>
</tr>
<tr>
<td>1901</td>
<td>指定的时间无效。</td>
</tr>
<tr>
<td>1902</td>
<td>指定的格式名称无效。</td>
</tr>
<tr>
<td>1903</td>
<td>指定的格式大小无效。</td>
</tr>
<tr>
<td>1904</td>
<td>指定的打印机句柄正等候在</td>
</tr>
<tr>
<td>1905</td>
<td>已删除指定的打印机。</td>
</tr>
<tr>
<td>1906</td>
<td>打印机的状态无效。</td>
</tr>
<tr>
<td>1907</td>
<td>在第一次登录之前，必须更改用户密码。</td>
</tr>
<tr>
<td>1908</td>
<td>找不到此域的域控制器。</td>
</tr>
<tr>
<td>1909</td>
<td>引用的帐户当前已锁定，且可能无法登录。</td>
</tr>
<tr>
<td>1910</td>
<td>没有发现指定的此对象导出者</td>
</tr>
<tr>
<td>1911</td>
<td>没有发现指定的对象。</td>
</tr>
<tr>
<td>1912</td>
<td>没有发现指定的对象解析器。</td>
</tr>
<tr>
<td>1913</td>
<td>一些待发数据仍停留在请求缓冲区内。</td>
</tr>
<tr>
<td>1914</td>
<td>无效的异步远程过程调用句柄。</td>
</tr>
<tr>
<td>1915</td>
<td>这个操作的异步 RPC 调用句柄不正确。</td>
</tr>
<tr>
<td>1916</td>
<td>RPC 管道对象已经关闭。</td>
</tr>
<tr>
<td>1917</td>
<td>在 RPC 调用完成之前全部的管道都已处理完成。</td>
</tr>
<tr>
<td>1918</td>
<td>没有其他可用的数据来自 RPC 管道。</td>
</tr>
<tr>
<td>1919</td>
<td>这个机器没有可用的站点名。</td>
</tr>
<tr>
<td>1920</td>
<td>系统无法访问此文件。</td>
</tr>
<tr>
<td>1921</td>
<td>系统无法辨识文件名。</td>
</tr>
<tr>
<td>1922</td>
<td>项目不是所要的类型。</td>
</tr>
<tr>
<td>1923</td>
<td>无法将所有对象的 UUID 导出到指定的项。</td>
</tr>
<tr>
<td>1924</td>
<td>无法将界面导出到指定的项。</td>
</tr>
<tr>
<td>1925</td>
<td>无法添加指定的配置文件项。</td>
</tr>
<tr>
<td>1926</td>
<td>无法添加指定的配置文件元素。</td>
</tr>
<tr>
<td>1927</td>
<td>无法删除指定的配置文件元素。</td>
</tr>
<tr>
<td>1928</td>
<td>无法添加组元素。</td>
</tr>
<tr>
<td>1929</td>
<td>无法删除组元素。</td>
</tr>
<tr>
<td>2000</td>
<td>无效的像素格式。</td>
</tr>
</tbody></table>
<p>更多错误编码请参看 <a href="/blog/sql-server-state-code-list-2">《中篇》</a>、<a href="/blog/sql-server-state-code-list-3">《下篇》</a>。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统 32位和64位</title>
    <url>/2013-01-19-os-32-64-bit/</url>
    <content><![CDATA[<p>两者之间存在的“五大不同”。与此同时，着重说明Microsoft Windows64位（x64）操作系统，相对于32位（x86）操作系统的最大优势和劣势是什么？</p>
<span id="more"></span>

<p>第一，设计初衷不同</p>
<p>64位操作系统的设计初衷是：满足机械设计和分析、三维动画、视频编辑和创作，以及科学计算和高性能计算应用程序等领域中需要大量内存和浮点性能的客户需求。换句简明的话说就是：它们是高科技人员使用本行业特殊软件的运行平台。而32位操作系统是为普通用户设计的。</p>
<p>第二，要求配置不同</p>
<p>64位操作系统只能安装在64位电脑上(CPU必须是64位的)。同时需要安装64位常用软件以发挥64位（x64）的最佳性能。32位操作系统则可以安装在32位(32位CPU)或64位(64位CPU)电脑上。当然，32位操作系统安装在64位电脑上，其硬件恰似“大马拉小车”：64位效能就会大打折扣。</p>
<p>第三，运算速度不同</p>
<p>64位CPU GPRs(General-Purpose Registers，通用寄存器)的数据宽度为64位，64位指令集可以运行64位数据指令，也就是说处理器一次可提取64位数据(只要两个指令，一次提取8个字节的数据)，比32位(需要四个指令,一次提取4个字节的数据)提高了一倍，理论上性能会相应提升1倍。</p>
<p>第四，寻址能力不同</p>
<p>64位处理器的优势还体现在系统对内存的控制上。由于地址使用的是特殊的整数，因此一个ALU（算术逻辑运算器）和寄存器可以处理更大的整数，也就是更大的地址。比如，Windows Vista x64 Edition支持多达128 GB的内存和多达16 TB的虚拟内存，而32位CPU和操作系统最大只可支持4G内存。</p>
<p>第五，软件普及不同</p>
<p>目前，64位常用软件比32位常用软件，要少得多的多。道理很简单：使用64位操作系统的用户相对较少。因此，软件开发商必须考虑“投入产出比”，将有限资金投入到更多使用群体的软件之中。这也是为什么64位软件价格相对昂贵的重要原因(将成本摊入较少的发售之中)。</p>
<p>总而言之，Microsoft Windows 64位操作系统，必须“上”靠64位主机硬件的支撑，“下”靠64位常用软件的协助，才能将64位的优势发挥到极致，“三位一体”缺一不可(道理很简单：操作系统只是承上启下的运行平台)。至于64位电脑可以安装32位操作系统，64位操作系统可以安装32位软件，那是设计上的“向下兼容”，不是64位设计初衷的本来含义(如上所述)。</p>
<p>附言</p>
<p>1、64位电脑虽然可以安装32位操作系统，但是32位电脑绝对不能安装64位操作系统。这点至关重要务必牢记，以避免盲目下载和安装。 </p>
<p>2、在64位电脑运行的32位操作系统上，不能采取硬盘安装方式安装64位操作系统。如若安装，首选光盘格式化安装方式，也可采用比较繁琐的DOS安装方式。 </p>
<p>3、使用虚拟机安装操作系统，实际上就是在目前运行的操作系统上安装软件。因此，在32位操作系统上不能虚拟安装64位操作系统。即便采取“曲线”方式勉强安装，其实已经脱离了底层设备的支持，是毫无疑义的。</p>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Factory模式与Prototype模式的异同</title>
    <url>/2013-01-23-factory-prototype-diff/</url>
    <content><![CDATA[<p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p>
<p>原型模式与工厂模式的定义，本文不想在这讲太多，本文主要想在这讲一下对原型模式的一些误解－－将原型模式等价于工厂模式。</p>
<span id="more"></span>

<p><strong>为什么会产生这种误导呢？</strong>其实也不是我们的错，关键在于设计模式这本书以及网上的其它资料很喜欢将原型和工厂方法进行比较，从而导致我们误解了原型引入的本质意义。</p>
<p>按博主的理解，原型引入的根本原因就是在于它可以利用一个原型对象（指的是实例，而非类），快速地生成一批和原型对象一样的实例。举个例子来说，你有一个类A的实例a (A a&#x3D;new A()),现在你想生成一个和a一样的实例b,那么，按照原型的定义，你应该可以这样做b&#x3D;a.clone()。这样，你就可以得到一个和a一模一样的实例b(即a和部b的数据成员的值完全一样）。</p>
<p>上面是原型的一个简单说明，那么引入原型有什么好处呢？按博主的理解，就是在于：你如果要生成一大批很相像的类的实例时，省得每次去做重复的赋值工作。再举个例子，如果你有一个类A,它有十个成员变量，现在你打算生成100个A的实例，而这些实例的变量值大部分相同（比如说七个相同），只有一小部分不一样（比如说三个），那么如果没有Prototype,那么你就得每次New一个A的对像，然后赋值，这样，你要重复100次同样的七个变量的赋值工作，显然，这样很麻烦。现在你有了原型，那么问题就简单了，你只要生成一个A的实例，再通过clone来生成其它的实例，然后再一一修改其它实例不同的地方。</p>
<p>可能这么讲，大家不信，那下面，再让我们来看看Java中活生生的原型应用。</p>
<p>学过Java的人都知道，在Java中,有一个clone()函数，这个函数的功能，就是返回一个和当前调用它的对象一样的实例。那么Java中为什么要引入这个函数呢？</p>
<p>在【Think in Java】一书中，作者如是解释：<br>“如果，你要将一个对象的引用作为参数传进去，但又不希望函数改变对象的值，那么，你该怎么办？由于在Java中对象没有像C++那样的Const修饰符，所以，为了实现这个功能，Java中引入了clone函数，使得你将对象的引用作为参数传进函数时，这个函数可以调用该对象的Clone方法生成该对象的一份拷贝，从而达到不修改原对象的目的。”</p>
<p>之所以用上面这么多篇幅来讲述原型本质，目的就在于希望各位不要把原型的功能与它的意义给混了，以致于当真正要使用原型来解决问题时，却不知可以使用它。</p>
<p>好了，上面说了原型的本质意义。那为什么很多资料喜欢将原型同工厂模式进行比较呢？不知是不是巧合，虽然原型引入的初衷是像上面所说，但它实现起来，却又完全可以达到工厂模式的效果。而且，用起来甚至比工厂模式更方便、灵活。对于工厂模式与原型模式在功能上的这点巧合，也许是因为本来工厂模式和原型模式都是创建型模式，这样，它们的基本功能都能生成对象，因而使得原型模式在功能上可以代替工厂模式。</p>
<p>对这两种模式在功能上的相同点，程序员2001年第11期杂志上有一篇”非鱼“写的文章，作者理解得非常巧妙，即：如果你将工厂模式的UML图对折，你得到的就是Prototype原型的UML图。有兴趣比较这两种模式的朋友，可以去参考这篇文章。</p>
<p>接下来，让我们在实现机制上来看看原型模式为什么可以实现工厂模式的功能(本文只限于Java语言）。在Java中，对于原型的实现，其实根本不用我们做，在object类中早就定义了一个clone函数，而这个函数，就使得我们可以动态地生成对象的当前拷贝。既然这样，那么让我们来看看，如果要实现工厂模式的功能，我们该如何使用原型模式为做到呢？</p>
<p>工厂模式实现生产产品的功能，关键是利用了继承的特性。也就是说，你生成的产品，一定是由同一个抽象产品类派生出来的。所以，在工厂模式下，你如果要生成一类产品，就要引入一个抽像产品类，然后再由它派生出具体产品。同样，在原型模式中，你完全可以同样定义一个这样的“抽象产品－－具体产品”层次，再利用具体产品本身的clone功能来产生具体产品本身。从而达到实现工厂模式功能的目的。可能说到这，大家有点糊涂了。实际上，在原型模式中，每个具体产品就扮演了工厂模式里的具体工厂的角色（为什么会这样，其实很简单，因为，每个具体产品都具有生成自己拷贝的功能？从这种意义上讲，难道这不正是工厂的作用吗？）。</p>
<p>另外，要在Java中利用原型模式实现工厂模式的功能，则更为简单，因为object已经为我们实现了clone函数，且对于clone方法，Java中默认是：如果A是父类且A实现了clone函数，B是A的子类，则B不用实现clone函数，它只要调用父类的clone函数，Java就会在运行时动态地为我们生成正确的B的对象。理解这点的关键在于，所有类实现的clone操作都是调用object的clone方法。这也就是说，上面所说的父类A根本就不用自己实现clone方法，而仅仅是调用父类（object)的clone方法而已。</p>
<p>好，到了这，读者也许又有疑问了，既然所有的clone操作都是由object实现的，而在Java中所有的自定义类默认都是由object派生而来，那这样的话，应该所有的类都自动就具有了clone自己的能力？<br>确实，如果object不将它的clone函数声明为protect的话，情况的确如此。但Java为了安全方面的原因，所以没有将clone方法公开，而是声明为保护类型，这样的话，子类是不可以直接调用object类的clone方法的，而必须做到如下两点：</p>
<ul>
<li>1.必须实现Cloneable接口；</li>
<li>2.必须声明一个clone方法，来调用object的clone函数；</li>
</ul>
<p>Java在调用父类的clone函数时，都会在运行时动态地进行检查，如果发现调用的类不符合上面的任何一点，则会抛出一个异常。<br>明白了上面的原因，那么如果我们希望某个类具备clone自身的能力，那么，我们可以这样做：</p>
<ul>
<li>1.直接按上面所说，自己实现clone操作；</li>
<li>2.声明一个抽象父类，实现上面的clone操作并将它声明为公开方法，再由此类派生出子类，这样，所有的子类只要调用父类的clone方法，就能够正确地拷贝自己。</li>
</ul>
<p>通常，我们都是使用第一种方式，但在我们现在讨论的如何用原型模式实现工厂模式的功能的问题中，我们最好是采用第二种方式。</p>
<p>最后，让我们通过具体的代码来看看如何用Prototype模式实现工厂模式的功能。</p>
<p>问题：</p>
<p>现有两类产品 1－Ram,2–Cpu,现在要生成具体的产品<br>MacRam,MacCpu和WinRam,WinCpu.</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*A:Abstract</span></span><br><span class="line"><span class="comment">*C:Concrete </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义抽象产品Ram的类 APrototypeRam </span></span><br><span class="line"><span class="comment">* 同时它也是抽象工厂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">APrototypeRam</span> <span class="title">implements</span> <span class="title">Cloneable</span> &#123;</span></span><br><span class="line">	public Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">		Object o=null;</span><br><span class="line">		try &#123;</span><br><span class="line">			o=super.clone();<span class="comment">//调用父类，即Object的clone()</span></span><br><span class="line">		&#125;</span><br><span class="line">		catch(CloneNotSupportedException e) &#123;</span><br><span class="line">			System.err.println(<span class="string">&quot;APrototypeRam is not cloneable!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> o;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义抽象产品Ram的类APrototypeProductCpu</span></span><br><span class="line"><span class="comment">* 同时它也是抽象工厂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">APrototypeCpu</span> <span class="title">implements</span> <span class="title">Cloneable</span> &#123;</span></span><br><span class="line">	public Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">		Object o=null;</span><br><span class="line">		try &#123;</span><br><span class="line">			o=super.clone();<span class="comment">//调用父类，即Object的clone()</span></span><br><span class="line">		&#125;</span><br><span class="line">		catch(CloneNotSupportedException e) &#123;</span><br><span class="line">			System.err.println(<span class="string">&quot;APrototypeCpu is not cloneable!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> o;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义具体产品MacRam的类CPrototypeMacRam</span></span><br><span class="line"><span class="comment">* 同时它也是具体工厂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPrototypeMacRam</span> <span class="title">extends</span> <span class="title">APrototypeRam</span>&#123;</span></span><br><span class="line">	public String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;MacRam&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义具体产品WinRam的类CPrototypeWinRam</span></span><br><span class="line"><span class="comment">* 同时它也是具体工厂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPrototypeWinRam</span> <span class="title">extends</span> <span class="title">APrototypeRam</span> &#123;</span></span><br><span class="line">	public String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;WinRam&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义具体产品MacCpu的类CPrototypeMacCpu</span></span><br><span class="line"><span class="comment">* 同时它也是具体工厂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPrototypeMacCpu</span> <span class="title">extends</span> <span class="title">APrototypeCpu</span>&#123;</span></span><br><span class="line">	public String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;MacCpu&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义具体产品WinCpu的类CPrototypeWinCpu</span></span><br><span class="line"><span class="comment">* 同时它也是具体工厂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPrototypeWinCpu</span> <span class="title">extends</span> <span class="title">APrototypeCpu</span>&#123;</span></span><br><span class="line">	public String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;WinCpu&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 客户端，使用CPrototypeRam和CPrototypeCpu生成如下产品</span></span><br><span class="line"><span class="comment">* MacRam,MacCpu,WinRam,WinCpu</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> &#123;</span></span><br><span class="line">	public <span class="type">static</span> <span class="type">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 在生成产品之前，先生成原型产品，以便后面利用它们成批生产相同产品</span></span><br><span class="line"><span class="comment">	* 其作用等价于产品工厂</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	CPrototypeMacRam prototypeMacRam=new CPrototypeMacRam();</span><br><span class="line">	CPrototypeWinRam prototypeWinRam=new CPrototypeWinRam();</span><br><span class="line">	CPrototypeMacCpu prototypeMacCpu=new CPrototypeMacCpu();</span><br><span class="line">	CPrototypeWinCpu prototypeWinCpu=new CPrototypeWinCpu();</span><br><span class="line">	</span><br><span class="line">	CPrototypeMacRam MacRam=(CPrototypeMacRam)prototypeMacRam.clone();</span><br><span class="line">	CPrototypeWinRam WinRam=(CPrototypeWinRam)prototypeWinRam.clone();</span><br><span class="line">	CPrototypeMacCpu MacCpu=(CPrototypeMacCpu)prototypeMacCpu.clone();</span><br><span class="line">	CPrototypeWinCpu WinCpu=(CPrototypeWinCpu)prototypeWinCpu.clone();</span><br><span class="line">	System.out.println(<span class="string">&quot;打印原型产品与它的克隆产品与比较异同!&quot;</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;prototypeMacRam:&quot;</span>+prototypeMacRam+<span class="string">&quot; Cloned:&quot;</span>+MacRam);</span><br><span class="line">	System.out.println(<span class="string">&quot;prototypeWinRam:&quot;</span>+prototypeWinRam+<span class="string">&quot; Cloned:&quot;</span>+WinRam);</span><br><span class="line">	System.out.println(<span class="string">&quot;prototypeMacCpu:&quot;</span>+prototypeMacCpu+<span class="string">&quot; Cloned:&quot;</span>+MacCpu);</span><br><span class="line">	System.out.println(<span class="string">&quot;prototypeWinCpu:&quot;</span>+prototypeWinCpu+<span class="string">&quot; Cloned:&quot;</span>+WinCpu);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面代码，我们可以清楚地看到，用Prototype模式实现工厂模式更为简单，如果再配上原型管理器的话，那么Prototype模式则会变得更为灵活。但同时，我们也发现，使用原型模式时，有一个不足之处，即在客户端代码里，我们必须显式进行类型转换，这样可能导致错误。为了改正这一点，我们可以使用真正的工厂模式将Prototype模式再封装一遍。对工厂模式的这项功能，恐怕，Prototype原型模式就无能为力了。</p>
<p>总之，工厂模式和原型模式虽然在引入目的上不同，但在实现上，原型模式可以实现工厂模式同样的功能。但读者也不要因为这样，而将两者混为一体，因为，反过来，在将原型模式作为生成本身拷贝的这项功能使用时，工厂模式根本无法取代它。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>VC 调用 DLL</title>
    <url>/2013-01-24-vc-invoke-dll/</url>
    <content><![CDATA[<p>DLL 动态数据链路库。</p>
<p>调用DLL有两种方法：静态调用和动态调用.</p>
<span id="more"></span>

<p>(一).静态调用其步骤如下:</p>
<ul>
<li><p>1.把你的youApp.DLL拷到你目标工程(需调用youApp.DLL的工程)的Debug目录下;</p>
</li>
<li><p>2.把你的youApp.lib拷到你目标工程(需调用youApp.DLL的工程)目录下;</p>
</li>
<li><p>3.把你的youApp.h(包含输出函数的定义)拷到你目标工程(需调用youApp.DLL的工程)目录下;</p>
</li>
<li><p>4.打开你的目标工程选中工程,选择Visual C++的Project主菜单的Settings菜单;</p>
</li>
<li><p>5.执行第4步后，VC将会弹出一个对话框，在对话框的多页显示控件中选择Link页。然后在Object&#x2F;library modules输入框中输入:youApp.lib</p>
</li>
<li><p>6.选择你的目标工程Head Files加入：youApp.h文件;</p>
</li>
<li><p>7.最后在你目标工程(*.cpp,需要调用DLL中的函数)中包含你的:#include “youApp.h”</p>
</li>
</ul>
<p>注：youApp是你DLL的工程名。</p>
<p>(二).动态调用其程序如下:</p>
<p>动态调用时只需做静态调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	HINSTANCE hDllInst = LoadLibrary(<span class="string">&quot;youApp.DLL&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(hDllInst)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">typedef</span> <span class="title function_">DWORD</span> <span class="params">(WINAPI *MYFUNC)</span><span class="params">(DWORD,DWORD)</span>;</span><br><span class="line">		MYFUNC youFuntionNameAlias = <span class="literal">NULL</span>; <span class="comment">// youFuntionNameAlias 函数别名</span></span><br><span class="line">		youFuntionNameAlias = (MYFUNC)GetProcAddress(hDllInst,<span class="string">&quot;youFuntionName&quot;</span>);</span><br><span class="line">		<span class="comment">// youFuntionName 在DLL中声明的函数名</span></span><br><span class="line">		<span class="keyword">if</span>(youFuntionNameAlias)	</span><br><span class="line">		&#123;	</span><br><span class="line">			youFuntionNameAlias(param1,param2);</span><br><span class="line">		&#125;</span><br><span class="line">		FreeLibrary(hDllInst);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>显式（静态）调用：</li>
</ul>
<p>LIB + DLL + .H，注意.H中dllexport改为dllimport</p>
<ul>
<li>隐式（动态）调用：</li>
</ul>
<p>DLL + 函数原型声明，先LoadLibrary，再GetProcAddress（即找到DLL中函数的地址），不用后FreeLibrary</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>NSString 字符串使用（基础篇）</title>
    <url>/2015-09-13-nsstring-using/</url>
    <content><![CDATA[<p>iOS字符串主要分为两大类：NSString和NSMutableString。即不可变和可变字符串。在很多时候两者使用差异不大。文章分享字符串使用方法。</p>
<span id="more"></span>


<h1 id="一、不可变字符"><a href="#一、不可变字符" class="headerlink" title="一、不可变字符"></a>一、不可变字符</h1><p>NSString是不可变字符串，它产生的其他字符串方法都是生成一个新的字符串，而不会改变原来字符串。</p>
<h2 id="1-创建方式"><a href="#1-创建方式" class="headerlink" title="1.创建方式"></a>1.创建方式</h2><p>1）字面量，它是常量字符串，存储常量区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *str=@&quot;hello&quot;;</span><br></pre></td></tr></table></figure>
<p>2）通过快捷构造法，存储堆区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *str = [NSString stringWithFormat:@&quot;hello %@&quot;, @&quot;world&quot;];</span><br></pre></td></tr></table></figure>
<p>3）初始化方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *str = [[NSString alloc] initWithFormat:@&quot;%@&quot;,@&quot;hello&quot;];</span><br></pre></td></tr></table></figure>

<h2 id="2-字符串的获取"><a href="#2-字符串的获取" class="headerlink" title="2.字符串的获取"></a>2.字符串的获取</h2><p>1）获取字符串长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *str=@&quot;hello&quot;;</span><br><span class="line">long length = str.length;</span><br></pre></td></tr></table></figure>

<p>2）获取子串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *str=@&quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">/*从索引字符串开始截取，直到字符串末尾，包含索引上的字符*/</span><br><span class="line">NSString *strSub = [str substringFormIndex:2];</span><br><span class="line"></span><br><span class="line">/*从字符串开头开始截取，直到索引位置，不包含索引上的字符*/</span><br><span class="line">NSString *strSubT = [str substringToIndex:2];</span><br><span class="line"></span><br><span class="line">/*从哪个位置开始，截取多长*/</span><br><span class="line">NSRange range = &#123;2,4&#125;;</span><br><span class="line">NSString *strSubR = [str substringWithRange:range];</span><br><span class="line"></span><br><span class="line">/*获取某个子串所在的区域*/</span><br><span class="line">NSRange rangeS = [str rangeOfString&quot;@&quot;el&quot;];</span><br><span class="line"></span><br><span class="line">/*单词首字母转大写*/</span><br><span class="line">[str capitalizedString];</span><br><span class="line"></span><br><span class="line">/*字符替换*/</span><br><span class="line">NSString *newStr = [str stringByReplacingOccurencesOfString:@&quot;ll&quot; withString:@&quot;al&quot;];</span><br><span class="line"></span><br><span class="line">/*使用某个字符串替换掉原来字符串中某个区间的字符串*/</span><br><span class="line">NSRange range = [str rangeOfString:@&quot;ll&quot;];</span><br><span class="line">NSString *newStr = [str stringByReplacingCharactersInRange:range withSring:@&quot;hi&quot;];</span><br><span class="line"></span><br><span class="line">/*删除原字符串中的所有指定字符串*/</span><br><span class="line">NSString *newStr = [str stringByReplacingOccurencesOfString:@&quot;ll&quot; withString:@&quot;&quot;];</span><br><span class="line"></span><br><span class="line">/*去掉两头空格*/</span><br><span class="line">NSString *newStr = [str stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];</span><br><span class="line"></span><br><span class="line">/*在原来路径上拼接一个路径*/</span><br><span class="line">NSString *path = @&quot;/Users/dengwei&quot;;</span><br><span class="line">path = [path stringByAppendingPathComponent:@&quot;Desktop&quot;];</span><br><span class="line"></span><br><span class="line">/*获取扩展名*/</span><br><span class="line">NSString *path = @&quot;/Users/dengwei/Desktop/apple.txt&quot;;</span><br><span class="line">path = [path stringByDeletingPathExtension];</span><br><span class="line">path = [path stringByAppendingPathExtension:@&quot;png&quot;];</span><br><span class="line"></span><br><span class="line">/*把字符串写入文件*/</span><br><span class="line">NSString *str = @&quot;today is cold!&quot;;</span><br><span class="line">NSString *path = @&quot;/Users/dengwei/Desktop/apple.txt&quot;;</span><br><span class="line">NSError *error;</span><br><span class="line">BOOL isSuccess = [str writeToFile:path atomically:YES encoding:NSUTF8StringEncoding error:&amp;error];</span><br><span class="line"></span><br><span class="line">/*读取文件*/</span><br><span class="line">NSString *string = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:&amp;error];</span><br><span class="line"></span><br><span class="line">/*字符串与URL*/</span><br><span class="line">/*</span><br><span class="line">URL：Uniform Resource Locator 统一资源定位符</span><br><span class="line">URL：格式  协议头://主机名称/资源路径</span><br><span class="line">http://www.baidu.com/some/images/pic.png</span><br><span class="line">404：没有找到资源</span><br><span class="line">*/</span><br><span class="line">NSString *str = @&quot;today is cold!&quot;;</span><br><span class="line">/*url路径中不支持中文，若是有中文则需将中文转码*/</span><br><span class="line">NSURL *url =  [NSURL URLWithString:@&quot;file:///Users/dengwei/Desktop/apple.txt&quot;];</span><br><span class="line"></span><br><span class="line">/*将中文转码*/</span><br><span class="line">NSString *url_cn =  @&quot;file:///Users/dengwei/Desktop/中文.txt&quot;;</span><br><span class="line">/*编码，把UTF8编码的字符串编码成URL中可用的字符串*/</span><br><span class="line">url_cn = [url_cn stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">/*解码，把URL中可用的字符串编码的字符串解码成UTF8编码的字符串*/</span><br><span class="line">url_cn = [url_cn stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">url_cn = [NSURL URLWithString:url_cn];</span><br><span class="line">NSError *error;</span><br><span class="line">/*写入*/</span><br><span class="line">BOOL isSuccess = [str writeToURL:url atomically:YES encoding:NSUTF8StringEncoding error:&amp;error];</span><br><span class="line">/*读取*/</span><br><span class="line">NSString *string = [str stringWithContentsOfURL:url atomically:YES encoding:NSUTF8StringEncoding error:&amp;error];</span><br></pre></td></tr></table></figure>

<h2 id="3-字符串范围获取"><a href="#3-字符串范围获取" class="headerlink" title="3.字符串范围获取"></a>3.字符串范围获取</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*计算文本大小*/</span><br><span class="line">CGSize maxSize = CGSizeMake(MAXFLOAT, MAXFLOAT);/*width与height都不限制*/</span><br><span class="line">CGSize nameSize = [self.microBlogModel.name boundingRectWithSize:maxSize options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:15]&#125; context:nil].size;</span><br></pre></td></tr></table></figure>


<h1 id="二、可变字符"><a href="#二、可变字符" class="headerlink" title="二、可变字符"></a>二、可变字符</h1><p>NSMutableString，可变字符，是NSString的子类。<br>一个字符串需要经常修改其中的内容，则使用NSMutableString。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSMutableString *strM = [NSMutableString string];</span><br><span class="line">/*Capacity表示容量，可以容纳多少字符，如果超过这个存储空间，就会扩展它*/</span><br><span class="line">NSMutableString *strM = [NSMutableString stringWithCapacity:10];</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>objc</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C 继承和多态</title>
    <url>/2015-09-26-objc-inherit-multimodal/</url>
    <content><![CDATA[<p>学习Java我们知道类有三大特征，封装，继承，多态。而在Objective-C中也有继承的概念，今天就来看看Objective-C中的继承和多态。</p>
<span id="more"></span>

<p>首先,我们来看看示例代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Animal.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">  </span><br><span class="line">@interface Animal : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    int food_consumption; //食量</span><br><span class="line">    int count; //数量</span><br><span class="line">    int parturition_days; //生产周期</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">-(int)count;</span><br><span class="line"> </span><br><span class="line">-(void)setCount:(int)c;</span><br><span class="line"> </span><br><span class="line">-(int)foodConsumption;</span><br><span class="line"> </span><br><span class="line">-(void)setFoodConsumption:(int)food_c;</span><br><span class="line"> </span><br><span class="line">-(int)parturitionDays;</span><br><span class="line"> </span><br><span class="line">-(void)setParturitionDays:(int)parturition_day;</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Animal.m</span><br><span class="line">#import &quot;Animal.h&quot;</span><br><span class="line"> </span><br><span class="line">@implementation Animal</span><br><span class="line"> </span><br><span class="line">-(int)count&#123;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">-(void)setCount:(int)c&#123;</span><br><span class="line">    count = c;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">-(int)foodConsumption&#123;</span><br><span class="line">    return food_consumption;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">-(void)setFoodConsumption:(int)food_c&#123;</span><br><span class="line">    food_consumption = food_c;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">-(int)parturitionDays&#123;</span><br><span class="line">    return parturition_days;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">-(void)setParturitionDays:(int)parturition_day&#123;</span><br><span class="line">    parturition_days = parturition_day;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Panda.h</span><br><span class="line">#import &quot;Animal.h&quot;</span><br><span class="line">  </span><br><span class="line">@interface Panda : Animal</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Panda.m</span><br><span class="line">#import &quot;Panda.h&quot;</span><br><span class="line"> </span><br><span class="line">@implementation Panda</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Tool.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;Animal.h&quot;</span><br><span class="line">#import &quot;Panda.h&quot;</span><br><span class="line"> </span><br><span class="line">@interface Tool : NSObject</span><br><span class="line"> </span><br><span class="line">+(void) initWithAnimalDictionary:(Animal *)animal andDict:(NSDictionary *)dict;</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Tool.m</span><br><span class="line">#import &quot;Tool.h&quot;</span><br><span class="line"> </span><br><span class="line">@implementation Tool</span><br><span class="line"> </span><br><span class="line">+(void) initWithAnimalDictionary:(Animal *)animal andDict:(NSDictionary *)dict&#123;</span><br><span class="line">    NSDictionary *animalDict;</span><br><span class="line">    if(YES == [animal isKindOfClass:[Panda class]])&#123;</span><br><span class="line">        animalDict = [dict objectForKey:@&quot;Panda&quot;];</span><br><span class="line">         </span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        NSLog(@&quot;error class!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    [animal setCount:[[animalDict objectForKey:@&quot;count&quot;] intValue]];</span><br><span class="line">    [animal setFoodConsumption:[[animalDict objectForKey:@&quot;food_consumption&quot;] intValue]];</span><br><span class="line">    [animal setParturitionDays:[[animalDict objectForKey:@&quot;parturition_days&quot;] intValue]];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>data.plist文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;fodder&lt;/key&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;count_num&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;1024&lt;/string&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">    &lt;key&gt;Panda&lt;/key&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;food_consumption&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;2&lt;/string&gt;</span><br><span class="line">        &lt;key&gt;count&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;6&lt;/string&gt;</span><br><span class="line">        &lt;key&gt;parturition_days&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;76&lt;/string&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//main.m</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;Tool.h&quot;</span><br><span class="line"> </span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // insert code here...</span><br><span class="line">        Panda *panda = [[Panda alloc] init];</span><br><span class="line">     </span><br><span class="line">        //读取plist</span><br><span class="line">        NSString *plistPath = [[NSBundle mainBundle] pathForResource:@&quot;data&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">        NSMutableDictionary *data = [[NSMutableDictionary alloc] initWithContentsOfFile:plistPath];</span><br><span class="line">     </span><br><span class="line">        [Tool initWithAnimalDictionary:panda andDict:data];</span><br><span class="line">     </span><br><span class="line">        int fooder_num = 0;</span><br><span class="line">        int surplus = 0;</span><br><span class="line">        int day = 1;</span><br><span class="line">     </span><br><span class="line">        NSDictionary *fooderDict = [data objectForKey:@&quot;fodder&quot;];</span><br><span class="line">        fooder_num = [[fooderDict objectForKey:@&quot;count_num&quot;] intValue];</span><br><span class="line">        surplus = fooder_num;</span><br><span class="line">     </span><br><span class="line">        while(surplus &gt; 0)&#123;</span><br><span class="line">            if(0 == (day % [panda parturitionDays]))&#123;</span><br><span class="line">                [panda setCount:([panda count] + 1)];</span><br><span class="line">            &#125;</span><br><span class="line">            surplus = fooder_num - ([panda count] * [panda foodConsumption]);</span><br><span class="line">            fooder_num = surplus;</span><br><span class="line">         </span><br><span class="line">            if(surplus)&#123;</span><br><span class="line">                NSLog(@&quot;第 %d 天，熊猫:%d 只，饲料余量:%d 。\n&quot;, day, [panda count],  surplus);</span><br><span class="line">            &#125;</span><br><span class="line">            day++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承是类中的一个重要的特性，它的出现使得我们没必要别写重复的代码，可重用性很高。当然Objective-C中的继承和Java中是一样的，没多大区别。不仅仅Java，C++也有继承特性，但C++支持多继承，而Objective-C不支持多继承。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h2><p>(1)超类(superclass)，是你所继承的类。例如，Panda的超类是Animal，Animal的超类是NSObject。</p>
<p>(2)父类(parentclass)，是超类的另一种表达方式。例如，Animal是Panda的父类。</p>
<p>(3)子类(subclass)，是实施继承的类。例如，Panda是Animal的子类。</p>
<p>(4)孩子类(childclass)，是子类的另一种表达方式。例如，Panda是Animal的孩子类。</p>
<h2 id="继承的工作机制"><a href="#继承的工作机制" class="headerlink" title="继承的工作机制:"></a>继承的工作机制:</h2><p>(1)方法调度</p>
<p>当代码发送消息时，Objective-C的方法调度程序将在当前类中搜索相应的方法。如果调度程序无法在接收消息的对象类中找到相应的方法，它就在该对象的超类中进行查找。</p>
<p>(2)实例变量</p>
<p>接下来我们看看Objective-C如何访问实例变量。创建一个新类时，其对象首先从自身的超类中继承实例变量，然后(可选)添加它们自己的实例变量。</p>
<p>最后，说说重写方法，制作自己全新的子类时，通常需要添加自己的方法。有时，为了在类中引入某个独特的特性，需要添加新方法。还有些时候，可能需要替换或增强由这个新类的某个超类所定义的现有方法。当遇到我们子类特有的方法时，则只需要在子类中重写该方法即可。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>在Objective-C中，多态就是指，父类指针可以指向子类。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+(void) initWithAnimalDictionary:(Animal *)animal andDict:(NSDictionary *)dict;</span><br></pre></td></tr></table></figure>

<p>上例代码中的从字典中获取数据的类方法就很好地使用了多态。该方法主要是从字典中读取数据，示例中只有Panda一个子类，若是以后拥有更多的类，那么该功能的方法需要为每一个子类写一个方法，而使用多态特性，则只需根据传入的参数进行分别处理即可，减少代码冗余问题。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>objc</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>地图定位异常问题</title>
    <url>/2015-11-04-location-map-debug-error/</url>
    <content><![CDATA[<p>地图定位是做LBS服务的App通常用到的模块。但是，随着iOS系统的升级，地图定位模块出现了不一样的异常，这里将遇到的并解决的问题分享出来。</p>
<span id="more"></span>

<p>一、CLLocationManagerDelegate不调用didUpdateLocations</p>
<p>这是因为xcode升级造成的定位权限设置问题。</p>
<p>升级xcode6以后打开以前xcode5工程，程序不能定位。工程升级到xcode6编译时需要iOS8 要自己写授权，不然没权限定位。</p>
<p>解决方法：</p>
<p>首先在 info.plist里加入对应的缺省字段，值设置为YES（前台定位写上边字段，前后台定位写下边字段）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSLocationWhenInUseUsageDescription  //允许在前台获取GPS的描述</span><br><span class="line">NSLocationAlwaysUsageDescription  //允许在前、后台获取GPS的描述</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;CoreLocation/CoreLocation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()&lt;<span class="title">CLLocationManagerDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)<span class="built_in">CLLocationManager</span> *locationManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    1. 懒加载初始化：</span></span><br><span class="line">- (<span class="built_in">CLLocationManager</span> *)locationManager&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_locationManager)&#123;</span><br><span class="line">        <span class="keyword">self</span>.locationManager= [[<span class="built_in">CLLocationManager</span> alloc] init];</span><br><span class="line">        <span class="keyword">self</span>.locationManager.delegate= <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return_locationManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewDidLoad &#123;</span><br><span class="line">    [superviewDidLoad];</span><br><span class="line"></span><br><span class="line"><span class="comment">//    2. 调用请求：</span></span><br><span class="line">    <span class="keyword">if</span> ([[[<span class="built_in">UIDevicecurrentDevice</span>] systemVersion] doubleValue] &gt; <span class="number">8.0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置定位权限 仅ios8有意义</span></span><br><span class="line">        [<span class="keyword">self</span>.locationManagerrequestWhenInUseAuthorization];<span class="comment">// 前台定位        </span></span><br><span class="line">        <span class="comment">//[self.locationManagerrequestAlwaysAuthorization];// 前后台同时定位</span></span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.locationManagerstartUpdatingLocation];</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.代理方法</span></span><br><span class="line">- (<span class="type">void</span>)locationManager:(<span class="built_in">CLLocationManager</span>*)manager didUpdateLocations:(<span class="built_in">NSArray</span> *)locations&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%ld&quot;</span>,locations.count);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>二、ErrorDomain&#x3D;kCLErrorDomain Code&#x3D;0 “The operation couldn’t be completed.</p>
<p>环境：XCODE6.0.1 + iPhone &#x2F; iOS8</p>
<p>错误：使用CoreLocation获取地理位置信息，报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error Domain=kCLErrorDomain Code=0&quot;The operation couldn’t be completed. (kCLErrorDomain error 0.)&quot;</span><br></pre></td></tr></table></figure>

<p>解决方法：</p>
<p>1.确定模拟器（手机）已经联网并且允许程序获取地理位置</p>
<p>2.重置地理位置服务或者网络服务</p>
<p>PS：如果是模拟器就果断直接重置模拟器</p>
<p>重置模拟器方法：iOS Simulator -&gt; Reset Content andSettings…</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>MD5 算法解析</title>
    <url>/2015-11-21-algorithm-md5-resolve/</url>
    <content><![CDATA[<p>MD5的全称是Message-Digest Algorithm 5，在90年代初由MIT的计算机科学实验室和RSA Data Security Inc发明，经MD2、MD3和MD4发展而来。</p>
<p>MD5将任意长度的“字节串”变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，换句话说就是，即使你看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的数学函数。</p>
<p>MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹)，以防止被“篡改”。举个例子，你将一段话写在一个叫 readme.txt文件中，并对这个readme.txt产生一个MD5的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内容，你对这个文件重新计算MD5时就会发现。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。</p>
<span id="more"></span>

<p>MD5还广泛用于加密和解密技术上，在很多操作系统中，用户的密码是以MD5值（或类似的其它算法）的方式保存的， 用户Login的时候，系统是把用户输入的密码计算成MD5值，然后再去和系统中保存的MD5值进行比较，而系统并不“知道”用户的密码是什么。</p>
<p>在一些初始化处理后，MD5以512位分组来处理输入文本，每一分组又划分为16个32位子分组。算法的输出由四个32位分组组成，将它们级联形成一个128位散列值。 </p>
<p>首先填充消息使其长度恰好为一个比512位的倍数仅小64位的数。填充方法是附一个1在消息后面，后接所要求的多个0，然后在其后附上64位的消息长度（填充前）。这两步的作用是使消息长度恰好是512位的整数倍（算法的其余部分要求如此），同时确保不同的消息在填充后不相同。 </p>
<p>四个32位变量初始化为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A=0×01234567 </span><br><span class="line">B=0×89abcdef </span><br><span class="line">C=0xfedcba98 </span><br><span class="line">D=0×76543210 </span><br></pre></td></tr></table></figure>
<p>它们称为<strong>链接变量（chaining variable）</strong> </p>
<p>接着进行算法的主循环，循环的次数是消息中512位消息分组的数目。 </p>
<p>将上面四个变量复制到别外的变量中：A到a，B到b，C到c，D到d。 </p>
<p>主循环有四轮（MD4只有三轮），每轮很相拟。第一轮进行16次操作。每次操作对a，b，c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量，文本的一个子分组和一个常数。再将所得结果向右环移一个不定的数，并加上a，b，c或d中之一。最后用该结果取代a，b，c或d中之一。 </p>
<p>以下是每次操作中用到的四个非线性函数（每轮一个）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F(X,Y,Z)=(X&amp;Y)|((~X)&amp;Z) </span><br><span class="line">G(X,Y,Z)=(X&amp;Z)|(Y&amp;(~Z)) </span><br><span class="line">H(X,Y,Z)=X^Y^Z </span><br><span class="line">I(X,Y,Z)=Y^(X|(~Z)) </span><br><span class="line">(&amp;是与,|是或,~是非,^是异或) </span><br></pre></td></tr></table></figure>

<p>这些函数是这样设计的：如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。 </p>
<p>函数F是按逐位方式操作：如果X，那么Y，否则Z。函数H是逐位奇偶操作符。<br>设Mj表示消息的第j个子分组（从0到15），&lt;&lt;&lt; s表示循环左移s位，则四种操作为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FF(a,b,c,d,Mj,s,ti)表示a=b+((a+(F(b,c,d)+Mj+ti)&lt;&lt;&lt; s) </span><br><span class="line">GG(a,b,c,d,Mj,s,ti)表示a=b+((a+(G(b,c,d)+Mj+ti)&lt;&lt;&lt; s) </span><br><span class="line">HH(a,b,c,d,Mj,s,ti)表示a=b+((a+(H(b,c,d)+Mj+ti)&lt;&lt;&lt; s) </span><br><span class="line">II(a,b,c,d,Mj,s,ti)表示a=b+((a+(I(b,c,d)+Mj+ti)&lt;&lt;&lt; s) </span><br></pre></td></tr></table></figure>

<p>这四轮（64步）是：</p>
<p>第一轮 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FF(a,b,c,d,M0,7,0xd76aa478) </span><br><span class="line">FF(d,a,b,c,M1,12,0xe8c7b756) </span><br><span class="line">FF(c,d,a,b,M2,17,0×242070db) </span><br><span class="line">FF(b,c,d,a,M3,22,0xc1bdceee) </span><br><span class="line">FF(a,b,c,d,M4,7,0xf57c0faf) </span><br><span class="line">FF(d,a,b,c,M5,12,0×4787c62a) </span><br><span class="line">FF(c,d,a,b,M6,17,0xa8304613) </span><br><span class="line">FF(b,c,d,a,M7,22,0xfd469501) </span><br><span class="line">FF(a,b,c,d,M8,7,0×698098d8) </span><br><span class="line">FF(d,a,b,c,M9,12,0×8b44f7af) </span><br><span class="line">FF(c,d,a,b,M10,17,0xffff5bb1) </span><br><span class="line">FF(b,c,d,a,M11,22,0×895cd7be) </span><br><span class="line">FF(a,b,c,d,M12,7,0×6b901122) </span><br><span class="line">FF(d,a,b,c,M13,12,0xfd987193) </span><br><span class="line">FF(c,d,a,b,M14,17,0xa679438e) </span><br><span class="line">FF(b,c,d,a,M15,22,0×49b40821)</span><br></pre></td></tr></table></figure>
<p>第二轮 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GG(a,b,c,d,M1,5,0xf61e2562) </span><br><span class="line">GG(d,a,b,c,M6,9,0xc040b340) </span><br><span class="line">GG(c,d,a,b,M11,14,0×265e5a51) </span><br><span class="line">GG(b,c,d,a,M0,20,0xe9b6c7aa) </span><br><span class="line">GG(a,b,c,d,M5,5,0xd62f105d) </span><br><span class="line">GG(d,a,b,c,M10,9,0×02441453) </span><br><span class="line">GG(c,d,a,b,M15,14,0xd8a1e681) </span><br><span class="line">GG(b,c,d,a,M4,20,0xe7d3fbc8) </span><br><span class="line">GG(a,b,c,d,M9,5,0×21e1cde6) </span><br><span class="line">GG(d,a,b,c,M14,9,0xc33707d6) </span><br><span class="line">GG(c,d,a,b,M3,14,0xf4d50d87) </span><br><span class="line">GG(b,c,d,a,M8,20,0×455a14ed) </span><br><span class="line">GG(a,b,c,d,M13,5,0xa9e3e905) </span><br><span class="line">GG(d,a,b,c,M2,9,0xfcefa3f8) </span><br><span class="line">GG(c,d,a,b,M7,14,0×676f02d9) </span><br><span class="line">GG(b,c,d,a,M12,20,0×8d2a4c8a)</span><br></pre></td></tr></table></figure>
<p>第三轮 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HH(a,b,c,d,M5,4,0xfffa3942) </span><br><span class="line">HH(d,a,b,c,M8,11,0×8771f681) </span><br><span class="line">HH(c,d,a,b,M11,16,0×6d9d6122) </span><br><span class="line">HH(b,c,d,a,M14,23,0xfde5380c) </span><br><span class="line">HH(a,b,c,d,M1,4,0xa4beea44) </span><br><span class="line">HH(d,a,b,c,M4,11,0×4bdecfa9) </span><br><span class="line">HH(c,d,a,b,M7,16,0xf6bb4b60) </span><br><span class="line">HH(b,c,d,a,M10,23,0xbebfbc70) </span><br><span class="line">HH(a,b,c,d,M13,4,0×289b7ec6) </span><br><span class="line">HH(d,a,b,c,M0,11,0xeaa127fa) </span><br><span class="line">HH(c,d,a,b,M3,16,0xd4ef3085) </span><br><span class="line">HH(b,c,d,a,M6,23,0×04881d05) </span><br><span class="line">HH(a,b,c,d,M9,4,0xd9d4d039) </span><br><span class="line">HH(d,a,b,c,M12,11,0xe6db99e5) </span><br><span class="line">HH(c,d,a,b,M15,16,0×1fa27cf8) </span><br><span class="line">HH(b,c,d,a,M2,23,0xc4ac5665) </span><br></pre></td></tr></table></figure>

<p>第四轮 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">II(a,b,c,d,M0,6,0xf4292244) </span><br><span class="line">II(d,a,b,c,M7,10,0×432aff97) </span><br><span class="line">II(c,d,a,b,M14,15,0xab9423a7) </span><br><span class="line">II(b,c,d,a,M5,21,0xfc93a039) </span><br><span class="line">II(a,b,c,d,M12,6,0×655b59c3) </span><br><span class="line">II(d,a,b,c,M3,10,0×8f0ccc92) </span><br><span class="line">II(c,d,a,b,M10,15,0xffeff47d) </span><br><span class="line">II(b,c,d,a,M1,21,0×85845dd1) </span><br><span class="line">II(a,b,c,d,M8,6,0×6fa87e4f) </span><br><span class="line">II(d,a,b,c,M15,10,0xfe2ce6e0) </span><br><span class="line">II(c,d,a,b,M6,15,0xa3014314) </span><br><span class="line">II(b,c,d,a,M13,21,0×4e0811a1) </span><br><span class="line">II(a,b,c,d,M4,6,0xf7537e82) </span><br><span class="line">II(d,a,b,c,M11,10,0xbd3af235) </span><br><span class="line">II(c,d,a,b,M2,15,0×2ad7d2bb) </span><br><span class="line">II(b,c,d,a,M9,21,0xeb86d391) </span><br></pre></td></tr></table></figure>

<p>常数ti可以如下选择：</p>
<p>在第i步中，ti是4294967296*abs(sin(i))的整数部分,i的单位是弧度。<br>(2的32次方) </p>
<p>所有这些完成之后，将A，B，C，D分别加上a，b，c，d。然后用下一分组数据继续运行算法，最后的输出是A，B，C和D的级联。 
　　</p>
<p><strong>MD5的安全性</strong> </p>
<p>MD5相对MD4所作的改进： </p>
<ul>
<li>增加了第四轮。</li>
<li>每一步均有唯一的加法常数。</li>
<li>为减弱第二轮中函数G的对称性从(X&amp;Y)|(X&amp;Z)|(Y&amp;Z)变为(X&amp;Z)|(Y&amp;(~Z)) </li>
<li>第一步加上了上一步的结果，这将引起更快的雪崩效应。 </li>
<li>改变了第二轮和第三轮中访问消息子分组的次序，使其更不相似。</li>
<li>近似优化了每一轮中的循环左移位移量以实现更快的雪崩效应。各轮的位移量互不相同。</li>
</ul>
<p><strong>MD5源码:</strong></p>
<p>md5.h</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*                  md5.h            */</span><br><span class="line">#ifndef _MD5_H_</span><br><span class="line">#define _MD5_H_</span><br><span class="line">#define R_memset(x, y, z) memset(x, y, z)</span><br><span class="line">#define R_memcpy(x, y, z) memcpy(x, y, z)</span><br><span class="line">#define R_memcmp(x, y, z) memcmp(x, y, z)</span><br><span class="line">typedef unsigned long UINT4;</span><br><span class="line">typedef unsigned char *POINTER;</span><br><span class="line">/* MD5 context. */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">   /* state (ABCD) */  </span><br><span class="line">   /*四个32bits数，用于存放最终计算得到的消息摘要。当消息长度〉512bits时，也用于存放每个512bits的中间结果*/</span><br><span class="line">   UINT4 state[4];  </span><br><span class="line">   /* number of bits, modulo 2^64 (lsb first) */   </span><br><span class="line">   /*存储原始信息的bits数长度,不包括填充的bits，最长为 2^64 bits，因为2^64是一个64位数的最大值*/</span><br><span class="line">   UINT4 count[2];</span><br><span class="line">   </span><br><span class="line">   /* input buffer */</span><br><span class="line">   /*存放输入的信息的缓冲区，512bits*/</span><br><span class="line">   unsigned char buffer[64]; </span><br><span class="line">&#125; MD5_CTX;</span><br><span class="line">void MD5Init(MD5_CTX *);</span><br><span class="line">void MD5Update(MD5_CTX *, unsigned char *, unsigned int);</span><br><span class="line">void MD5Final(unsigned char [16], MD5_CTX *);</span><br><span class="line">#endif /* _MD5_H_ */</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>md5.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*     md5.cpp    */</span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">/* Constants for MD5Transform routine. */</span><br><span class="line">/*md5转换用到的常量，算法本身规定的*/</span><br><span class="line">#define S11 7</span><br><span class="line">#define S12 12</span><br><span class="line">#define S13 17</span><br><span class="line">#define S14 22</span><br><span class="line">#define S21 5</span><br><span class="line">#define S22 9</span><br><span class="line">#define S23 14</span><br><span class="line">#define S24 20</span><br><span class="line">#define S31 4</span><br><span class="line">#define S32 11</span><br><span class="line">#define S33 16</span><br><span class="line">#define S34 23</span><br><span class="line">#define S41 6</span><br><span class="line">#define S42 10</span><br><span class="line">#define S43 15</span><br><span class="line">#define S44 21</span><br><span class="line">static void MD5Transform(UINT4 [4], unsigned char [64]);</span><br><span class="line">static void Encode(unsigned char *, UINT4 *, unsigned int);</span><br><span class="line">static void Decode(UINT4 *, unsigned char *, unsigned int);</span><br><span class="line">/*</span><br><span class="line">用于bits填充的缓冲区，为什么要64个字节呢？因为当欲加密的信息的bits数被512除其余数为448时，</span><br><span class="line">需要填充的bits的最大值为512=64*8 。</span><br><span class="line">*/</span><br><span class="line">static unsigned char PADDING[64] = &#123;</span><br><span class="line">   0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span><br><span class="line">0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span><br><span class="line">&#125;;</span><br><span class="line">/*</span><br><span class="line">接下来的这几个宏定义是md5算法规定的，就是对信息进行md5加密都要做的运算。</span><br><span class="line">据说有经验的高手跟踪程序时根据这几个特殊的操作就可以断定是不是用的md5</span><br><span class="line">*/</span><br><span class="line">/* F, G, H and I are basic MD5 functions.</span><br><span class="line">*/</span><br><span class="line">#define F(x, y, z) (((x) &amp; (y)) | ((~x) &amp; (z)))</span><br><span class="line">#define G(x, y, z) (((x) &amp; (z)) | ((y) &amp; (~z)))</span><br><span class="line">#define H(x, y, z) ((x) ^ (y) ^ (z))</span><br><span class="line">#define I(x, y, z) ((y) ^ ((x) | (~z)))</span><br><span class="line">/* ROTATE_LEFT rotates x left n bits.</span><br><span class="line">*/</span><br><span class="line">#define ROTATE_LEFT(x, n) (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n))))</span><br><span class="line">/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.</span><br><span class="line">   Rotation is separate from addition to prevent recomputation.</span><br><span class="line">*/</span><br><span class="line">#define FF(a, b, c, d, x, s, ac) &#123; \</span><br><span class="line">   (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \</span><br><span class="line">   (a) = ROTATE_LEFT ((a), (s)); \</span><br><span class="line">   (a) += (b); \</span><br><span class="line">&#125;</span><br><span class="line">#define GG(a, b, c, d, x, s, ac) &#123; \</span><br><span class="line">   (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \</span><br><span class="line">   (a) = ROTATE_LEFT ((a), (s)); \</span><br><span class="line">   (a) += (b); \</span><br><span class="line">&#125;</span><br><span class="line">#define HH(a, b, c, d, x, s, ac) &#123; \</span><br><span class="line">   (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \</span><br><span class="line">   (a) = ROTATE_LEFT ((a), (s)); \</span><br><span class="line">   (a) += (b); \</span><br><span class="line">&#125;</span><br><span class="line">#define II(a, b, c, d, x, s, ac) &#123; \</span><br><span class="line">   (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \</span><br><span class="line">   (a) = ROTATE_LEFT ((a), (s)); \</span><br><span class="line">   (a) += (b); \</span><br><span class="line">&#125;</span><br><span class="line">/* MD5 initialization. Begins an MD5 operation, writing a new context. */</span><br><span class="line">/*初始化md5的结构*/</span><br><span class="line">void MD5Init (MD5_CTX *context)</span><br><span class="line">&#123;</span><br><span class="line">   /*将当前的有效信息的长度设成0,这个很简单,还没有有效信息,长度当然是0了*/</span><br><span class="line">   context-&gt;count[0] = context-&gt;count[1] = 0;</span><br><span class="line">   /* Load magic initialization constants.*/</span><br><span class="line">   /*初始化链接变量，算法要求这样，这个没法解释了*/</span><br><span class="line">   context-&gt;state[0] = 0x67452301;</span><br><span class="line">   context-&gt;state[1] = 0xefcdab89;</span><br><span class="line">   context-&gt;state[2] = 0x98badcfe;</span><br><span class="line">   context-&gt;state[3] = 0x10325476;</span><br><span class="line">&#125;</span><br><span class="line">/* MD5 block update operation. Continues an MD5 message-digest</span><br><span class="line">   operation, processing another message block, and updating the</span><br><span class="line">   context. */</span><br><span class="line">/*将与加密的信息传递给md5结构，可以多次调用</span><br><span class="line">context：初始化过了的md5结构</span><br><span class="line">input：欲加密的信息，可以任意长</span><br><span class="line">inputLen：指定input的长度</span><br><span class="line">*/</span><br><span class="line">void MD5Update(MD5_CTX *context,unsigned char * input,unsigned int   inputLen)</span><br><span class="line">&#123;</span><br><span class="line">unsigned int i, index, partLen;</span><br><span class="line">/* Compute number of bytes mod 64 */</span><br><span class="line">/*计算已有信息的bits长度的字节数的模64, 64bytes=512bits。</span><br><span class="line">用于判断已有信息加上当前传过来的信息的总长度能不能达到512bits，</span><br><span class="line">如果能够达到则对凑够的512bits进行一次处理*/</span><br><span class="line">index = (unsigned int)((context-&gt;count[0] &gt;&gt; 3) &amp; 0x3F);</span><br><span class="line">/* Update number of bits *//*更新已有信息的bits长度*/</span><br><span class="line">if((context-&gt;count[0] += ((UINT4)inputLen &lt;&lt; 3)) &lt; ((UINT4)inputLen &lt;&lt; 3))</span><br><span class="line">   context-&gt;count[1]++;</span><br><span class="line">context-&gt;count[1] += ((UINT4)inputLen &gt;&gt; 29);</span><br><span class="line">/*计算已有的字节数长度还差多少字节可以 凑成64的整倍数*/</span><br><span class="line">partLen = 64 - index;</span><br><span class="line">/* Transform as many times as possible.</span><br><span class="line">   */</span><br><span class="line">/*如果当前输入的字节数 大于 已有字节数长度补足64字节整倍数所差的字节数*/</span><br><span class="line">if(inputLen &gt;= partLen)</span><br><span class="line">     &#123;</span><br><span class="line">   /*用当前输入的内容把context-&gt;buffer的内容补足512bits*/</span><br><span class="line">   R_memcpy((POINTER)&amp;context-&gt;buffer[index], (POINTER)input, partLen);</span><br><span class="line">   /*用基本函数对填充满的512bits（已经保存到context-&gt;buffer中） 做一次转换，转换结果保存到context-&gt;state中*/</span><br><span class="line">   MD5Transform(context-&gt;state, context-&gt;buffer);</span><br><span class="line">/*</span><br><span class="line">对当前输入的剩余字节做转换（如果剩余的字节&lt;在输入的input缓冲区中&gt;大于512bits的话 ），</span><br><span class="line">转换结果保存到context-&gt;state中</span><br><span class="line">*/</span><br><span class="line">   for(i = partLen; i + 63 &lt; inputLen; i += 64)/*把i+63&lt;inputlen改为i+64&lt;=inputlen更容易理解*/</span><br><span class="line">    MD5Transform(context-&gt;state, &amp;input[i]);</span><br><span class="line">         index = 0;</span><br><span class="line">     &#125;</span><br><span class="line">     else</span><br><span class="line">   i = 0;</span><br><span class="line">/* Buffer remaining input */</span><br><span class="line">/*将输入缓冲区中的不足填充满512bits的剩余内容填充到context-&gt;buffer中，留待以后再作处理*/</span><br><span class="line">R_memcpy((POINTER)&amp;context-&gt;buffer[index], (POINTER)&amp;input[i], inputLen-i);</span><br><span class="line">&#125;</span><br><span class="line">/* MD5 finalization. Ends an MD5 message-digest operation, writing the</span><br><span class="line">   the message digest and zeroizing the context. */</span><br><span class="line">/*获取加密 的最终结果</span><br><span class="line">digest：保存最终的加密串</span><br><span class="line">context：你前面初始化并填入了信息的md5结构</span><br><span class="line">*/</span><br><span class="line">void MD5Final (unsigned char digest[16],MD5_CTX *context)</span><br><span class="line">&#123;</span><br><span class="line">unsigned char bits[8];</span><br><span class="line">unsigned int index, padLen;</span><br><span class="line">/* Save number of bits */</span><br><span class="line">/*将要被转换的信息(所有的)的bits长度拷贝到bits中*/</span><br><span class="line">Encode(bits, context-&gt;count, 8);</span><br><span class="line">/* Pad out to 56 mod 64. */</span><br><span class="line">/* 计算所有的bits长度的字节数的模64, 64bytes=512bits*/</span><br><span class="line">index = (unsigned int)((context-&gt;count[0] &gt;&gt; 3) &amp; 0x3f);</span><br><span class="line">/*计算需要填充的字节数，padLen的取值范围在1-64之间*/</span><br><span class="line">padLen = (index &lt; 56) ? (56 - index) : (120 - index);</span><br><span class="line">/*这一次函数调用绝对不会再导致MD5Transform的被调用，因为这一次不会填满512bits*/</span><br><span class="line">MD5Update(context, PADDING, padLen);</span><br><span class="line">/* Append length (before padding) */</span><br><span class="line">/*补上原始信息的bits长度（bits长度固定的用64bits表示），这一次能够恰巧凑够512bits，不会多也不会少*/</span><br><span class="line">MD5Update(context, bits, 8);</span><br><span class="line">/* Store state in digest */</span><br><span class="line">/*将最终的结果保存到digest中。ok，终于大功告成了*/</span><br><span class="line">Encode(digest, context-&gt;state, 16);</span><br><span class="line">/* Zeroize sensitive information. */</span><br><span class="line">R_memset((POINTER)context, 0, sizeof(*context));</span><br><span class="line">&#125;</span><br><span class="line">/* MD5 basic transformation. Transforms state based on block. */</span><br><span class="line">/*</span><br><span class="line">对512bits信息(即block缓冲区)进行一次处理，每次处理包括四轮</span><br><span class="line">state[4]：md5结构中的state[4]，用于保存对512bits信息加密的中间结果或者最终结果</span><br><span class="line">block[64]：欲加密的512bits信息</span><br><span class="line">*/</span><br><span class="line">static void MD5Transform (UINT4 state[4], unsigned char block[64])</span><br><span class="line">&#123;</span><br><span class="line">UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];</span><br><span class="line">Decode(x, block, 64);</span><br><span class="line">/* Round 1 */</span><br><span class="line">FF(a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */</span><br><span class="line">FF(d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */</span><br><span class="line">FF(c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */</span><br><span class="line">FF(b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */</span><br><span class="line">FF(a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */</span><br><span class="line">FF(d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */</span><br><span class="line">FF(c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */</span><br><span class="line">FF(b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */</span><br><span class="line">FF(a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */</span><br><span class="line">FF(d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */</span><br><span class="line">FF(c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */</span><br><span class="line">FF(b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */</span><br><span class="line">FF(a, b, c, d, x[12], S11, 0x6b901122); /* 13 */</span><br><span class="line">FF(d, a, b, c, x[13], S12, 0xfd987193); /* 14 */</span><br><span class="line">FF(c, d, a, b, x[14], S13, 0xa679438e); /* 15 */</span><br><span class="line">FF(b, c, d, a, x[15], S14, 0x49b40821); /* 16 */</span><br><span class="line">/* Round 2 */</span><br><span class="line">GG(a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */</span><br><span class="line">GG(d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */</span><br><span class="line">GG(c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */</span><br><span class="line">GG(b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */</span><br><span class="line">GG(a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */</span><br><span class="line">GG(d, a, b, c, x[10], S22,   0x2441453); /* 22 */</span><br><span class="line">GG(c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */</span><br><span class="line">GG(b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */</span><br><span class="line">GG(a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */</span><br><span class="line">GG(d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */</span><br><span class="line">GG(c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */</span><br><span class="line">GG(b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */</span><br><span class="line">GG(a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */</span><br><span class="line">GG(d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */</span><br><span class="line">GG(c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */</span><br><span class="line">GG(b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */</span><br><span class="line">/* Round 3 */</span><br><span class="line">HH(a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */</span><br><span class="line">HH(d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */</span><br><span class="line">HH(c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */</span><br><span class="line">HH(b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */</span><br><span class="line">HH(a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */</span><br><span class="line">HH(d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */</span><br><span class="line">HH(c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */</span><br><span class="line">HH(b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */</span><br><span class="line">HH(a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */</span><br><span class="line">HH(d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */</span><br><span class="line">HH(c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */</span><br><span class="line">HH(b, c, d, a, x[ 6], S34,   0x4881d05); /* 44 */</span><br><span class="line">HH(a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */</span><br><span class="line">HH(d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */</span><br><span class="line">HH(c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */</span><br><span class="line">HH(b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */</span><br><span class="line">/* Round 4 */</span><br><span class="line">II(a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */</span><br><span class="line">II(d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */</span><br><span class="line">II(c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */</span><br><span class="line">II(b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */</span><br><span class="line">II(a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */</span><br><span class="line">II(d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */</span><br><span class="line">II(c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */</span><br><span class="line">II(b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */</span><br><span class="line">II(a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */</span><br><span class="line">II(d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */</span><br><span class="line">II(c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */</span><br><span class="line">II(b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */</span><br><span class="line">II(a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */</span><br><span class="line">II(d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */</span><br><span class="line">II(c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */</span><br><span class="line">II(b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */</span><br><span class="line">state[0] += a;</span><br><span class="line">state[1] += b;</span><br><span class="line">state[2] += c;</span><br><span class="line">state[3] += d;</span><br><span class="line">/* Zeroize sensitive information. */</span><br><span class="line">R_memset((POINTER)x, 0, sizeof(x));</span><br><span class="line">&#125;</span><br><span class="line">/* Encodes input (UINT4) into output (unsigned char). Assumes len is</span><br><span class="line">   a multiple of 4. */</span><br><span class="line">/*将4字节的整数copy到字符形式的缓冲区中</span><br><span class="line">output：用于输出的字符缓冲区</span><br><span class="line">input：欲转换的四字节的整数形式的数组</span><br><span class="line">len：output缓冲区的长度，要求是4的整数倍</span><br><span class="line">*/</span><br><span class="line">static void Encode(unsigned char *output, UINT4 *input,unsigned int   len)</span><br><span class="line">&#123;</span><br><span class="line">unsigned int i, j;</span><br><span class="line">for(i = 0, j = 0; j &lt; len; i++, j += 4) &#123;</span><br><span class="line">   output[j] = (unsigned char)(input[i] &amp; 0xff);</span><br><span class="line">   output[j+1] = (unsigned char)((input[i] &gt;&gt; 8) &amp; 0xff);</span><br><span class="line">   output[j+2] = (unsigned char)((input[i] &gt;&gt; 16) &amp; 0xff);</span><br><span class="line">   output[j+3] = (unsigned char)((input[i] &gt;&gt; 24) &amp; 0xff);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* Decodes input (unsigned char) into output (UINT4). Assumes len is</span><br><span class="line">   a multiple of 4. */</span><br><span class="line">/*与上面的函数正好相反，这一个把字符形式的缓冲区中的数据copy到4字节的整数中（即以整数形式保存）</span><br><span class="line">output：保存转换出的整数</span><br><span class="line">input：欲转换的字符缓冲区</span><br><span class="line">len：输入的字符缓冲区的长度，要求是4的整数倍</span><br><span class="line">*/</span><br><span class="line">static void Decode(UINT4 *output, unsigned char *input,unsigned int   len)</span><br><span class="line">&#123;</span><br><span class="line">unsigned int i, j;</span><br><span class="line">for(i = 0, j = 0; j &lt; len; i++, j += 4)</span><br><span class="line">   output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) &lt;&lt; 8) |</span><br><span class="line">    (((UINT4)input[j+2]) &lt;&lt; 16) | (((UINT4)input[j+3]) &lt;&lt; 24);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>md5test.cpp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// md5test.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	MD5_CTX md5;</span><br><span class="line">	MD5Init(&amp;md5);                          //初始化用于md5加密的结构</span><br><span class="line"> </span><br><span class="line">	unsigned char encrypt[200];      //存放于加密的信息</span><br><span class="line">	unsigned char decrypt[17];        //存放加密后的结果</span><br><span class="line">	scanf(&quot;%s&quot;,encrypt);                  //输入加密的字符</span><br><span class="line"> </span><br><span class="line">	MD5Update(&amp;md5,encrypt,strlen((char *)encrypt));    //对欲加密的字符进行加密</span><br><span class="line">	MD5Final(decrypt,&amp;md5);                                             	//获得最终结果</span><br><span class="line"> </span><br><span class="line">	printf(&quot;加密前:%s\n加密后:&quot;,encrypt);</span><br><span class="line">	for(int i=0;i&lt;16;i++)</span><br><span class="line">   		printf(&quot;%2x &quot;,decrypt[i]);</span><br><span class="line"> </span><br><span class="line">	printf(&quot;\n\n\n加密结束!\n&quot;);</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>写在最后</strong></p>
<p>欢迎大家加入移动开发交流Q群交流讨论，Q群号：855454453</p>
<p><img src="/assets/images/Q811237468.jpg" alt="Q811237468"></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>md5</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 实现自适应窗口大小的网页</title>
    <url>/2015-11-26-js-adjust-window-page/</url>
    <content><![CDATA[<p>随着移动互联网的兴起，网页浏览端不再仅仅只是电脑，更多的用户选择在移动端使用，那么，我们肯定不能再使用电脑版的页面布局，那么我们将如何适应纷繁多样的界面尺寸呢，本问主要介绍如何使用JavaScript实现自适应窗口大小的网页。</p>
<span id="more"></span>


<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;imagetoolbar&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,inital-scale=1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-align</span>: left;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: F6F6F6;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-attachment</span>: fixed;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-id">#imgcenter</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>:relative;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: auto;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>:<span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">left</span>:<span class="number">20%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>:<span class="number">250px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-id">#center</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>:relative;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: auto;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>:<span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">left</span>:<span class="number">20%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>:<span class="number">220px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-id">#account</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>:relative;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: auto;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">left</span>:<span class="number">60%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>:-<span class="number">110px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>:<span class="number">2%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>:<span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-id">#pwd</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>:relative;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: auto;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">left</span>:<span class="number">60%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>:-<span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>:<span class="number">2%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-id">#login</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>:relative;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: auto;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">left</span>:<span class="number">60%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>:-<span class="number">95px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>:<span class="number">1%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">25%</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-id">#logo</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>:<span class="number">3%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: auto;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-id">#div_forgetpwd</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>:relative;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">30%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">left</span>: <span class="number">90%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>:-<span class="number">115px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">25%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">1pt</span>;   </span></span><br><span class="line"><span class="language-css">    <span class="attribute">white-space</span>:nowrap;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-id">#div_forgetpwd</span> <span class="selector-tag">a</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-id">#div_forgetpwd</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">text-decoration</span>: underline;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: auto;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.Clew</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">position</span>:relative;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">15px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">left</span>:-<span class="number">10%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">top</span>:-<span class="number">80%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>:<span class="number">2%</span> <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">white-space</span>:nowrap;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: <span class="number">#FFFFD5</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-weight</span>: bold;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-family</span>: century gothic, arial;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: <span class="number">#FCBE47</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-top</span>: <span class="number">2px</span> solid <span class="number">#db6e3c</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-bottom</span>: <span class="number">2px</span> solid <span class="number">#db6e3c</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;E:\MyProject\html\KServer\jquery-1.4.2.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">//error clew</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> userFlag=<span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> pwdFlag=<span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">$().<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&quot;form :input&quot;</span>).<span class="title function_">blur</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> $parent = $(<span class="variable language_">this</span>).<span class="title function_">parent</span>();</span></span><br><span class="line"><span class="language-javascript">        $parent.<span class="title function_">find</span>(<span class="string">&quot;.clew&quot;</span>).<span class="title function_">remove</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>($(<span class="variable language_">this</span>).<span class="title function_">is</span>(<span class="string">&quot;.username&quot;</span>)) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">value</span>==<span class="string">&quot;&quot;</span> || <span class="variable language_">this</span>.<span class="property">value</span>.<span class="property">length</span> &lt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> errorMsg = <span class="string">&quot;Please enter your account.&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">                $parent.<span class="title function_">append</span>(<span class="string">&quot;&lt;span class=&#x27;clew Clew&#x27;&gt;&quot;</span>+errorMsg+<span class="string">&quot;&lt;/span&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;<span class="keyword">else</span></span></span><br><span class="line"><span class="language-javascript">		userFlag=<span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>($(<span class="variable language_">this</span>).<span class="title function_">is</span>(<span class="string">&quot;.password&quot;</span>)) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">value</span>==<span class="string">&quot;&quot;</span> || <span class="variable language_">this</span>.<span class="property">value</span>.<span class="property">length</span> &lt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> errorMsg = <span class="string">&quot;Please enter your password.&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">                $parent.<span class="title function_">append</span>(<span class="string">&quot;&lt;span class=&#x27;clew Clew&#x27;&gt;&quot;</span>+errorMsg+<span class="string">&quot;&lt;/span&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;<span class="keyword">else</span></span></span><br><span class="line"><span class="language-javascript">		pwdFlag=<span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;       </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;).<span class="title function_">keyup</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        $(<span class="variable language_">this</span>).<span class="title function_">triggerHandler</span>(<span class="string">&quot;blur&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;).<span class="title function_">focus</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        $(<span class="variable language_">this</span>).<span class="title function_">triggerHandler</span>(<span class="string">&quot;blur&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"><span class="comment">//提交检验</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">validate_form</span>(<span class="params">thisform</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">with</span> (thisform)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (userFlag==<span class="number">0</span>||pwdFlag==<span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            username.<span class="title function_">focus</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;#F6F6F6&quot;</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;form  action=&quot;#&quot; method=&quot;get&quot; name=&quot;form&quot; id=&quot;form&quot;&gt;</span></span><br><span class="line"><span class="comment"> 当前窗口高度：</span></span><br><span class="line"><span class="comment"> &lt;input type=&quot;text&quot; name=&quot;availHeight&quot; size=&quot;6&quot;&gt;</span></span><br><span class="line"><span class="comment"> &lt;br&gt;</span></span><br><span class="line"><span class="comment"> 当前窗口宽度：</span></span><br><span class="line"><span class="comment"> &lt;input type=&quot;text&quot; name=&quot;availWidth&quot; size=&quot;6&quot;&gt;</span></span><br><span class="line"><span class="comment"> &lt;br&gt;</span></span><br><span class="line"><span class="comment"> &lt;/form&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;imgcenter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;E:\MyProject\html\KServer\login\login.png&quot;</span> <span class="attr">id</span>=<span class="string">&quot;logo&quot;</span> <span class="attr">align</span>=<span class="string">&quot;left&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;db.html&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return validate_form(this);&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;请输入用户名..&quot;</span> <span class="attr">id</span>=<span class="string">&quot;account&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">password</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;..&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">class</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span> <span class="attr">id</span>=<span class="string">&quot;login&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div_forgetpwd&quot;</span>&gt;</span>                </span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;E:\MyProject\html\KServer\register\register.html&quot;</span> &gt;</span>注册帐号<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;E:\MyProject\html\KServer\forget_pwd\forget_pwd.html&quot;</span> &gt;</span>忘记密码<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//更改元素CSS属性</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">set</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setImgDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;imgcenter&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setImgDiv.<span class="property">style</span>.<span class="property">top</span> = <span class="string">&quot;150px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setImgDiv.<span class="property">style</span>.<span class="property">left</span> = <span class="string">&quot;36%&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setTextDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;center&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setTextDiv.<span class="property">style</span>.<span class="property">top</span> = <span class="string">&quot;280px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setTextDiv.<span class="property">style</span>.<span class="property">left</span> = <span class="string">&quot;8%&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setLogo=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;logo&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setLogo.<span class="property">style</span>.<span class="property">height</span>=<span class="string">&quot;100px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setLogo.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;240px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setAccount=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;account&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setAccount.<span class="property">style</span>.<span class="property">height</span>=<span class="string">&quot;15px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setAccount.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;240px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setPwd=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;pwd&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setPwd.<span class="property">style</span>.<span class="property">height</span>=<span class="string">&quot;15px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setPwd.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;240px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setLogin=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;login&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setLogin.<span class="property">style</span>.<span class="property">height</span>=<span class="string">&quot;25px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setLogin.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;100px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setForgetPwd=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div_forgetpwd&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setForgetPwd.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;100px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setForgetPwd.<span class="property">style</span>.<span class="property">left</span>=<span class="string">&quot;100%&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">reSet</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> reSetImgDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;imgcenter&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        reSetImgDiv.<span class="property">style</span>.<span class="property">top</span> = <span class="string">&quot;250px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        reSetImgDiv.<span class="property">style</span>.<span class="property">left</span> = <span class="string">&quot;20%&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> reSetTextDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;center&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        reSetTextDiv.<span class="property">style</span>.<span class="property">top</span> = <span class="string">&quot;220px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        reSetTextDiv.<span class="property">style</span>.<span class="property">left</span> = <span class="string">&quot;20%&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> reSetLogo=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;logo&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        reSetLogo.<span class="property">style</span>.<span class="property">height</span>=<span class="string">&quot;auto&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        reSetLogo.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;50%&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> reSetAccount=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;account&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        reSetAccount.<span class="property">style</span>.<span class="property">height</span>=<span class="string">&quot;auto&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        reSetAccount.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;50%&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> reSetPwd=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;pwd&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        reSetPwd.<span class="property">style</span>.<span class="property">height</span>=<span class="string">&quot;auto&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        reSetPwd.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;50%&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> reSetLogin=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;login&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        reSetLogin.<span class="property">style</span>.<span class="property">height</span>=<span class="string">&quot;auto&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        reSetLogin.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;25%&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> reSetForgetPwd=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div_forgetpwd&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        reSetForgetPwd.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;100px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        reSetForgetPwd.<span class="property">style</span>.<span class="property">left</span>=<span class="string">&quot;90%&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">setSizeMid</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setSizeMidImgDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;imgcenter&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setSizeMidImgDiv.<span class="property">style</span>.<span class="property">top</span> = <span class="string">&quot;150px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setSizeMidImgDiv.<span class="property">style</span>.<span class="property">left</span> = <span class="string">&quot;22%&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setSizeMidTextDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;center&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setSizeMidTextDiv.<span class="property">style</span>.<span class="property">top</span> = <span class="string">&quot;280px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setSizeMidTextDiv.<span class="property">style</span>.<span class="property">left</span> = <span class="string">&quot;-35px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setSizeMidLogo=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;logo&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setSizeMidLogo.<span class="property">style</span>.<span class="property">height</span>=<span class="string">&quot;100px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setSizeMidLogo.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;240px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setSizeMidAccount=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;account&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setSizeMidAccount.<span class="property">style</span>.<span class="property">height</span>=<span class="string">&quot;15px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setSizeMidAccount.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;240px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setSizeMidPwd=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;pwd&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setSizeMidPwd.<span class="property">style</span>.<span class="property">height</span>=<span class="string">&quot;15px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setSizeMidPwd.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;240px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setSizeMidLogin=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;login&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setSizeMidLogin.<span class="property">style</span>.<span class="property">height</span>=<span class="string">&quot;25px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setSizeMidLogin.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;80px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setSizeMidForgetPwd=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div_forgetpwd&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setSizeMidForgetPwd.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;80px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setSizeMidForgetPwd.<span class="property">style</span>.<span class="property">left</span>=<span class="string">&quot;110%&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">setSizeMini</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setSizeMiniImgDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;imgcenter&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setSizeMiniImgDiv.<span class="property">style</span>.<span class="property">top</span> = <span class="string">&quot;150px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setSizeMiniImgDiv.<span class="property">style</span>.<span class="property">left</span> = <span class="string">&quot;6%&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setSizeMiniTextDiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;center&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setSizeMiniTextDiv.<span class="property">style</span>.<span class="property">top</span> = <span class="string">&quot;280px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setSizeMiniTextDiv.<span class="property">style</span>.<span class="property">left</span> = <span class="string">&quot;-60px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setSizeMiniLogo=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;logo&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setSizeMiniLogo.<span class="property">style</span>.<span class="property">height</span>=<span class="string">&quot;100px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setSizeMiniLogo.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;240px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setSizeMiniAccount=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;account&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setSizeMiniAccount.<span class="property">style</span>.<span class="property">height</span>=<span class="string">&quot;15px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setSizeMiniAccount.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;240px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setSizeMiniPwd=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;pwd&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setSizeMiniPwd.<span class="property">style</span>.<span class="property">height</span>=<span class="string">&quot;15px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setSizeMiniPwd.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;240px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setSizeMiniLogin=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;login&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setSizeMiniLogin.<span class="property">style</span>.<span class="property">height</span>=<span class="string">&quot;25px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setSizeMiniLogin.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;80px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> setSizeMiniForgetPwd=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div_forgetpwd&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        setSizeMiniForgetPwd.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&quot;80px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        setSizeMiniForgetPwd.<span class="property">style</span>.<span class="property">left</span>=<span class="string">&quot;125%&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//获取当前窗口尺寸</span></span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">var</span> winWidth = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">var</span> winHeight = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">function</span> <span class="title function_">findDimensions</span>(<span class="params"></span>) <span class="comment">//函数：获取尺寸</span></span></span><br><span class="line"><span class="language-javascript">     &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//获取窗口宽度</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">innerWidth</span>)</span></span><br><span class="line"><span class="language-javascript">        winWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="variable language_">document</span>.<span class="property">body</span>) &amp;&amp; (<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>))</span></span><br><span class="line"><span class="language-javascript">        winWidth = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//获取窗口高度</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">innerHeight</span>)</span></span><br><span class="line"><span class="language-javascript">        winHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="variable language_">document</span>.<span class="property">body</span>) &amp;&amp; (<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span>))</span></span><br><span class="line"><span class="language-javascript">        winHeight = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientHeight</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//通过深入Document内部对body进行检测，获取窗口大小</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">documentElement</span>  &amp;&amp; <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span> &amp;&amp; <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>)</span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">        winHeight = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>;</span></span><br><span class="line"><span class="language-javascript">        winWidth = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//结果输出至两个文本框</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span>(winWidth&lt;<span class="number">420</span>||winHeight&lt;<span class="number">537</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setSizeMini</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">420</span>&lt;=winWidth&amp;&amp;winWidth&lt;=<span class="number">595</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setSizeMid</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">595</span>&lt;winWidth&amp;&amp;winWidth&lt;<span class="number">850</span>||<span class="number">537</span>&lt;winHeight&amp;&amp;winHeight&lt;<span class="number">590</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">set</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">else</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">reSet</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;    </span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">findDimensions</span>();</span></span><br><span class="line"><span class="language-javascript">     <span class="comment">//调用函数，获取数值</span></span></span><br><span class="line"><span class="language-javascript">     <span class="variable language_">window</span>.<span class="property">onresize</span>=findDimensions;</span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP MVC模式简单实现</title>
    <url>/2015-11-30-php-mvc-framework/</url>
    <content><![CDATA[<p>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。</p>
<span id="more"></span>

<p>代码结构</p>
<p><img src="/assets/images/tech/php-mvc-framework-1.png" alt="代码结构-1"></p>
<p><img src="/assets/images/tech/php-mvc-framework-2.png" alt="代码结构-2"></p>
<p>代码实现</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">        <span class="comment">//function.php  </span></span><br><span class="line">	<span class="comment">//控制器调用函数</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$method</span></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">require_once</span>(<span class="string">&#x27;libs/Controller/&#x27;</span>.<span class="variable">$name</span>.<span class="string">&#x27;Controller.class.php&#x27;</span>);</span><br><span class="line">		<span class="comment">//$testController = new testController();</span></span><br><span class="line">		<span class="comment">//$testController-&gt;show();</span></span><br><span class="line">		<span class="keyword">eval</span>(<span class="string">&#x27;$obj = new &#x27;</span>.<span class="variable">$name</span>.<span class="string">&#x27;Controller(); $obj-&gt;&#x27;</span>.<span class="variable">$method</span>.<span class="string">&#x27;();&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//模型调用函数</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">M</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">require_once</span>(<span class="string">&#x27;libs/Model/&#x27;</span>.<span class="variable">$name</span>.<span class="string">&#x27;Model.class.php&#x27;</span>);</span><br><span class="line">		<span class="keyword">eval</span>(<span class="string">&#x27;$obj = new &#x27;</span>.<span class="variable">$name</span>.<span class="string">&#x27;Model();&#x27;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="variable">$obj</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//视图调用函数</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">V</span>(<span class="params"><span class="variable">$name</span></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">require_once</span>(<span class="string">&#x27;libs/View/&#x27;</span>.<span class="variable">$name</span>.<span class="string">&#x27;View.class.php&#x27;</span>);</span><br><span class="line">		<span class="keyword">eval</span>(<span class="string">&#x27;$obj = new &#x27;</span>.<span class="variable">$name</span>.<span class="string">&#x27;View();&#x27;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="variable">$obj</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//过滤非法值</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">daddslashes</span>(<span class="params"><span class="variable">$str</span></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (!<span class="title function_ invoke__">get_magic_quotes_gpc</span>())?<span class="title function_ invoke__">addslashes</span>(<span class="variable">$str</span>):<span class="variable">$str</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//test.php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一步 浏览者 -&gt; 调用控制器,对它发出指令</span></span><br><span class="line"><span class="comment">第二步 控制器 -&gt; 按指令选取一个合适的模型</span></span><br><span class="line"><span class="comment">第三步 模型 -&gt; 按控制器指令取相应数据</span></span><br><span class="line"><span class="comment">第四步 控制器 -&gt; 按指令选取相应视图</span></span><br><span class="line"><span class="comment">第五步 视图 -&gt; 把第三步取到的数据按用户想要的样子显示出来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">&#x27;View/testView.class.php&#x27;</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">&#x27;Model/testModel.class.php&#x27;</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">&#x27;Controller/testController.class.php&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$testController</span> = <span class="keyword">new</span> <span class="title function_ invoke__">testController</span>();</span><br><span class="line"><span class="variable">$testController</span>-&gt;<span class="title function_ invoke__">show</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//testController.class.php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">控制器的作用是调用模型,并调用视图,将模型产生的数据传递给视图,并让相关视图去显示</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">testController</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="comment">/*$testModel = new testModel();</span></span><br><span class="line"><span class="comment">			$data = $testModel-&gt;get();</span></span><br><span class="line"><span class="comment">			$testView = new testView();</span></span><br><span class="line"><span class="comment">			$testView-&gt;display($data);*/</span></span><br><span class="line">			<span class="variable">$testModel</span> = <span class="title function_ invoke__">M</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">			<span class="variable">$data</span> = <span class="variable">$testModel</span>-&gt;<span class="title function_ invoke__">get</span>();</span><br><span class="line">			<span class="variable">$testView</span> = <span class="title function_ invoke__">V</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">			<span class="variable">$testView</span>-&gt;<span class="title function_ invoke__">display</span>(<span class="variable">$data</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//testModel.class.php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">模型的作用是获取数据并处理,返回数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">testModel</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//testView.class.php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">视图的作用是将获得的数据进行组织,美化等,并最终向用户终端输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">testView</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"><span class="variable">$data</span></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="variable">$data</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="/assets/images/tech/php-mvc-framework-3.png" alt="运行结果"></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 状态码清单</title>
    <url>/2016-01-11-http-state-code-list/</url>
    <content><![CDATA[<p>HTTP 我们常用的网络请求之一，然因为各种网络或者硬件原因，网络请求之后总能拿到一些状态返回码，那么它们到底代表什么意思呢？本文就是将这些常见的状态码加以收集，整理归类。</p>
<span id="more"></span>

<h2 id="1xx消息"><a href="#1xx消息" class="headerlink" title="1xx消息"></a>1xx消息</h2><p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP&#x2F;1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。</p>
<h3 id="100-Continue"><a href="#100-Continue" class="headerlink" title="100 Continue"></a>100 Continue</h3><p>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</p>
<h3 id="101-Switching-Protocols"><a href="#101-Switching-Protocols" class="headerlink" title="101 Switching Protocols"></a>101 Switching Protocols</h3><p>服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。: 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</p>
<h3 id="102-Processing"><a href="#102-Processing" class="headerlink" title="102 Processing"></a>102 Processing</h3><p>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</p>
<h2 id="2xx成功"><a href="#2xx成功" class="headerlink" title="2xx成功"></a>2xx成功</h2><p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</p>
<h3 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h3><p>请求已成功，请求所希望的响应头或数据体将随此响应返回。</p>
<h3 id="201-Created"><a href="#201-Created" class="headerlink" title="201 Created"></a>201 Created</h3><p>请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回’202 Accepted’。</p>
<h3 id="202-Accepted"><a href="#202-Accepted" class="headerlink" title="202 Accepted"></a>202 Accepted</h3><p>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。:返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</p>
<h3 id="203-Non-Authoritative-Information"><a href="#203-Non-Authoritative-Information" class="headerlink" title="203 Non-Authoritative Information"></a>203 Non-Authoritative Information</h3><p>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</p>
<h3 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h3><p>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。<br>如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。<br>由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</p>
<h3 id="205-Reset-Content"><a href="#205-Reset-Content" class="headerlink" title="205 Reset Content"></a>205 Reset Content</h3><p>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。<br>与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</p>
<h3 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h3><p>服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。<br>该请求必须包含Range头信息来指示客户端希望得到的内容范围，并且可能包含If-Range来作为请求条件。<br>响应必须包含如下的头部域：</p>
<p>Content-Range用以指示本次响应中返回的内容的范围；如果是Content-Type为multipart&#x2F;byteranges的多段下载，则每一multipart段中都应包含Content-Range域用以指示本段的内容范围。假如响应中包含Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。<br>Date<br>ETag和／或Content-Location，假如同样的请求本应该返回200响应。<br>Expires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。</p>
<p>假如本响应请求使用了If-Range强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了If-Range弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。<br>假如ETag或Last-Modified头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。<br>任何不支持Range以及Content-Range头的缓存都禁止缓存206响应返回的内容。</p>
<h3 id="207-Multi-Status"><a href="#207-Multi-Status" class="headerlink" title="207 Multi-Status"></a>207 Multi-Status</h3><p>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</p>
<h2 id="3xx重定向"><a href="#3xx重定向" class="headerlink" title="3xx重定向"></a>3xx重定向</h2><p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。</p>
<p>当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP&#x2F;1.0版规范的建议，浏览器不应自动访问超过5次的重定向。</p>
<h3 id="300-Multiple-Choices"><a href="#300-Multiple-Choices" class="headerlink" title="300 Multiple Choices"></a>300 Multiple Choices</h3><p>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。<br>除非这是一个HEAD请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由Content-Type定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。<br>如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的URI；浏览器可能会将这个Location值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</p>
<h3 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h3><p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。<br>新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。<br>如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<br>注意：对于某些使用HTTP&#x2F;1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。</p>
<h3 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h3><p>请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。<br>新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。<br>如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<br>注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</p>
<h3 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h3><p>对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。<br>新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。<br>注意：许多HTTP&#x2F;1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</p>
<h3 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h3><p>如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。<br>该响应必须包含以下的头信息：</p>
<p>Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将Date字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。<br>ETag和／或Content-Location，假如同样的请求本应返回200响应。<br>Expires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。</p>
<p>假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的GET请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。<br>假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。<br>假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</p>
<h3 id="305-Use-Proxy"><a href="#305-Use-Proxy" class="headerlink" title="305 Use Proxy"></a>305 Use Proxy</h3><p>被请求的资源必须通过指定的代理才能被访问。Location域中将给出指定的代理所在的URI信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能创建305响应。<br>注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器创建。忽视这些限制可能导致严重的安全后果。</p>
<h3 id="306-Switch-Proxy"><a href="#306-Switch-Proxy" class="headerlink" title="306 Switch Proxy"></a>306 Switch Proxy</h3><p>在最新版的规范中，306状态码已经不再被使用。</p>
<h3 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h3><p>请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。<br>新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的URI发出访问请求。<br>如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p>
<h2 id="4xx客户端错误"><a href="#4xx客户端错误" class="headerlink" title="4xx客户端错误"></a>4xx客户端错误</h2><p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。</p>
<p>如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。</p>
<h3 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h3><p>由于包含语法错误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。</p>
<h3 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h3><p>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</p>
<h3 id="402-Payment-Required"><a href="#402-Payment-Required" class="headerlink" title="402 Payment Required"></a>402 Payment Required</h3><p>该状态码是为了将来可能的需求而预留的。</p>
<h2 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h2><p>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</p>
<h3 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h3><p>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</p>
<h3 id="405-Method-Not-Allowed"><a href="#405-Method-Not-Allowed" class="headerlink" title="405 Method Not Allowed"></a>405 Method Not Allowed</h3><p>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。<br>鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</p>
<h3 id="406-Not-Acceptable"><a href="#406-Not-Acceptable" class="headerlink" title="406 Not Acceptable"></a>406 Not Acceptable</h3><p>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。<br>除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</p>
<h3 id="407-Proxy-Authentication-Required"><a href="#407-Proxy-Authentication-Required" class="headerlink" title="407 Proxy Authentication Required"></a>407 Proxy Authentication Required</h3><p>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个Proxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy-Authorization信息头用以验证。参见RFC 2617。</p>
<h3 id="408-Request-Timeout"><a href="#408-Request-Timeout" class="headerlink" title="408 Request Timeout"></a>408 Request Timeout</h3><p>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</p>
<h3 id="409-Conflict"><a href="#409-Conflict" class="headerlink" title="409 Conflict"></a>409 Conflict</h3><p>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。<br>冲突通常发生于对PUT请求的处理中。例如，在采用版本检查的环境下，某次PUT提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</p>
<h3 id="410-Gone"><a href="#410-Gone" class="headerlink" title="410 Gone"></a>410 Gone</h3><p>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。<br>410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</p>
<h3 id="411-Length-Required"><a href="#411-Length-Required" class="headerlink" title="411 Length Required"></a>411 Length Required</h3><p>服务器拒绝在没有定义Content-Length头的情况下接受请求。在添加了表明请求消息体长度的有效Content-Length头之后，客户端可以再次提交该请求。</p>
<h3 id="412-Precondition-Failed"><a href="#412-Precondition-Failed" class="headerlink" title="412 Precondition Failed"></a>412 Precondition Failed</h3><p>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</p>
<h3 id="413-Request-Entity-Too-Large"><a href="#413-Request-Entity-Too-Large" class="headerlink" title="413 Request Entity Too Large"></a>413 Request Entity Too Large</h3><p>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。<br>如果这个状况是临时的，服务器应当返回一个Retry-After的响应头，以告知客户端可以在多少时间以后重新尝试。</p>
<h3 id="414-Request-URI-Too-Long"><a href="#414-Request-URI-Too-Long" class="headerlink" title="414 Request-URI Too Long"></a>414 Request-URI Too Long</h3><p>请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：</p>
<p>本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。<br>重定向URI“黑洞”，例如每次重定向把旧的URI作为新的URI的一部分，导致在若干次重定向后URI超长。<br>客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的URI，当GET后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</p>
<h3 id="415-Unsupported-Media-Type"><a href="#415-Unsupported-Media-Type" class="headerlink" title="415 Unsupported Media Type"></a>415 Unsupported Media Type</h3><p>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</p>
<h3 id="416-Requested-Range-Not-Satisfiable"><a href="#416-Requested-Range-Not-Satisfiable" class="headerlink" title="416 Requested Range Not Satisfiable"></a>416 Requested Range Not Satisfiable</h3><p>如果请求中包含了Range请求头，并且Range中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义If-Range请求头，那么服务器就应当返回416状态码。<br>假如Range使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个Content-Range实体头，用以指明当前资源的长度。这个响应也被禁止使用multipart&#x2F;byteranges作为其Content-Type。</p>
<h3 id="417-Expectation-Failed"><a href="#417-Expectation-Failed" class="headerlink" title="417 Expectation Failed"></a>417 Expectation Failed</h3><p>在请求头Expect中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect的内容无法被满足。</p>
<h3 id="418-I’m-a-teapot"><a href="#418-I’m-a-teapot" class="headerlink" title="418 I’m a teapot"></a>418 I’m a teapot</h3><p>本操作码是在1998年作为IETF的传统愚人节笑话, 在RFC 2324 超文本咖啡壶控制协议中定义的，并不需要在真实的HTTP服务器中定义。</p>
<h3 id="421-There-are-too-many-connections-from-your-internet-address"><a href="#421-There-are-too-many-connections-from-your-internet-address" class="headerlink" title="421 There are too many connections from your internet address"></a>421 There are too many connections from your internet address</h3><p>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</p>
<h3 id="422-Unprocessable-Entity"><a href="#422-Unprocessable-Entity" class="headerlink" title="422 Unprocessable Entity"></a>422 Unprocessable Entity</h3><p>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）</p>
<h3 id="423-Locked"><a href="#423-Locked" class="headerlink" title="423 Locked"></a>423 Locked</h3><p>当前资源被锁定。（RFC 4918 WebDAV）</p>
<h3 id="424-Failed-Dependency"><a href="#424-Failed-Dependency" class="headerlink" title="424 Failed Dependency"></a>424 Failed Dependency</h3><p>由于之前的某个请求发生的错误，导致当前请求失败，例如PROPPATCH。（RFC 4918 WebDAV）</p>
<h3 id="425-Unordered-Collection"><a href="#425-Unordered-Collection" class="headerlink" title="425 Unordered Collection"></a>425 Unordered Collection</h3><p>在WebDav Advanced Collections草案中定义，但是未出现在《WebDAV顺序集协议》（RFC 3658）中。</p>
<h3 id="426-Upgrade-Required"><a href="#426-Upgrade-Required" class="headerlink" title="426 Upgrade Required"></a>426 Upgrade Required</h3><p>客户端应当切换到TLS&#x2F;1.0。（RFC 2817）</p>
<h3 id="449-Retry-With"><a href="#449-Retry-With" class="headerlink" title="449 Retry With"></a>449 Retry With</h3><p>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</p>
<h2 id="5xx服务器错误"><a href="#5xx服务器错误" class="headerlink" title="5xx服务器错误"></a>5xx服务器错误</h2><p>这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。</p>
<p>这些状态码适用于任何响应方法。</p>
<h3 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h3><p>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</p>
<h3 id="501-Not-Implemented"><a href="#501-Not-Implemented" class="headerlink" title="501 Not Implemented"></a>501 Not Implemented</h3><p>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</p>
<h3 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h3><p>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</p>
<h3 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h3><p>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。</p>
<h3 id="504-Gateway-Timeout"><a href="#504-Gateway-Timeout" class="headerlink" title="504 Gateway Timeout"></a>504 Gateway Timeout</h3><p>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。<br>注意：某些代理服务器在DNS查询超时时会返回400或者500错误</p>
<h3 id="505-HTTP-Version-Not-Supported"><a href="#505-HTTP-Version-Not-Supported" class="headerlink" title="505 HTTP Version Not Supported"></a>505 HTTP Version Not Supported</h3><p>服务器不支持，或者拒绝支持在请求中使用的HTTP版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</p>
<h3 id="506-Variant-Also-Negotiates"><a href="#506-Variant-Also-Negotiates" class="headerlink" title="506 Variant Also Negotiates"></a>506 Variant Also Negotiates</h3><p>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</p>
<h3 id="507-Insufficient-Storage"><a href="#507-Insufficient-Storage" class="headerlink" title="507 Insufficient Storage"></a>507 Insufficient Storage</h3><p>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV（RFC 4918）</p>
<h3 id="509-Bandwidth-Limit-Exceeded"><a href="#509-Bandwidth-Limit-Exceeded" class="headerlink" title="509 Bandwidth Limit Exceeded"></a>509 Bandwidth Limit Exceeded</h3><p>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</p>
<h3 id="510-Not-Extended"><a href="#510-Not-Extended" class="headerlink" title="510 Not Extended"></a>510 Not Extended</h3><p>获取资源所需要的策略并没有没满足。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 二维码扫描</title>
    <url>/2015-12-26-ios-qrcode-scaner/</url>
    <content><![CDATA[<p>二维条码&#x2F;二维码（2-dimensional bar code）是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理：它具有条码技术的一些共性：每种码制有其特定的字符集；每个字符占有一定的宽度；具有一定的校验功能等。同时还具有对不同行的信息自动识别功能、及处理图形旋转变化点。</p>
<p>在这么一个二维码泛滥的时代，一般的App都会支持二维码扫描，那么这个功能应该如何实现呢？</p>
<span id="more"></span>

<p>这几天博主高仿新浪微博的项目进行一个阶段性的tag，在此也将这个项目在实现二维码扫描这个功能来做一个简要的记录。</p>
<p>关于二维码的扫描，网上说的最多的框架莫过于<a href="https://github.com/bmorton/ZBarSDK">ZBar</a>和ZXing框架，刚开始也是想使用第三方框架，但是，在iOS7之后苹果官方已经提供了二维码扫描方法，而且实现起来还是蛮简单的，故而选择原生态方法。不过，我们还是来看看，如何使用ZBar实现二维码扫描。</p>
<p>首先在github上下载ZBar代码，然后将如下的相关类库添加进去：　</p>
<ul>
<li>AVFoundation.framwork</li>
<li>CoreMedia.framework</li>
<li>CoreVideo.framework</li>
<li>libiconv.dylib</li>
<li>libzbar.a</li>
</ul>
<p>接下来在.h文件中#import “ZBarSDK.h”，同时添加代理ZBarReaderDelegate，然后在.m文件中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(void)sysbutbuttonclick&#123;</span><br><span class="line">      </span><br><span class="line">     ZBarReaderViewController *reader = [ZBarReaderViewController new];</span><br><span class="line">     reader.readerDelegate = self;</span><br><span class="line">     ZBarImageScanner *scanner = reader.scanner;</span><br><span class="line">      </span><br><span class="line">     [scanner setSymbology: ZBAR_I25</span><br><span class="line">                    config: ZBAR_CFG_ENABLE</span><br><span class="line">                        to: 0];</span><br><span class="line">     [self presentModalViewController: reader    animated: YES];</span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line"> - (void) imagePickerController: (UIImagePickerController*) reader</span><br><span class="line">  didFinishPickingMediaWithInfo: (NSDictionary*) info</span><br><span class="line"> &#123;</span><br><span class="line">      </span><br><span class="line">     NSLog(@&quot;info=%@&quot;,info);</span><br><span class="line">     // 得到条形码结果</span><br><span class="line">     id&lt;NSFastEnumeration&gt; results =[info objectForKey: ZBarReaderControllerResults];</span><br><span class="line">     ZBarSymbol *symbol = nil;</span><br><span class="line">     for(symbol in results)</span><br><span class="line">         // EXAMPLE: just grab the first barcode</span><br><span class="line">         break;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">     UIAlertView *alert=[[UIAlertView alloc] initWithTitle:@&quot;信息提示!&quot; message:symbol.data delegate:self cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:@&quot;确定&quot;, nil];</span><br><span class="line">     [alert show];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 最后触发扫描事件的时候调用sysbutbuttonclick即可。</p>
<p>博主在项目中使用的是苹果官方提供的，并将其实现单独封装，以方便使用。</p>
<p>其实我们只需要三个步骤即可实现二维码扫描功能：</p>
<p>1）导入AVFoundation框架，<code>import &lt;AVFoundation/AVFoundation.h&gt;</code>；</p>
<p>2）设置一个用于显示扫描的view；</p>
<p>3）实例化AVCaptureSession、AVCaptureVideoPreviewLayer。</p>
<p>具体实现方式如下：</p>
<p>1）添加开始扫描方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)startReading</span><br><span class="line">&#123;</span><br><span class="line">    NSError *error;</span><br><span class="line">     </span><br><span class="line">    //1.初始化捕捉设备（AVCaptureDevice），类型为AVMediaTypeVideo</span><br><span class="line">    AVCaptureDevice *captureDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];</span><br><span class="line">     </span><br><span class="line">    //2.用captureDevice创建输入流</span><br><span class="line">    AVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:captureDevice error:&amp;error];</span><br><span class="line">    if (!input) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, [error localizedDescription]);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //3.创建媒体数据输出流</span><br><span class="line">    AVCaptureMetadataOutput *captureMetadataOutput = [[AVCaptureMetadataOutput alloc] init];</span><br><span class="line">     </span><br><span class="line">    //4.实例化捕捉会话</span><br><span class="line">    _captureSession = [[AVCaptureSession alloc] init];</span><br><span class="line">    //4.1.将输入流添加到会话</span><br><span class="line">    [_captureSession addInput:input];</span><br><span class="line">    //4.2.将媒体输出流添加到会话中</span><br><span class="line">    [_captureSession addOutput:captureMetadataOutput];</span><br><span class="line">     </span><br><span class="line">    //5.创建串行队列，并加媒体输出流添加到队列当中</span><br><span class="line">    dispatch_queue_t dispatchQueue;</span><br><span class="line">    dispatchQueue = dispatch_queue_create(&quot;myScanQueue&quot;, NULL);</span><br><span class="line">    //5.1.设置代理</span><br><span class="line">    [captureMetadataOutput setMetadataObjectsDelegate:self queue:dispatchQueue];</span><br><span class="line">    //5.2.设置输出媒体数据类型为QRCode</span><br><span class="line">    [captureMetadataOutput setMetadataObjectTypes:[NSArray arrayWithObject:AVMetadataObjectTypeQRCode]];</span><br><span class="line">     </span><br><span class="line">    //6.实例化预览图层</span><br><span class="line">    _videoPreviewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:_captureSession];</span><br><span class="line">     </span><br><span class="line">    //7.设置预览图层填充方式</span><br><span class="line">    [_videoPreviewLayer setVideoGravity:AVLayerVideoGravityResizeAspectFill];</span><br><span class="line">     </span><br><span class="line">    //8.设置图层的frame</span><br><span class="line">    [_videoPreviewLayer setFrame:_viewPreview.layer.bounds];</span><br><span class="line">     </span><br><span class="line">    //9.将图层添加到预览view的图层上</span><br><span class="line">    [_viewPreview.layer addSublayer:_videoPreviewLayer];</span><br><span class="line">     </span><br><span class="line">    //10.设置扫描范围</span><br><span class="line">    captureMetadataOutput.rectOfInterest = CGRectMake(0.2f, 0.2f, 0.8f, 0.8f);</span><br><span class="line">    //10.1.扫描框</span><br><span class="line">    _boxView = [[UIView alloc] initWithFrame:CGRectMake(_viewPreview.bounds.size.width * 0.1f, _viewPreview.bounds.size.height * 0.2f, _viewPreview.bounds.size.width * 0.8f, _viewPreview.bounds.size.width * 0.8f)];</span><br><span class="line">    _boxView.layer.borderColor = kRangeColor;</span><br><span class="line">    _boxView.layer.borderWidth = 1.0f;</span><br><span class="line">    [_viewPreview addSubview:_boxView];</span><br><span class="line">    //10.2.扫描线</span><br><span class="line">    _scanLayer = [[CALayer alloc] init];</span><br><span class="line">    _scanLayer.frame = CGRectMake(0, 0, _boxView.bounds.size.width, kLineBorad);</span><br><span class="line">    _scanLayer.backgroundColor = kLineColor;</span><br><span class="line">    [_boxView.layer addSublayer:_scanLayer];</span><br><span class="line">     </span><br><span class="line">    NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:0.2f target:self selector:@selector(moveScanLayer:) userInfo:nil repeats:YES];   </span><br><span class="line">    [timer fire];</span><br><span class="line">     </span><br><span class="line">    //11.开始扫描</span><br><span class="line">    [_captureSession startRunning];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）实现代理方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma mark - AVCaptureMetadataOutputObjectsDelegate</span><br><span class="line">- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection</span><br><span class="line">&#123;</span><br><span class="line">    NSString *urlStr;</span><br><span class="line">    //判断是否有数据</span><br><span class="line">    if (metadataObjects != nil &amp;&amp; [metadataObjects count] &gt; 0) &#123;</span><br><span class="line">        AVMetadataMachineReadableCodeObject *metadataObj = [metadataObjects objectAtIndex:0];</span><br><span class="line">        //判断回传的数据类型</span><br><span class="line">        if ([[metadataObj type] isEqualToString:AVMetadataObjectTypeQRCode]) &#123;</span><br><span class="line">            urlStr = metadataObj.stringValue;</span><br><span class="line">            [self performSelectorOnMainThread:@selector(stopReading) withObject:nil waitUntilDone:NO];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    _videoPreviewLayer.hidden = YES;</span><br><span class="line">    _webView.hidden = NO;</span><br><span class="line">    NSURLRequest *request =[NSURLRequest requestWithURL:[NSURL URLWithString:urlStr]];</span><br><span class="line">    [self.webView loadRequest:request];   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）设置好页面布局，用来显示扫描结果即可。</p>
<p>以上就是两种二维码扫描实现简要过程。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>外设</tag>
      </tags>
  </entry>
  <entry>
    <title>拆拆 iOS 数据持久化</title>
    <url>/2016-01-19-ios-data-persistence/</url>
    <content><![CDATA[<p>持久存储是一种非易失性存储，在重启设备时也不会丢失数据。Cocoa框架提供了几种数据持久化机制：</p>
<p>1）属性列表；</p>
<p>2）对象归档；</p>
<p>3）iOS的嵌入式关系数据库SQLite3；</p>
<p>4）Core Data。</p>
<p>在iOS开发中，持久化数据的方法也并不限于属性列表、对象归档、SQLite3和Core Data。它们只是四种最常用且简单的方法。其实也可以使用传统C语言I&#x2F;O调用（比如，fopen()）读写数据，也可以使用Cocoa的底层文件管理工具。只不过这两种方法都需要写很多代码，并且没有必要这么做。</p>
<span id="more"></span>

<h1 id="一、应用的沙盒"><a href="#一、应用的沙盒" class="headerlink" title="一、应用的沙盒"></a>一、应用的沙盒</h1><p>Cocoa提供的四种数据持久化机制都涉及一个共同因素，即应用的&#x2F;Documents文件夹。每个应用都有自己的&#x2F;Documents文件夹，且能读写各自的&#x2F;Documents目录中的内容。</p>
<p>为了便于理解，我们先来看一下iPhone模拟器使用的文件夹布局，从而了解iOS中应用是如何组织的。打开Finder窗口，找到主目录，找到Library（资源库）目录，找到Developer&#x2F;CoreSimulator&#x2F;Devices&#x2F;，在该目录中可以看到一些子目录，分别对应Xcode中的模拟器。子目录的名称是Xcode自动生成的GUID（Globally Unique Identifier，全局唯一标识符），因此无法确定每个目录对应哪一个模拟器。解决这个问题的方法是找到模拟器目录中名为device.plist的文件，并打开它，就可以看见一个对应模拟器设备名称的键。</p>
<p>虽然这是模拟器的目录，但实际设备上的文件结构与此相似。如果想看到设备上应用程序的沙盒，就将它连接到Mac上并打开Xcode的Devices窗口，在窗口边侧栏可以看到该设备，选中它然后在Installed Apps表中选择一个应用程序。在表的下方有一个看起来像齿轮的图表。点击它并在弹出菜单中选择Show Container选项就可以看到应用程序沙盒的内容。</p>
<p>每个应用程序沙盒都包含以下三个目录：</p>
<p>1）Documents：应用程序可以将数据存储在Documents目录中。如果这个应用程序启用了iTunes文件分享功能，用户就可以在iTunes中看到目录的内容（以及应用程序创建的所有子目录），还可以对其更新文件。</p>
<p>如果要为应用程序启用文件分享功能，需要打开它的Info.plist文件并添加键为Application supports iTunes file sharing值为YES的条目。</p>
<p>2）Library：应用程序也可以在这里存储数据。它用来存放不想共享给用户的文件。需要时可以创建自己的子目录。系统创建了名为Cache和Preferences的子目录。后者包含了存储应用程序偏好设置的plist文件，通过NSUserDefaults来操作。</p>
<p>3）tmp：tmp目录供应用存储临时文件。当iOS设备执行同步时，iTunes不会备份tmp中的文件。在不需要这些文件时，应用要负责删除tmp中的文件，以免占用文件系统空间。</p>
<h2 id="获取Documents目录"><a href="#获取Documents目录" class="headerlink" title="获取Documents目录"></a>获取Documents目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSString *documentsDirectory = paths[0];</span><br></pre></td></tr></table></figure>

<p>常量<code>NSDocumentDirectory</code>表明我们正在查找Documents目录的路径。第二个常量<code>NSUserDomainMask</code>表明我们希望将搜索限制在应用的沙盒内，在OS X中表明我们希望该函数查看用户的主目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *filename = [documentsDirectory stringByAppendingPathComponent:@”theFile.txt”];</span><br></pre></td></tr></table></figure>
<p>完成此调用之后，filename就包含了指向应用Documents目录中theFile.txt文件的完整路径。</p>
<h2 id="获取Library目录"><a href="#获取Library目录" class="headerlink" title="获取Library目录"></a>获取Library目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSString *libraryDirectory = paths[0];</span><br></pre></td></tr></table></figure>

<p>常量<code>NSLibraryDirectory</code>表明我们正在查找Library目录的路径。第二个常量<code>NSUserDomainMask</code>表明我们希望将搜索限制在应用的沙盒内，在OS X中表明我们希望该函数查看用户的主目录。</p>
<h2 id="获取tmp目录"><a href="#获取tmp目录" class="headerlink" title="获取tmp目录"></a>获取tmp目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *tempPath = NSTemporaryDirectory();</span><br><span class="line">NSString *filename = [tempPath stringByAppendingPathComponent:@”theFile.txt”];</span><br></pre></td></tr></table></figure>

<h1 id="二、文件保存方案"><a href="#二、文件保存方案" class="headerlink" title="二、文件保存方案"></a>二、文件保存方案</h1><p>Cocoa提供的四种实现数据持久化的方法，都使用iOS的文件系统。使用SQLite3将创建一个SQLite3数据库文件，并让SQLite3去存储和检索数据。Core Data则以其最简单的形式帮助开发者完成所有的文件系统的管理工作。使用属性列表则需要考虑将数据存储在一个文件中，还是存储在多个文件中。</p>
<h2 id="单文件持久化"><a href="#单文件持久化" class="headerlink" title="单文件持久化"></a>单文件持久化</h2><p>把数据保存在一个文件中是最简单的方法，而且对于许多应用，这也是完全可以接受的方法。首先，创建一个根对象，通常是数组或字典（使用归档容器的情况下根对象可以给予这个自定义类）。接下来，使用所有需要保存的程序数据填充根对象。真正保存时，代码会将该根对象的全部内容重新写入单个文件。应用在启动时会将该文件的全部内容读入内存，并在退出时注销。</p>
<p>使用单文件的缺点：必须将全部数据加载到内存中，并且不管有多小的更改也必须将所有数据全部重新写入文件系统。</p>
<h2 id="多文件持久化"><a href="#多文件持久化" class="headerlink" title="多文件持久化"></a>多文件持久化</h2><p>使用多文件持久化是另一种实现持久化的方法。例如，电子邮件应用可能会将每封邮件都单独存储在一个文件中。</p>
<p>这种方法的优点，例如应用可以只加载用户请求的数据（另一种形式的延迟加载），当用户进行更改时只保存更改的文件。此方法允许开发者在收到内存不足通知时释放内存。用户当前未查看的任何数据都可以从内存中删除，下次需要时再从文件系统重新加载即可。</p>
<p>使用多文件持久化的缺点：它大大增加了应用的复杂性。</p>
<h1 id="三、属性列表"><a href="#三、属性列表" class="headerlink" title="三、属性列表"></a>三、属性列表</h1><p>属性列表使用起来非常方便，可以使用Xcode或Property List Editor应用手动编辑它们。而且只要字典或数组包含特定可序列化对象，就可以将NSDictionary和NSArray实例写入属性列表或者从属性列表创建它们。</p>
<h2 id="属性列表序列化"><a href="#属性列表序列化" class="headerlink" title="属性列表序列化"></a>属性列表序列化</h2><p>序列化对象，是指可以被转换为字节流以便于存储到文件中或通过网络进行传输的对象。虽然任何对象都可以被序列化，但是只有某些对象才能放置到某个集合类中（如NSDictionary或NSArray中），然后才使用该集合类的writeToFile:atomically:或writeToURL:atomically:方法将它们存储到属性列表中。可以按照该方法序列化下面的类：</p>
<p>1）NSArray、NSMutableArray</p>
<p>2）NSDictionary、NSMutableDictionary</p>
<p>3）NSData、NSMutableData</p>
<p>4）NSString、NSMutableString</p>
<p>5）NSNumber</p>
<p>6）NSDate</p>
<p>如果只使用这些对象构建数据模型，就可以使用属性列表来方便地保护和加载数据。如果打算使用属性列表持久保存应用数据，则可以使用数组或字典。假设放到字典或数组中的所有对象都是前面列出的可序列化对象，则可以通过对字典或数组的实例调用writeToFile:atomically:方法来写入属性列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[myArray writeToFile:@”/some/file/location/output.plist” atomically:YES];</span><br></pre></td></tr></table></figure>

<p>说明：这里的atomically参数让该方法将数据写入辅助文件，而不是写入指定位置。成功写入该文件之后，辅助文件将被复制到第一个参数指定的位置。这是更安全的写入文件的方法，因为如果应用在保存期间崩溃，则现有文件（如果有）不会被破坏。尽管增加一点开销，但是多数情况下还是值得的。</p>
<p>属性列表方法的一个问题就是，无法将自定义对象序列化到属性列表中，另外也不能使用没有在可序列化对象类型列表中指定的Cocoa Touch的其他类。这意味着无法使用NSURL、UIImage和UIColor等类。</p>
<p>且不说序列化问题，将这些模型对象保存到属性列表中还意味着无法轻松创建派生的或需要计算的属性（例如，等于两个属性之后的属性），并且必须将实际上应该包含在模型中的某些代码移动到控制器类。这些限制也适用于简单数据模型和简单应用。但在多数情况下，如果创建了专用的模型类，则应用更容易维护。</p>
<p>在复杂的应用中，简单属性列表仍然非常有用。它们是将静态数据包含在应用中的最佳方法。例如，当应用包含一个选取器时，创建一个属性列表文件并将其放在项目的Resources文件夹中，就是将项目列表包含到选取器中的最佳方法，这样能把项目列表编译到应用中。</p>
<h2 id="NSData"><a href="#NSData" class="headerlink" title="NSData"></a>NSData</h2><p>NSData主要是提供一块原始数据的封装，方便数据的封装与流动，比较常见的是NSString&#x2F;NSImage数据的封装与传递。在应用中，最常用于访问存储在文件中或者网络资源中的数据。</p>
<p>这个类提供的封装&#x2F;解封方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+(id)dataWithBytes:(const void *)bytes length:(NSUInteger)length;</span><br><span class="line">-(NSUInteger)length;</span><br><span class="line">-(const void *)bytes NS_RETURNS_INNER_POINTER;</span><br></pre></td></tr></table></figure>

<p>从这几个方法可以看出，NSData根本不管传递的内容到底是什么，仅仅是传递一块内存——仅需内存的起始地址和长度。</p>
<h2 id="解析plist"><a href="#解析plist" class="headerlink" title="解析plist"></a>解析plist</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idresult = [NSPropertyListSerialization propertyListWithData:data options:0format:NULL error:NULL];</span><br></pre></td></tr></table></figure>

<h2 id="读写plist"><a href="#读写plist" class="headerlink" title="读写plist"></a>读写plist</h2><p>1）写入文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSArray*phrase;</span><br><span class="line">phrase =[NSArray arrayWithObjects:@&quot;I&quot;, @&quot;seem&quot;, @&quot;to&quot;,@&quot;be&quot; ,@&quot;a&quot;, @&quot;verb&quot;, nil];</span><br><span class="line">[phrasewriteToFile:@&quot;/tmp/verbiage.txt&quot; atomically:YES];</span><br></pre></td></tr></table></figure>

<p>现在看一下文件&#x2F;tmp&#x2F;verbiage.txt，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xmlversion=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPEplist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot;</span><br><span class="line"> &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plistversion=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">  &lt;string&gt;I&lt;/string&gt;</span><br><span class="line">  &lt;string&gt;seem&lt;/string&gt;</span><br><span class="line">  &lt;string&gt;to&lt;/string&gt;</span><br><span class="line">  &lt;string&gt;be&lt;/string&gt;</span><br><span class="line">  &lt;string&gt;a&lt;/string&gt;</span><br><span class="line">  &lt;string&gt;verb&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>

<p>这些属性列表文件可以为任意复杂的形式，可以是包含字符串、数字和日期数组的字典数组。Xcode还包含一个属性列表编辑器，所以可以查看plist文件并进行编辑。</p>
<p><strong>说明：</strong>有些属性列表文件（特别是首选项文件）是以压缩的二进制格式存储的。通过使用plutil命令：<code>plutil -convert xml1 filename.plist</code>，可以将这些文件转换为人们可读的形式。</p>
<p>2）读取</p>
<p>之前已经将verbiage.txt文件存放在磁盘上，可以使用<code>+arrayWithContentsOfFile:</code>方法读取该文件。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSArray*pharse = [NSArray arrayWithContentsOfFile:@&quot;/tmp/ verbiage.txt &quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,phrase);</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>注意到<code>writeToFile:</code>方法中的单词<code>atomically</code>了吗？这种调用有什么负面作用吗？没有。<code>atomically:</code>参数的值为BOOL类型，用于通知Cocoa是否应该首先将文件内容保存在临时文件中，当文件成功保存后，再将该临时文件和原始文件交换。这是一种安全机制：如果在保存过程中出现意外，不会破坏原始文件。但这种安全机制需要付出一定的代价：在保存过程中，由于原始文件仍然保存在磁盘中，所以需要使用双倍的磁盘空间。除非保存的文件非常大，将会占用用户硬盘空间，否则应该自动保存文件。</p>
<p>如果能将数据精简为属性列表类型，则可以使用这些非常便捷的调用来将内容保存到磁盘中，供以后读取。如果你正在从事一项新创意或设计一个新项目，可以使用这些便捷方法来快速编写和运行程序。即使只想把数据块保存到磁盘中，并且根本不需要使用对象，也可以使用NSData来简化工作。只需要将数据包装在一个NSData对象中，然后再NSData对象上调用<code>writeToFile: atomically:</code>方法。</p>
<p>这些函数的一个缺点就是，它们不会返回任何错误信息。如果不能加载文件，只能从方法中得到nil指针，而不能确定出现了何种错误。</p>
<h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>在Xcode中，使用Single View Application模板创建一个项目，命名Persistence，点击Main.storyboard，布局如下图</p>
<p><img src="/assets/images/tech/ios-data-persistence-1.png" alt="布局"></p>
<p>连线，添加处理函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface PlistViewController ()</span><br><span class="line">- (IBAction)saveClicked:(id)sender;</span><br><span class="line">@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">    </span><br><span class="line">    NSString *filePath = [self dataFilePath];</span><br><span class="line">    if ([[NSFileManager defaultManager] fileExistsAtPath:filePath]) &#123;</span><br><span class="line">        NSArray *array = [[NSArray alloc] initWithContentsOfFile:filePath];</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            UITextField *theField = self.lineFields[i];</span><br><span class="line">            theField.text = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSString *)dataFilePath&#123;</span><br><span class="line">    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">    NSString *documentsDirectory = [paths objectAtIndex:0];</span><br><span class="line">    return [documentsDirectory stringByAppendingPathComponent:@&quot;data.plist&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)saveClicked:(id)sender &#123;</span><br><span class="line">    NSString *filePath = [self dataFilePath];</span><br><span class="line">    NSArray *array = [self.lineFields valueForKey:@&quot;text&quot;];</span><br><span class="line">    [array writeToFile:filePath atomically:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、归档"><a href="#四、归档" class="headerlink" title="四、归档"></a>四、归档</h1><p>在Cocoa世界中，归档是指另一中形式的序列化，但它是任何对象都可以实现的更常规的类型。专门编写用于保存数据的任何模型对象都应该支持归档。使用对模型对象进行归档的技术可以轻松将复杂的对象写入文件，然后再从中读取它们。</p>
<p>只要在类中实现的每个属性都是标量（如整型或浮点型）或都是遵循NSCoding协议的某个类的实例，就可以对整个对象进行完全的归档。由于大多数支持存储数据的Foundation和Cocoa Touch类都遵循NSCoding协议（不过，有一些例外，如UIImage），对于大多数类来说，归档相对而言比较容易实现。</p>
<p>尽管对归档的使用没有严格要求，但还有一个协议应该与NSCoding一起实现，即NSCopying协议。后者允许复制对象，这使开发者在使用数据模型对象时具备了较大的灵活性。</p>
<h2 id="遵循NSCoding协议"><a href="#遵循NSCoding协议" class="headerlink" title="遵循NSCoding协议"></a>遵循NSCoding协议</h2><p>NSCoding协议声明了两个必须实现的方法，一个方法将对象编码到归档中，另一个方法对归档解码来创建一个新对象。这两个方法都传递一个NSCoder实例，使用方式与NSUserDefaults非常相似。也可以使用KVC对对象和原生数据类型进行编码和解码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@protocolNSCoding</span><br><span class="line">-(void)encodeWithCoder:(NSCoder*)aCoder;</span><br><span class="line">-(id)initWithCoder:(NSCoder*)aDecoder;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>当对象需要保存自身时，<code>encodeWithCoder:</code>方法将被调用；当对象需要加载自身时，<code>initWithCoder:</code>方法将被调用。</p>
<p>那么，这个编码器是什么呢？NSCoder是一个抽象类，定义一些有用的方法来在对象与NSData之间来回转换。完全不需要创建新NSCoder，因为它实际上并无多大作用。但是，我们实际上要使用NSCoder的一些具体的子类来编码和解码对象。我们将使用其中两个子类NSKeyedArchiver和NSKeyedUnarchiver。</p>
<p><code>initWithCoder:</code>和其他任何init方法一样，在对对象执行操作之前，需要使用超类对它们进行初始化。为此，可以采用两种方式，具体取决于父类。如果父类采用NSCoding协议，则应该调用<code>[super initWithCoder:decoder]</code>；否则，只需要调用<code>[super init]</code>即可。NSObject不采用NSCoding协议，因此我们使用简单的init方法。</p>
<p><code>+ archivedDataWithRootObject:</code>类方法编码thing对象。首先，它在后台创建一个NSKeyedArchiver实例；然后，它将NSKeyedArchiver实例传递给对象thing的<code>-encodeWithCoder:</code>方法。当thing编码自身的属性时，它可能对其他对象也进行编码，例如，字符串、数组以及我们可能输入到该数组中的任何内容。整个对象集合完成键和值的编码后，具有键&#x2F;值对的归档程序将所有对象扁平化为一个NSData类并将其返回。</p>
<p>如果愿意，可以使用<code>-writeToFile:atomically:</code>方法将这个NSData类保存到磁盘中。在此，我们先处理thing对象，然后通过freezeDried表示法重新创建它，并将它输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thing =[NSKeyedUnarchiveObjectWithData: freezeDried];</span><br><span class="line">NSLog(@&quot;reconstitutedthing:%@&quot;,thing);</span><br></pre></td></tr></table></figure>

<p>如果被编码的数据中含有循环将会怎么样？例如，如果thing包含在自身的subThingies数组中会怎样？thing会对数组进行编码吗？哪个对象对thing进行编码，哪个对象对数组进行编码，哪个对象再次对thing进行编码，依此类推？幸运的是，Cocoa在归档程序和解压程序实现上非常灵活，能够保存并恢复对象周期。</p>
<h2 id="实现NSCopying协议"><a href="#实现NSCopying协议" class="headerlink" title="实现NSCopying协议"></a>实现NSCopying协议</h2><p>遵循NSCopying对于任何数据模型对象来说都是非常好的事情。NSCopying有一个copyWithZone:方法，可用来复制对象。实现NSCopying与实现initWithCoder:非常相似，只需要创建一个同一类的新实例，然后将新实例的所有属性都设置为与该对象属性相同的值即可。</p>
<p>说明：不要过于担心NSZone参数。它指向系统用于管理内存的struct。只有在极少数情况下，开发者才需要关注zone或者创建自己的zone。目前，还没有使用多个zone的说法。对某个对象调用copy的方法与使用默认zone调用copyWithZone的方法完全相同，几乎始终能满足你的需求。事实上，现在的iOS上完全可以忽略zone。NSCopying用zone在本质上是考虑向后兼容性所致。</p>
<h2 id="创建工程-1"><a href="#创建工程-1" class="headerlink" title="创建工程"></a>创建工程</h2><p>按照上文创建工程，设计界面（与上文界面相同），连线，添加响应方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &quot;ArchiverViewController.h&quot;</span><br><span class="line">#import &quot;Lines.h&quot;</span><br><span class="line"></span><br><span class="line">static NSString *const kRootKey = @&quot;kRootKey&quot;;</span><br><span class="line"></span><br><span class="line">@interface ArchiverViewController ()</span><br><span class="line">- (IBAction)saveClicked:(id)sender;</span><br><span class="line">@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">    </span><br><span class="line">    NSString *filePath = [self dataFilePath];</span><br><span class="line">    if ([[NSFileManager defaultManager] fileExistsAtPath:filePath]) &#123;</span><br><span class="line">        NSData *data = [[NSMutableData alloc] initWithContentsOfFile:filePath];</span><br><span class="line">        NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];</span><br><span class="line">        Lines *lines = [unarchiver decodeObjectForKey:kRootKey];</span><br><span class="line">        [unarchiver finishDecoding];</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            UITextField *theField = self.lineFields[i];</span><br><span class="line">            theField.text = lines.lines[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSString *)dataFilePath&#123;</span><br><span class="line">    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">    NSString *documentsDirectory = [paths objectAtIndex:0];</span><br><span class="line">    return [documentsDirectory stringByAppendingPathComponent:@&quot;data.archive&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)saveClicked:(id)sender &#123;</span><br><span class="line">    NSString *filePath = [self dataFilePath];</span><br><span class="line">    Lines *lines = [[Lines alloc] init];</span><br><span class="line">    lines.lines = [self.lineFields valueForKey:@&quot;text&quot;];</span><br><span class="line">    NSMutableData *data = [[NSMutableData alloc] init];</span><br><span class="line">    NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];</span><br><span class="line">    [archiver encodeObject:lines forKey:kRootKey];</span><br><span class="line">    [archiver finishEncoding];</span><br><span class="line">    [data writeToFile:filePath atomically:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与属性列表序列化实现多几行代码，那么是否就是使用归档比使用序列化属性列表更有优势呢？答案是否定的。如果我们拥有一个包含可归档对象的数组，则可以对数组实例本身进行归档来归档整个数组。对集合类（如数组）进行归档时，也会归档其包含的所有对象。只要放入数组或字典中的对象遵循NSCoding，就可以归档数组或字典并还原它。这样，对其进行归档时，其中所有对象都将位于已还原的数组和字典中。这一点并不适用于属性链接的持久化，它只支持一小部分的Foundation对象类型。如果没有编写额外的代码，来将这些自定义类的实例与字典通过每个对象属性的键进行互相转化，就不能对其进行持久化。</p>
<p>换句话说，NSCoding方法具有非常好的伸缩性，因为无论添加多少对象，将这些对象写入磁盘的方式都完全相同。不过使用属性列表的话，工作量会随着添加对象而增加。</p>
<h1 id="五、SQLite3"><a href="#五、SQLite3" class="headerlink" title="五、SQLite3"></a>五、SQLite3</h1><p>SQLite3在存储和检索大量数据方面非常有效。它能够对数据进行复杂的聚合，与使用对象执行这些操作相比，获得结果的速度更快。</p>
<p>SQLite3使用SQL（Structured Query Language，结构化查询语言），SQL是与关系数据库交互的标准语言。</p>
<p>这里推荐两篇SQLite3深入研究探索的参考文章：</p>
<p>An Introduction to the SQLite3 C&#x2F;C++ Interface (<a href="http://www.sqlite.org/cintro.html">www.sqlite.org/cintro.html</a>)</p>
<p>SQL As Understood by SQLite (<a href="http://www.sqlite.org/lang.html">www.sqlite.org/lang.html</a>)</p>
<p>关系数据库（包括SQLite3）和面向对象的编程语言使用完全不同的方法来存储和组织数据。这些方法差异很大，因而出现了在两者之间进行转换的各种技术以及很多库和工具。这些技术统称为ORM（Object-Relational-Mapping，对象关系映射）。目前有很多种ORM工具可用于Cocoa Touch。</p>
<h2 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h2><p>虽然可以通过创建SQL字符串来插入值，但常用的方法是使用绑定变量来执行数据库插入操作。正确处理字符串并确保它们没有无效字符（以及引号处理过的属性）是非常烦琐的事情。借助绑定变量，这些问题将迎刃而解。</p>
<p>要使用绑定变量插入值，只需要按正常方式创建SQL语句即可，不过要在SQL字符串中添加一个问号。每个问号都表示一个需要在语句执行之前进行绑定的变量。然后，准备好SQL语句，将值绑定到各个变量并执行命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*将整型数据绑定到第一个变量，将字符串绑定到第二个变量，然后执行并结束语句*/</span><br><span class="line">char *sql = “insert into foo values (?, ?);”;</span><br><span class="line">sqlite3_stmt *stmt;</span><br><span class="line"></span><br><span class="line">if(sqlite3_prepare_v2(database, sql, -1, &amp;stmt, nil) == SQLITE_OK)&#123;</span><br><span class="line">    sqlite3_bind_int(stmt, 1, 235);</span><br><span class="line">    sqlite3_bind_text(stmt, 2, “Bar”, -1, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(sqlite3_step(stmt) != SQLITE_DONE)&#123;</span><br><span class="line">    NSLog(@”This should be real error checking!”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sqlite3_finalize(stmt);</span><br></pre></td></tr></table></figure>

<p>根据希望使用的数据类型，可以选择不同的绑定语句。大部分绑定函数都只有3个参数。</p>
<p>1）无论针对哪种数据类型，任何绑定函数的第一个参数都指向之前在sqlite3_prepare_v2()调用中使用的sqlite3_stmt。</p>
<p>2）第二个参数是被绑定变量的索引。它是一个有序索引值，者这表示SQL语句中的第一个问号是索引1，其后面的每个问号都依次按序增加1。</p>
<p>3）第三个参数始终表示应该替换问号的值。</p>
<p>有些绑定函数（比如用于绑定文本和二进制数据的绑定函数）拥有另外两个参数。</p>
<p>1）一个参数是在上面第三个参数中传递的数据长度。对于C字符串，可以传递-1来代替字符串长度，这样函数将使用整个字符串。对于所有其他情况，需要指定所传递数据的长度。</p>
<p>2）另外一个参数是可选的函数回调，用于在语句执行后完成内存清理工作。通常，这种函数使用malloc()释放已分配的内存。</p>
<h2 id="创建工程-2"><a href="#创建工程-2" class="headerlink" title="创建工程"></a>创建工程</h2><p>创建工程，设计布局，与前文工程相同操作，连线，添加响应方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &quot;SqliteViewController.h&quot;</span><br><span class="line">#import &lt;sqlite3.h&gt;</span><br><span class="line"></span><br><span class="line">@interface SqliteViewController ()</span><br><span class="line">- (IBAction)saveClicked:(id)sender;</span><br><span class="line">@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>导入sqlite库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">    </span><br><span class="line">    sqlite3 *database;</span><br><span class="line">    //打开数据库</span><br><span class="line">    if (sqlite3_open([[self dataFilePath] UTF8String], &amp;database) != SQLITE_OK) &#123;</span><br><span class="line">        sqlite3_close(database);</span><br><span class="line">        NSAssert(0, @&quot;Failed to open database&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     有用的C语言知识：</span><br><span class="line">     如果两个内联的字符串之间只有空白（包括换行符）而没有其他字符，</span><br><span class="line">     那么这两个字符串会被连接为一个字符串。</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">    //创建数据库SQL</span><br><span class="line">    NSString *createSQL = @&quot;create table if not exists fields (row integer primary key, field_data text);&quot;;</span><br><span class="line">    char *errorMsg;</span><br><span class="line">    //执行SQL语句</span><br><span class="line">    if (sqlite3_exec(database, [createSQL UTF8String], NULL, NULL, &amp;errorMsg) != SQLITE_OK) &#123;</span><br><span class="line">        sqlite3_close(database);</span><br><span class="line">        NSAssert(0, @&quot;Error creating table: %s&quot;, errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //查询数据库</span><br><span class="line">    NSString *query = @&quot;select row, field_data from fields order by row;&quot;;</span><br><span class="line">    sqlite3_stmt *statement;</span><br><span class="line">    if (sqlite3_prepare_v2(database, [query UTF8String], -1, &amp;statement, nil) == SQLITE_OK) &#123;</span><br><span class="line">        //遍历返回的每行</span><br><span class="line">        while (sqlite3_step(statement) == SQLITE_ROW) &#123;</span><br><span class="line">            int row = sqlite3_column_int(statement, 0);</span><br><span class="line">            char *rowData = (char *)sqlite3_column_text(statement, 1);</span><br><span class="line">            NSString *fieldValue = [[NSString alloc] initWithUTF8String:rowData];</span><br><span class="line">            UITextField *field = self.lineFields[row];</span><br><span class="line">            field.text = fieldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        sqlite3_finalize(statement);</span><br><span class="line">    &#125;</span><br><span class="line">    //关闭数据库</span><br><span class="line">    sqlite3_close(database);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSString *)dataFilePath&#123;</span><br><span class="line">    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">    NSString *documentsDirectory = [paths objectAtIndex:0];</span><br><span class="line">    return [documentsDirectory stringByAppendingPathComponent:@&quot;data.sqlite&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)saveClicked:(id)sender &#123;</span><br><span class="line">    sqlite3 *database;</span><br><span class="line">    if (sqlite3_open([[self dataFilePath] UTF8String], &amp;database) != SQLITE_OK) &#123;</span><br><span class="line">        sqlite3_close(database);</span><br><span class="line">        NSAssert(0, @&quot;Failed to open database&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        UITextField *field = self.lineFields[i];</span><br><span class="line">        //内联字符串的连接，又一次派上用场</span><br><span class="line">        char *update = &quot;insert or replace into fields (row, field_data) values (?, ?);&quot;;</span><br><span class="line">        char *errorMsg = NULL;</span><br><span class="line">        sqlite3_stmt *stmt;</span><br><span class="line">        //绑定变量</span><br><span class="line">        if (sqlite3_prepare_v2(database, update, -1, &amp;stmt, nil) == SQLITE_OK) &#123;</span><br><span class="line">            sqlite3_bind_int(stmt, 1, i);</span><br><span class="line">            sqlite3_bind_text(stmt, 2, [field.text UTF8String], -1, NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        //判断执行更新是否成功</span><br><span class="line">        if (sqlite3_step(stmt) != SQLITE_DONE) &#123;</span><br><span class="line">            NSAssert(0, @&quot;Error updating table: %s&quot;, errorMsg);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlite3_finalize(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlite3_close(database);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，以上者三种方式没有什么差异，只不过是三种不同的持久化机制而已。</p>
<h1 id="六、Core-Data"><a href="#六、Core-Data" class="headerlink" title="六、Core Data"></a>六、Core Data</h1><p>Core Data是一款稳定、功能全面的持久化工具。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>实体：表示对对象的描述。</p>
<p>托管对象：表示在运行时创建该实体的具体实例。</p>
<p>注意，在数据模型编辑器中，你将创建实体；而在代码中，你将创建并检索托管对象。实体和托管对象之间的差异类似于类与类的实例。 </p>
<p>实体由属性组成，属性分为3种类型：</p>
<p>1）特性（attribute）：特性在Core Data实体中的作用与实例变量在Objective-C类中的作用完全相同，它们都用于保存数据。</p>
<p>2）关系（relationship）：关系用于定义实体之间的关系。举例来说，假设要定义一个Person实体，你可能首先会定义一些特性，比如height和weight，还可以定义地址特性，比如state和zipCode，或者将它们嵌入到单独的HomeAddr实体中。使用后面这种方法，你可能希望在Person与HomeAddr之间创建一个关系。关系可以是一对一或一对多。从Person到HomeAddr的关系可以是“一对一”，因为大多数人都只有一个家庭地址。从HomeAddr到Person的关系则可以是“一对多”，因为可能多个人住在同一个家庭地址。</p>
<p>3）提取属性（fetched property）：提取属性是关系的备选方法。用提取属性可以创建一个能在提取时被评估的查询，从而确定哪些对象属于这个关系。沿用刚才的例子，一个Person对象可以拥有一个名为Neighbors的提取属性，该属性查找数据存储中与这个Person的HomeAddr拥有相同zipCode的所有HomeAddr对象。由于提取属性的结构和使用方式，它们通常都是一对一关系。提取属性也是唯一一种能够让你跨越多个数据存储的关系。</p>
<h2 id="创建工程-3"><a href="#创建工程-3" class="headerlink" title="创建工程"></a>创建工程</h2><p>依旧如前文方式创建工程，添加响应参数，不过在这里要注意的是，Core Data的创建方法步骤：</p>
<p>1）创建Model文件</p>
<p><img src="/assets/images/tech/ios-data-persistence-2.png" alt="创建Model文件"></p>
<p>2）编辑Model文件，点击“Add Entity”添加实体，点击“Add Attribute”添加特性</p>
<p><img src="/assets/images/tech/ios-data-persistence-3.png" alt="编辑Model文件"></p>
<p>3）创建NSManagedObject文件，关联数据模型</p>
<p><img src="/assets/images/tech/ios-data-persistence-4.png" alt="创建NSManagedObject文件-1"></p>
<p><img src="/assets/images/tech/ios-data-persistence-5.png" alt="创建NSManagedObject文件-2"></p>
<p><img src="/assets/images/tech/ios-data-persistence-6.png" alt="创建NSManagedObject文件-3"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &quot;CoreDataViewController.h&quot;</span><br><span class="line">#import &lt;CoreData/CoreData.h&gt;</span><br><span class="line"></span><br><span class="line">static NSString *const kLineEntityName = @&quot;Line&quot;;</span><br><span class="line">static NSString *const kLineNumberKey = @&quot;lineNumber&quot;;</span><br><span class="line">static NSString *const kLineTextKey = @&quot;lineText&quot;;</span><br><span class="line"></span><br><span class="line">@interface CoreDataViewController ()</span><br><span class="line">- (IBAction)saveClicked:(id)sender;</span><br><span class="line">@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">    </span><br><span class="line">    NSManagedObjectContext *context = [self myContext];</span><br><span class="line"></span><br><span class="line">    NSFetchRequest *request = [[NSFetchRequest alloc] initWithEntityName:kLineEntityName];</span><br><span class="line">    NSError *error;</span><br><span class="line">    NSArray *objects = [context executeFetchRequest:request error:&amp;error];</span><br><span class="line">    if (objects == nil) &#123;</span><br><span class="line">        NSLog(@&quot;There was an error!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (NSManagedObject *oneObject in objects) &#123;</span><br><span class="line">        int lineNum = [[oneObject valueForKey:kLineNumberKey] intValue];</span><br><span class="line">        NSString *lineText = [oneObject valueForKey:kLineTextKey];</span><br><span class="line"></span><br><span class="line">        UITextField *theField = self.lineFields[lineNum];</span><br><span class="line">        theField.text = lineText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSManagedObjectContext *)myContext&#123;</span><br><span class="line">    //上下文 关联Company.xcdatamodeld模型文件</span><br><span class="line">    NSManagedObjectContext *context = [[NSManagedObjectContext alloc] init];</span><br><span class="line">    //模型文件</span><br><span class="line">    NSManagedObjectModel *model = [NSManagedObjectModel mergedModelFromBundles:nil];</span><br><span class="line">    //持久化存储调度器</span><br><span class="line">    NSPersistentStoreCoordinator *store = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:model];</span><br><span class="line">    NSString *doc = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">    NSString *sqlitePath = [doc stringByAppendingPathComponent:@&quot;line.sqlite&quot;];</span><br><span class="line">    //数据存储的类型 数据库存储路径</span><br><span class="line">    [store addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:[NSURL fileURLWithPath:sqlitePath] options:nil error:nil];</span><br><span class="line">    context.persistentStoreCoordinator = store;</span><br><span class="line">    </span><br><span class="line">    return context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (IBAction)saveClicked:(id)sender &#123;</span><br><span class="line">    </span><br><span class="line">    NSManagedObjectContext *context = [self myContext];</span><br><span class="line">    </span><br><span class="line">    NSError *error;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        UITextField *theField = self.lineFields[i];</span><br><span class="line">        NSFetchRequest *request = [[NSFetchRequest alloc] initWithEntityName:kLineEntityName];</span><br><span class="line">        NSPredicate *pred = [NSPredicate predicateWithFormat:@&quot;(%K = %d)&quot;, kLineNumberKey, i];</span><br><span class="line">        [request setPredicate:pred];</span><br><span class="line"></span><br><span class="line">        NSArray *objects = [context executeFetchRequest:request error:&amp;error];</span><br><span class="line">        if (objects == nil) &#123;</span><br><span class="line">            NSLog(@&quot;There was an error!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        NSManagedObject *theLine = nil;</span><br><span class="line">        if ([objects count] &gt; 0) &#123;</span><br><span class="line">            theLine = [objects objectAtIndex:0];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            theLine = [NSEntityDescription insertNewObjectForEntityForName:kLineEntityName inManagedObjectContext:context];</span><br><span class="line">        &#125;</span><br><span class="line">        [theLine setValue:[NSNumber numberWithInt:i] forKey:kLineNumberKey];</span><br><span class="line">        [theLine setValue:theField.text forKey:kLineTextKey];</span><br><span class="line">    &#125;</span><br><span class="line">    [context save:nil];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Core Data版本与之前的版本功能完全相同。Core Data需要的工作量很大。对于这种简单的应用，它并没有提供明显的优势。但是在比较复杂的应用中，Core Data可以显著减少设计和编写数据模型所需的时间。</p>
<h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><p>四种数据持久化机制，各有优势，根据使用情况选择对应机制进行数据持久化。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS App 偏好设置</title>
    <url>/2016-01-15-ios-preference-setting/</url>
    <content><![CDATA[<p>如今，即便是最简单的计算机程序也会包含一个偏好设置窗口，用户可以在其中设置应用专属的选项。在MAC OS X中，Preferences…菜单通常位于应用菜单中。选择该菜单项会弹出一个窗口，用户可以在其中输入和更改各种选项。iPhone和其他iOS设备有一个专门的“设置”应用程序来进行各种设置，你肯定用过很多次了。</p>
<span id="more"></span>

<h1 id="设置捆绑包"><a href="#设置捆绑包" class="headerlink" title="设置捆绑包"></a>设置捆绑包</h1><p>通过应用设置，用户可以输入和更改任何带有设置捆绑包（settings bundle）的应用中的偏好设置。设置捆绑包是应用自带的一组文件，用于告诉设置该应用期望得到用户的哪些偏好设置。下图是实例效果图：</p>
<p><img src="/assets/images/tech/ios-preference-setting-1.png" alt="效果图"></p>
<p>对于iOS用户默认设置（User Defaults）机制，设置应用充当着通用用户界面的角色。用户默认设置是保存和获取偏好设置的系统的一部分。</p>
<p>在iOS应用中，用户默认设置由NSUserDefaults类实现。应用通过NSUserDefaults用键值对的方式来读取和保存偏好设置数据，与通过键从NSDictionary对象中获取数据一样。不同之处在于NSUserDefaults数据会被持久保存在文件系统中，而不是存储在内存的对象实例中。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>接下来的部分，通过创建一个简单的应用，来实现应用设置控制应用程序。</p>
<h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><p>在Xcode中，创建Tabbed Application工程。</p>
<h2 id="使用设置捆绑包"><a href="#使用设置捆绑包" class="headerlink" title="使用设置捆绑包"></a>使用设置捆绑包</h2><p>设置应用使用每个应用中设置捆绑包的内容构建出一个应用的设置视图。如果应用没有设置捆绑包，则设置应用不会显示出应用程序的任何信息。每个设置捆绑包必须包含一个名为Root.plist的属性列表，它定义了根级偏好设置视图。此属性列表必须遵循一种非常严格的格式。</p>
<p>当设置应用启动时，它会检查每个应用程序的设置捆绑包并为包含设置捆绑包的每个应用添加设置组。</p>
<h3 id="在项目中添加设置捆绑包"><a href="#在项目中添加设置捆绑包" class="headerlink" title="在项目中添加设置捆绑包"></a>在项目中添加设置捆绑包</h3><p>新建设置捆绑包，操作如下图</p>
<p><img src="/assets/images/tech/ios-preference-setting-2.png" alt="新建"></p>
<p>在iOS－－&gt;Resource－－&gt;Settings Bundle点击Next，名字保留默认，最后点击Create即可。</p>
<h3 id="编辑属性列表文件"><a href="#编辑属性列表文件" class="headerlink" title="编辑属性列表文件"></a>编辑属性列表文件</h3><p>接下来需要编辑Root.plist文件，具体内容如下图</p>
<p><img src="/assets/images/tech/ios-preference-setting-3.png" alt="Root.plist文件 1"></p>
<p><img src="/assets/images/tech/ios-preference-setting-4.png" alt="Root.plist文件 2"></p>
<p><img src="/assets/images/tech/ios-preference-setting-5.png" alt="Root.plist文件 3"></p>
<p>在Item8中，引用的More.plist文件，具体内容如下图</p>
<p><img src="/assets/images/tech/ios-preference-setting-6.png" alt="More.plist文件"></p>
<p>这里需要补充说明一点：</p>
<p>iOS上的应用不能从其他应用的沙盒中读取文件。设置捆绑包并不是我们应用沙盒的一部分，而是设置应用沙盒的一部分。</p>
<h2 id="设计展示界面"><a href="#设计展示界面" class="headerlink" title="设计展示界面"></a>设计展示界面</h2><p>数据准备好之后，添加图标资源，设计数据展示界面。效果图如下</p>
<p><img src="/assets/images/tech/ios-preference-setting-7.png" alt="界面展示图"></p>
<p>界面是通过代码实现的，主要使用了如下几个控件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface FirstViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) UILabel *officerLabel;</span><br><span class="line">@property (nonatomic, strong) UILabel *authorizationCodeLabel;</span><br><span class="line">@property (nonatomic, strong) UILabel *rankLabel;</span><br><span class="line">@property (nonatomic, strong) UILabel *warpDriveLabel;</span><br><span class="line">@property (nonatomic, strong) UILabel *warpFactorLabel;</span><br><span class="line">@property (nonatomic, strong) UILabel *favoriteTeaLabel;</span><br><span class="line">@property (nonatomic, strong) UILabel *favoriteCaptainLabel;</span><br><span class="line">@property (nonatomic, strong) UILabel *favoriteGadgetLabel;</span><br><span class="line">@property (nonatomic, strong) UILabel *favoriteAlienLabel;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface SecondViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) UISwitch *engineSwitch;</span><br><span class="line">@property (nonatomic, strong) UISlider *warpFactorSlider;</span><br><span class="line">@property (nonatomic, strong) UIButton *settingInfo;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="读取应用中的设置"><a href="#读取应用中的设置" class="headerlink" title="读取应用中的设置"></a>读取应用中的设置</h2><p>我们将使用NSUserDefaults类访问用户设置。NSUserDefaults作为单例类，意味着应用中只能有一个NSUserDefaults实例在运行。为了访问这个实例，需要调用standardUserDefaults。</p>
<h3 id="键宏定义"><a href="#键宏定义" class="headerlink" title="键宏定义"></a>键宏定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef BridgeControl_Constants_h</span><br><span class="line">#define BridgeControl_Constants_h</span><br><span class="line"></span><br><span class="line">#define kOfficerKey @&quot;officer&quot;</span><br><span class="line">#define kAuthorizationCodeKey @&quot;authorizationCode&quot;</span><br><span class="line">#define kRankKey @&quot;rank&quot;</span><br><span class="line">#define kWarpDriveKey @&quot;warp&quot;</span><br><span class="line">#define kWarpFactorKey @&quot;warpFactor&quot;</span><br><span class="line">#define kFavoriteTeaKey @&quot;favoriteTea&quot;</span><br><span class="line">#define kFavoriteCaptionKey @&quot;favoriteCaptain&quot;</span><br><span class="line">#define kFavoriteGadgetKey @&quot;favoriteGadget&quot;</span><br><span class="line">#define kFavoriteAlienKey @&quot;favoriteAlien&quot;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h3 id="更新主视图控制器"><a href="#更新主视图控制器" class="headerlink" title="更新主视图控制器"></a>更新主视图控制器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//FirstViewController.m</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">    [self refreshFields];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)refreshFields&#123;</span><br><span class="line">    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">    self.officerLabel.text = [defaults objectForKey:kOfficerKey];</span><br><span class="line">    self.authorizationCodeLabel.text = [defaults objectForKey:kAuthorizationCodeKey];</span><br><span class="line">    self.rankLabel.text = [defaults objectForKey:kRankKey];</span><br><span class="line">    self.warpDriveLabel.text = [defaults boolForKey:kWarpDriveKey] ? @&quot;engaged&quot; : @&quot;Disabled&quot;;</span><br><span class="line">    self.warpFactorLabel.text = [[defaults objectForKey:kWarpFactorKey] stringValue];</span><br><span class="line">    self.favoriteTeaLabel.text = [defaults objectForKey:kFavoriteTeaKey];</span><br><span class="line">    self.favoriteCaptainLabel.text = [defaults objectForKey:kFavoriteCaptionKey];</span><br><span class="line">    self.favoriteGadgetLabel.text = [defaults objectForKey:kFavoriteGadgetKey];</span><br><span class="line">    self.favoriteAlienLabel.text = [defaults objectForKey:kFavoriteAlienKey];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//SecondViewController.m</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">    [self refreshFields];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)refreshFields&#123;</span><br><span class="line">    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">    self.engineSwitch.on = [defaults boolForKey:kWarpDriveKey];</span><br><span class="line">    self.warpFactorSlider.value = [defaults floatForKey:kWarpFactorKey];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加控件响应事件"><a href="#添加控件响应事件" class="headerlink" title="添加控件响应事件"></a>添加控件响应事件</h3><p>为SecondViewController中的UIButton，UISwitch和UISlider控件添加监听事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)engineSwitchTapped &#123;</span><br><span class="line">    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">    [defaults setBool:self.engineSwitch.on forKey:kWarpDriveKey];</span><br><span class="line">    [defaults synchronize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)warpSliderTouched &#123;</span><br><span class="line">    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">    [defaults setFloat:self.warpFactorSlider.value forKey:kWarpFactorKey];</span><br><span class="line">    [defaults synchronize];</span><br><span class="line">&#125;</span><br><span class="line">//切换到“设置”应用程序</span><br><span class="line">-(void)settingInfoClicked&#123;</span><br><span class="line">    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册默认值"><a href="#注册默认值" class="headerlink" title="注册默认值"></a>注册默认值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//AppDelegate.m</span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    // Override point for customization after application launch.</span><br><span class="line">    </span><br><span class="line">    //程序启动后的一些自定义设置</span><br><span class="line">    NSDictionary *defaults = @&#123;kWarpDriveKey:@YES,</span><br><span class="line">                               kWarpFactorKey:@2,</span><br><span class="line">                               kFavoriteAlienKey:@&quot;Vulcan&quot;</span><br><span class="line">                               &#125;;</span><br><span class="line">    [[NSUserDefaults standardUserDefaults] registerDefaults:defaults];</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="保证设置有效"><a href="#保证设置有效" class="headerlink" title="保证设置有效"></a>保证设置有效</h2><p>如果现在将应用运行，查看设置信息并按下主屏幕按钮来修改一些值。然后再按Home键，再重新打开应用，结果发现设置并没有生效。</p>
<p>原因在于：在iOS中，当应用正在运行时按Home键并不会退出该应用，而是由操作系统在后台将其暂停，这样它就能随时快速启动。</p>
<p>在这个例子中，我们需要添加一点工作，以实现应用被唤醒时，能重新加载用户偏好设置并重新显示它们。</p>
<p>通知，时对象之间进行通信的轻量级机制。任何对象都能定义一个或多个发送到应用通知中心的通知。通知中心是一个单例对象，作用在于对象之间传送通知。</p>
<p>UIApplication类会发送大量的通知，大多数通知的用途从命名就能看出来，这个例子中我们就使用到了通知。</p>
<p>将下列代码添加到两个控制器的viewDidLoad方法中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UIApplication *app = [UIApplication sharedApplication];</span><br><span class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationWillEnterForeground:) name:UIApplicationWillEnterForegroundNotification object:app];</span><br></pre></td></tr></table></figure>

<p>然后添加相应的响应方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(void)applicationWillEnterForeground:(NSNotification *)notification&#123;</span><br><span class="line">    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];</span><br><span class="line">    [defaults synchronize];</span><br><span class="line">    [self refreshFields];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文主要讲解了如何使用应用设置，如何使用NSUserDefaults读取偏好设置，以及如何让用户在应用内修改偏好设置。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>application</tag>
      </tags>
  </entry>
  <entry>
    <title>内存对齐详解</title>
    <url>/2016-02-10-memory-alignment/</url>
    <content><![CDATA[<p>现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问， 这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是内存对齐。<br>本文分享博主对内存对齐的一些理解。</p>
<span id="more"></span>

<h1 id="一、什么是内存对齐"><a href="#一、什么是内存对齐" class="headerlink" title="一、什么是内存对齐"></a>一、什么是内存对齐</h1><p>现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问， 这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是内存对齐。</p>
<h1 id="二、内存对齐的原因"><a href="#二、内存对齐的原因" class="headerlink" title="二、内存对齐的原因"></a>二、内存对齐的原因</h1><p>1、平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p>
<p>2、性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p>
<h1 id="三、对齐规则"><a href="#三、对齐规则" class="headerlink" title="三、对齐规则"></a>三、对齐规则</h1><p>每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。程序员可以通过预编译命令#pragma pack(n)，n&#x3D;1,2,4,8,16 来改变这一系数，其中的n 就是你要指定的“对齐系数”。</p>
<h2 id="规则1"><a href="#规则1" class="headerlink" title="规则1"></a>规则1</h2><p><strong>数据成员对齐规则：</strong>结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0 的地方，以后每个数据成员的对齐按照#pragma pack 指定的数值和这个数据成员自身长度中，比较小的那个进行。</p>
<h2 id="规则2"><a href="#规则2" class="headerlink" title="规则2"></a>规则2</h2><p><strong>结构（或联合）的整体对齐规则：</strong>在数据成员完成各自对齐之后，结构（或联合）本身也要进行对齐，对齐将按照#pragma pack 指定的数值和结构（或联合）最大数据成员长度中，比较小的那个进行。</p>
<h2 id="规则3"><a href="#规则3" class="headerlink" title="规则3"></a>规则3</h2><p>结合1、2 可推断：当#pragma pack 的n 值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。</p>
<h1 id="四、试验"><a href="#四、试验" class="headerlink" title="四、试验"></a>四、试验</h1><p>接下来我们通过实际例子来说明这些规则。</p>
<p><strong>试验环境：</strong>编译器包括GCC 3.4.2 和VC6.0 的C 编译器。</p>
<p><strong>平台：</strong>Windows XP SP2。</p>
<p>我们将用典型的struct 对齐来说明。首先我们定义一个struct：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma pack(n) /* n = 1, 2, 4, 8, 16 */</span><br><span class="line">struct test_t&#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">    short c;</span><br><span class="line">    char d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>#pragma pack(n)</code></p>
<p>首先我们首先确认在试验平台上的各个类型的size，经验证两个编译器的输出均为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sizeof(char) = 1</span><br><span class="line">sizeof(short) = 2</span><br><span class="line">sizeof(int) = 4</span><br></pre></td></tr></table></figure>

<p>验证过程如下：通过#pragma pack(n)改变“对齐系数”，然后查看sizeof(struct test_t)的值。</p>
<h2 id="字节对齐-pragma-pack-1"><a href="#字节对齐-pragma-pack-1" class="headerlink" title="字节对齐(#pragma pack(1))"></a>字节对齐(#pragma pack(1))</h2><p>输出结果：sizeof(struct test_t) &#x3D; 8 [两个编译器输出一致]</p>
<p>分析过程：</p>
<h3 id="成员数据对齐"><a href="#成员数据对齐" class="headerlink" title="成员数据对齐"></a>成员数据对齐</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma pack(1)</span><br><span class="line"></span><br><span class="line">struct test_t &#123;</span><br><span class="line">    /* 长度4 &lt; 1 按1 对齐；起始offset=0 0%1=0；存放位置区间[0,3] */   </span><br><span class="line">    int a;</span><br><span class="line">    /* 长度1 = 1 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */</span><br><span class="line">    char b;</span><br><span class="line">    /* 长度2 &gt; 1 按1 对齐；起始offset=5 5%1=0；存放位置区间[5,6] */</span><br><span class="line">    short c;</span><br><span class="line">    /* 长度1 = 1 按1 对齐；起始offset=7 7%1=0；存放位置区间[7] */</span><br><span class="line">    char d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>#pragma pack()</code></p>
<p>成员总大小&#x3D;8</p>
<h3 id="整体对齐"><a href="#整体对齐" class="headerlink" title="整体对齐"></a>整体对齐</h3><p>整体对齐系数&#x3D; min((max(int,short,char), 1) &#x3D; 1</p>
<p>整体大小(size)&#x3D;$(成员总大小) 按$(整体对齐系数) 圆整&#x3D; 8 &#x2F;* 8%1&#x3D;0 *&#x2F; [注1]</p>
<p><strong>[注1] 什么是圆整</strong></p>
<p>举例说明：如上面的8 字节对齐中的“整体对齐”，整体大小&#x3D;9 按4 圆整&#x3D; 12</p>
<p>圆整的过程：从9 开始每次加一，看是否能被4 整除，这里9，10，11 均不能被4 整除，到12 时可以，则圆整结束。</p>
<h2 id="字节对齐-pragma-pack-2"><a href="#字节对齐-pragma-pack-2" class="headerlink" title="字节对齐(#pragma pack(2))"></a>字节对齐(#pragma pack(2))</h2><p>输出结果：sizeof(struct test_t) &#x3D; 10 [两个编译器输出一致]</p>
<p>分析过程：</p>
<h3 id="成员数据对齐-1"><a href="#成员数据对齐-1" class="headerlink" title="成员数据对齐"></a>成员数据对齐</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma pack(2)</span><br><span class="line"></span><br><span class="line">struct test_t &#123;</span><br><span class="line">    /* 长度4 &gt; 2 按2 对齐；起始offset=0 0%2=0；存放位置区间[0,3] */</span><br><span class="line">    int a;</span><br><span class="line">     /* 长度1 &lt; 2 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */</span><br><span class="line">    char b;</span><br><span class="line">    /* 长度2 = 2 按2 对齐；起始offset=6 6%2=0；存放位置区间[6,7] */</span><br><span class="line">    short c;</span><br><span class="line">    /* 长度1 &lt; 2 按1 对齐；起始offset=8 8%1=0；存放位置区间[8] */</span><br><span class="line">    char d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>#pragma pack()</code></p>
<p>成员总大小&#x3D;9</p>
<h3 id="整体对齐-1"><a href="#整体对齐-1" class="headerlink" title="整体对齐"></a>整体对齐</h3><p>整体对齐系数&#x3D; min((max(int,short,char), 2) &#x3D; 2</p>
<p>整体大小(size)&#x3D;$(成员总大小) 按$(整体对齐系数) 圆整&#x3D; 10 &#x2F;* 10%2&#x3D;0 *&#x2F;</p>
<h2 id="字节对齐-pragma-pack-4"><a href="#字节对齐-pragma-pack-4" class="headerlink" title="字节对齐(#pragma pack(4))"></a>字节对齐(#pragma pack(4))</h2><p>输出结果：sizeof(struct test_t) &#x3D; 12 [两个编译器输出一致]</p>
<p>分析过程：</p>
<h3 id="成员数据对齐-2"><a href="#成员数据对齐-2" class="headerlink" title="成员数据对齐"></a>成员数据对齐</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma pack(4)</span><br><span class="line"></span><br><span class="line">struct test_t &#123;</span><br><span class="line">    /* 长度4 = 4 按4 对齐；起始offset=0 0%4=0；存放位置区间[0,3] */</span><br><span class="line">    int a;</span><br><span class="line">    /* 长度1 &lt; 4 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */</span><br><span class="line">    char b;</span><br><span class="line">    /* 长度2 &lt; 4 按2 对齐；起始offset=6 6%2=0；存放位置区间[6,7] */</span><br><span class="line">    short c;</span><br><span class="line">    /* 长度1 &lt; 4 按1 对齐；起始offset=8 8%1=0；存放位置区间[8] */</span><br><span class="line">    char d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>#pragma pack()</code></p>
<p>成员总大小&#x3D;9</p>
<h3 id="整体对齐-2"><a href="#整体对齐-2" class="headerlink" title="整体对齐"></a>整体对齐</h3><p>整体对齐系数&#x3D; min((max(int,short,char), 4) &#x3D; 4</p>
<p>整体大小(size)&#x3D;$(成员总大小) 按$(整体对齐系数) 圆整&#x3D; 12 &#x2F;* 12%4&#x3D;0 *&#x2F;</p>
<h2 id="字节对齐-pragma-pack-8"><a href="#字节对齐-pragma-pack-8" class="headerlink" title="字节对齐(#pragma pack(8))"></a>字节对齐(#pragma pack(8))</h2><p>输出结果：sizeof(struct test_t) &#x3D; 12 [两个编译器输出一致]</p>
<p>分析过程：</p>
<h3 id="成员数据对齐-3"><a href="#成员数据对齐-3" class="headerlink" title="成员数据对齐"></a>成员数据对齐</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#pragma pack(8)</span><br><span class="line"></span><br><span class="line">struct test_t &#123;</span><br><span class="line">    /* 长度4 &lt; 8 按4 对齐；起始offset=0 0%4=0；存放位置区间[0,3] */</span><br><span class="line">    int a;</span><br><span class="line">    /* 长度1 &lt; 8 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */</span><br><span class="line">    char b;</span><br><span class="line">    /* 长度2 &lt; 8 按2 对齐；起始offset=6 6%2=0；存放位置区间[6,7] */</span><br><span class="line">    short c; </span><br><span class="line">    /* 长度1 &lt; 8 按1 对齐；起始offset=8 8%1=0；存放位置区间[8] */</span><br><span class="line">    char d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>#pragma pack()</code></p>
<p>成员总大小&#x3D;9</p>
<h3 id="整体对齐-3"><a href="#整体对齐-3" class="headerlink" title="整体对齐"></a>整体对齐</h3><p>整体对齐系数&#x3D; min((max(int,short,char), 8) &#x3D; 4</p>
<p>整体大小(size)&#x3D;$(成员总大小) 按$(整体对齐系数) 圆整&#x3D; 12 &#x2F;* 12%4&#x3D;0 *&#x2F;</p>
<h2 id="字节对齐-pragma-pack-16"><a href="#字节对齐-pragma-pack-16" class="headerlink" title="字节对齐(#pragma pack(16))"></a>字节对齐(#pragma pack(16))</h2><p>输出结果：sizeof(struct test_t) &#x3D; 12 [两个编译器输出一致]</p>
<p>分析过程：</p>
<h3 id="成员数据对齐-4"><a href="#成员数据对齐-4" class="headerlink" title="成员数据对齐"></a>成员数据对齐</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#pragma pack(16)</span><br><span class="line"></span><br><span class="line">struct test_t &#123;</span><br><span class="line">    /* 长度4 &lt; 16 按4 对齐；起始offset=0 0%4=0；存放位置区间[0,3] */</span><br><span class="line">    int a;</span><br><span class="line">    /* 长度1 &lt; 16 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */</span><br><span class="line">    char b;</span><br><span class="line">    /* 长度2 &lt; 16 按2 对齐；起始offset=6 6%2=0；存放位置区间[6,7] */</span><br><span class="line">    short c;</span><br><span class="line">    /* 长度1 &lt; 16 按1 对齐；起始offset=8 8%1=0；存放位置区间[8] */</span><br><span class="line">    char d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>#pragma pack()</code></p>
<p>成员总大小&#x3D;9</p>
<h3 id="整体对齐-4"><a href="#整体对齐-4" class="headerlink" title="整体对齐"></a>整体对齐</h3><p>整体对齐系数&#x3D; min((max(int,short,char), 16) &#x3D; 4</p>
<p>整体大小(size)&#x3D;$(成员总大小) 按$(整体对齐系数) 圆整&#x3D; 12 &#x2F;* 12%4&#x3D;0 *&#x2F;</p>
<h1 id="五、结论"><a href="#五、结论" class="headerlink" title="五、结论"></a>五、结论</h1><p>8 字节和16 字节对齐试验证明了“规则”的第3 点：“当#pragma pack 的n 值等于或超过所有数据成员长度的时候，这个n 值的大小将不产生任何效果”。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>YYModel源代码阅读 - 基础知识</title>
    <url>/2016-02-16-YYModel-reading/</url>
    <content><![CDATA[<p>YYModel堪称神级大作，虽然不免一些小bug，但是完全不影响膝盖碎一地。文章主要分享在阅读YYModel源代码时，所引发的知识点的补充与思考。</p>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这段时间因为工作需要，阅读了YYModel这个开源框架，至于它能做什么，最直白的讲述就是JSON与Model之间的相互转化。</p>
<p>源代码在<a href="https://github.com/ibireme/YYModel">Github</a>，大家可以自行<code>git clone</code>或者download。</p>
<p>接下来，笔者主要分析阅读源代码而引出的各种问题与知识点，不足之处请大家指正。</p>
<h1 id="NS-ASSUME-NONNULL-BEGIN-amp-NS-ASSUME-NONNULL-END"><a href="#NS-ASSUME-NONNULL-BEGIN-amp-NS-ASSUME-NONNULL-END" class="headerlink" title="NS_ASSUME_NONNULL_BEGIN &amp; NS_ASSUME_NONNULL_END"></a>NS_ASSUME_NONNULL_BEGIN &amp; NS_ASSUME_NONNULL_END</h1><p>这组宏是成对使用的，不得不说我们自己写代码的时候使用的很少，以至于遗漏这个知识点，现在我们就来看看这两个宏会引出什么问题。</p>
<p>这组宏会引出几个关于Objective-C新特性的知识点：</p>
<ul>
<li><p>Nullability Annotations</p>
</li>
<li><p>Lightweight Generics</p>
</li>
<li><p>__kindof</p>
</li>
</ul>
<h2 id="Nullability-Annotations"><a href="#Nullability-Annotations" class="headerlink" title="Nullability Annotations"></a>Nullability Annotations</h2><p>我们都知道在swift中，可以使用!和?来表示一个对象是optional的还是non-optional，如view?和view!。而在 Objective-C中则没有这一区分，view既可表示这个对象是optional，也可表示是non-optioanl。这样就会造成一个问题：在 Swift与Objective-C混编时，Swift编译器并不知道一个Objective-C对象到底是optional还是non-optional，因此这种情况下编译器会隐式地将Objective-C的对象当成是non-optional。</p>
<p>为了解决这个问题，苹果在Xcode 6.3引入了一个Objective-C的新特性：<strong>nullability annotations</strong>。这一新特性的核心是两个新的类型注释：** __nullable** 和 <strong>__nonnull</strong> 。从字面上我们可以猜到，<code>__nullable</code>表示对象可以是NULL或nil，而<code>__nonnull</code>表示对象不应该为空。当我们不遵循这一规则时，编译器就会给出警告。</p>
<p>我们来看看以下的实例，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface TestNullabilityClass ()</span><br><span class="line">@property (nonatomic, copy) NSArray * items;</span><br><span class="line">- (id)itemWithName:(NSString * __nonnull)name;</span><br><span class="line">@end</span><br><span class="line">@implementation TestNullabilityClass</span><br><span class="line">...</span><br><span class="line">- (void)testNullability &#123;</span><br><span class="line">    [self itemWithName:nil];    // 编译器警告：Null passed to a callee that requires a non-null argument</span><br><span class="line">&#125;</span><br><span class="line">- (id)itemWithName:(NSString * __nonnull)name &#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>不过这只是一个警告，程序还是能编译通过并运行。</p>
<p>事实上，在任何可以使用const关键字的地方都可以使用<code>__nullable</code>和<code>__nonnull</code>，不过这两个关键字仅限于使用在指针类型上。而在方法的声明中，我们还可以使用不带下划线的<code>nullable</code>和<code>nonnull</code>，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (nullable id)itemWithName:(NSString * nonnull)name</span><br><span class="line">在属性声明中，也增加了两个相应的特性，因此上例中的items属性可以如下声明：</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy, nonnull) NSArray * items;</span><br><span class="line">当然也可以用以下这种方式：</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSArray * __nonnull items;</span><br><span class="line">推荐使用nonnull这种方式，这样可以让属性声明看起来更清晰。</span><br></pre></td></tr></table></figure>

<h3 id="Nonnull区域设置-Audited-Regions"><a href="#Nonnull区域设置-Audited-Regions" class="headerlink" title="Nonnull区域设置(Audited Regions)"></a>Nonnull区域设置(Audited Regions)</h3><p>如果需要每个属性或每个方法都去指定<code>nonnull</code>和<code>nullable</code>，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：<strong>NS_ASSUME_NONNULL_BEGIN</strong>和<strong>NS_ASSUME_NONNULL_END</strong>。在这两个宏之间的代码，所有简单指针对象都被假定为 <code>nonnull</code>，因此我们只需要去指定那些<code>nullable</code>的指针。如下代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line">@interface TestNullabilityClass ()</span><br><span class="line">@property (nonatomic, copy) NSArray * items;</span><br><span class="line">- (id)itemWithName:(nullable NSString *)name;</span><br><span class="line">@end</span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，items属性默认是nonnull的，itemWithName:方法的返回值也是nonnull，而参数是指定为nullable的。</p>
<p>不过，为了安全起见，苹果还制定了几条规则：</p>
<ul>
<li><p>typedef定义的类型的nullability特性通常依赖于上下文，即使是在Audited Regions中，也不能假定它为nonnull。</p>
</li>
<li><p>复杂的指针类型(如id *)必须显示去指定是nonnull还是nullable。例如，指定一个指向nullable对象的nonnull指针，可以使用”__nullable id * __nonnull”。</p>
</li>
<li><p>我们经常使用的NSError **通常是被假定为一个指向nullable NSError对象的nullable指针。</p>
</li>
</ul>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>因为Nullability Annotations是Xcode 6.3新加入的，所以我们需要考虑之前的老代码。实际上，苹果已以帮我们处理好了这种兼容问题，我们可以安全地使用它们：</p>
<ul>
<li><p>老代码仍然能正常工作，即使对nonnull对象使用了nil也没有问题。</p>
</li>
<li><p>老代码在需要和swift混编时，在新的swift编译器下会给出一个警告。</p>
</li>
<li><p>nonnull不会影响性能。事实上，我们仍然可以在运行时去判断我们的对象是否为nil。</p>
</li>
</ul>
<p>事实上，我们可以将nonnull&#x2F;nullable与我们的断言和异常一起看待，其需要处理的问题都是同一个：违反约定是一个程序员的错误。特别是，返回值是我们可控的东西，如果返回值是nonnull的，则我们不应该返回nil，除非是为了向后兼容。</p>
<h2 id="Lightweight-Generics"><a href="#Lightweight-Generics" class="headerlink" title="Lightweight Generics"></a>Lightweight Generics</h2><p>Lightweight Generics 轻量级泛型，轻量是因为这是个纯编译器的语法支持（LLVM 7.0），和 Nullability 一样，没有借助任何 objc runtime 的升级，也就是说，这个新语法在 Xcode 7 上可以使用且完全向下兼容（更低的 iOS 版本）</p>
<h3 id="带泛型的容器"><a href="#带泛型的容器" class="headerlink" title="带泛型的容器"></a>带泛型的容器</h3><p>这无疑是本次最重大的改进，有了泛型后终于可以指定容器类中对象的类型了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSArray&lt;NSString *&gt; *strings = @[@&quot;sun&quot;, @&quot;yuan&quot;];</span><br><span class="line">NSDictionary&lt;NSString *, NSNumber *&gt; *mapping = @&#123;@&quot;a&quot;: @1, @&quot;b&quot;: @2&#125;;</span><br></pre></td></tr></table></figure>
<p>返回值的 id 被替换成具体的类型后，令人感动的代码提示也出来了。</p>
<p>假如向泛型容器中加入错误的对象，编译器会不开心的。</p>
<p>系统中常用的一系列容器类型都增加了泛型支持，甚至连 <code>NSEnumerator</code> 都支持了，这是非常 Nice 的改进。和 <code>Nullability</code> 一样，我认为最大的意义还是丰富了接口描述信息，对比下面两种写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (readonly) NSArray *imageURLs;</span><br><span class="line">@property (readonly) NSArray&lt;NSURL *&gt; *imageURLs;</span><br></pre></td></tr></table></figure>
<p>不用多想就清楚下面的数组中存的是什么，避免了 <code>NSString</code> 和 <code>NSURL</code> 的混乱。</p>
<h3 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h3><p>比起使用系统的泛型容器，更好玩的是自定义一个泛型类，目前这里还没什么文档，但拦不住我们写测试代码，假设我们要自定义一个 Stack 容器类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface Stack&lt;ObjectType&gt; : NSObject</span><br><span class="line">- (void)pushObject:(ObjectType)object;</span><br><span class="line">- (ObjectType)popObject;</span><br><span class="line">@property (nonatomic, readonly) NSArray&lt;ObjectType&gt; *allObjects;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这个 <code>ObjectType</code> 是传入类型的 <code>placeholder</code>，它只能在 <code>@interface</code> 上定义（类声明、类扩展、Category），如果你喜欢用 T 表示也 OK，这个类型在 <code>@interface</code> 和 <code>@end</code> 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型，应该说一切都是符合预期的。我们还可以给 ObjectType 增加类型限制，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 只接受 NSNumber * 的泛型</span><br><span class="line">@interface Stack&lt;ObjectType: NSNumber *&gt; : NSObject</span><br><span class="line">// 只接受满足 NSCopying 协议的泛型</span><br><span class="line">@interface Stack&lt;ObjectType: id&lt;NSCopying&gt;&gt; : NSObject</span><br></pre></td></tr></table></figure>
<p>若什么都不加，表示接受任意类型 ( id )；当类型不满足时编译器将产生 error。<br>实例化一个 Stack，一切工作正常：</p>
<p>对于多参数的泛型，用逗号隔开，其他都一样，可以参考 NSDictionary 的头文件。</p>
<h3 id="协变性和逆变性"><a href="#协变性和逆变性" class="headerlink" title="协变性和逆变性"></a>协变性和逆变性</h3><p>当类支持泛型后，它们的 Type 发生了变化，比如下面三个对象看上去都是 Stack，但实际上属于三个 Type：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stack *stack; // Stack *</span><br><span class="line">Stack&lt;NSString *&gt; *stringStack; // Stack&lt;NSString *&gt;</span><br><span class="line">Stack&lt;NSMutableString *&gt; *mutableStringStack; // Stack&lt;NSMutableString *&gt;</span><br></pre></td></tr></table></figure>
<p>当其中两种类型做类型转化时，编译器需要知道哪些转化是允许的，哪些是禁止的，比如，默认情况下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stack *stack;</span><br><span class="line">Stack&lt;NSString *&gt; *stringStack;</span><br><span class="line">Stack&lt;NSMutableString *&gt; *mutableStringStack; </span><br><span class="line"></span><br><span class="line">stack = stringStack;</span><br><span class="line">stack = mutableStringStack;</span><br><span class="line">stringStack = stack;</span><br><span class="line">stringStack = mutableStringStack;</span><br><span class="line">mutableStringStack = stack;</span><br><span class="line">mutableStringStack = stringStack</span><br></pre></td></tr></table></figure>
<p>在Xcode中我们可以看到，不指定泛型类型的 Stack 可以和任意泛型类型转化，但指定了泛型类型后，两个不同类型间是不可以强转的，假如你希望主动控制转化关系，就需要使用泛型的协变性和逆变性修饰符了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__covariant - 协变性，子类型可以强转到父类型（里氏替换原则）</span><br><span class="line">__contravariant - 逆变性，父类型可以强转到子类型（WTF）</span><br></pre></td></tr></table></figure>

<h4 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface Stack&lt;__covariant ObjectType&gt; : NSObject</span><br></pre></td></tr></table></figure>

<h4 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface Stack&lt;__contravariant ObjectType&gt; : NSObject</span><br></pre></td></tr></table></figure>

<p>协变是非常好理解的，像 <code>NSArray</code> 的泛型就用了协变的修饰符。</p>
<h2 id="kindof"><a href="#kindof" class="headerlink" title="__kindof"></a>__kindof</h2><p><code>__kindof</code> 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 <code>UITableView</code> 的这个方法来说：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;</span><br></pre></td></tr></table></figure>
<p>使用时前面基本会使用 <code>UITableViewCell</code> 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 <code>UITableViewCell</code> 或 <code>UITableViewCell</code> 子类的实例，于是新的 <code>__kindof</code> 关键字解决了这个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;</span><br></pre></td></tr></table></figure>

<p>既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView 的 subviews 属性被修改成了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, readonly, copy) NSArray&lt;__kindof UIView *&gt; *subviews;</span><br></pre></td></tr></table></figure>

<p>这样，写下面的代码时就没有任何警告了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UIButton *button = view.subviews.lastObject;</span><br></pre></td></tr></table></figure>

<h1 id="NS-ENUM-amp-NS-OPTIONS"><a href="#NS-ENUM-amp-NS-OPTIONS" class="headerlink" title="NS_ENUM &amp; NS_OPTIONS"></a>NS_ENUM &amp; NS_OPTIONS</h1><p>枚举是指将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。</p>
<p>枚举本质上是一个整数，枚举的作用是把值限定在指定的范围内，并且增加代码的可读性。 枚举的成员如果没有显示指定值，那么第一个成员的值总是0，后面成员的值依次递增。枚举可以直接用于比较。</p>
<p>一般我们声明枚举：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">// 声明枚举类型</span><br><span class="line">enum Direction &#123;up, down, left = 10, right&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[])&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">其中up = 0, down = 1, left = 10, right = 11。</span><br></pre></td></tr></table></figure>

<p>我们会发现枚举中一些不可自定义的部分，例如，枚举名。</p>
<p>NS_ENUM 和 NS_OPTIONS 都不算太古老的宏，在iOS 6 &#x2F; OS X Mountain Lion才开始有，它们都是代替 enum 的更好的办法。</p>
<h2 id="NS-ENUM"><a href="#NS-ENUM" class="headerlink" title="NS_ENUM"></a>NS_ENUM</h2><p>如果要在早期的iOS或OS X系统中使用这两个宏，简单定义一下就好</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef NS_ENUM</span><br><span class="line">#define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>在OS X 10.4 中的原始定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define NS_ENUM(_type, _name) CF_ENUM(_type, _name)</span><br><span class="line">#define NS_OPTIONS(_type, _name) CF_OPTIONS(_type, _name)</span><br></pre></td></tr></table></figure>
<p>在之前枚举可以这么定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef enum &#123;</span><br><span class="line">    UITableViewCellStyleDefault,</span><br><span class="line">    UITableViewCellStyleValue1,</span><br><span class="line">    UITableViewCellStyleValue2,</span><br><span class="line">    UITableViewCellStyleSubtitle</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef NSInteger UITableViewCellStyle;</span><br></pre></td></tr></table></figure>

<p>现在，有了统一的风格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UITableViewCellSelectionStyle) &#123;</span><br><span class="line">    UITableViewCellSelectionStyleNone,</span><br><span class="line">    UITableViewCellSelectionStyleBlue,</span><br><span class="line">    UITableViewCellSelectionStyleGray,</span><br><span class="line">    UITableViewCellSelectionStyleDefault</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>NS_ENUM</code> 的第一个参数是用于存储的新类型的类型。在64位环境下，<code>UITableViewCellStyle</code> 和 <code>NSInteger</code> 一样有8 bytes长。你要保证你给出的所有值能被该类型容纳，否则就会产生错误。第二个参数是新类型的名字。大括号里面和以前一样，是你要定义的各种值。</p>
<h2 id="NS-OPTIONS"><a href="#NS-OPTIONS" class="headerlink" title="NS_OPTIONS"></a>NS_OPTIONS</h2><p>语法和 <code>NS_ENUM</code> 完全相同，但这个宏提示编译器值是如何通过位掩码 | 组合在一起的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, AMGResizing) &#123;</span><br><span class="line">    AMGResizingNone            = 0,</span><br><span class="line">    AMGResizingFlexibleWidth   = 1 &lt;&lt; 0,</span><br><span class="line">    AMGResizingFlexibleHeight  = 1 &lt;&lt; 1,</span><br><span class="line">    AMGResizingFlexibleUnicorn = 1 &lt;&lt; 2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="attribute-always-inline"><a href="#attribute-always-inline" class="headerlink" title="attribute((always_inline))"></a><strong>attribute</strong>((always_inline))</h1><p>我们知道一般的函数调用都会通过call的方式来调用，这样让攻击很容易对一个函数做手脚，如果是以<code>inline</code>的方式编译的会，会把该函数的code拷贝到每次调用该函数的地方。而<code>static</code>会让生成的二进制文件中没有清晰的符号表，让逆向的人很难弄清楚逻辑。</p>
<p><code>__attribute__((always_inline))</code> 的意思是强制内联，所有加了<code>__attribute__((always_inline))</code> 的函数再被调用时不会被编译成函数调用而是直接扩展到调用函数体内，比如定义了函数<br><code>__attribute__((always_inline)) void a()</code><br>和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void b()｛  </span><br><span class="line">    a();</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>b 调用 a 函数的汇编代码不会是跳转到a执行，而是 a 函数的代码直接在 b 内成为 b 的一部分。<br><code>#define __inline __attribute__((always_inline))</code> 的意思就是用<br><code>__inline</code> 代替<code>__attribute__((always_inline))</code><br>内声明a的时候可以直接写成<code>__inline void a()</code> 这样比较方便因为<code>__attribute__((always_inline))</code> 字多。</p>
<h1 id="undef"><a href="#undef" class="headerlink" title="undef"></a>undef</h1><p>这是预编译指令，和<code>#define</code>搭配使用，意思是取消之前的宏定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define PROC_ADD </span><br><span class="line">void main(void) </span><br><span class="line">&#123;</span><br><span class="line">#ifdef PROC_ADD </span><br><span class="line">// Do this code here then undefined it to run the code in the else </span><br><span class="line">// processing work </span><br><span class="line">#undef PROC_ADD </span><br><span class="line">#else </span><br><span class="line">// now that PROC_ADD has been undefined run this code </span><br><span class="line">// processing work </span><br><span class="line">#endif </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="__unsafe_unretained"></a>__unsafe_unretained</h1><p><code>__unsafe_unretained</code>是对对象的非zeroing的weak reference，意思是当对象所指向的内存被销毁了，对象还存在，称为“野指针”。</p>
<p>在iOS引入了Automatic Reference Count（ARC）之后，编译器可以在编译时对obj-c对象进行内存管理。大致规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alloc的要release;</span><br><span class="line">retain/copy的要release;</span><br><span class="line">NSAutoreleasePool在ARC中被禁止使用,替换成@autoreleasepool 函数体;</span><br><span class="line">使用@ autoreleasepool,在函数入口的时候,autorelease pool入栈,正常退出时,autorelease pool出栈,从而释放变量.</span><br><span class="line">注意:@ autoreleasepool在非ARC模式下,也能使用,并据说使用@autoreleasepool比使用NSAutoreleasePool速度能快6倍, 明显提升程序性能.</span><br></pre></td></tr></table></figure>

<h1 id="package"><a href="#package" class="headerlink" title="@package"></a>@package</h1><p>为了强制一个对象隐藏其数据，编译器限制实例变量范围以限制其在程序中的可见性，但是为了提供灵活性，苹果也让开发者显式设置范围。</p>
<p>以下是这些关键字的使用范围：</p>
<ul>
<li>@private</li>
</ul>
<p>The instance variable is accessible only within the class that declares it.</p>
<p>实例变量只能被声明它的类访问.</p>
<ul>
<li>@protected</li>
</ul>
<p>The instance variable is accessible within the class that declares it and within classes that inherit it. All instance variables without an explicit scope directive have @protected scope.</p>
<p>实例变量能被声明它的类和子类访问，所有没有显式制定范围的实例变量都是.</p>
<ul>
<li>@public</li>
</ul>
<p>The instance variable is accessible everywhere.</p>
<p>实例变量可以被在任何地方访问.</p>
<ul>
<li>@package</li>
</ul>
<p>Using the modern runtime, an <code>@package</code> instance variable has <code>@public</code> scope inside the executable image that implements the class, but acts like <code>@private</code> outside.使用modern运行时，一个<code>@package</code>实例变量在实现这个类的可执行文件镜像中实际上是<code>@public</code>的，但是在外面就是<code>@private</code>【runtime需要再看一下苹果文档Runtime Programming Guide】</p>
<p>The <code>@package</code> scope for Objective-C instance variables is analogous to private_extern for C variables and functions. Any code outside the class implementation’s image that tries to use the instance variable gets a link error.</p>
<p>Objective-C中的<code>@package</code>与C语言中变量和函数的private_extern类似。任何在实现类的镜像之外的代码想使用这个实例变量都会引发link error</p>
<p>This scope is most useful for instance variables in framework classes, where <code>@private</code> may be too restrictive but <code>@protected</code> or <code>@public</code> too permissive.</p>
<p>这个类型最常用于框架类的实例变量，使用<code>@private</code>太限制，使用<code>@protected</code>或者<code>@public</code>又太开放. |</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C 中 new、alloc和init的区别</title>
    <url>/2016-02-16-objc-new-alloc-init/</url>
    <content><![CDATA[<p>在实际开发中很少会用到new，一般创建对象我们看到的全是[[className alloc] init]，但是并不意味着你不会接触到new，在一些代码中还是会看到[className new]，还有去面试的时候，也很可能被问到这个问题。</p>
<span id="more"></span>

<p>那么，它们两者之间到底有什么区别呢？我们先来看源码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ new &#123; </span><br><span class="line">    <span class="type">id</span> newObject = (*_alloc)((Class)<span class="keyword">self</span>, <span class="number">0</span>); </span><br><span class="line">    Class metaClass = <span class="keyword">self</span>-&gt;isa; </span><br><span class="line">    <span class="keyword">if</span> (class_getVersion(metaClass) &gt; <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> [newObject init]; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> newObject; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 alloc&#x2F;init 像这样 </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ alloc &#123; </span><br><span class="line">    <span class="keyword">return</span> (*_zoneAlloc)((Class)<span class="keyword">self</span>, <span class="number">0</span>, malloc_default_zone());  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">- init &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过源码中我们发现，[className new]基本等同于[[className alloc] init]，区别只在于alloc分配内存的时候使用了zone。</p>
<p>那么，这个zone是个什么东西呢？</p>
<p>它是给对象分配内存的时候，把关联的对象分配到一个相邻的内存区域内，以便于调用时消耗很少的代价，提升了程序处理速度。</p>
<p>为什么不推荐使用new？</p>
<p>不知大家发现了没有，如果使用new的话，初始化方法被固定死只能调用init。而你想调用initXXX怎么办？没门儿！据说最初的设计是完全借鉴Smalltalk语法来的。传说那个时候已经有allocFromZone:这个方法，但是这个方法需要传个参数id myCompanion &#x3D; [[TheClass allocFromZone:[self zone]] init];</p>
<p>这个方法像下面这样：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ allocFromZone:(<span class="type">void</span> *) z &#123; </span><br><span class="line">    <span class="keyword">return</span> (*_zoneAlloc)((Class)<span class="keyword">self</span>, <span class="number">0</span>, z);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后来简化为下面这个：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ alloc &#123; </span><br><span class="line">    <span class="keyword">return</span> (*_zoneAlloc)((Class)<span class="keyword">self</span>, <span class="number">0</span>, malloc_default_zone());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，出现个问题：这个方法只是给对象分配了内存，并没有初始化实例变量。</p>
<p>是不是又回到new那样的处理方式：在方法内部隐式调用init方法呢？后来发现“显示调用总比隐式调用更好”，所以后来就把两个方法分开了。 </p>
<p>概括来说，new和alloc&#x2F;init在功能上几乎是一致的，分配内存并完成初始化。差别在于，采用new的方式只能采用默认的init方法完成初始化，采用alloc的方式可以用其他定制的初始化方法。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>objc</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>Apk 反编译</title>
    <url>/2016-02-18-apk-decompile/</url>
    <content><![CDATA[<p>最近看见一些正版软件，便想到pc端软件的破解，便在网络上大肆搜索，终于找到了一个办公软件破解key的软件，对其实现非常感兴趣，想着反编译其apk，在网上也找了很多相关的实现方式，这里，本文介绍博主使用的简约方法与工具。</p>
<span id="more"></span>

<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>1、将apk文件解压，得到其中的classes.dex（java文件编译再通过dx工具打包而成的）。</p>
<p>将classes.dex复制到d2j-dex2jar.bat所在目录dex2jar-0.0.9.13文件夹。 </p>
<p>在命令行下定位到d2j-dex2jar.bat所在目录，运行</p>
<p><code>d2j-dex2jar.bat</code>    <code>classes.dex</code></p>
<p>生成<code>classes_dex2jar.jar</code></p>
<p><a href="http://download.csdn.net/detail/dengw0716/5270008">dex2jar工具下载</a></p>
<p>2、使用jdgui.exe打开classes_dex2jar.jar，即可看见源码。</p>
<p><a href="http://download.csdn.net/detail/dengw0716/5270043">jdgui工具下载</a></p>
<p>只需以上两步，即可获得apk源码。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>逆向</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的算法思想总结</title>
    <url>/2016-02-22-algorithm-idea/</url>
    <content><![CDATA[<p>对于计算机科学而言，算法是一个非常重要的概念。它是程序设计的灵魂，是将实际问题同解决该问题的计算机程序建立起联系的桥梁。文章主要介绍一些常用的算法思想。</p>
<span id="more"></span>

<h1 id="一、穷举法思想"><a href="#一、穷举法思想" class="headerlink" title="一、穷举法思想"></a>一、穷举法思想</h1><p>穷举法，又称为强力法。它是一种最为直接，实现最为简单，同时又最为耗时的一种解决实际问题的算法思想。</p>
<p>基本思想：在可能的解空间中穷举出每一种可能的解，并对每一个可能解进行判断，从中得到问题的答案。</p>
<p>使用穷举法思想解决实际问题，最关键的步骤是划定问题的解空间，并在该解空间中一一枚举每一个可能的解。这里有两点需要注意，一是解空间的划定必须保证覆盖问题的全部解，二是解空间集合及问题的解集一定是离散的集合，也就是说集合中的元素是可列的、有限的。</p>
<p>穷举法用时间上的牺牲换来了解的全面性保证，因此穷举法的优势在于确保得到问题的全部解，而瓶颈在于运算效率十分低下。但是穷举法算法思想简单，易于实现，在解决一些规模不是很大的问题，使用穷举法不失为一种很好地选择。</p>
<p>现在我们通过具体的实例来理解穷举法思想。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  实例：寻找[1,100]之间的素数</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> *  判断n是否是素数，是则返回1，不是则返回0</span><br><span class="line"> */</span><br><span class="line">int isPrime(int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (i = 2; i &lt; n; i++) &#123;</span><br><span class="line">        if (0 == n % i) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> *  寻找[low,high]之间的素数</span><br><span class="line"> */</span><br><span class="line">void getPrime(int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (i = low; i &lt;= high; i++) &#123;</span><br><span class="line">        if (isPrime(i)) &#123;</span><br><span class="line">            printf(&quot;%d &quot;, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    // insert code here...</span><br><span class="line">    int low = 0, high = 0;</span><br><span class="line">    printf(&quot;Please input the domain for searching prime\n&quot;);</span><br><span class="line">    printf(&quot;low limitation:&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;low);</span><br><span class="line">    printf(&quot;high limitation:&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;high);</span><br><span class="line">    printf(&quot;The whole primes in this domain are\n&quot;);</span><br><span class="line">    getPrime(low, high);</span><br><span class="line">    getchar();</span><br><span class="line">     </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Please input the domain for searching prime</span><br><span class="line">low limitation:1</span><br><span class="line">high limitation:100</span><br><span class="line">The whole primes in this domain are</span><br><span class="line">1 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97</span><br></pre></td></tr></table></figure>

<h1 id="二、递归与分治思想"><a href="#二、递归与分治思想" class="headerlink" title="二、递归与分治思想"></a>二、递归与分治思想</h1><p>递归与分治的算法思想往往是相伴而生的，它们在各类算法中使用非常频繁，应用递归和分治的算法思想有时可以设计出代码简洁且比较高效的算法来。</p>
<p>在解决一些比较复杂的问题，特别是解决一些规模较大得问题时，常常将问题进行分解。具体来说，就是将一个规模较大的问题分割成规模较小的同类问题，然后将这些小问题的子问题逐个加以解决，最终也就将整个大问题解决了。这种思想称之为分治。在解决一些问题比较复杂、计算量庞大的问题时经常被用到。</p>
<p>最为经典的使用分治思想设计的算法就是“折半查找算法”。折半查找算法利用了元素之间的顺序关系（有序序列），采用分而治之的策略，不断缩小问题的规模，每次都将问题的规模减小至上一次的一半。</p>
<p>而递归思想也是一种常见的算法设计思想，所谓递归算法，就是一种直接或间接地调用原算法本身的一种算法。</p>
<p>接下来我们通过实例代码来理解递归、分治思想。</p>
<p>分治思想：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  有一个数组A[10]，里面存放了10个整数，顺序递增</span><br><span class="line"> *  A[10] = &#123;2, 3, 5, 7, 8, 10, 12, 15, 19, 21&#125;</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int bin_search(int A[], int n, int key)</span><br><span class="line">&#123;</span><br><span class="line">    int low = 0, high = 0, mid = 0;</span><br><span class="line">    high = n - 1;</span><br><span class="line">    while (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / 2;</span><br><span class="line">        if (A[mid] == key) &#123; //查找成功，返回mid</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        if (A[mid] &lt; key) &#123; //在后半序列中查找</span><br><span class="line">            low = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (A[mid] &gt; key) &#123; //在前半序列中查找</span><br><span class="line">            high = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1; //查找失败</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    // insert code here...</span><br><span class="line">    int A[10] = &#123;2, 3, 5, 7, 8, 10, 12, 15, 19, 21&#125;;</span><br><span class="line">    int i = 0, n = 0, addr = 0;</span><br><span class="line">    printf(&quot;The contents of the Array A[10] are\n&quot;);</span><br><span class="line">    for (i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        printf(&quot;%d &quot;,A[i]); //显示数组A中的内容</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\nPlease input a interger for search\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n); //输入待查找得元素</span><br><span class="line">    addr = bin_search(A, 10, n); //折半查找，返回该元素在数组中的下标</span><br><span class="line">    if (-1 != addr) &#123;</span><br><span class="line">        printf(&quot;%d is at the %dth unit is array A\n&quot;, n, addr);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;There is no %d in array A\n&quot;, n); //查找失败</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">     </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The contents of the Array A[10] are</span><br><span class="line">2 3 5 7 8 10 12 15 19 21</span><br><span class="line">Please input a interger for search</span><br><span class="line">12</span><br><span class="line">12 is at the 6th unit is array A</span><br></pre></td></tr></table></figure>

<p>递归思想：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  计算n的阶乘n!</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">int factorial(int n)</span><br><span class="line">&#123;</span><br><span class="line">    if (0 == n) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return n * factorial(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    // insert code here...</span><br><span class="line">    int n = 0, result = 0;</span><br><span class="line">    printf(&quot;Please input factorial number\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    result = factorial(n);</span><br><span class="line">    printf(&quot;result is %d&quot;, result);</span><br><span class="line">    getchar();</span><br><span class="line">     </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Please input factorial number</span><br><span class="line">6</span><br><span class="line">result is 720</span><br></pre></td></tr></table></figure>


<h1 id="三、贪心算法思想"><a href="#三、贪心算法思想" class="headerlink" title="三、贪心算法思想"></a>三、贪心算法思想</h1><p>贪心算法的思想非常简单且算法效率很高，在一些问题的解决上有着明显的优势。</p>
<p>先来看一个生活中的例子。假设有3种硬币，面值分别为1元、5角、1角。这3种硬币各自的数量不限，现在要找给顾客3元6角钱，请问怎样找才能使得找给顾客的硬币数量最少呢？你也许会不假思索的说出答案：找给顾客3枚1元硬币，1枚5角硬币，1枚1角硬币。其实也可以找给顾客7枚5角硬币，1枚1角硬币。可是在这里不符合题意。在这里，我们下意识地应用了所谓贪心算法解决这个问题。</p>
<p>所谓贪心算法，就是总是做出在当前看来是最好的选择的一种方法。以上述的题目为例，为了找给顾客的硬币数量最少，在选择硬币的面值时，当然是尽可能地选择面值大的硬币。因此，下意识地遵循了以下方案：</p>
<p>（1）首先找出一个面值不超过3元6角的最大硬币，即1元硬币。</p>
<p>（2）然后从3元6角中减去1元，得到2元6角，再找出一个面值不超过2元6角的最大硬币，即1元硬币。</p>
<p>（3）然后从2元6角中减去1元，得到1元6角，再找出一个面值不超过1元6角的最大硬币，即1元硬币。</p>
<p>（4）然后从1元6角中减去1元，得到6角，再找出一个面值不超过6角的最大硬币，即5角硬币。</p>
<p>（5）然后从6角中减去5角，得到1角，再找出一个面值不超过1角的最大硬币，即1角硬币。</p>
<p>（6）找零钱的过程结束。</p>
<p>这个过程就是一个典型的贪心算法思想。</p>
<p>因此，不难看出应用贪心算法求解问题，并不从问题的整体最优上加以考虑，它所作出的每一步选择只是在某种意义上得局部最优选择。因此，严格意义上讲，要使用贪心算法求解问题，该问题应当具备以下性质。</p>
<p>（1）贪心选择性质</p>
<p>所谓贪心选择性质，就是指所求解的问题的整体最优解可以通过一系列的局部最优解得到。所谓局部最优解，就是指在当前的状态下做出的最好选择。</p>
<p>（2）最优子结构性质</p>
<p>当一个问题的最优解包含着它的子问题的最优解时，就称此问题具有最优子结构性质。</p>
<p>我们经常使用的哈夫曼（Huffman Tree）编码算法，求解最小生成树的克鲁斯卡尔（Kruskal）算法和普利姆（Prim）算法，求解图的单源最短路径的迪克斯特拉（Dijkstra）算法都是基于贪心算法的思想设计的。</p>
<p>下面，我们来通过实例代码来理解贪心算法思想。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  最优装船问题</span><br><span class="line"> *  有一批集装箱要装入一个载质量为C的货船中，每个集装箱的质量由用户自己输入指定，在货船的装载体积不限的前提下，如何装载集装箱才能尽可能多地将集装箱装入货船中。</span><br><span class="line"> */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line">void sort(int w[], int t[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0, j = 0, tmp = 0;</span><br><span class="line">    //存放w[]中的内容，用于排序</span><br><span class="line">    int *w_tmp = (int *)malloc(sizeof(int) * n);</span><br><span class="line">     </span><br><span class="line">    for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        t[i] = i;  //初始化数组t</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        w_tmp[i] = w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i &lt; n - 1; i++) &#123; //冒泡排序</span><br><span class="line">        for (j = 0; j &lt; n - i - 1; j++) &#123;</span><br><span class="line">            if (w_tmp[j] &gt; w_tmp[j+1]) &#123;</span><br><span class="line">                tmp = w_tmp[j];</span><br><span class="line">                w_tmp[j] = w_tmp[j+1];</span><br><span class="line">                w_tmp[j+1] = tmp;</span><br><span class="line">                tmp = t[j];</span><br><span class="line">                t[j] = t[j+1];</span><br><span class="line">                t[j+1] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void Loading(int x[], int w[], int c, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    //存放w[]的下标，如果t[i]、t[j]、i&lt;j，则w[i]&lt;=w[j]</span><br><span class="line">    int *t = (int *)malloc(sizeof(int) * n);</span><br><span class="line">    //排序，用数组t[[]存放w[]的下标</span><br><span class="line">    sort(w, t, n);</span><br><span class="line">    for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        x[i] = 0;  //初始化数组x[]</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i &lt; n &amp;&amp; w[t[i]] &lt;= c; i++) &#123;</span><br><span class="line">        x[t[i]] = 1; //将第t[i]个集装箱装入货船中</span><br><span class="line">        c = c - w[t[i]]; //变量c中存放货船的剩余载质量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    // insert code here...</span><br><span class="line">    int x[5], w[5], c = 0, i = 0;</span><br><span class="line">    printf(&quot;Please input the maximum loading of the sheep\n&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;c); //</span><br><span class="line">    printf(&quot;Please input the weight of FIVE box\n&quot;);</span><br><span class="line">    for (i = 0; i &lt; 5; i++) &#123; //</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Loading(x, w, c, 5); //</span><br><span class="line">    printf(&quot;The following boxes will be loaded\n&quot;);</span><br><span class="line">    for (i = 0; i &lt; 5; i++) &#123; //</span><br><span class="line">        if (1 == x[i]) &#123;</span><br><span class="line">            printf(&quot;BOX:%d &quot;, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">     </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Please input the maximum loading of the sheep</span><br><span class="line">13</span><br><span class="line">Please input the weight of FIVE box</span><br><span class="line">5 7 6 3 2</span><br><span class="line">The following boxes will be loaded</span><br><span class="line">BOX:0 BOX:3 BOX:4</span><br></pre></td></tr></table></figure>


<p>以上，就是对算法设计中几个常见的思想的总结。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>欢迎大家加入移动开发交流Q群交流讨论，Q群号：811237468</p>
<p><img src="/assets/images/Q811237468.jpg" alt="Q811237468"></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>OAuth2.0 协议</title>
    <url>/2016-03-02-oauth2-protocol/</url>
    <content><![CDATA[<p>OAuth（Open Authorization），协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是OAuth的授权不会使第三方触及到用户的帐号信息（如用户名和密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户的授权，因此，OAuth是安全的。这些解释都是官方的，本文中博主会根据自己的学习所得，整理分享对OAuth协议的理解。</p>
<span id="more"></span>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>OAuth（Open Authorization），协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是OAuth的授权不会使第三方触及到用户的帐号信息（如用户名和密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户的授权，因此，OAuth是安全的。</p>
<p>这些解释其实都是可以在网上搜索到的。为了解释的更加清楚，接下来博主结合实例绘图解释：</p>
<p><img src="/assets/images/tech/oauth2-protocol-1.png" alt="1"></p>
<p>整个OAuth授权过程中，三者都获得了自己的便利。<br>用户可以不用注册帐号，可以直接使用关联帐号就可登录新的网站使用资源，且不用担心帐号失窃，因为这个授权过程是安全的。<br>慕课网可以更加轻易的获取用户量。<br>腾讯将海量的数据开放给第三方网站，既是为其他小企业做的贡献，也增大了自身的知名度。
 </p>
<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><p>OAuth1.0 发布于2007年末，存在严重安全漏洞。</p>
<p>OAuth2.0 发布于2010年初，解决上一版本的安全漏洞，现被各大网站公司一直使用。
 </p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>1）QQ用户授权慕课网使用其QQ帐号相关信息。</p>
<p>2）获取授权后，在符合权限规则的情况下访问各种API。</p>
<p>3）淘宝帐号，可在支付宝，阿里云中使用。</p>
<p>总的来说，OAuth是某一独立系统，开放其用户资源给另一系统使用的协议。
 </p>
<h1 id="实现过程（三个步骤）"><a href="#实现过程（三个步骤）" class="headerlink" title="实现过程（三个步骤）"></a>实现过程（三个步骤）</h1><p><img src="/assets/images/tech/oauth2-protocol-2.png" alt="2"></p>
<h2 id="步骤一：请求OAuth登录页面"><a href="#步骤一：请求OAuth登录页面" class="headerlink" title="步骤一：请求OAuth登录页面"></a>步骤一：请求OAuth登录页面</h2><p>Request Token URL，未授权的令牌请求服务地址。</p>
<p>慕课网请求QQ登录页面时使用的带有特定参数的URL。</p>
<p>例如，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　https://graph.qq.com/oauth/...?...</span><br><span class="line">　　&amp;client_id=100490398&amp;...</span><br><span class="line">　　&amp;redirect_uri=http://www.mukewang.com/...</span><br></pre></td></tr></table></figure>
<p>第一行为QQ登录OAuth页面的地址。</p>
<p>第二行为一个唯一的站点ID，必须和预置服务器上的一致。</p>
<p>第三行为一个回调地址，必须和预置服务器上的一致。</p>
<h2 id="步骤二：用户使用QQ号登录并授权"><a href="#步骤二：用户使用QQ号登录并授权" class="headerlink" title="步骤二：用户使用QQ号登录并授权"></a>步骤二：用户使用QQ号登录并授权</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　https://graph.qq.com/oauth/...?...</span><br><span class="line">　　&amp;client_id=100490398&amp;...</span><br><span class="line">　　&amp;redirect_uri=http://www.mukewang.com/...</span><br></pre></td></tr></table></figure>
<p>跳转到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　http://www.mukewang.com/user/qqcallback?code=xxxxx....</span><br></pre></td></tr></table></figure>

<p>慕课网服务器使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　$_GET[&#x27;code&#x27;];</span><br></pre></td></tr></table></figure>
<p>获取加密字符。</p>
<h2 id="步骤三：返回登录结果"><a href="#步骤三：返回登录结果" class="headerlink" title="步骤三：返回登录结果"></a>步骤三：返回登录结果</h2><p>User Authorization URL，用户授权的令牌请求服务地址</p>
<p>为保证安全，确保code是合法服务器获得，没有被劫持，则需要合法接收服务器再发送一个请求（User Authorization URL）。</p>
<p>例如，用户QQ登录授权之后需要请求一个带有特定参数的URL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　https://xxx.qq.com/oauth/...?...</span><br><span class="line">　　&amp;client_id=100490398&amp;...</span><br><span class="line">　　&amp;client_secret=xxxxxx&amp;...</span><br><span class="line">　　&amp;code=xxxxx......</span><br></pre></td></tr></table></figure>
<p>code在短期内会过期且只可使用一次，通常是10秒左右。基于安全考虑。
 </p>
<h1 id="关于AccessToken"><a href="#关于AccessToken" class="headerlink" title="关于AccessToken"></a>关于AccessToken</h1><p>AccessToken，用户通过第三方应用访问OAuth接口的令牌，具有较长生命周期（10天半个月甚至更长）。如果AccessToken过期，可以重新登录授权，或在User Authorization URL中指定参数（刷新AccessToken的参数，各平台各有不同）”……&amp;need_refresh_token&#x3D;true&amp;……”。</p>
<p>获取AccessToken就可以访问授权帐号的资源，例如，通过慕课网把自己喜欢的课程分享到QQ空间。
 </p>
<h2 id="AccessToken与RefreshToken"><a href="#AccessToken与RefreshToken" class="headerlink" title="AccessToken与RefreshToken"></a>AccessToken与RefreshToken</h2><p>RefreshToken也是有生命周期的，不过比AccessToken生命周期要长，各大平台不一样。</p>
<p><img src="/assets/images/tech/oauth2-protocol-3.png" alt="3"></p>
<p>使用实例类比AccessToken</p>
<p><img src="/assets/images/tech/oauth2-protocol-4.png" alt="4"></p>
<p>将返回的XML或JSON解析成我们想要的数据</p>
<p><img src="/assets/images/tech/oauth2-protocol-5.png" alt="5"></p>
<p>希望对大家有所帮助。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode 使用小记</title>
    <url>/2016-03-05-xcode-console-cli/</url>
    <content><![CDATA[<p>Xcode 是iOS开发者的福利，不得不说乔帮主给爱疯开发者提供了从业便利。我们这些后继者都发自内心的膜拜。也正是乔帮主的偏执，成就了苹果的伟大。Xcode 的可视化操作便捷，可是为了更灵活地debug，我们还是需要掌握一些提供效率的debug命令，文章分享迄今为止博主所知晓的debug命令，也会保持本文的持续更新。希望对大家有所帮助。</p>
<span id="more"></span>

<h1 id="debug-命令表"><a href="#debug-命令表" class="headerlink" title="debug 命令表"></a>debug 命令表</h1><table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>break NUM</td>
<td>在指定的行上设置断点</td>
</tr>
<tr>
<td>bt</td>
<td>显示所有的调用栈帧，该命令可用来显示函数的调用顺序</td>
</tr>
<tr>
<td>clear</td>
<td>删除设置在特定源文件、特定行上的断点，其用法为：clear FILENAME:NUM</td>
</tr>
<tr>
<td>continue</td>
<td>继续执行正在调试的程序，该命令用在程序由于处理信号或断点而导致停止运行时</td>
</tr>
<tr>
<td>display EXPR</td>
<td>每次程序停止后显示表达式的值。表达式由程序定义的变量组成</td>
</tr>
<tr>
<td>file FILE</td>
<td>装载指定的可执行文件进行调试</td>
</tr>
<tr>
<td>help NAME</td>
<td>显示指定命令的帮助信息</td>
</tr>
<tr>
<td>info break</td>
<td>显示当前断电清单，包括到达断点处的次数等</td>
</tr>
<tr>
<td>info files</td>
<td>显示被调试文件的详细信息</td>
</tr>
<tr>
<td>info func</td>
<td>显示所有的函数名称</td>
</tr>
<tr>
<td>info local</td>
<td>显示当前函数中的局部变量信息</td>
</tr>
<tr>
<td>info prog</td>
<td>显示被调试程序的执行状态</td>
</tr>
<tr>
<td>info var</td>
<td>显示所有的全局和静态变量名称</td>
</tr>
<tr>
<td>kill</td>
<td>终止正被调试的程序</td>
</tr>
<tr>
<td>list</td>
<td>显示源代码段</td>
</tr>
<tr>
<td>make</td>
<td>在不退出gdb的情况下运行make工具</td>
</tr>
<tr>
<td>next</td>
<td>在不单步执行进入其他函数的情况下，向前执行一行源代码</td>
</tr>
<tr>
<td>print EXPR</td>
<td>显示表达式EXPR的值</td>
</tr>
<tr>
<td>print-object</td>
<td>打印一个对象</td>
</tr>
<tr>
<td>print (int) name</td>
<td>打印一个类型</td>
</tr>
<tr>
<td>print-object [artist description]</td>
<td>调用一个函数</td>
</tr>
<tr>
<td>set artist - @”test”</td>
<td>设置变量值</td>
</tr>
<tr>
<td>help</td>
<td>查看帮助</td>
</tr>
</tbody></table>
<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><ul>
<li>文件</li>
</ul>
<table>
<thead>
<tr>
<th>按键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>CMD + N</td>
<td>新文件</td>
</tr>
<tr>
<td>CMD + SHIFT + N</td>
<td>新项目</td>
</tr>
<tr>
<td>CMD + O</td>
<td>打开</td>
</tr>
<tr>
<td>CMD + S</td>
<td>保存</td>
</tr>
<tr>
<td>CMD + SHIFT + S</td>
<td>另存为</td>
</tr>
<tr>
<td>CMD + W</td>
<td>关闭窗口</td>
</tr>
<tr>
<td>CMD + SHIFT + W</td>
<td>关闭文件</td>
</tr>
</tbody></table>
<ul>
<li>编辑</li>
</ul>
<table>
<thead>
<tr>
<th>按键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>CMD + [</td>
<td>左缩进</td>
</tr>
<tr>
<td>CMD + ]</td>
<td>右缩进</td>
</tr>
<tr>
<td>CMD + CTRL + LEFT</td>
<td>折叠</td>
</tr>
<tr>
<td>CMD + CTRL + RIGHT</td>
<td>取消折叠</td>
</tr>
<tr>
<td>CMD + CTRL + TOP</td>
<td>折叠全部函数</td>
</tr>
<tr>
<td>CMD + CTRL + BOTTOM</td>
<td>取消全部函数折叠</td>
</tr>
<tr>
<td>CTRL + U</td>
<td>取消全部折叠</td>
</tr>
<tr>
<td>CMD + D</td>
<td>添加书签</td>
</tr>
<tr>
<td>CMD + &#x2F;</td>
<td>注释或取消注释</td>
</tr>
<tr>
<td>CTRL + .</td>
<td>参数提示</td>
</tr>
<tr>
<td>ESC</td>
<td>自动提示列表</td>
</tr>
</tbody></table>
<ul>
<li>调试</li>
</ul>
<table>
<thead>
<tr>
<th>按键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>CMD + | 设置或取消断点</td>
<td></td>
</tr>
<tr>
<td>CMD + OPT + | 允许或禁用当前断点</td>
<td></td>
</tr>
<tr>
<td>CMD + OPT + B</td>
<td>查看全部断点</td>
</tr>
<tr>
<td></td>
<td>CMD + RETURN</td>
</tr>
<tr>
<td>CMD + R</td>
<td>编译并运行（不触发断点）</td>
</tr>
<tr>
<td>CMD + Y</td>
<td>编译并调试（触发断点）</td>
</tr>
<tr>
<td>CMD + SHIFT + RETURN</td>
<td>终止运行或调试</td>
</tr>
<tr>
<td>CMD + B</td>
<td>编译</td>
</tr>
<tr>
<td>CMD + SHIFT + K</td>
<td>清理</td>
</tr>
</tbody></table>
<ul>
<li>窗体</li>
</ul>
<table>
<thead>
<tr>
<th>按键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>CMD + SHIFT + B</td>
<td>编译窗口</td>
</tr>
<tr>
<td>CMD + SHIFT + Y</td>
<td>调试代码窗口</td>
</tr>
<tr>
<td>CMD + SHIFT + R</td>
<td>调试控制台</td>
</tr>
<tr>
<td>CMD + SHIFT + E</td>
<td>主编辑窗口调整</td>
</tr>
</tbody></table>
<ul>
<li>帮助</li>
</ul>
<table>
<thead>
<tr>
<th>按键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>CMD + OPT + ?</td>
<td>开发手册</td>
</tr>
<tr>
<td>CMD + CTRL + ?</td>
<td>快速帮助</td>
</tr>
<tr>
<td>Command + Shift + E</td>
<td>扩展编辑器</td>
</tr>
<tr>
<td>Command + [</td>
<td>左移代码块</td>
</tr>
<tr>
<td>Command + ]</td>
<td>右移代码块</td>
</tr>
<tr>
<td>Tab</td>
<td>接受代码提示</td>
</tr>
<tr>
<td>Esc</td>
<td>显示代码提示菜单</td>
</tr>
<tr>
<td>Ctrl + . （句点）</td>
<td>循环浏览代码提示</td>
</tr>
<tr>
<td>Shift + Ctrl + . （句点）</td>
<td>反向循环浏览代码提示</td>
</tr>
<tr>
<td>Ctrl + &#x2F;</td>
<td>移动到代码提示中的下一个占位符</td>
</tr>
<tr>
<td>Command + Ctrl + S</td>
<td>创建快照</td>
</tr>
<tr>
<td>Ctrl + F</td>
<td>前移光标</td>
</tr>
<tr>
<td>Ctrl + B</td>
<td>后移光标</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>移动光标到上一行</td>
</tr>
<tr>
<td>Ctrl + N</td>
<td>移动光标到下一行</td>
</tr>
<tr>
<td>Ctrl + A</td>
<td>移动光标到本行行首</td>
</tr>
<tr>
<td>Ctrl + E</td>
<td>移动光标到本行行尾</td>
</tr>
<tr>
<td>Ctrl + T</td>
<td>交换光标左右两边的字符</td>
</tr>
<tr>
<td>Ctrl + D</td>
<td>删除光标右边的字符</td>
</tr>
<tr>
<td>Ctrl + K</td>
<td>删除本行</td>
</tr>
<tr>
<td>Ctrl + L</td>
<td>将插入点置于窗口正中</td>
</tr>
<tr>
<td>Command + Alt + D</td>
<td>显示open quickly 窗口</td>
</tr>
<tr>
<td>Command + Alt + 上方向键</td>
<td>打开配套文件</td>
</tr>
<tr>
<td>Command + D</td>
<td>添加书签</td>
</tr>
<tr>
<td>Option + 双击</td>
<td>在文档中搜索</td>
</tr>
<tr>
<td>Command + Y</td>
<td>以调试方式运行程序</td>
</tr>
<tr>
<td>Command + Alt + P</td>
<td>继续（在调试中）</td>
</tr>
<tr>
<td>Command + Alt + 0</td>
<td>跳过</td>
</tr>
<tr>
<td>Command + Alt + I</td>
<td>跳入</td>
</tr>
<tr>
<td>Command + Alt + T</td>
<td>跳出</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS Project与OS X Project中plist使用区别</title>
    <url>/2016-03-06-ios-application-plist-diff/</url>
    <content><![CDATA[<p>这篇文章来源于开源中国的一道题目，因为答题，所以coding，所以发现了原来还有这样子的区别。因此，拿出来和大家分享。</p>
<p>之前在开源中国看到一个求源代码的问题:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">模拟一个动物园系统MyZoo </span><br><span class="line"> </span><br><span class="line">1、动物园里面有三种动物:Panda,Elephant,Kangaroo </span><br><span class="line">2、三种动物都有一定的数量(不止一只) </span><br><span class="line">3、动物有各自不同的食量(以天为单位的食量),并且每天都在消耗食物。 </span><br><span class="line">4、动物园里的食物有固定的储备,而且假设三种动物都吃这一种食物。 </span><br><span class="line">5、每个动物都有不同的生产周期,每当到了这种动物的生产周期,动物园就会出现一位新生宝宝(假设其食量和成年动物是一样的)。 </span><br><span class="line">6、在主循环里模拟动物园的运转情况,要求在控制台上输出如下内容:第几天、动物的数量、动物园饲料的余量,直到饲料不够吃为止。 </span><br><span class="line">7、动物的数量,食量,生产周期,饲料总量都应该是可以配置的(在同一个文件中统一配置) </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>因此创建了一个OS X Project，使用plist当做这个动物园系统的初始数据的配置，代码结构如下：</p>
<p><img src="/assets/images/tech/ios-application-plist-diff-1.png" alt="1"></p>
<p>在main.m文件中实现上述题目的要求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;Tool.h&quot;</span><br><span class="line"> </span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // insert code here...</span><br><span class="line">        Panda *panda = [[Panda alloc] init];</span><br><span class="line">        Elephant *elephant = [[Elephant alloc] init];</span><br><span class="line">        Kangaroo *kangaroo = [[Kangaroo alloc] init];</span><br><span class="line">         </span><br><span class="line">        //读取plist</span><br><span class="line">        NSString *plistPath = [[NSBundle mainBundle] pathForResource:@&quot;data&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">        NSMutableDictionary *data = [[NSMutableDictionary alloc] initWithContentsOfFile:plistPath];</span><br><span class="line">        NSLog(@&quot;%@&quot;, plistPath);</span><br><span class="line">         </span><br><span class="line">        [Tool initWithAnimalDictionary:panda andDict:data];</span><br><span class="line">        [Tool initWithAnimalDictionary:elephant andDict:data];</span><br><span class="line">        [Tool initWithAnimalDictionary:kangaroo andDict:data];</span><br><span class="line">         </span><br><span class="line">        int fooder_num = 0;</span><br><span class="line">        int surplus = 0;</span><br><span class="line">        int day = 1;</span><br><span class="line">         </span><br><span class="line">        NSDictionary *fooderDict = [data objectForKey:@&quot;fodder&quot;];</span><br><span class="line">        fooder_num = [[fooderDict objectForKey:@&quot;count_num&quot;] intValue];</span><br><span class="line">        surplus = fooder_num;</span><br><span class="line">         </span><br><span class="line">        while(surplus &gt; 0)&#123;</span><br><span class="line">            if(0 == (day % [panda parturitionDays]))&#123;</span><br><span class="line">                [panda setCount:([panda count] + 1)];</span><br><span class="line">            &#125;</span><br><span class="line">            if(0 == (day % [elephant parturitionDays]))&#123;</span><br><span class="line">                [elephant setCount:([elephant count] + 1)];</span><br><span class="line">            &#125;</span><br><span class="line">            if(0 == (day % [kangaroo parturitionDays]))&#123;</span><br><span class="line">                [kangaroo setCount:([kangaroo count] + 1)];</span><br><span class="line">            &#125;</span><br><span class="line">            surplus = fooder_num - ([panda count] * [panda foodConsumption] + [elephant count] * [elephant foodConsumption] + [kangaroo count] * [kangaroo foodConsumption]);</span><br><span class="line">            fooder_num = surplus;</span><br><span class="line">             </span><br><span class="line">            if(surplus)&#123;</span><br><span class="line">                NSLog(@&quot;第 %d 天，熊猫:%d 只，大象:%d 头，袋鼠:%d 只，饲料余量:%d 。\n&quot;, day, [panda count], [elephant count], [kangaroo count], surplus);</span><br><span class="line">            &#125;</span><br><span class="line">            day++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个时候遇见了问题，下面这句代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *plistPath = [[NSBundle mainBundle] pathForResource:@&quot;data&quot; ofType:@&quot;plist&quot;];</span><br></pre></td></tr></table></figure>

<p>在执行时一直是null，无法找到文件路径。而后在iOS Application Project – Single View Application中，plistPath是正确值,这下就不知道问题是什么了。看了<code>[NSBundle mainBundle]</code>中对于不同文件夹使用不同的方法,确定将文件放在工程下是使用上述代码。最后尝试各种方法，找到了一种解决方案：</p>
<p><img src="/assets/images/tech/ios-application-plist-diff-2.png" alt="2"></p>
<p>如上图所示，在Build Phase中Compile Sources中添加data.plist文件即可。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C中的alloc和init问题</title>
    <url>/2016-03-07-objc-alloc-init/</url>
    <content><![CDATA[<p>这些都是小知识点，没有办法，博主自学过来的，关于一些知识并没有形成系统，这里也是博主自己的学习笔记。发现这个问题，拿出来和大家分享，有什么不足，还请指正。</p>
<p>从开始学的<code>NSString *name=[[NSString alloc] init] </code>起，仅知道这句话是分配内存空间，一直在用，从来没考虑过它的内部是怎么实现的。今天无意中看到了这一句代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *name = [NSString alloc];</span><br><span class="line">NSLog(@&quot;%p&quot;,name);</span><br><span class="line">name = [name init];</span><br><span class="line">NSLog(@&quot;%p&quot;,name);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>试着打印了一下，发现两个的内存地址不一样：</p>
<p><img src="/assets/images/tech/objc-alloc-init-1.png" alt="1"></p>
<p>alloc是开辟一个内存空间，init是初始化，为什么初始化不在原有的内存空间上初始化，而是重新开辟一个内存空间。于是开始查资料，这时又发现了一个新的迷惑：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSObject *obj = [NSObject alloc];</span><br><span class="line">NSLog(@&quot;%p&quot;,obj);</span><br><span class="line">obj = [obj init];</span><br><span class="line">NSLog(@&quot;%p&quot;,obj);</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<p><img src="/assets/images/tech/objc-alloc-init-2.png" alt="2"></p>
<p>怎么地址又变一样了？再打印NSArray的试一试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSArray *person = [NSArray alloc];</span><br><span class="line">NSLog(@&quot;%p&quot;,person);</span><br><span class="line">person = [person init];</span><br><span class="line">NSLog(@&quot;%p&quot;,person);</span><br></pre></td></tr></table></figure>
<p>再次打印结果：</p>
<p><img src="/assets/images/tech/objc-alloc-init-3.png" alt="3"></p>
<p>仍然是不一样的。原因是什么呢？首先看看NSStrng的init方法吧：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(id)init&#123; </span><br><span class="line">  if(self = [super init]) &#123;</span><br><span class="line">    // 重新赋值 </span><br><span class="line">    //… </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以分析，<code>self=[super init]</code>如果不为nil，就重新分配内存空间，这就解释了为什么 NSString，NSArray的调用alloc]init]方法后，内存地址会不一样，但是NSObject为什么会一样呢，我们知道NSObject是一切类的基类，当<code>[[NSString alloc]init]</code>执行时，调用的<code>[super init]</code>就是 NSObject中的init方法，既然NSObject身为基类，它也就无法调用super init，所以当NSObject执行<code>[[NSObject alloc]init]</code>时，也就没有了init重新分配空间这一环节。</p>
<p>至于苹果公司为什么初始化一个实例要分两步，个人认为是方便构造后初始化不同的方法，如果用 new关键字，只能调用一个init，而不能调用initWithName等方法。</p>
<p><strong>知识拓展：</strong></p>
<p>NSString alloc之后，没有init，那么这部分alloc后的内存空间可不可以用？答案是显而易见的，如果可以用，苹果公司也就没必要提供一个init方法，那么alloc后的指针称为什么呢？ ——悬挂指针。</p>
<p>如果一个地方指针既不为空，也没有被设置为指向一个已知的对象，则这样的指针称为<strong>悬挂指针</strong>。在程序里面是很危险的事。当程序运行使用该指针时，程序不能判断指针的合法性，将会产生很严重的错误。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>objc</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>socket 通信简介</title>
    <url>/2016-03-09-socket-communicate-introduction/</url>
    <content><![CDATA[<p>我们深谙信息交流的价值，那网络中进程之间如何通信，如我们每天打开浏览器浏览网页时，浏览器的进程怎么与web服务器通信的？当你用QQ聊天时，QQ进程怎么与服务器或你好友所在的QQ进程通信？这些都得靠socket？那什么是socket？socket的类型有哪些？还有socket的基本函数，这些都是本文想介绍的。</p>
<span id="more"></span>


<h1 id="1-网络中进程之间如何通信"><a href="#1-网络中进程之间如何通信" class="headerlink" title="1 网络中进程之间如何通信"></a>1 网络中进程之间如何通信</h1><p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p>
<ul>
<li>消息传递（管道、FIFO、消息队列）</li>
<li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li>
<li>共享内存（匿名的和具名的）</li>
<li>远程过程调用（Solaris门和Sun RPC）</li>
</ul>
<p> </p>
<p>但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP&#x2F;IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p>
<p>使用TCP&#x2F;IP协议的应用程序通常采用应用编程接口：UNIX  BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆socket”。
 </p>
<h1 id="2-什么是socket"><a href="#2-什么是socket" class="headerlink" title="2 什么是socket"></a>2 什么是socket</h1><p>上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix&#x2F;Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写read &#x2F;write –&gt; 关闭close”模式来操作。我的理解就是socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读&#x2F;写IO、打开、关闭），这些函数我们在后面进行介绍。</p>
<h2 id="socket一词的起源"><a href="#socket一词的起源" class="headerlink" title="socket一词的起源"></a>socket一词的起源</h2><p>在组网领域的首次使用是在1970年2月12日发布的文献IETF RFC33中发现的，撰写者为Stephen Carr、Steve Crocker和Vint Cerf。根据美国计算机历史博物馆的记载，Croker写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。”
 </p>
<h1 id="3-socket的基本操作"><a href="#3-socket的基本操作" class="headerlink" title="3 socket的基本操作"></a>3 socket的基本操作</h1><p>既然Socket是“open—read&#x2F;write—close”模式的一种实现，那么Socket就提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。</p>
<h2 id="3-1-socket-函数"><a href="#3-1-socket-函数" class="headerlink" title="3.1 socket()函数"></a>3.1 socket()函数</h2><p><code>int socket(int domain, int type, int protocol);</code></p>
<p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p>
<p>正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p>
<p>1）domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</p>
<p>2）type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。</p>
<p>3）protocol：顾名思义，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。</p>
<p><strong>注意：</strong>并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p>
<p>当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。
 </p>
<h2 id="3-2-bind-函数"><a href="#3-2-bind-函数" class="headerlink" title="3.2 bind()函数"></a>3.2 bind()函数</h2><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p>
<p><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></p>
<p>函数的三个参数分别为：</p>
<p>1）sockfd：即socket描述字，它是通过socket()函数创建，唯一标识一个socket。bind()函数就是给这个描述字绑定一个名字。</p>
<p>2）addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，例如，<br>ipv4对应的是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sockaddr_in &#123;</span><br><span class="line">    sa_family_t    sin_family; /* address family: AF_INET */</span><br><span class="line">    in_port_t      sin_port;   /* port in network byte order */</span><br><span class="line">    struct in_addr sin_addr;   /* internet address */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* Internet address. */</span><br><span class="line">struct in_addr &#123;</span><br><span class="line">    uint32_t       s_addr;     /* address in network byte order */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ipv6对应的是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sockaddr_in6 &#123; </span><br><span class="line">    sa_family_t     sin6_family;   /* AF_INET6 */ </span><br><span class="line">    in_port_t       sin6_port;     /* port number */ </span><br><span class="line">    uint32_t        sin6_flowinfo; /* IPv6 flow information */ </span><br><span class="line">    struct in6_addr sin6_addr;     /* IPv6 address */ </span><br><span class="line">    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */ </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct in6_addr &#123; </span><br><span class="line">    unsigned char   s6_addr[16];   /* IPv6 address */ </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Unix域对应的是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define UNIX_PATH_MAX    108</span><br><span class="line">struct sockaddr_un &#123; </span><br><span class="line">    sa_family_t sun_family;               /* AF_UNIX */ </span><br><span class="line">    char        sun_path[UNIX_PATH_MAX];  /* pathname */ </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3）addrlen：对应的是地址的长度。</p>
<p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，由系统自动分配一个端口号和自身的ip地址组合。**这就是为什么通常服务器端在listen之前会调用bind()**，而客户端就不会调用，而是在connect()时由系统随机生成一个。
 </p>
<h3 id="网络字节序与主机字节序"><a href="#网络字节序与主机字节序" class="headerlink" title="网络字节序与主机字节序"></a>网络字节序与主机字节序</h3><p>主机字节序就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：</p>
<p>a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</p>
<p>b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。（所见即所得）</p>
<p><strong>网络字节序：</strong>4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。由于TCP&#x2F;IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。字节序，顾名思义，字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。</p>
<p>因此，在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。
 </p>
<h2 id="3-3-listen-、connect-函数"><a href="#3-3-listen-、connect-函数" class="headerlink" title="3.3 listen()、connect()函数"></a>3.3 listen()、connect()函数</h2><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>

<p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p>
<p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。
 </p>
<h2 id="3-4-accept-函数"><a href="#3-4-accept-函数" class="headerlink" title="3.4 accept()函数"></a>3.4 accept()函数</h2><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址。TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数去接收请求，这样连接就建立好了。之后就可以开始网络I&#x2F;O操作了，即类同于普通文件的读写I&#x2F;O操作。</p>
<p><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code></p>
<p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p>
<p>** 注意：** accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接收的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。
 </p>
<h2 id="3-5-read-、write-等函数"><a href="#3-5-read-、write-等函数" class="headerlink" title="3.5 read()、write()等函数"></a>3.5 read()、write()等函数</h2><p>万事具备只欠东风，至此服务器与客户已经建立好连接。可以调用网络I&#x2F;O进行读写操作了，即实现了网络中不同进程之间的通信！网络I&#x2F;O操作有下面几组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read()/write()</span><br><span class="line">recv()/send()</span><br><span class="line">readv()/writev()</span><br><span class="line">recvmsg()/sendmsg()</span><br><span class="line">recvfrom()/sendto()</span><br></pre></td></tr></table></figure>

<p>推荐使用recvmsg()&#x2F;sendmsg()函数，这两个函数是最通用的I&#x2F;O函数，实际上可以把上面的其它函数都替换成这两个函数。它们的声明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line"></span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"></span><br><span class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br><span class="line">ssize_t recv(int sockfd, void *buf, size_t len, int flags);</span><br><span class="line"></span><br><span class="line">ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);</span><br><span class="line">ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);</span><br><span class="line"></span><br><span class="line">ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);</span><br><span class="line">ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</span><br></pre></td></tr></table></figure>

<p>read函数是负责从fd中读取内容。当成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。</p>
<p>write函数将buf中的nbytes字节内容写入文件描述符fd。成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有两种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。</p>
<p>其它的就不一一介绍这几对I&#x2F;O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send&#x2F;recv。
 </p>
<h2 id="3-6-close-函数"><a href="#3-6-close-函数" class="headerlink" title="3.6 close()函数"></a>3.6 close()函数</h2><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p>
<p>close一个TCP socket的缺省行为是把该socket标记为已关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p>
<p>** 注意：**close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。
 </p>
<h1 id="4-socket中TCP的三次握手建立连接详解"><a href="#4-socket中TCP的三次握手建立连接详解" class="headerlink" title="4 socket中TCP的三次握手建立连接详解"></a>4 socket中TCP的三次握手建立连接详解</h1><p>我们知道TCP建立连接要进行“三次握手”，即交换三个分组。大致流程如下：</p>
<p>1）客户端向服务器发送一个SYN J</p>
<p>2）服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1</p>
<p>3）客户端再向服务器发一个确认ACK K+1</p>
<p>这样就完成了三次握手，但是这个三次握手发生在socket的哪几个函数中呢？请看下图：</p>
<p><img src="/assets/images/tech/socket-communicate-introduction-1.png" alt="1"></p>
<p>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。</p>
<p><strong>总结：</strong>客户端的connect在三次握手的第二次返回，而服务器端的accept在三次握手的第三次返回。
 </p>
<h1 id="5-socket中TCP的四次挥手释放连接详解"><a href="#5-socket中TCP的四次挥手释放连接详解" class="headerlink" title="5 socket中TCP的四次挥手释放连接详解"></a>5 socket中TCP的四次挥手释放连接详解</h1><p>上面介绍了socket中TCP的三次握手建立过程，与涉及的socket函数。现在我们介绍socket中的四次挥手释放连接的过程，请看下图：</p>
<p><img src="/assets/images/tech/socket-communicate-introduction-2.png" alt="2"></p>
<p>图示过程如下：</p>
<p>1）某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；</p>
<p>2）另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认，返回一个ACK M+1。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；</p>
<p>3）一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</p>
<p>4）接收到这个FIN的源发送端TCP对它进行确认，返回一个ACK N+1。<br>这样每个方向上都有一个FIN和ACK。
 </p>
<h1 id="6-一个例子"><a href="#6-一个例子" class="headerlink" title="6 一个例子"></a>6 一个例子</h1><p>说了这么多了，动手实践一下。下面编写一个简单的服务器、客户端（使用TCP）——服务器端一直监听本机的6666号端口，如果收到连接请求，将接收请求并接收客户端发来的消息；客户端与服务器端建立连接并发送一条消息。</p>
<p>服务器端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//server</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line">#include&lt;netinet/in.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 4096</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    int    listenfd, connfd;</span><br><span class="line">    struct sockaddr_in     servaddr;</span><br><span class="line">    char    buff[4096];</span><br><span class="line">    int     n;</span><br><span class="line"></span><br><span class="line">    if( (listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1 )&#123;</span><br><span class="line">        printf(&quot;create socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memset(&amp;servaddr, 0, sizeof(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(6666);</span><br><span class="line"></span><br><span class="line">    if( bind(listenfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) == -1)&#123;</span><br><span class="line">        printf(&quot;bind socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if( listen(listenfd, 10) == -1)&#123;</span><br><span class="line">        printf(&quot;listen socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;======waiting for client&#x27;s request======\n&quot;);</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        if( (connfd = accept(listenfd, (struct sockaddr*)NULL, NULL)) == -1)&#123;</span><br><span class="line">            printf(&quot;accept socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        n = recv(connfd, buff, MAXLINE, 0);</span><br><span class="line">        buff[n] = &#x27;/0&#x27;;</span><br><span class="line">        printf(&quot;recv msg from client: %s\n&quot;, buff);</span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(listenfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <br>客户端代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//client</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;sys/socket.h&gt;</span><br><span class="line">#include&lt;netinet/in.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAXLINE 4096</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    int    sockfd, n;</span><br><span class="line">    char    recvline[4096], sendline[4096];</span><br><span class="line">    struct sockaddr_in    servaddr;</span><br><span class="line"></span><br><span class="line">    if( argc != 2)&#123;</span><br><span class="line">        printf(&quot;usage: ./client &lt;ipaddress&gt;\n&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)&#123;</span><br><span class="line">        printf(&quot;create socket error: %s(errno: %d)\n&quot;, strerror(errno),errno);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memset(&amp;servaddr, 0, sizeof(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(6666);</span><br><span class="line">    if( inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;= 0)&#123;</span><br><span class="line">        printf(&quot;inet_pton error for %s\n&quot;,argv[1]);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if( connect(sockfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) &lt; 0)&#123;</span><br><span class="line">        printf(&quot;connect error: %s(errno: %d)\n&quot;,strerror(errno),errno);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;send msg to server: \n&quot;);</span><br><span class="line">    fgets(sendline, 4096, stdin);</span><br><span class="line">    if( send(sockfd, sendline, strlen(sendline), 0) &lt; 0)&#123;</span><br><span class="line">        printf(&quot;send msg error: %s(errno: %d)\n&quot;, strerror(errno), errno);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然上面的代码很简单，也有很多缺点，这只是简单的演示socket的基本函数使用。其实不管多复杂的网络程序，都使用的这些基本函数。上面的服务器使用的是迭代模式，即只有处理完一个客户端请求才会去处理下一个客户端的请求，这样的服务器处理能力是很弱的，现实中的服务器都需要有并发处理能力！为了需要并发处理，服务器需要fork()一个新的进程或者线程去处理请求等。
 </p>
<h1 id="7-动动手"><a href="#7-动动手" class="headerlink" title="7 动动手"></a>7 动动手</h1><p>留下一个问题。是否熟悉Linux下网络编程？如熟悉，编写如下程序完成如下功能：</p>
<p>服务器端：</p>
<p>接收地址192.168.100.2的客户端信息，如信息为“Client Query”，则打印“Receive Query”</p>
<p>客户端：</p>
<p>向地址192.168.100.168的服务器端顺序发送信息“Client Query test”，“Cleint Query”，“Client Query Quit”，然后退出。</p>
<p>题目中出现的IP地址可以根据实际情况而定。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>网络</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C中的引用计数</title>
    <url>/2016-03-15-objc-quote-count/</url>
    <content><![CDATA[<p>Objective-C语言使用引用计数来管理内存，也就是说，每个对象都有个可以递增或递减的计数器。如果想使某个对象继续存活，那就递增其引用计数；用完了之后，就递减其计数。计数为0，就表示没人关注此对象了，于是，就可以把它销毁。在Objective-C中称之为引用计数，本文主要分享引用计数相关知识。</p>
<span id="more"></span>

<h1 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h1><p>Objective-C语言使用引用计数来管理内存，也就是说，每个对象都有个可以递增或递减的计数器。如果想使某个对象继续存活，那就递增其引用计数；用完了之后，就递减其计数。计数为0，就表示没人关注此对象了，于是，就可以把它销毁。</p>
<p>从Mac OS X 10.8开始，“垃圾收集器”（garbage collector）已经正式废弃了，以Objective-C代码编写Mac OS X程序时不应再使用它，而iOS则从未支持过垃圾收集。因此，掌握引用计数机制对于学好Objective-C来说十分重要。Mac OS X程序已经不能再依赖垃圾收集器了，而iOS系统不支持此功能，将来也不会支持。</p>
<p>已经用过ARC的人可能会知道：所有与引用计数有关的方法都无法编译，然而现在先暂时忘掉这件事。那些方法确实无法用在ARC中，不过本文就是要从Objective-C的角度讲解引用计数，而ARC实际上也是一种引用计数机制，所以，还是要谈谈这些在开启ARC功能时不能直接调用的方法。</p>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>在引用计数架构下，对象有个计数器，用以表示当前有多少个事物想令此对象继续存活下去。这在Objective-C中叫做“保留计数”（retain count），不过也可以叫“引用计数”（reference count）。NSObject协议声明了下面三个方法用于操作计数器，以递增或递减其值：</p>
<p>1）retain 递增保留计数。</p>
<p>2）release 递减保留计数。</p>
<p>3）autorelease 待稍后清理“自动释放池”（autorelease pool）时，再递减保留计数。</p>
<p><img src="/assets/images/tech/objc-quote-count-1.jpg" alt="1"></p>
<p>上图是对象创建及保留计数操作的效果图。</p>
<p><img src="/assets/images/tech/objc-quote-count-2.jpg" alt="2"></p>
<p>上图对象图中，ObjectB与ObjectC都引用了ObjectA。若ObjectB与ObjectC都不再使用ObjectA，则其保留计数降为0，于是便可摧毁了。还有其他对象想令ObjectB与ObjectC继续存活，而应用程序里又有另外一些对象想令那些对象继续存活。如果按“引用树”回溯，那么最终会发现一个“根对象”（root object）。在Mac OS X应用程序中，此对象是NSApplication对象；而在iOS应用程序中，则是UIApplication对象。两者都是应用程序启动时创建的单例。</p>
<p>下面这段代码有助于理解这些方法的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSMutableArray *array = [[NSMutableArray alloc] init];</span><br><span class="line">NSNumber *number = [[NSNumber alloc] initWithInt:1337];</span><br><span class="line">[array addObject:number];</span><br><span class="line">[number release];</span><br><span class="line">//do something with &#x27;array&#x27;</span><br><span class="line">[array release];</span><br></pre></td></tr></table></figure>

<p>由于代码中直接调用了release方法，所以在ARC下无法编译。在Objective-C中，调用alloc方法所返回的对象由调用者所拥有。也就是说，调用者已通过alloc方法表达了想令该对象继续存活下去的意愿。不过，这并不是说对象此时的保留计数就是1。在alloc或“initWithInt:”方法的代码实现中，也许还有其他对象也保留了此对象。绝不能说保留计数一定是某个值，只能说你所执行的操作的递增了该计数还是递减了该计数。</p>
<p>创建完数组后，把number对象加入其中。调用数组的“addObject:”方法时，数组也会在number上调用retain方法，以期继续保留此对象。这时，保留计数至少为2。接下来，代码不再需要number对象了，于是将其释放。现在的保留计数至少为1。这样就不能照常使用number变量了。调用release之后，已经无法保证所指的对象仍然存活。当然，根据本例中的代码，我们显然知道number对象在调用了release之后仍然存活，因为数组还在引用着它。然而绝不应该假设此对象一定存活，也就是说，不要像下面这样子编写代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSNumber *number = [[NSNumber alloc] initWithInt:1337];</span><br><span class="line">[array addObject:number];</span><br><span class="line">[number release];</span><br><span class="line">NSLog(@&quot;number = %@&quot;, number);</span><br></pre></td></tr></table></figure>

<p>即便上述代码在本例中可以正常执行，也仍然不是个好办法。如果调用release之后，基于某些原因，其保留计数降至为0，那么number对象所占内存也许会回收，这样的话，再调用NSLog可能就将使程序崩溃了。为什么是“可能”，因为对象所占的内存在“解除分配”（deallocated）之后，只是放回“可用内存池”（avaiable pool）。如果执行NSLog时还尚未覆写对象内存，那么该对象仍然有效，这是程序不会崩溃。故，<strong>因过早释放对象而导致的bug很难调试</strong>。</p>
<p>为避免在不经意间使用了无效对象，一般调用完release之后都会清空指针。这就能保证不会出现可能指向无效对象的指针，这种指针通常称为“悬挂指针”（dangling pointer）。例如，可以这样编写代码来防止此情况发生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSNumber *number = [[NSNumber alloc] initWithInt:1337];</span><br><span class="line">[array addObject:number];</span><br><span class="line">[number release];</span><br><span class="line">number = nil;</span><br></pre></td></tr></table></figure>

<h1 id="属性存取方法中的内存管理"><a href="#属性存取方法中的内存管理" class="headerlink" title="属性存取方法中的内存管理"></a>属性存取方法中的内存管理</h1><p>如前所述，对象图由相互关联的对象所构成。刚才那个例子中的数组通过在其元素上调用retain方法来保留那些对象。不光数组，其他对象也可以保留别的对象，这一般通过访问“属性”来实现，而访问属性时，会用到相关实例变量的获取方法和设置方法。若属性为“strong关系”（strong relationship），则设置的属性值会保留。比方说，有个名叫foo的属性由名为_foo的实例变量所实现，那么，该属性的设置方法会是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(void)setFoo:(id)foo &#123; </span><br><span class="line">    [foo retain];</span><br><span class="line">    [_foo release]; </span><br><span class="line">    _foo = foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法将保留新值并释放旧值，然后更新实例变量，令其指向新值。顺序很重要。假如还未保留新值就先把旧值释放了，而两个值又指向同一个对象，那么，先执行release操作就可能导致系统将此对象永久回收。而后续的retain操作则无法令这个已经彻底回收的对象复生，于是实例变量就成了<strong>悬挂指针</strong>。</p>
<h1 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h1><p>在Objective-C的引用计数架构中，自动释放池是一项重要特性。调用release会立刻递减对象的保留计数（而且还可能令系统回收此对象），然而有时候可以不调用它，改为调用autorelease，此方法会在稍后递减计数，通常是在下一次“事件循环”（event loop）时递减，不过也可能执行得更早些。 </p>
<p>此特性很有用，尤其是在方法中返回对象时更应该用它。在这种情况下，我们并总是想令方法调用者手工保留其值。比方说，有下面这个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(NSString *)stringValue &#123; </span><br><span class="line">    NSString *str = [[NSString alloc] initWithFormat:@&quot;I am this: %@&quot;, self]; </span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时返回的str对象其保留计数比期望值要多1，因为调用者alloc会令保留计数加1，而又没有与之对应的释放操作。保留计数多1，就意味着调用者要负责处理多出来的这一次保留操作。必须设法将其抵消。这并不是说保留计数本身就一定是1，它可能大于1，不过那取决于“initWithFormat:”方法内的实现细节。你要考虑的是如何将多出来的这一次保留操作抵消掉。但是，不能在方法呢你释放str，否则还没等方法返回，系统就把该对象回收了。这里应该用autorelease，它会在稍后释放对象，从而给调用者留下了足够长的时间，使其可以在需要时先保留返回值。换句话说，此方法可以保证对象在跨越“方法调用边界”（method call boundary）后一定存活。实际上，释放操作会在清空最外层的自动释放池时执行，除非你有自己的自动释放池，否则这个时机指的就是当前线程的下一次事件循环。改写stringValue方法，使用autorelease来释放对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(NSString *)stringValue &#123; </span><br><span class="line">    NSString *str = [[NSString alloc] initWithFormat:@&quot;I am this: %@&quot;, self]; </span><br><span class="line">    return [str autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改之后，stringValue方法把NSString对象返回给调用者，此对象必然存活。所以我们能够如此使用它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *str = [self stringValue];</span><br><span class="line">NSLog(@&quot;The string is: %@&quot;, str);</span><br></pre></td></tr></table></figure>
<p>由于返回的str对象将于稍后自动释放，所以多出来的那一次保留操作时自然就会抵消，无须再执行内存管理操作。因为自动释放池中的释放操作要等到下一次事件循环时才会执行，所以NSLog语句在使用str对象前不需要手工执行保留操作。但是，假如要持有此对象的话（比如将其设置给实例变量），那就需要保留，并于稍后释放：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_instanceVariable = [[self stringValue] retain];</span><br><span class="line">//...</span><br><span class="line">[_instaceVariable release];</span><br></pre></td></tr></table></figure>

<p>由此可见，autorelease能延长对象生命期，使其在跨越方法调用边界后依然可以存活一段时间。</p>
<h1 id="保留环"><a href="#保留环" class="headerlink" title="保留环"></a>保留环</h1><p>使用引用计数机制时，经常要注意的一个问题就是“保留环”（retain cycle），也就是呈环状相互引用的多个对象。这将导致内存泄露，因为循环中的对象其保留计数不会降为0。对于循环中的每个对象来说，至少还有另外一个对象引用着它。</p>
<p><img src="/assets/images/tech/objc-quote-count-3.jpg" alt="3"></p>
<p>如上图，在这个循环里，所以对象的保留计数都是1。在垃圾收集环境中，通常将这种情况认定为“孤岛”（island of isolation）。此时，垃圾收集器会把三个对象全部回收。而在Objective-C的引用计数架构中，则享受不到这一便利。通常采用“弱引用”（weak reference）来解决此问题，或是从外界命令循环中的某个对象不再保留另外一个对象。这两种办法都能打破保留环，从而避免内存泄露。 </p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1。若保留计数为正，则对象继续存活。当保留计数降为0时，对象就被销毁。</p>
<p>在对象生命周期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>objc</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>说说那些iOS笔试题</title>
    <url>/2016-03-18-ios-test-in-writing/</url>
    <content><![CDATA[<p>博主之前从事嵌入式开发，本科专业软件工程。毕业后一直从事嵌入式C语言。之所以进入嵌入式行业，完全是个人兴趣。不过，在从业两年之后发现不是自己喜欢的菜。毅然决然的转型到iOS行业。然，博主并非参加培训学校出来，完全利用工作之余时间自学，现在已经在ZAKER工作，从事ZAKER客户端的iPhone版本开发。这里，博主分享一下之前找工作时，总结的笔试题。</p>
<span id="more"></span>

<h1 id="题目与答案"><a href="#题目与答案" class="headerlink" title="题目与答案"></a>题目与答案</h1><p>答案仅供参考，如有异议或者错误，请指正。</p>
<h2 id="中文试题"><a href="#中文试题" class="headerlink" title="中文试题"></a>中文试题</h2><ul>
<li><code>#import 跟#include、@class有什么区别？#import&lt;&gt;跟 #import&quot;&quot;又什么区别？</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) #import和#include都能完整地包含某个文件的内容，#import能防止同一个文件被包含多次</span><br><span class="line">2) @class仅仅是声明一个类名，并不会包含类的完整声明;@class还能解决循环包含的问题</span><br><span class="line">3) #import &lt;&gt;用来包含系统自带的文件，#import “”用来包含自定义的文件</span><br></pre></td></tr></table></figure>

<ul>
<li><code>属性readwrite，readonly，assign，retain，copy，nonatomic各是什么作用，在那种情况下用？</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">readwrite：同时生成get方法和set方法的声明和实现</span><br><span class="line">readonly：只生成get方法的声明和实现</span><br><span class="line">assign：set方法的实现是直接赋值，用于基本数据类型</span><br><span class="line">retain：set方法的实现是release旧值，retain新值，用于OC对象类型</span><br><span class="line">copy：set方法的实现是release旧值，copy新值，用于NSString、block等类型</span><br><span class="line">nonatomic：非原子性，set方法的实现不加锁（比atomic性能高）</span><br></pre></td></tr></table></figure>

<ul>
<li><code>写一个setter方法用于完成@property （nonatomic,retain）NSString *name,写一个setter方法用于完成@property（nonatomic，copy）NSString *name.</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, retain) NSString *name;</span><br><span class="line">- (void)setName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">	if (_name != name) &#123;</span><br><span class="line">		[_name release];</span><br><span class="line">		_name = [name retain];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property(nonatomic, copy) NSString *name;</span><br><span class="line">- (void)setName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">	if (_name != name) &#123;</span><br><span class="line">		[_name release];</span><br><span class="line">		_name = [name copy];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>对于语句NSString*obj = [[NSData alloc] init]; ，编译时和运行时obj分别是什么类型？</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编译时是NSString类型</span><br><span class="line">运行时是NSData类型</span><br></pre></td></tr></table></figure>

<ul>
<li><code>常见的object-c的数据类型有那些，和C的基本数据类型有什么区别？</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常用OC类型：NSString、NSArray、NSDictionary、NSData、NSNumber等</span><br><span class="line">OC对象需要手动管理内存，C的基本数据类型不需要管理内存</span><br></pre></td></tr></table></figure>

<ul>
<li><code>id 声明的变量有什么特性？</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id声明的变量能指向任何OC对象</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Objective-C如何对内存管理的,说说你的看法和解决方法?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每个对象都有一个引用计数器，每个新对象的计数器是1，当对象的计数器减为0时，就会被销毁</span><br><span class="line">通过retain可以让对象的计数器+1、release可以让对象的计数器-1</span><br><span class="line">还可以通过autorelease pool管理内存</span><br><span class="line">如果用ARC，编译器会自动生成管理内存的代码</span><br></pre></td></tr></table></figure>

<ul>
<li><code>内存管理的几条原则时什么？按照默认法则.哪些方法生成的对象需要手动释放？在和property结合的时候怎样有效的避免内存泄露？</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只要调用了alloc、copy、new方法产生了一个新对象，都必须在最后调用一次release或者autorelease</span><br><span class="line">只要调用了retain，都必须在最后调用一次release或者autorelease</span><br><span class="line">@property如果用了copy或者retian，就需要对不再使用的属性做一次release操作</span><br><span class="line">如果用了ARC，另外讨论.</span><br></pre></td></tr></table></figure>

<ul>
<li><code>看下面的程序,三次NSLog会输出什么？为什么？</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSMutableArray* ary = [[NSMutableArray array] retain];  </span><br><span class="line">NSString *str = [NSString stringWithFormat:@&quot;test&quot;];  // 1 </span><br><span class="line">[strretain];   // 2</span><br><span class="line">[aryaddObject:str]; // 3  </span><br><span class="line">NSLog(@&quot;%d&quot;,[str retainCount]);  </span><br><span class="line">[strretain];  // 4</span><br><span class="line">[strrelease];   // 3</span><br><span class="line">[strrelease];   // 2</span><br><span class="line">NSLog(@&quot;%d&quot;,[str retainCount]);  </span><br><span class="line">[aryremoveAllObjects]; // 1  </span><br><span class="line">NSLog(@&quot;%d&quot;,[str retainCount]);</span><br></pre></td></tr></table></figure>
<p>  <br>结果：3、2、1</p>
<ul>
<li><code>OC中创建线程的方法是什么？如果指定在主线程中执行代码？如何延时执行代码？</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建线程的方法</span><br><span class="line">NSThread</span><br><span class="line">NSOperationQueue和NSOperation</span><br><span class="line">GCD</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主线程中执行代码</span><br><span class="line">[self performSelectorOnMainThread: withObject: waitUntilDone:];</span><br><span class="line">[self performSelector: onThread:[NSThreadmainThread] withObject: waitUntilDone:];</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">延时执行</span><br><span class="line">double delayInSeconds = 2.0;</span><br><span class="line">dispatch_time_tpopTime = dispatch_time(DISPATCH_TIME_NOW, </span><br><span class="line">(int64_t)(delayInSeconds * NSEC_PER_SEC));</span><br><span class="line">dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123;        </span><br><span class="line">&#125;);</span><br><span class="line">[self performSelector: withObject: afterDelay:];</span><br><span class="line">[NSTimer scheduledTimerWithTimeInterval: target: selector: userInfo: repeats:];</span><br></pre></td></tr></table></figure>

<h2 id="英文试题"><a href="#英文试题" class="headerlink" title="英文试题"></a>英文试题</h2><p><strong>提示：</strong> 一定要把英文题目过一遍，有些公司的题目故意弄成英文的。</p>
<ul>
<li><code>Difference between shallow copy and deep copy?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浅拷贝：指针（地址）拷贝，不会产生新对象</span><br><span class="line">深拷贝：内容拷贝，会产生新对象</span><br></pre></td></tr></table></figure>

<ul>
<li><code>What is advantage of categories? What is difference between implementing a category and inheritance?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分类可以在不修改原来类模型的基础上拓充方法</span><br><span class="line">分类只能扩充方法、不能扩充成员变量；继承可以扩充方法和成员变量</span><br><span class="line">继承会产生新的类</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Difference between categories and extensions?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分类是有名称的，类扩展没有名称</span><br><span class="line">分类只能扩充方法、不能扩充成员变量；类扩展可以扩充方法和成员变量</span><br><span class="line">类扩展一般就写在.m文件中，用来扩充私有的方法和成员变量（属性）</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Difference between protocol in objective c and interfaces in java?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java的接口中声明的方法必须都实现</span><br><span class="line">Oc的protocol中声明的方法并不一定要实现</span><br></pre></td></tr></table></figure>

<ul>
<li><code>What are KVO and KVC?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KVC是键值编码，可以通过一个字符串的key（属性名）修改对象的属性值</span><br><span class="line">KVO是键值监听，可以监听一个对象属性值的改变</span><br></pre></td></tr></table></figure>

<ul>
<li><code>What is purpose of delegates?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两个对象之间传递数据和消息</span><br><span class="line">解耦，拆分业务逻辑</span><br></pre></td></tr></table></figure>

<ul>
<li><code>What are mutable and immutable types in Objective C?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutable是可变类型，比如NSMutableArray，可以动态往里面添加元素</span><br><span class="line">immutable是不可变类型，比如NSArray，固定的存储空间，不能添加元素</span><br></pre></td></tr></table></figure>

<ul>
<li><code>When we call objective c is runtime language what does it mean?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">动态绑定：对象类型在运行时才真正确定</span><br><span class="line">多态性</span><br><span class="line">消息机制</span><br></pre></td></tr></table></figure>

<ul>
<li><code>what is difference between NSNotification and protocol?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过NSNotification可以给多个对象传递数据和消息</span><br><span class="line">通过protocol（代理模式）只能给一个对象传递数据和消息</span><br></pre></td></tr></table></figure>

<ul>
<li><code>What is push notification?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本地推送：程序内部弹出通知到用户设备</span><br><span class="line">远程推送：由推送服务器推送通知到用户设备</span><br></pre></td></tr></table></figure>

<ul>
<li><code>What is Polymorphism？</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">多态：父类指针指向子类对象</span><br></pre></td></tr></table></figure>

<ul>
<li><code>What is Singleton?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单例：保证程序运行过程中，永远只有一个对象实例</span><br><span class="line">目的是：全局共享一份资源、节省不必要的内存开销</span><br></pre></td></tr></table></figure>

<ul>
<li><code>What is responder chain?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">响应者链：</span><br><span class="line">UIResponder有一个nextResponder属性，通过该属性可以组成一个响应者链，事件或消息在其路径上进行传递</span><br><span class="line">如果UIResponder没有处理传给它的事件，会将未处理的消息转发给自己的nextResponder</span><br></pre></td></tr></table></figure>
<p><img src="/assets/images/tech/ios-test-in-writing-1.png" alt="响应链"></p>
<ul>
<li><code>Difference between frame and bounds?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frame以父控件的左上角为坐标原点</span><br><span class="line">bounds以控件本身的左上角为坐标原点</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Difference between method and selector?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过一个selector可以找到方法地址，进而调用一个方法</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Is there any garbage collection mechanism in Objective C.?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OC 1.0没有垃圾回收</span><br><span class="line">OC 2.0有垃圾回收，只能用在Mac上</span><br><span class="line">iOS中有ARC机制，是编译器特性，垃圾回收是运行时特性</span><br></pre></td></tr></table></figure>

<ul>
<li><code>What is NSOperation queue?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用来存放NSOperation对象的队列，可以用来异步执行一些操作</span><br><span class="line">一般可以用在网络请求等耗时操作</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Can we use one tableview with two different datasources? How you will achieve this?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从对象属性上分析，tableView只有一个dataSource属性。当然，真要使用两个不同的数据源，还是有其他办法解决的</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Can we use two tableview controllers on one viewcontroller?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从技术角度上分析，一个控制器内部添加两个表格控制器是没有问题的</span><br></pre></td></tr></table></figure>

<ul>
<li><code>What is lazy loading?</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">延迟加载：比如控制器的view，在第一次用到view时才会调用loadView方法进行创建</span><br></pre></td></tr></table></figure>

<ul>
<li>链表不具备的特点是（）</li>
</ul>
<p>A. 可随机访问任何一个元素</p>
<p>B. 插入，删除操作不需要移动元素</p>
<p>C. 无需事先估计存储空间大小</p>
<p>D. 所欲存储空间可以是不连续的</p>
<p>参考答案： （A）<br>链表不同于数组。链表之所有叫链表，就是像一条链一样，要过到某个节点处，就得遍历着找；而数组才具备随机访问任何一个元素的能力，数组可以通过索引直接访问元素，时间复杂度为常量，效率非常高，因此在某些场合上，我们需要数组这样的数据结构。</p>
<p>B. 链表的插入、删除都不需要移动元素，只需要修改指针的指向就可以了，因为链表上的每个节点都是动态分配的，分配在堆上，通过指针来指向每个节点的内存区，要获取某个节点的值，是需要遍历一遍才能找到对应的节点的。</p>
<p>C. 因为链表上的每个节点是分配在堆上，需要开发人员手动申请内存空间的，因此不像数组在定义时就要指定存储空间大小。对于链表，需要增加一个节点时，直接在堆上申请。当需要删除某个节点时，可以直接将该节点的内存给释放掉。</p>
<p>D. 因为链接中的节点都是存储在堆上的，而每个节点之间都有一个指向前一个节点和后一个节点的指针，只要知道链表头指针，就可以通过遍历查找到任何一个节点。因此，链表不同于数组，数组是要连续的内存存储空间，才能保证以常量时间复杂度快速访问任意元素；而链表不要求每个节点是连接，在堆上申请的内存空间很难得到连续的，而且空间产生内存碎片。</p>
<ul>
<li>关于多线程和多进程编程，下面描述正确的是（）</li>
</ul>
<p>A. 多进程里，子进程可获取父进程的所有堆和栈的数据；而线程会与同进程的其他线程共享数据，拥有自己的栈空间。</p>
<p>B. 线程因为有自己的独立栈空间且共享数据，所有执行的开销相对较大，同时不利于资源管理和保护。</p>
<p>C. 线程的通信速度更快，切换更快，因为他们在同一地址空间内。</p>
<p>D. 线程使用公共变量&#x2F;内存时需要使用同步机制，因为他们在同一地址空间内。</p>
<ul>
<li>设两个变量a&#x3D;19;b&#x3D;29;在不创建新实例的情况下使a、b的值互换？</li>
</ul>
<p>参考答案：</p>
<p>这道题要求不创建新的实例，只有a、b两个变量，要交换这两个变量的值，通常的做法是使用临时变量来临时存储，但是现在要求不使用新的实例，那么有什么办法呢？</p>
<p>方法就是通过位运算来操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>
<p>对于题目中的a &#x3D; 19，也就是对应二进制00010011；而b&#x3D;29，也就是对应二进制00011101</p>
<p>第一步：a &#x3D; 00010011 ^ 00011101 &#x3D;&gt; 00001110，将a、b的值都记录下来了</p>
<p>第二步：b &#x3D; 00001110 ^ 00011101 &#x3D;&gt; 00010011（值为19，也就是b得到了原来的a的值）</p>
<p>第三步：a &#x3D; 00001110 ^ 00010011 &#x3D;&gt; 00011101 (值为29，也就是a得到了原来的b的值)</p>
<p>注意，符号表示按位异或。所谓按位异或是指对应位置上的二进制数值相同为0，不同为1。</p>
<ul>
<li>使用block时什么情况会发生引用循环，如何解决？</li>
</ul>
<p>参考答案：<a href="http://www.henishuo.com/ios-block-memory-cycle">http://www.henishuo.com/ios-block-memory-cycle</a></p>
<ul>
<li>为什么要序列化，对象序列化方式？</li>
</ul>
<p>参考答案：</p>
<p>将对象JSON序列化： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSLog(@&quot;%s&quot;, __FUNCTION__);</span><br><span class="line">NSDictionary *dict = @&#123;@&quot;key&quot;  : @&quot;value&quot;,</span><br><span class="line">                     @&quot;key1&quot; : @&quot;value1&quot;,</span><br><span class="line">                     @&quot;key2&quot; : @&quot;value2&quot;&#125;;</span><br><span class="line">NSData *data = [NSJSONSerialization dataWithJSONObject:dict options:NSJSONWritingPrettyPrinted error:nil];</span><br><span class="line">NSLog(@&quot;%@&quot;, [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);</span><br></pre></td></tr></table></figure>

<p>将对象归档：需要遵守NSCoding协议，实现如下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder &#123;</span><br><span class="line">  [aCoder encodeObject:self.title forKey:@&quot;title&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>简述如何处理UI与耗时操作的通信，有哪些方式及各自的优缺点？</li>
</ul>
<p>参考答案：</p>
<p>1）将耗时的计算和IO操作放在子线程去处理，然后到主线程更新UI。优点是采用预加载方式，将耗时操作提前处理。优点是可让UI更流畅；缺点是内存会增多，控制加载逻辑比较复杂。</p>
<p>2）采用延迟加载方式，将耗时操作而不立刻使用时，采用延迟加载。优点是界面可提高流畅度；缺点是在需要显示时还需要加载才能显示，需要稍稍等待。</p>
<ul>
<li>如何优化一个TableView？</li>
</ul>
<p>参考答案：</p>
<p>1）若高度一定，直接使用rowHeight属性而不是使用heightForRowAtIndexPath方法，以减少调用的消耗。若高度是不固定的，heightForRowAtIndexPath所计算的高度应该缓存起来，每次数据源发生变化时，比如删除、插入、更新行都会重新请求所有的高度。若有100个行，就会有调用100次，因为将高度缓存起来是应该的。同理，heightForHeaderInSection、heightForFooterInSection也应该缓存起来。</p>
<p>2）不要在tableView:cellForRowAtIndexPath:中做太多的计算和IO操作，比如可以将需要的计算提前计算好、IO操作也提前计算好。它应该直接调用来显示就可以。</p>
<p>3）将计算行高的时间提前到从服务器获取数据的时候，计算完了高度一并写回数据库或者通过转型为model，将高度放到模型中。但是，最好将高度缓存起来。若一个model的数据有不同的状态，比如展开与收起状态，应该也将高度都缓存起来。注意使用异步去计算，计算完成后再回到主线程显示。</p>
<p>4）在设置显示图片时，不要直接设置UIImageView的contentMode属性自动适应，图片变形会计算transform，压缩时会乘以一个矩阵，消耗性能。对于要求性能较高的app，应该将得到的图片经过处理成UIImageView大小后再呈现。</p>
<p>5）不要将视图的opaque属性设置为NO，默认为YES,它表示不透明度。当opque为NO的时候，图层的半透明取决于图片和其本身合成的图层为结果。</p>
<p>6）layer添加圆角是比较耗时的，这样会离屏渲染，需要牺牲更多的性能。比如，图片显示有圆角时，可以通过core graphics来生成带圆角的图片等。</p>
<p>7）手动绘制cell。绘制cell不建议使用UIView，建议使用CALayer。 UIView的绘制是建立在CoreGraphic上的，其使用的是CPU。CALayer使用的是Core Animation，CPU、GPU都可以使用且由系统自动决定使用哪一个。UIView的绘制，使用的是自下向上的一层一层的绘制，而后渲染。Layer处理的是纹理，利用GPU的 Texture Cache和独立的浮点数计算单元可以加速纹理的处理。</p>
<p>8）重用cell。防止重复的绘制，减少渲染次数，可提高性能。</p>
<p>9）减少subviews的数量。尽量放在同一层view上显示。</p>
<p>10）尽量少动态给cell添加子view。用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示。</p>
<p>更多参看：<br><a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/</a></p>
<h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><ul>
<li>假设类SomeClass中声明了一个委托属性delegate，该属性遵守自定义委托协议SomeDelegate，请写出该类和对应委托协议的定义？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@protocol SomeDelegate&lt;NSObject&gt;</span><br><span class="line">@required //必须要实现的方法</span><br><span class="line">@optional //可选实现的方法</span><br><span class="line">@end</span><br><span class="line">@interface SomeClass</span><br><span class="line">@property (nonatomic, assign)id &lt;SomeDelegate&gt; delegate;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<ul>
<li>简述UITableView的重用机制，并写出实现该机制的关键代码？</li>
</ul>
<p>关键代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cellId&quot;];</span><br><span class="line">    if (cell == nil) &#123;</span><br><span class="line">        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;cellId&quot;];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>简述推送实现步骤？</p>
</li>
<li><p>定义一个带参宏，返回两个参数中较小的那个？</p>
</li>
<li><p>strong和weak分别起什么作用？有什么区别？</p>
</li>
<li><p>执行下面程序后NSLog的输出结果为（  C  ）？</p>
</li>
</ul>
<p>A.1，1    B.2，1    C.2，5    D.运行错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[5] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">int *ptr = (int *)(&amp;a+1);</span><br><span class="line">NSLog(@“%d,%d”, *(a+1), *(ptr-1));</span><br></pre></td></tr></table></figure>

<ul>
<li>执行下面程序后NSLog的输出结果为（  B  ）？</li>
</ul>
<p>A.a，a1，a1    B.a1，a1，a1    C.a1，a，a    D.a1，a1，a</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main(int argc, char *argv[])&#123;</span><br><span class="line">    NSArray *mArray1 = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@&quot;a&quot;], @&quot;b&quot;, @&quot;c&quot;, nil];</span><br><span class="line">        NSArray *mArrayCopy2 = [mArray1 copy];</span><br><span class="line">        NSMutableArray *mArrayMCopy1 = [mArray1 mutableCopy];</span><br><span class="line">        NSMutableString *testString = [mArray1 objectAtIndex:0];</span><br><span class="line">        [testString appendString:@&quot;1&quot;];</span><br><span class="line">        NSLog(@&quot;%@,%@,%@&quot;, [mArray1 objectAtIndex:0],[mArrayCopy2 objectAtIndex:0],[mArrayMCopy1 objectAtIndex:0]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Cocoa中所有的类都是（  NSObject和NSProxy  ）的子类。</p>
</li>
<li><p>列举几个Cocoa Touch框架？</p>
</li>
</ul>
<p>Foundation、UIKit、Core Data</p>
<ul>
<li>下面机型屏幕分辨率分别是多少？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iPhone4、4S：960X640</span><br><span class="line">iPhone5、5S、5C：1136X640</span><br><span class="line">iPhone6：375X667</span><br><span class="line">iPhone6 Plus：414X736</span><br><span class="line">iPad mini：1024X768</span><br><span class="line">iPad mini 2：2048X1536</span><br><span class="line">iPad Air：2048X1536</span><br><span class="line">iPad Air 2：2048X1536</span><br></pre></td></tr></table></figure>

<ul>
<li>Objective-C中的线程类是（   NSThread ），常见方法有哪些（  dispatch_async  ）、（  dispatch_sync  ），处理多线程同步有哪些类（    ）。</li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>现有MySQL数据库，分别对下表写出要求的SQL语句，用到实例数据请自行给出即可。</p>
<p>表结构如下：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>UserID</td>
<td>Integer</td>
</tr>
<tr>
<td>UserName</td>
<td>varchar(20)</td>
</tr>
<tr>
<td>Password</td>
<td>varchar(20)</td>
</tr>
</tbody></table>
<p>创建表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE  TABLE `test`.`table_a` (</span><br><span class="line">  `UserID` INT NOT NULL ,</span><br><span class="line">  `UserName` VARCHAR(20) NULL ,</span><br><span class="line">  `Password` VARCHAR(20) NULL ,</span><br><span class="line">  PRIMARY KEY (`UserID`) );</span><br></pre></td></tr></table></figure>

<p>增加记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into `test`.`table_a` ( `UserName`, `UserID`, `Password`) values ( &#x27;cd&#x27;, &#x27;10&#x27;, &#x27;123&#x27;)</span><br></pre></td></tr></table></figure>

<p>删除记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from `test`.`table_a` where `UserID`=’10&#x27;</span><br><span class="line">修改记录：update `test`.`table_a` set `Password`=&#x27;12346&#x27; where `UserID`=&#x27;10&#x27; </span><br></pre></td></tr></table></figure>

<h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><p>1.请通过接口“<a href="http://someurl/somefunc%E2%80%9D%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%B9%B6%E5%9C%A8UI%E4%B8%8A%E6%98%BE%E7%A4%BA%E3%80%82%E6%8E%A5%E5%8F%A3%E5%85%A5%E5%8F%82argu%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E5%AD%97%E5%85%B8%E3%80%82">http://someurl/somefunc”获取数据，并在UI上显示。接口入参argu是一个字符串类型的变量，返回值是字典。</a></p>
<p>1）使用NSURL相关API实现网络加载类，其中：通过post方法发送请求，建立异步连接；</p>
<p>2）报文采用JSON格式；</p>
<p>3）多线程采用GCD或NSOperation实现；</p>
<p>4）以左边键右边值的格式在界面上显示结果。</p>
<p>2.传入数组*array和数组长度length，实现冒泡排序算法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *BubbleSort(int *array, int length);</span><br><span class="line"></span><br><span class="line">int *BubbleSort(int *array, int length) &#123;</span><br><span class="line">    int i = 0, j = 0, temp = 0;</span><br><span class="line">    if (NULL == array) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        for (j = i; j &lt; length; j++) &#123;</span><br><span class="line">            if (*(array + i) &gt; *(array + j)) &#123;</span><br><span class="line">                temp = *(array + i);</span><br><span class="line">                *(array + i) = *(array + j);</span><br><span class="line">                *(array + j) = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊 class-dump 使用</title>
    <url>/2016-03-23-class-dump-using/</url>
    <content><![CDATA[<p>class-dump is a command-line utility for examining the Objective-C segment of Mach-O files. It generates declarations for the classes, categories and protocols. This is the same information provided by using ‘otool -ov’, but presented as normal Objective-C declarations.</p>
<p>上面是class-dump的官方解释，我们用的最多就是做iOS的逆向工程。class-dump，是可以把Objective-C运行时的声明的信息导出来的工具。其实就是可以导出.h文件。用class-dump可以把未经加密的app的头文件导出来。</p>
<p>官方网址：<a href="http://stevenygard.com/projects/class-dump/">http://stevenygard.com/projects/class-dump/</a></p>
<span id="more"></span>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>class-dump的下载地址：<a href="http://stevenygard.com/download/class-dump-3.5.tar.gz">http://stevenygard.com/download/class-dump-3.5.tar.gz</a></p>
<p>点击下载后解压后会有class-dump和源码文件。将class-dump 复制到<code>/usr/bin/class-dump</code>。如果是OS X 10.11，因为没有<code>/usr/bin</code>文件夹的写权限，所以将class-dump复制到<code>/usr/local/bin/class-dump</code>即可。</p>
<p>同时打开Terminal，执行命令赋予其执行权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo chmod 777 /usr/bin/class-dump</span><br></pre></td></tr></table></figure>

<p><img src="/assets/images/tech/class-dump-using-1.png" alt="命令列表"></p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>使用class-dump导出头文件的命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class-dump -H 需要导出的框架路径 -o 导出的头文件存放路径</span><br></pre></td></tr></table></figure>

<h2 id="示例：导出Xcode中DVTKit框架的头文件"><a href="#示例：导出Xcode中DVTKit框架的头文件" class="headerlink" title="示例：导出Xcode中DVTKit框架的头文件"></a>示例：导出Xcode中DVTKit框架的头文件</h2><p>1）找到DVTKit框架路径</p>
<p><img src="/assets/images/tech/class-dump-using-2.png" alt="路径图"></p>
<p>2）使用上述的操作命令格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ class-dump -H /Applications/Xcode.app/Contents/SharedFrameworks/DVTKit.framework/Versions/A/DVTKit -o ~/local/DVTKit</span><br></pre></td></tr></table></figure>

<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>class-dump AppKit:</p>
<p><code>class-dump /System/Library/Frameworks/AppKit.framework</code></p>
<p>class-dump UIKit:</p>
<p><code>class-dump /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS4.3.sdk/System/Library/Frameworks/UIKit.framework</code></p>
<p>class-dump UIKit and all the frameworks it uses:</p>
<p><code>class-dump /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS4.3.sdk/System/Library/Frameworks/UIKit.framework -r --sdk-ios 4.3</code></p>
<p>class-dump UIKit (and all the frameworks it uses) from developer tools that have been installed in &#x2F;Dev42 instead of &#x2F;Developer:</p>
<p><code>class-dump /Dev42/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS5.0.sdk/System/Library/Frameworks/UIKit.framework -r --sdk-root /Dev42/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS5.0.sdk</code></p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode插件开发教程指南</title>
    <url>/2016-03-25-xcode-plugin-develop/</url>
    <content><![CDATA[<p>对于Xcode而言，我们苹果开发者并不陌生，对于Xcode的插件，我们也不陌生。但是，有几个人做过Xcode插件呢？！Who care？显然，博主是关心的，这里分享一下博主自己开发插件的过程。</p>
<p>在平时开发过程中我们使用了很多的Xcode插件，虽然官方对于插件制作没有提供任何支持，但是加载三方的插件，默认还是被允许的。第三方的插件，存放在 <code>~/Library/Application Support/Developer/Shared/Xcode/Plug-ins</code>文件夹中，后缀名必须是<code>.xcplugin</code> ，其实际上是一种bundle。所以我们创建一个插件工程，直接创建bundle工程即可。然后通过修改后缀名为<code>.xcplugin</code>，将其放到<code>~/Library/Application Support/Developer/Shared/Xcode/Plug-ins</code>目录中即可。</p>
<p>Xcode插件开发现在主要通过两种方式实现，其实也就是一种，只不过其中一种是使用别人提供的开发模板来省去很多中间步骤而已。文章会依次详细介绍两种的实现方法。</p>
<span id="more"></span>

<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="方式一：通过Bundle实现"><a href="#方式一：通过Bundle实现" class="headerlink" title="方式一：通过Bundle实现"></a>方式一：通过Bundle实现</h2><p>1.创建Bundle工程</p>
<p><img src="/assets/images/tech/xcode-plugin-develop-1.png" alt="1"></p>
<p>2.工程设置</p>
<p>插件工程和普通的bundle工程还是有区别的,所以需要进行特殊的设置。</p>
<p>1）工程的plist文件</p>
<p><img src="/assets/images/tech/xcode-plugin-develop-2.png" alt="2"></p>
<p>添加三项：</p>
<p>XCPluginHasUI &#x3D; NO</p>
<p>XC4Compatible &#x3D; YES</p>
<p>DVTPlugInCompatibilityUUIDs 这是一个数组。数组内容字符串，指示了该插件兼容的Xcode版本，只有对应版本的Xcode的UIID加入这个数组，插件才能被加载。</p>
<p>否则，即使将插件放入Xcode的插件文件夹，插件也不会被加载。获取当前版本的Xcode的UUID方式：</p>
<p>在terminal中输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID</span><br></pre></td></tr></table></figure>

<p>terminal会返回一串字符串，这就是Xcode的DVTPlugInCompatibilityUUID。</p>
<p>2）Build Setting</p>
<p><img src="/assets/images/tech/xcode-plugin-develop-3.png" alt="3"></p>
<p><img src="/assets/images/tech/xcode-plugin-develop-4.png" alt="4"></p>
<p>Installation Build Products Location 设置为 ${HOME} [显示的时候,显示的是你的用户目录]，这个是products的根目录。</p>
<p>Installation Directory 设置为 &#x2F;Library&#x2F;Application Support&#x2F;Developer&#x2F;Shared&#x2F;Xcode&#x2F;Plug-ins，这个是指定你的插件安装的目录。</p>
<p> <strong>注意，这里填入的其实是相对目录。</strong></p>
<p>插件的绝对目录是这样的，例如 &#x2F;Users&#x2F;yohunl&#x2F;Library&#x2F;Application\ Support&#x2F;Developer&#x2F;Shared&#x2F;Xcode&#x2F;Plug-ins&#x2F;Alcatraz.xcplugin ，最后的绝对目录是 Installation Build Products Location和Installation Directory的结合，这也是为什么两者都要设置的原因。</p>
<p>Deployment Location 设置为 YES，这个是指示该工程不使用设置里的build location，而是用Installation Directory来确定build后放置的位置。</p>
<p><img src="/assets/images/tech/xcode-plugin-develop-5.png" alt="5"></p>
<p>默认工程生成的相关文件位置都是 Build Locations指定的，通过Deployment Location 设置为 YES告诉工程，我们不使用这个默认的设置，而是我们自定义的。</p>
<p>Wrapper extension 设置为 xcplugin，后缀名必须为xcplugin，否则不会被加载。</p>
<h2 id="方式二：通过模板实现"><a href="#方式二：通过模板实现" class="headerlink" title="方式二：通过模板实现"></a>方式二：通过模板实现</h2><p>1）下载Xcode插件开发模板</p>
<p>地址：<a href="https://github.com/kattrali/Xcode-Plugin-Template">https://github.com/kattrali/Xcode-Plugin-Template</a></p>
<p>2）将下载下来的template复制到 ~&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;Templates&#x2F;Project Templates&#x2F;Application Plug-in&#x2F;Xcode Plugin.xctemplate文件夹中，如果没有对应的文件夹就自己手动创建一个。</p>
<p>3）重启Xcode，当你新建一个工程的时候就可以在OS X中看到一个Application Plug-in的选项，里面有一个Xcode Plug-in模板。</p>
<p><img src="/assets/images/tech/xcode-plugin-develop-6.png" alt="6"></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>通过以上的两种准备方式，我们已可以创建Xcode插件工程，接下来就是如何实现插件功能。</p>
<p>1.功能需求<br>在当前选中文件中实现代码风格重构，目前主要实现setter方法这一风格重构。例如，</p>
<p><code>[self setName:@&quot;Davy&quot;];</code> &#x3D;&#x3D;&gt; <code>self.name = @&quot;Davy&quot;;</code></p>
<p>2.思路分析</p>
<p>1）找到当前文件中符合setter方法命名风格的方法调用。</p>
<p>2）替换找到的符合重构风格的代码，提醒用户保存。</p>
<p>3.技术难点</p>
<p>1）Xcode代码编辑框文件内容操作。</p>
<p>2）正则表达式书写。</p>
<p>3）Xcode代码编辑框提醒用户保存文件。</p>
<p>关于最后一点，因为Xcode对于没有保存的已修改过的文件会显灰以提示用户该文件需要保存，我们可以借鉴这种方式。另外，在查找时，如果能够实现高亮并且跟随滚动，效果会更佳。</p>
<p>4.关键代码</p>
<p>以上这些问题，本人在“Refactor Code”插件中全部实现，现在放上关键方法。</p>
<p>1）添加菜单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(void) setupMenuItem &#123;</span><br><span class="line">    // Menu Item:</span><br><span class="line">    NSMenuItem *editMenuItem = [[NSApp mainMenu] itemWithTitle:@&quot;Edit&quot;];</span><br><span class="line">    if (editMenuItem) &#123;</span><br><span class="line">        [[editMenuItem submenu] addItem:[NSMenuItem separatorItem]];</span><br><span class="line">        NSMenu *refactorCodeMenu = [[NSMenu alloc] initWithTitle:@&quot;Refactor Code&quot;];</span><br><span class="line">        NSMenuItem *menuItem;</span><br><span class="line">        menuItem = [[NSMenuItem alloc] initWithTitle:@&quot;Refactor Method Style&quot; action:@selector(refactorMethodStyleMenuAction) keyEquivalent:@&quot;&quot;];</span><br><span class="line">        [menuItem setTarget:self]; [refactorCodeMenu addItem:menuItem];</span><br><span class="line">        NSMenuItem *refactorCodeMenuItem = [[NSMenuItem alloc] initWithTitle:@&quot;Refactor Code&quot; action:nil keyEquivalent:@&quot;&quot;];</span><br><span class="line">        [refactorCodeMenuItem setSubmenu:refactorCodeMenu];</span><br><span class="line">        [[editMenuItem submenu] addItem:refactorCodeMenuItem];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果图如下：</p>
<p><img src="/assets/images/tech/xcode-plugin-develop-7.png" alt="7"></p>
<p>2）显示操作面板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)refactorMethodStyleMenuAction &#123;</span><br><span class="line">    [self.operateController showWindow:nil];</span><br><span class="line">    NSURL *url = [[NSBundle bundleForClass:[self class]] URLForResource:@&quot;DZOperateController&quot; withExtension:@&quot;nib&quot;];</span><br><span class="line">    if (!url) &#123;</span><br><span class="line">        NSAlert *alert = [[NSAlert alloc] init];</span><br><span class="line">        alert.messageText = @&quot;Refactor Method Style could not be shown because the plugin is corrupted.&quot;;</span><br><span class="line">        alert.informativeText = @&quot;If you build the plugin from sources using Xcode, make sure to perform “Clean Build Folder“ in　　　　　　　　Xcode and then build the plugin again.\n\nIf you installed the plugin via Alctraz, there is a pending issue causing　　　　　　　　some files to be missing in the plugin. Prefer to install it via the plugin webpage.&quot;;</span><br><span class="line">        [alert addButtonWithTitle:@&quot;Download Latest&quot;];</span><br><span class="line">        [alert addButtonWithTitle:@&quot;Cancel&quot;];</span><br><span class="line">        NSModalResponse result = [alert runModal];</span><br><span class="line">        if (result == NSAlertFirstButtonReturn) &#123;</span><br><span class="line">            [[NSWorkspace sharedWorkspace] openURL:[NSURL URLWithString:@&quot;https://github.com/CharsDavy/RefactorCodePlugin-Xcode&quot;]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="/assets/images/tech/xcode-plugin-develop-8.png" alt="8"></p>
<p>3）查找替换代码风格</p>
<p>这一部分是重点部分，包括如何书写正则表达式，并且利用正则表达式生成替换字符。还包括高亮代码，具体可以参见本人源码：<a href="https://github.com/CharsDavy/RefactorCodePlugin-Xcode">https://github.com/CharsDavy/RefactorCodePlugin-Xcode</a></p>
<p>4）最终效果图</p>
<p><img src="/assets/images/tech/xcode-plugin-develop-9.png" alt="9"></p>
<h1 id="提交插件至Alcatraz"><a href="#提交插件至Alcatraz" class="headerlink" title="提交插件至Alcatraz"></a>提交插件至Alcatraz</h1><p>1.打开Alcatraz的插件包仓库，地址：<a href="https://github.com/supermarin/alcatraz-packages">https://github.com/supermarin/alcatraz-packages</a></p>
<p>2.在简介里可以看到Alcatraz的包分为三类，分别为：插件(plugins)，配色方案(color schemes)和模板(templates)。每个包都必须包含”name”、”url”和”description”字段，还有一个可选的”screenshot”字段。</p>
<p>3.Fork这个仓库，再克隆到本地。</p>
<p>4.以添加”Refactor Code”插件为例，打开packages.json文件，在”plugins”数组里加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  &quot;name&quot;: &quot;Refactor Code&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;https://github.com/CharsDavy/RefactorCodePlugin-Xcode.git&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Refactor code style,such as setter method.&quot;,</span><br><span class="line">  &quot;screenshot&quot;: &quot;https://github.com/CharsDavy/RefactorCodePlugin-Xcode/raw/master/Screenshots/window.png&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.提交代码到Fork的地址，再提交一个pull request到Master即可。</p>
<p>6.merged成功之后，即可看见以下效果图</p>
<p><img src="/assets/images/tech/xcode-plugin-develop-10.png" alt="10"></p>
<p>希望对大家有所帮助。</p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>application</tag>
      </tags>
  </entry>
  <entry>
    <title>list.h文件分析</title>
    <url>/2016-03-29-list-code-reading/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">structlist_head &#123;</span><br><span class="line">       struct list_head *next, *prev; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一上来就放这么一个数据结构，那么，这个到底要做什么呢？没错，就如上面代码所示，本文的主角就是它，由它衍生而来的一些问题。首先自我介绍，它，来自Linux系统中的链表。</p>
<span id="more"></span>

<p>就是个链表的头！是不觉得很奇怪？怎么只有两个指针域，没有数据域呢？其实笔者现在也纠结这这个问题着呢！没事，咱们先往下看。说不定什么时候，咱就明白了这是怎么一回事情呢。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;</span><br><span class="line">#defineLIST_HEAD(name) \</span><br><span class="line">       struct list_head name = LIST_HEAD_INIT(name)</span><br></pre></td></tr></table></figure>

<p>这俩是宏没错吧！来看看这个俩到底是个什么意思。</p>
<p>先来看看这个<code>LIST_HEAD_INIT(name)</code>，当程序当中出现了这个东西的时候，它立马就会替换成后面的东西，例如出现了：<br><code>LIST_HEAD_INIT(headnode)；</code><br>它立马就会替换成{&amp;(headnode),&amp;(headnode)}.<br>假设有这么一段C代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct list_head headnode ;//定义了一个headnode节点</span><br><span class="line">headnode = LIST_HEAD_INIT(headnode);</span><br></pre></td></tr></table></figure>

<p>那么它是不应该再编译阶段就立马的被替换成这样呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct list_head headnode ;//定义了一个headnode节点</span><br><span class="line">headnode = &#123; &amp;(headnode), &amp;(headnode) &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：这里面对标准的C进行了拓展叫：GNU C，这个意思呢就是说，对headnode的两个成员赋值。这赋值之后成了什么样子了呢？看下图：</p>
<p><img src="/assets/images/tech/list-code-reading-1.jpeg" alt="图一"></p>
<p>是不是自己指向了自己？至于为什么可以这么赋值，不是本文讨论的重点，详细的可以Google.</p>
<p>其实这里的<code>LIST_HEAD_INIT(name)</code>宏是用来初始化的；<br>而<code>LIST_HEAD(name)</code>宏则是用来定义+初始化。你看<code>LIST_HEAD(name)</code>宏是不比<code>LIST_HEAD_INIT(name)</code>宏多了这句 <code>struct list_head name</code> ？</p>
<p><strong>记住：</strong></p>
<p><code>LIST_HEAD_INIT(name)</code>宏是用来初始化的；</p>
<p><code>LIST_HEAD(name)</code>宏则是用来定义+初始化。</p>
<p>OK，我们接着往下看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static inline void INIT_LIST_HEAD(struct list_head *list)</span><br><span class="line">&#123;</span><br><span class="line">       list-&gt;next = list;</span><br><span class="line">       list-&gt;prev = list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>奇怪这里怎么好像又是在初始化，而且还和上面的功能一样。笔者觉得，他们这样做有如下考虑：</p>
<p>有些人习惯于调用函数进行初始化，而有的人喜欢代码简洁而直接使用宏来进行初始化，但是不论是那种方式，都达到了一样的功能,即初始化。</p>
<p>往下看，有关链表添加的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef CONFIG_DEBUG_LIST</span><br><span class="line">static inline void __list_add(struct list_head *new,  struct list_head *prev,  struct list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">       next-&gt;prev = new;</span><br><span class="line">       new-&gt;next = next;</span><br><span class="line">       new-&gt;prev = prev;</span><br><span class="line">       prev-&gt;next = new;</span><br><span class="line">&#125;</span><br><span class="line">#else</span><br><span class="line">extern void __list_add(struct list_head *new,  struct list_head *prev,  struct list_head *next);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> <code>__list_add</code>前面可是两个下划线；这个就是说，这个函数是linux内核的东西，使用的时候，就得注意了。一看名字就知道是增加链表节点；其实我们学习双向链表的时候，那么多的指针操作，能把人绕死，而且到最后也搞得不清楚，看看人家linux源代码是咋实现的：是不觉得有差距？</p>
<p>往下看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static inline void list_add(struct list_head *new, struct list_head *head)</span><br><span class="line">&#123;</span><br><span class="line">       __list_add(new, head, head-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚才不说了么，前头俩下划线的让谨慎的使用么，这不？又弄了一个函数，可以调用这个函数来进行链表的添加。</p>
<p>实际上，还是调用的是刚才的那个有两个下划线的函数。这里体现了两个思想：</p>
<p>1、封装，其实这个概念是C++等一类程序设计语言的OOP思想，用在了这里。</p>
<p>2、重用，很多时候，代码其实都是可以不用自己写的，有一些现成的东西你可以去调用，这样可以很好的提高生产效率，而且linux源代码使用的是GPL许可证，没有什么版权啊乱七八糟的东西，有这么好的东西干嘛不用呢？其实下来的这个你会体会的更深：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static inline void list_add_tail(struct list_head *new, struct list_head*head)</span><br><span class="line">&#123;</span><br><span class="line">       __list_add(new, head-&gt;prev, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看名字，看看<code>list_add_tail</code>这个名字。是不是“尾插法”？还是调用了前头的那个有两个下划线的函数吧？而且，仅仅只是调换了一下参数的次序。高明吧！</p>
<p>好！再接着往下看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static inline void __list_del(struct list_head * prev, struct list_head * next)</span><br><span class="line">&#123;</span><br><span class="line">       next-&gt;prev = prev;</span><br><span class="line">       prev-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#ifndef CONFIG_DEBUG_LIST</span><br><span class="line">static inline void list_del(struct list_head *entry)</span><br><span class="line">&#123;</span><br><span class="line">       __list_del(entry-&gt;prev, entry-&gt;next);</span><br><span class="line">       entry-&gt;next = LIST_POISON1;</span><br><span class="line">       entry-&gt;prev = LIST_POISON2;</span><br><span class="line">&#125;</span><br><span class="line">#else</span><br><span class="line">extern void list_del(struct list_head *entry);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>这里是删除一节点，这里再一次的体现了封装和重用的思想。不过这里注意：</p>
<p>在将entry这个节点删除之后你得将它指向一个正确的错误区域！什么意思呢，就是说，你的将它放在一个大家公认的错误的地方，因为所有的人都不会去碰那个错误的地方，所以，你这个entry就不会引起各种不必要的麻烦。其实这里有一个问题：你free了某个节点之后，其实，我们还是可以使用这个节点的，这个在一篇博文里讲述的很清楚：<br><a href="http://blog.sina.com.cn/s/blog_6e9342530100yaef.html">http://blog.sina.com.cn/s/blog_6e9342530100yaef.html</a>  </p>
<p>其实这里，<code>LIST_POISON1= 0x00100100</code>. <code>LIST_POISON2=0x00200200</code>。为什么，笔者不知道。</p>
<p>下来接着看这个替换函数。将链表当中某个节点用新的节点替换掉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static inline void list_replace(struct list_head *old, struct list_head *new)</span><br><span class="line">&#123;</span><br><span class="line">       new-&gt;next = old-&gt;next;</span><br><span class="line">       new-&gt;next-&gt;prev = new;</span><br><span class="line">       new-&gt;prev = old-&gt;prev;</span><br><span class="line">       new-&gt;prev-&gt;next = new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面在给出图例：</p>
<p><img src="/assets/images/tech/list-code-reading-2.jpeg" alt="图二"></p>
<p>大家可以根据图例来理解。</p>
<p>下来这个函数就是将某个链表里头的节点删除，然后添加到另外一个链表当中。你会发现代码很简单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static inline void list_move(struct list_head *list, struct list_head *head)</span><br><span class="line">&#123;</span><br><span class="line">       __list_del(list-&gt;prev, list-&gt;next);</span><br><span class="line">       list_add(list, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这两个函数，一个用来判断是否为链表的最后一个节点，一个用来判断该链表是否为空。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static inline int list_is_last(const struct list_head *list, const struct list_head *head)</span><br><span class="line">&#123;</span><br><span class="line">       return list-&gt;next == head;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static inline int list_empty(const struct list_head *head)</span><br><span class="line">&#123;</span><br><span class="line">       return head-&gt;next == head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>详细情况如下图：</p>
<p><img src="/assets/images/tech/list-code-reading-3.jpeg" alt="图三"></p>
<p>然而实际上，我们用这种方式来判断链表是否为空是不太精确的。它同时判断头指针的next和prev，仅当两者都指向自己时才返回真。这主要是为了应付另一个cpu正在处理同一个链表而造成next、prev不一致的情况。但代码注释也承认，这一安全保障能力有限：除非其他cpu的链表操作只有<code>list_del_init()</code>，否则仍然不能保证安全，也就是说，还是需要加锁保护。</p>
<p>两个链表合并：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static inline void __list_splice(const struct list_head *list, struct list_head *prev,  struct list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">       struct list_head *first = list-&gt;next;</span><br><span class="line">       struct list_head *last = list-&gt;prev;</span><br><span class="line"> </span><br><span class="line">       first-&gt;prev = prev;</span><br><span class="line">       prev-&gt;next = first;</span><br><span class="line"> </span><br><span class="line">       last-&gt;next = next;</span><br><span class="line">       next-&gt;prev = last;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static inline void list_splice(const struct list_head *list, struct list_head *head)</span><br><span class="line">&#123;</span><br><span class="line">       if (!list_empty(list))</span><br><span class="line">              __list_splice(list, head, head-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设当前有两个链表，表头分别是list1和list2（都是struct list_head变量），当调用<code>list_splice(&amp;list1,&amp;list2)</code>时，只要list1非空，list1链表的内容将被挂接在list2链表上，位于list2和list2.next（原list2表的第一个节点）之间。新list2链表将以原list1表的第一个节点为首节点，而尾节点不变。如图（虚箭头为next指针）：</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/list-code-reading-4.jpeg?imageView/2/w/500" alt="图四"></p>
<p>由于篇幅限制，当中其实，还有一些很有用的函数：比如切割啊，判断是否为单链表啊等等，其实当你再了解了这些函数之后，后面的都是大同小异。可以自己在做研究，下面将重点放在list.h当中的几个很重要的宏当中。<br>还是顺着list.h往下看，你会看到第一宏：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define list_entry(ptr, type, member) \</span><br><span class="line">   container_of(ptr, type, member)</span><br></pre></td></tr></table></figure>

<p>看到上面的那英文注释：获得结构体入口！</p>
<p>ptr：这个参数是指向list_head 类型的指针（注意这里，很容易再代码当中用错）。</p>
<p>type：看到那英文解释了么？这个type可不是list_head！他是list_head嵌入的那个结构体类型。详细会给出一断源代码，帮助大家理解。</p>
<p>member：这个看到名字就知道这个是结构体的一个成员。</p>
<p><code>list_entry(ptr,type,member)</code>这个宏到底是干嘛的，是不应该看container_of这个宏是干嘛的呢？用Sorce Insight 查看，会发现它在很多文件里头都存在，它们都是一样的，这里选取<code>/include/linux/kernel.h</code>当中的container_of宏来说明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define container_of(ptr, type, member) (&#123;        \</span><br><span class="line">   const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \</span><br><span class="line">   (type *)( (char *)__mptr - offsetof(type,member) );&#125;)</span><br></pre></td></tr></table></figure>

<p>这个宏的作用是：计算结构体成员member再结构体当中的相对位置（相对地址）。<br>现在想想，开头的时候，是不是看到了这个链表的结构体定义只有指针域而没有数据域？现在就是要计算出嵌入了list_head结构的结构体的数据域的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct stu&#123;</span><br><span class="line">   int id；</span><br><span class="line">   struct list_head *next，*prev；</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<p>就是要根据list_head类型的结构体计算出struct stu结构体当中成员id的地址。</p>
<p>现在假设有如下定义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct stu *p；</span><br><span class="line">struct list_head *r;</span><br><span class="line">r = p-&gt;next;</span><br></pre></td></tr></table></figure>

<p>现在我们肯定是可以直接通过p来访问<code>struct  stu</code>结构体当中的id的。但是这样做旧失去了其通用性，要知道内核当中链表的组织形式可是list_head。现在要如何才能够通过r访问的id呢？</p>
<p>我们将宏container_of分开成两部分来看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);</span><br></pre></td></tr></table></figure>

<p>这里的typeof也是GNU C所拓展的。Typeof(x) 就是返回x的数据类型。我们先从最里面的括号开始看起吧，</p>
<p><code>(type *)0</code>先将0转化成type 类型的指针，此时地址为0x0。然后再引用member成员，即就是:<code>((type *)0)-&gt;member</code> 然后再加上<code>typeof()</code> 不就是返回member的数据类型么。再加上前面的const 后面的 <code>* __mptr</code> 。这是个什么意思？</p>
<p>我们来个一个假设。假设member返回的数据类型是int。那么是不是就成了<code>const int * __mptr = (ptr)</code>?现在是不是明白了？<code>typeof( ((type *)0)-&gt;member )</code> 这个东西，就是为了要得到member的数据类型。</p>
<p>总结一下：这个就是为了定义一个member类型的指针，并且指向ptr(list_head类型)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(type *)( (char *)__mptr - offsetof(type,member) );</span><br></pre></td></tr></table></figure>

<p><code>（char *）__mptr</code> 将__mptr强制转化成<code>char *</code>类型，为什么转化成<code>char*</code> ，就是要获得__mptr指针的地址。而不是其他的类型呢？先来看offsetof这个宏吧。它被定义在<code>/include/linux/stddef.h</code>当中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span><br></pre></td></tr></table></figure>

<p>不着急，还是先从最里面的括号开始看起。<code>(TYPE *)0)-&gt;MEMBER</code> 这不是为了获取member么。在加个&amp; 获得他的地址、在加上(size_t) 强制转化成size_t 类型(其实也就是 unsigned int)。现在该注意了。刚才是不是说得到了type类型的指针的地址是0x0 ？ 你这里又得到了type类型指针成员member的地址。这个就是member的偏移地址吧！</p>
<p>再将这两个合并起来看。将获得的__mptr指针的地址 ，减去member成员在其中的偏移量。就是member的地址了吧！！O(∩_∩)O~</p>
<p>还有一个重要的问题？就是为什么要转化成<code>char*</code>，而不是其他的<code>*</code>？char类型的数据不论在什么类型的机器上，存储方式应该只是占了一个字节？因为它的实质是ascii码。这样的话，就好理解了，对<code>char*</code>减一 那就是实实在在的减一个字节；但是你要是对<code>int*</code>减一会实实在在的减多少？是不是4？（32位机器下）。这样一来，你怎么知道他的真实地址？<br>可以根据下图来理解：</p>
<p><img src="/assets/images/tech/list-code-reading-5.jpeg" alt="图五"></p>
<p>下面再来看看和这个宏很类似的宏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define list_first_entry(ptr, type, member) \</span><br><span class="line">   list_entry((ptr)-&gt;next, type, member)</span><br></pre></td></tr></table></figure>

<p>和刚才唯一的区别就是ptr所代表的意思不同了，list_entry这个宏是用来获得链表的入口的。但是这里却是为了得到链表的第一个元素。详细的不再赘述。</p>
<p>下来看看这个遍历宏：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define list_for_each(pos, head) \</span><br><span class="line">   for (pos = (head)-&gt;next; prefetch(pos-&gt;next), pos != (head); \</span><br><span class="line">          pos = pos-&gt;next)</span><br></pre></td></tr></table></figure>

<p>这里prefetch其实还是一个宏，其作用是预取。作用是使得的便利更加快速、高效、安全，我们这里基本上可以不用考虑这些问题，故，使用的时候可以将该宏去掉。</p>
<p>再来看看向前遍历的宏：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define list_for_each_prev(pos, head) \</span><br><span class="line">   for (pos = (head)-&gt;prev; prefetch(pos-&gt;prev), pos != (head); \</span><br><span class="line">          pos = pos-&gt;prev)</span><br></pre></td></tr></table></figure>

<p>跟上面遍历宏一样，其本质还是for循环，结束条件是遍历到了头！</p>
<p>具体的双向循环链表就分析到这里，后面的还有一大堆的遍历宏，只不过也就是上面这几种宏的组合使用罢了；更有甚者，考虑了很多的安全性问题；比如：多线程、并发访问一链表等等，这些应该说在用户级别的程序不大会出现这类问题，我们大可不必注意；但是考虑到在OS当中，有很多是用到了链表；比如：在进程调度的时候，就绪队列、等等。在这个时候就不仅仅需要考虑链表的实现问题了，而且还得考虑安全问题。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>框架</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式 - 概述</title>
    <url>/2016-04-12-design-pattern-introduction/</url>
    <content><![CDATA[<p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
<p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p>
<span id="more"></span>

<p><strong>什么是 GOF（四人帮，全拼 Gang of Four）？</strong><br>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 <strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong> 的书，该书首次提到了软件开发中设计模式的概念。<br>四位作者合称 <strong>GOF（四人帮，全拼 Gang of Four）</strong>。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p>
<ul>
<li>对接口编程而不是对实现编程。</li>
<li>优先使用对象组合而不是继承。</li>
</ul>
<p><strong>设计模式的使用</strong><br>设计模式在软件开发中的两个主要用途。<br><strong>开发人员的共同平台</strong><br>设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。<br><strong>最佳的实践</strong><br>设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。</p>
<p><strong>设计模式的类型</strong><br>根据设计模式的参考书 <strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong> 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。</p>
<p><strong>创建型模式</strong><br>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p>
<ul>
<li>工厂模式（Factory Pattern）</li>
<li>抽象工厂模式（Abstract Factory Pattern）</li>
<li>单例模式（Singleton Pattern）</li>
<li>建造者模式（Builder Pattern）</li>
<li>原型模式（Prototype Pattern）</li>
</ul>
<p><strong>结构型模式</strong><br>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p>
<ul>
<li>适配器模式（Adapter Pattern）</li>
<li>桥接模式（Bridge Pattern）</li>
<li>过滤器模式（Filter、Criteria Pattern）</li>
<li>组合模式（Composite Pattern）</li>
<li>装饰器模式（Decorator Pattern）</li>
<li>外观模式（Facade Pattern）</li>
<li>享元模式（Flyweight Pattern）</li>
<li>代理模式（Proxy Pattern）</li>
</ul>
<p><strong>行为型模式</strong><br>这些设计模式特别关注对象之间的通信。</p>
<ul>
<li>责任链模式（Chain of Responsibility Pattern）</li>
<li>命令模式（Command Pattern）</li>
<li>解释器模式（Interpreter Pattern）</li>
<li>迭代器模式（Iterator Pattern）</li>
<li>中介者模式（Mediator Pattern）</li>
<li>备忘录模式（Memento Pattern）</li>
<li>观察者模式（Observer Pattern）</li>
<li>状态模式（State Pattern）</li>
<li>空对象模式（Null Object Pattern）</li>
<li>策略模式（Strategy Pattern）</li>
<li>模板模式（Template Pattern）</li>
<li>访问者模式（Visitor Pattern）</li>
</ul>
<p><strong>J2EE 模式</strong><br>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</p>
<ul>
<li>MVC 模式（MVC Pattern）</li>
<li>业务代表模式（Business Delegate Pattern）</li>
<li>组合实体模式（Composite Entity Pattern）</li>
<li>数据访问对象模式（Data Access Object Pattern）</li>
<li>前端控制器模式（Front Controller Pattern）</li>
<li>拦截过滤器模式（Intercepting Filter Pattern）</li>
<li>服务定位器模式（Service Locator Pattern）</li>
<li>传输对象模式（Transfer Object Pattern）</li>
</ul>
<p>下面用一个图片来整体描述一下设计模式之间的关系：</p>
<p><img src="/assets/images/tech/design-pattern-introduction.jpeg" alt="设计模式之间的关系"></p>
<p><strong>设计模式的六大原则</strong><br><strong>1、开闭原则（Open Close Principle）</strong><br>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。<br><strong>2、里氏代换原则（Liskov Substitution Principle）</strong><br>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。<br><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong><br>这个原则是开闭原则的基础，具体内容：针对对接口编程，依赖于抽象而不依赖于具体。<br><strong>4、接口隔离原则（Interface Segregation Principle）</strong><br>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。<br><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong><br>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。<br><strong>6、合成复用原则（Composite Reuse Principle）</strong><br>合成复用原则是指：尽量使用合成&#x2F;聚合的方式，而不是使用继承。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby 正则表达式</title>
    <url>/2016-04-13-ruby-regular-expression/</url>
    <content><![CDATA[<p>正则表达式是一种特殊序列的字符，它通过使用有专门语法的模式来匹配或查找字符串集合。正则表达式用事先定义好的一些特定字符、及这些特定字符的组合，组成一个”规则字符串”，这个”规则字符串”用来表达对字符串的一种过滤逻辑。文章分享关于Ruby中的正则表达式的相关知识与使用。</p>
<span id="more"></span>

<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>正则表达式从字面上看是一种介于斜杠之间或介于跟在 %r 后的任意分隔符之间的模式，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/pattern/</span><br><span class="line">/pattern/im    # 可以指定选项</span><br><span class="line">%r!/usr/local! # 使用分隔符的正则表达式</span><br></pre></td></tr></table></figure>

<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/ruby</span><br><span class="line">line1 = &quot;Cats are smarter than dogs&quot;;</span><br><span class="line">line2 = &quot;Dogs also like meat&quot;;</span><br><span class="line">if ( line1 =~ /Cats(.*)/ )</span><br><span class="line">  puts &quot;Line1 contains Cats&quot;</span><br><span class="line">end</span><br><span class="line">if ( line2 =~ /Cats(.*)/ )</span><br><span class="line">  puts &quot;Line2 contains  Dogs&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>实例运行输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Line1 contains Cats</span><br></pre></td></tr></table></figure>

<h1 id="正则表达式修饰符"><a href="#正则表达式修饰符" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h1><p>正则表达式从字面上看可能包含一个可选的修饰符，用于控制各方面的匹配。修饰符在第二个斜杠字符后指定，如上面实例所示。下标列出了 可能的修饰符：</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>当匹配文本时忽略大小写。</td>
</tr>
<tr>
<td>o</td>
<td>只执行一次 #{} 插值，正则表达式在第一次时就进行判断。</td>
</tr>
<tr>
<td>x</td>
<td>忽略空格，允许在整个表达式中放入空白符和注释。</td>
</tr>
<tr>
<td>m</td>
<td>匹配多行，把换行字符识别为正常字符。</td>
</tr>
<tr>
<td>u,e,s,n</td>
<td>把正则表达式解释为 Unicode（UTF-8）、EUC、SJIS 或 ASCII。如果没有指定修饰符，则认为正则表达式使用的是源编码。</td>
</tr>
</tbody></table>
<p>就像字符串通过 %Q 进行分隔一样，Ruby 允许您以 %r 作为正则表达式的开头，后面跟着任意分隔符。这在描述包含大量您不想转义的斜杠字符时非常有用。</p>
<p><code># 下面匹配单个斜杠字符，不转义</code></p>
<p><code>%r|/|</code>  </p>
<p><code># Flag 字符可通过下面的语法进行匹配</code></p>
<p><code>%r[&lt;/(.*)&gt;]i</code> </p>
<h1 id="正则表达式模式"><a href="#正则表达式模式" class="headerlink" title="正则表达式模式"></a>正则表达式模式</h1><p>除了控制字符，(+ ? . * ^ $ ( ) [ ] { } | )，其他所有字符都匹配本身。您可以通过在控制字符前放置一个反斜杠来对控制字符进行转义。</p>
<p>下表列出了 Ruby 中可用的正则表达式语法。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配行的开头。</td>
</tr>
<tr>
<td>$</td>
<td>匹配行的结尾。</td>
</tr>
<tr>
<td>.</td>
<td>匹配除了换行符以外的任意单字符。使用 m 选项时，它也可以匹配换行符。</td>
</tr>
<tr>
<td>[…]</td>
<td>匹配在方括号中的任意单字符。</td>
</tr>
<tr>
<td>[^…]</td>
<td>匹配不在方括号中的任意单字符。</td>
</tr>
<tr>
<td>re*</td>
<td>匹配前面的子表达式零次或多次。</td>
</tr>
<tr>
<td>re+</td>
<td>匹配前面的子表达式一次或多次。</td>
</tr>
<tr>
<td>re?</td>
<td>匹配前面的子表达式零次或一次。</td>
</tr>
<tr>
<td>re{ n}</td>
<td>匹配前面的子表达式 n 次。</td>
</tr>
<tr>
<td>re{ n,}</td>
<td>匹配前面的子表达式 n 次或 n 次以上。</td>
</tr>
<tr>
<td>re{ n, m}</td>
<td>匹配前面的子表达式至少 n 次至多 m 次。</td>
</tr>
<tr>
<td>(re)</td>
<td>对正则表达式进行分组，并记住匹配文本。</td>
</tr>
<tr>
<td>(?imx)</td>
<td>暂时打开正则表达式内的 i、 m 或 x 选项。如果在圆括号中，则只影响圆括号内的部分。</td>
</tr>
<tr>
<td>(?-imx)</td>
<td>暂时关闭正则表达式内的 i、 m 或 x 选项。如果在圆括号中，则只影响圆括号内的部分。</td>
</tr>
<tr>
<td>(?: re)</td>
<td>对正则表达式进行分组，但不记住匹配文本。</td>
</tr>
<tr>
<td>(?imx: re)</td>
<td>暂时打开圆括号内的 i、 m 或 x 选项。</td>
</tr>
<tr>
<td>(?-imx: re)</td>
<td>暂时关闭圆括号内的 i、 m 或 x 选项。</td>
</tr>
<tr>
<td>(?#…)</td>
<td>注释。</td>
</tr>
<tr>
<td>(?&#x3D; re)</td>
<td>使用模式指定位置。没有范围。</td>
</tr>
<tr>
<td>(?! re)</td>
<td>使用模式的否定指定位置。没有范围。</td>
</tr>
<tr>
<td>(?&gt; re)</td>
<td>匹配无回溯的独立模式。</td>
</tr>
<tr>
<td>\w</td>
<td>匹配单词字符。</td>
</tr>
<tr>
<td>\W</td>
<td>匹配非单词字符。</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空白字符。等价于 [\t\n\r\f]。</td>
</tr>
<tr>
<td>\S</td>
<td>匹配非空白字符。</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字。等价于 [0-9]。</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字。</td>
</tr>
<tr>
<td>\A</td>
<td>匹配字符串的开头。</td>
</tr>
<tr>
<td>\Z</td>
<td>匹配字符串的结尾。如果存在换行符，则只匹配到换行符之前。</td>
</tr>
<tr>
<td>\z</td>
<td>匹配字符串的结尾。</td>
</tr>
<tr>
<td>\G</td>
<td>匹配最后一个匹配完成的点。</td>
</tr>
<tr>
<td>\b</td>
<td>当在括号外时匹配单词边界，当在括号内时匹配退格键（0x08）。</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界。</td>
</tr>
<tr>
<td>\n, \t, etc.</td>
<td>匹配换行符、回车符、制表符，等等。</td>
</tr>
<tr>
<td>\1…\9</td>
<td>匹配第 n 个分组子表达式。</td>
</tr>
<tr>
<td>\10</td>
<td>如果已匹配过，则匹配第 n 个分组子表达式。否则指向字符编码的八进制表示。</td>
</tr>
</tbody></table>
<p><strong>补充：</strong> <code>a|b</code> ：匹配 a 或 b。</p>
<h1 id="正则表达式实例"><a href="#正则表达式实例" class="headerlink" title="正则表达式实例"></a>正则表达式实例</h1><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;ruby&#x2F;</td>
<td>匹配 “ruby”</td>
</tr>
<tr>
<td>¥</td>
<td>匹配 Yen 符号。Ruby 1.9 和 Ruby 1.8 支持多个字符。</td>
</tr>
</tbody></table>
<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;[Rr]uby&#x2F;</td>
<td>匹配 “Ruby” 或 “ruby”</td>
</tr>
<tr>
<td>&#x2F;rub[ye]&#x2F;</td>
<td>匹配 “ruby” 或 “rube”</td>
</tr>
<tr>
<td>&#x2F;[aeiou]&#x2F;</td>
<td>匹配任何一个小写元音字母</td>
</tr>
<tr>
<td>&#x2F;[0-9]&#x2F;</td>
<td>匹配任何一个数字，与 &#x2F;[0123456789]&#x2F; 相同</td>
</tr>
<tr>
<td>&#x2F;[a-z]&#x2F;</td>
<td>匹配任何一个小写 ASCII 字母</td>
</tr>
<tr>
<td>&#x2F;[A-Z]&#x2F;</td>
<td>匹配任何一个大写 ASCII 字母</td>
</tr>
<tr>
<td>&#x2F;[a-zA-Z0-9]&#x2F;</td>
<td>匹配任何一个括号内的字符</td>
</tr>
<tr>
<td>&#x2F;[^aeiou]&#x2F;</td>
<td>匹配任何一个非小写元音字母的字符</td>
</tr>
<tr>
<td>&#x2F;[^0-9]&#x2F;</td>
<td>匹配任何一个非数字字符</td>
</tr>
</tbody></table>
<h2 id="特殊字符类"><a href="#特殊字符类" class="headerlink" title="特殊字符类"></a>特殊字符类</h2><table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;.&#x2F;</td>
<td>匹配除了换行符以外的其他任意字符</td>
</tr>
<tr>
<td>&#x2F;.&#x2F;m</td>
<td>在多行模式下，也能匹配换行符</td>
</tr>
<tr>
<td>&#x2F;\d&#x2F;</td>
<td>匹配一个数字，等同于 &#x2F;[0-9]&#x2F;</td>
</tr>
<tr>
<td>&#x2F;\D&#x2F;</td>
<td>匹配一个非数字，等同于 &#x2F;[^0-9]&#x2F;</td>
</tr>
<tr>
<td>&#x2F;\s&#x2F;</td>
<td>匹配一个空白字符，等同于 &#x2F;[ \t\r\n\f]&#x2F;</td>
</tr>
<tr>
<td>&#x2F;\S&#x2F;</td>
<td>匹配一个非空白字符，等同于 &#x2F;[^ \t\r\n\f]&#x2F;</td>
</tr>
<tr>
<td>&#x2F;\w&#x2F;</td>
<td>匹配一个单词字符，等同于 &#x2F;[A-Za-z0-9_]&#x2F;</td>
</tr>
<tr>
<td>&#x2F;\W&#x2F;</td>
<td>匹配一个非单词字符，等同于 &#x2F;[^A-Za-z0-9_]&#x2F;</td>
</tr>
</tbody></table>
<h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;ruby?&#x2F;</td>
<td>匹配 “rub” 或 “ruby”。其中，y 是可有可无的。</td>
</tr>
<tr>
<td>&#x2F;ruby*&#x2F;</td>
<td>匹配 “rub” 加上 0 个或多个的 y。</td>
</tr>
<tr>
<td>&#x2F;ruby+&#x2F;</td>
<td>匹配 “rub” 加上 1 个或多个的 y。</td>
</tr>
<tr>
<td>&#x2F;\d{3}&#x2F;</td>
<td>刚好匹配 3 个数字。</td>
</tr>
<tr>
<td>&#x2F;\d{3,}&#x2F;</td>
<td>匹配 3 个或多个数字。</td>
</tr>
<tr>
<td>&#x2F;\d{3,5}&#x2F;</td>
<td>匹配 3 个、4 个或 5 个数字。</td>
</tr>
</tbody></table>
<h2 id="非贪婪重复"><a href="#非贪婪重复" class="headerlink" title="非贪婪重复"></a>非贪婪重复</h2><p>这会匹配最小次数的重复。</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;&lt;.*&gt;&#x2F;</td>
<td>贪婪重复：匹配 “<ruby>perl&gt;”</td>
</tr>
<tr>
<td>&#x2F;&lt;.*?&gt;&#x2F;</td>
<td>非贪婪重复：匹配 “<ruby>perl&gt;” 中的 “<ruby>“</td>
</tr>
</tbody></table>
<h2 id="通过圆括号进行分组"><a href="#通过圆括号进行分组" class="headerlink" title="通过圆括号进行分组"></a>通过圆括号进行分组</h2><table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;\D\d+&#x2F;</td>
<td>无分组： + 重复 \d</td>
</tr>
<tr>
<td>&#x2F;(\D\d)+&#x2F;</td>
<td>分组： + 重复 \D\d 对</td>
</tr>
<tr>
<td>&#x2F;([Rr]uby(, )?)+&#x2F;</td>
<td>匹配 “Ruby”、”Ruby, ruby, ruby”，等等</td>
</tr>
</tbody></table>
<h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>这会再次匹配之前匹配过的分组。</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;([Rr])uby&amp;\1ails&#x2F;</td>
<td>匹配 ruby&amp;rails 或 Ruby&amp;Rails</td>
</tr>
<tr>
<td>&#x2F;([‘“])(?:(?!\1).)*\1&#x2F;</td>
<td>单引号或双引号字符串。\1 匹配第一个分组所匹配的字符，\2 匹配第二个分组所匹配的字符，依此类推。</td>
</tr>
</tbody></table>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;ruby</td>
<td>rube&#x2F;</td>
</tr>
<tr>
<td>&#x2F;rub(y</td>
<td>le))&#x2F;</td>
</tr>
<tr>
<td>&#x2F;ruby(!+</td>
<td>?)&#x2F;</td>
</tr>
</tbody></table>
<h2 id="锚"><a href="#锚" class="headerlink" title="锚"></a>锚</h2><p>这需要指定匹配位置。</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;^Ruby&#x2F;</td>
<td>匹配以 “Ruby” 开头的字符串或行</td>
</tr>
<tr>
<td>&#x2F;Ruby$&#x2F;</td>
<td>匹配以 “Ruby” 结尾的字符串或行</td>
</tr>
<tr>
<td>&#x2F;\ARuby&#x2F;</td>
<td>匹配以 “Ruby” 开头的字符串</td>
</tr>
<tr>
<td>&#x2F;Ruby\Z&#x2F;</td>
<td>匹配以 “Ruby” 结尾的字符串</td>
</tr>
<tr>
<td>&#x2F;\bRuby\b&#x2F;</td>
<td>匹配单词边界的 “Ruby”</td>
</tr>
<tr>
<td>&#x2F;\brub\B&#x2F;</td>
<td>\B 是非单词边界：匹配 “rube” 和 “ruby” 中的 “rub”，但不匹配单独的 “rub”</td>
</tr>
<tr>
<td>&#x2F;Ruby(?&#x3D;!)&#x2F;</td>
<td>如果 “Ruby” 后跟着一个感叹号，则匹配 “Ruby”</td>
</tr>
<tr>
<td>&#x2F;Ruby(?!!)&#x2F;</td>
<td>如果 “Ruby” 后没有跟着一个感叹号，则匹配 “Ruby”</td>
</tr>
</tbody></table>
<h2 id="圆括号的特殊语法"><a href="#圆括号的特殊语法" class="headerlink" title="圆括号的特殊语法"></a>圆括号的特殊语法</h2><table>
<thead>
<tr>
<th>实例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;R(?#comment)&#x2F;</td>
<td>匹配 “R”。所有剩余的字符都是注释。</td>
</tr>
<tr>
<td>&#x2F;R(?i)uby&#x2F;</td>
<td>当匹配 “uby” 时不区分大小写。</td>
</tr>
<tr>
<td>&#x2F;R(?i:uby)&#x2F;</td>
<td>与上面相同。</td>
</tr>
</tbody></table>
<p><strong>补充</strong> <code>/rub(?:y|le))/</code> ：只分组，不进行 \1 反向引用</p>
<h1 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h1><p>sub 和 gsub 及它们的替代变量 sub! 和 gsub! 是使用正则表达式时重要的字符串方法。</p>
<p>所有这些方法都是使用正则表达式模式执行搜索与替换操作。sub 和 sub! 替换模式的第一次出现，gsub 和 gsub! 替换模式的所有出现。</p>
<p>sub 和 gsub 返回一个新的字符串，保持原始的字符串不被修改，而 sub! 和 gsub! 则会修改它们调用的字符串。</p>
<p>下面是一个实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/ruby</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">phone = &quot;138-3453-1111 #这是一个电话号码&quot;</span><br><span class="line"># 删除 Ruby 的注释</span><br><span class="line">phone = phone.sub!(/#.*$/, &quot;&quot;)   </span><br><span class="line">   puts &quot;电话号码 : #&#123;phone&#125;&quot;</span><br><span class="line"># 移除数字以外的其他字符</span><br><span class="line">phone = phone.gsub!(/\D/, &quot;&quot;)    </span><br><span class="line">    puts &quot;电话号码 : #&#123;phone&#125;&quot;</span><br><span class="line">以上实例运行结果：</span><br><span class="line">电话号码 : 138-3453-1111 </span><br><span class="line">电话号码 : 13834531111</span><br><span class="line">下面是另一个实例：</span><br><span class="line">#!/usr/bin/ruby</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">text = &quot;rails 是 rails,  Ruby on Rails 非常好的 Ruby 框架&quot;</span><br><span class="line"># 把所有的 &quot;rails&quot; 改为 &quot;Rails&quot;</span><br><span class="line">text.gsub!(&quot;rails&quot;, &quot;Rails&quot;)</span><br><span class="line"># 把所有的单词 &quot;Rails&quot; 都改成首字母大写</span><br><span class="line">text.gsub!(/\brails\b/, &quot;Rails&quot;)</span><br><span class="line">puts &quot;#&#123;text&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>以上实例运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Rails 是 Rails,  Ruby on Rails 非常好的 Ruby 框架</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2016-04-13-singleton-pattern/</url>
    <content><![CDATA[<p>单例模式的作用是解决“应用中只有一个实例”的一类问题。本文主要介绍单例模式所谓何物，以及如何实现。</p>
<span id="more"></span>


<h1 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h1><p>在一个iOS 应用的生命周期中，有时候我们只需要某个类的一个实例。例如，iOS 设备都有一个重力加速计硬件设备，要访问设备在x轴、y轴和z轴上的重力加速度，就必然要有一个类能够与硬件设备沟通来实时获得这些数据，这个类就是UIAccelerometer 。除了实时地获得数据，该类还能够保持x 轴、y轴和z 轴的状态。但是这个类只需要一个实例就够了，如果有多个实例，就会占用过多的内存。 再有，当应用程序启动时，应用的状态由UIApplication 类的一个实例维护，这个实例代表了整个“应用程序对象”，它只能是一个实例，其作用是实现应用程序中一些共享资源的访问和状态的保持等。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>单例模式一般会封装一个静态属性，并提供静态实例的创建方法，其UML类图如图所示:</p>
<p><img src="/assets/images/tech/singleton-pattern-1.jpg" alt="单例设计模式类图"></p>
<h1 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Singleton.h</span><br><span class="line">//</span><br><span class="line">@interface Singleton : NSObject</span><br><span class="line">+ (Singleton*)sharedManager;</span><br><span class="line">@property (nonatomic ,strong) NSString* singletonData;</span><br><span class="line">@end</span><br><span class="line">   </span><br><span class="line">//Singleton.m </span><br><span class="line">//</span><br><span class="line">#import &quot;Singleton.h&quot;</span><br><span class="line">@implementation Singleton</span><br><span class="line">@synthesize singletonData = _singletonData;</span><br><span class="line">static Singleton *sharedManager = nil;</span><br><span class="line">+ (Singleton*)sharedManager</span><br><span class="line">&#123;</span><br><span class="line">    static dispatch_once_t once;</span><br><span class="line">    dispatch_once(&amp;once, ^&#123;</span><br><span class="line">        sharedManager = [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return sharedManager;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>其中<code>static Singleton *sharedManager</code> 为静态变量，类方法为<code>+ (Singleton*)sharedManager</code>。sharedManager 方法采用了GCD（Grand Central Dispatch）技术，这是一种基于C语言的多线程访问技术。在上述代码中，<code>dispatch_once</code> 函数就是由GCD提供的，它的作用是在整个应用程序生命周期中只执行一次代码块（^{…}）。 <code>dispatch_once_t</code> 是GCD提供的结构体，使用时需要将GCD地址传给<code>dispatch_once</code> 函数。<code>dispatch_once</code> 函数能够记录该代码块是否被调用过。<code>dispatch_once</code>函数不仅意味着代码仅会被运行一次，而且还意味着此运行还是线程同步的。也就是说，当我们使用了<code>dispatch_once</code>函数时，就不再需要使用诸如<code>@synchronized</code>之类的语句。</p>
<p>将以上单例实现代码，抽成宏，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// @interface</span><br><span class="line">#define singleton_interface(className) \</span><br><span class="line">+ (className *)shared##className;</span><br><span class="line"> </span><br><span class="line">// @implementation</span><br><span class="line">#define singleton_implementation(className) \</span><br><span class="line">static className *_instance; \</span><br><span class="line">+ (id)allocWithZone:(NSZone *)zone \</span><br><span class="line">&#123; \</span><br><span class="line">    static dispatch_once_t onceToken; \</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123; \</span><br><span class="line">        _instance = [super allocWithZone:zone]; \</span><br><span class="line">    &#125;); \</span><br><span class="line">    return _instance; \</span><br><span class="line">&#125; \</span><br><span class="line">+ (className *)shared##className \</span><br><span class="line">&#123; \</span><br><span class="line">    static dispatch_once_t onceToken; \</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123; \</span><br><span class="line">        _instance = [[self alloc] init]; \</span><br><span class="line">    &#125;); \</span><br><span class="line">    return _instance; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h1><p>在Cocoa Touch框架中，有UIApplication、UIAccelerometer 、NSUserDefaults和NSNotificationCenter等单例类。另外，NSFileManager 和NSBundle 类虽然属于Cocoa框架的内容，但也可以在Cocoa Touch框架中使用（Cocoa框架中的单例类有NSFileManager 、NSBundle 、NSWorkspace和NSApplication 等）。 </p>
<h2 id="1-UIApplication"><a href="#1-UIApplication" class="headerlink" title="1. UIApplication"></a>1. UIApplication</h2><p>UIApplication 类的实例提供了应用程序的集中控制点来保持应用的状态。UIApplication 实例总是分配给应用程序委托对象（UIApplicationDelegate ），通过应用程序委托对象来响应低内存、应用启动、后台运行和应用终止等事件。在HelloWorld 案例中，AppDelegate 就是这个应用程序的委托对象，它实现了UIApplicationDelegate协议。</p>
<p>UIApplication 类有很多方法和属性，下面我们重点介绍其中几个：<br><code>+ sharedApplication</code> 方法。创建和获得UIApplication 实例的方法。<br><code>idleTimerDisabled</code>属性。设定和获得“空闲时间禁止”的状态。idleTimerDisabled属性的默认值是NO，即默认情况下系统会锁定屏幕。当idleTimerDisabled &#x3D; YES 时，则不会开启“空闲时间禁止”状态，系统不会锁定屏幕。开启这项设定需要谨慎，它会使你的应用比较耗电。<br><code>- openURL: </code>方法。可以打开一些内置的iOS 应用，其中包括打开浏览器、打开Google 地图、拨打电话、发送短信和发送E-mail 等。</p>
<p>打开浏览器的示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSURL *url = [NSURL URLWithString:@&quot;http://www.cnblogs.com/chars&quot;];</span><br><span class="line">[[UIApplication sharedApplication] openURL:url];</span><br></pre></td></tr></table></figure>
<p>打开Google 地图时，实际上是通过内置浏览器来打开，示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString* searchQuery = @&quot;清华大学&quot;;</span><br><span class="line">searchQuery = [searchQuery stringByAddingPercentEscapesUsingEncoding: NSUTF8StringEncoding];</span><br><span class="line">NSString* urlString = [NSString stringWithFormat: @&quot;http://maps.google.com/maps?q=%@&quot;, searchQuery];</span><br><span class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString]];</span><br></pre></td></tr></table></figure>
<p>其中NSString 的<code>stringByAddingPercentEscapesUsingEncoding</code>方法将字符串转换为URL编码，例如 “%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6 ”是“清华大学”的 URL 编码。 拨打电话时，苹果官方要求使用该方法调用内置拨号程序，示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;tel://10010&quot;]];</span><br></pre></td></tr></table></figure>
<p>发送短信时，苹果官方要求使用该方法调用内置发送短信程序，示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;sms:10010&quot;]];</span><br></pre></td></tr></table></figure>
<p>发送E-mail 时，这种方式可以发送简单的不带附件的E-mail ，示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;mailto://eorient@sina.com&quot;]];</span><br></pre></td></tr></table></figure>
<h2 id="2-UIAccelerometer"><a href="#2-UIAccelerometer" class="headerlink" title="2.   UIAccelerometer"></a>2.   UIAccelerometer</h2><p>单例类UIAccelerometer 前面也讲过，它可以访问重力加速计硬件设备，实时获得设备在x 轴、y轴和z 轴方向上的重力加速度。<br><code>+ sharedAccelerometer</code>方法是创建和获得UIAccelerometer实例的共享方法。</p>
<p>与UIApplication类似，UIAccelerometer也有对应的委托对象，其委托对象为UIAccelerometerDelegate。UIAccelerometer 将实例分配给委托对象UIAccelerometerDelegate ，然后由委托对象响应重力加速计事件。</p>
<h2 id="3-NSUserDefaults"><a href="#3-NSUserDefaults" class="headerlink" title="3.   NSUserDefaults"></a>3.   NSUserDefaults</h2><p>单例类NSUserDefaults可以很方便地读取应用设置项目。<br><code>+ standardUserDefaults</code>方法是创建和获得NSUserDefaults实例的静态方法。</p>
<h2 id="4-NSNotificationCenter"><a href="#4-NSNotificationCenter" class="headerlink" title="4.   NSNotificationCenter"></a>4.   NSNotificationCenter</h2><p>单例类NSNotificationCenter提供信息广播通知，它采用观察者模式的通知机制。<br><code>+ defaultCenter </code>方法是创建和获得NSNotificationCenter实例的共享方法。</p>
<h2 id="5-NSFileManager"><a href="#5-NSFileManager" class="headerlink" title="5.   NSFileManager"></a>5.   NSFileManager</h2><p>NSFileManager 提供了访问文件系统的通用操作，可以定位、创建、复制文件和文件夹。在iOS 5和Mac OS X v10.7之后，它还可以管理存储在iCloud 上的数据。</p>
<p><code>+ defaultManager </code>方法是创建和获得NSFileManager 实例的方法。除了该方法外，创建NSFileMa nager对象时还可以使用实例构造方法– init。这两种方法有着比较大的差别，+ defaultManager方法总是返回相同的NSFileManager 对象，但如果要使用委托（NSFileManagerDelegate）完成基于文件的操作并接收通知，应该使用– init 方法创建一个新的实例，而不是使用共享的对象。</p>
<h2 id="6-NSBundle"><a href="#6-NSBundle" class="headerlink" title="6.   NSBundle"></a>6.   NSBundle</h2><p>NSBundle 提供了动态加载（或卸载）可执行代码、定位资源文件以及资源本地化、访问文件系统等功能。<br><code>+ mainBundle</code>方法是创建和获得NSBundle 实例的共享方法。
 </p>
<h1 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h1><p>单例模式无疑是Cocoa框架下最重要的设计模式之一。灵活而有机地运用设计模式，意味着编程工作的高效性和产品健壮性、安全性的提高。因此，我们应该要善于使用设计模式，将自己的开发经验与代码、设计模式完美融合起来，提高软件代码质量。
 </p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>objc</tag>
      </tags>
  </entry>
  <entry>
    <title>VFL 语言简介</title>
    <url>/2016-04-17-VFL-introduction/</url>
    <content><![CDATA[<p>VFL（Visual Format Language），“可视化格式语言”。VFL是苹果公司为了简化autolayout的编码而推出的抽象语言。本文分享VFL的基本使用方法。</p>
<span id="more"></span>

<h1 id="什么是VFL语言"><a href="#什么是VFL语言" class="headerlink" title="什么是VFL语言"></a>什么是VFL语言</h1><p>VFL（Visual Format Language），“可视化格式语言”。</p>
<p>VFL 是苹果公司为了简化autolayout的编码而推出的抽象语言。</p>
<p><img src="/assets/images/tech/VFL-introduction-1.png" alt="1"></p>
<h1 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">H:[cancelButton(72)]-12-[acceptButton(50)]</span><br><span class="line">cancelButton宽72，acceptButton宽50，它们之间间距12</span><br><span class="line"> </span><br><span class="line">H:[wideView(&gt;=60@700)]</span><br><span class="line">wideView宽度大于等于60point，该约束条件优先级为700（优先级最大值为1000，优先级越高的约束条件越先被满足）</span><br><span class="line">  </span><br><span class="line">V:[redBox][yellowBox(==redBox)]</span><br><span class="line">垂直方向上，先有一个redBox，其下方紧接一个高度等于redBox高度的yellowBox</span><br><span class="line">  </span><br><span class="line">H:|-10-[Find]-[FindNext]-[FindField(&gt;=20)]-|</span><br><span class="line">水平方向上，Find距离父view左边缘间隔10，之后是FindNext距离Find间隔默认宽度；再之后是宽度不小于20的FindField，它和FindNext以及父view右边边缘的间距都是默认宽度。（竖线“|”表示superview的边缘）。</span><br></pre></td></tr></table></figure>

<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用VFL来创建约束数组</span><br><span class="line">+(NSArray *)constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)opts metrics:(NSDictionary *)metrics views:(NSDictionary *)views;</span><br><span class="line">  </span><br><span class="line">format：VFL语句</span><br><span class="line">opts：约束类型</span><br><span class="line">metrics：VFL语句中用到的具体数值</span><br><span class="line">views：VFL语句中用到的控件</span><br><span class="line">  </span><br><span class="line">创建一个字典（内部包含VFL语句中用到的控件）的快捷宏定义</span><br><span class="line">NSDictionaryOfVariableBindings(...)</span><br></pre></td></tr></table></figure>

<h1 id="实例展示"><a href="#实例展示" class="headerlink" title="实例展示"></a>实例展示</h1><p>效果图如下：</p>
<p><img src="/assets/images/tech/VFL-introduction-2.png" alt="2"> </p>
<p><img src="/assets/images/tech/VFL-introduction-3.png" alt="3"></p>
<h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(void)horizontalLayout&#123;</span><br><span class="line">    //1.添加两个控件</span><br><span class="line">    UIView *blueView = [[UIView alloc] init];</span><br><span class="line">    blueView.backgroundColor = [UIColor blueColor];</span><br><span class="line">    </span><br><span class="line">    blueView.translatesAutoresizingMaskIntoConstraints = NO;</span><br><span class="line">    [self.view addSubview:blueView];</span><br><span class="line">    </span><br><span class="line">    UIView *redView = [[UIView alloc] init];</span><br><span class="line">    redView.backgroundColor = [UIColor redColor];</span><br><span class="line">    redView.translatesAutoresizingMaskIntoConstraints = NO;</span><br><span class="line">    [self.view addSubview:redView];</span><br><span class="line">    </span><br><span class="line">    //2.添加约束</span><br><span class="line">    //2.1水平方向的约束</span><br><span class="line">    NSString *hVFL = @&quot;H:|-30-[blueView]-30-[redView(==blueView)]-30-|&quot;;</span><br><span class="line">    NSArray *hCons = [NSLayoutConstraint constraintsWithVisualFormat:hVFL options:NSLayoutFormatAlignAllBottom | NSLayoutFormatAlignAllTop metrics:nil views:@&#123;@&quot;blueView&quot;:blueView, @&quot;redView&quot;:redView&#125;];</span><br><span class="line">    [self.view addConstraints:hCons];</span><br><span class="line">    </span><br><span class="line">    //2.2垂直方向的约束</span><br><span class="line">    NSString *vVFL = @&quot;V:[blueView(50)]-30-|&quot;;</span><br><span class="line">    NSArray *vCons = [NSLayoutConstraint constraintsWithVisualFormat:vVFL options:0 metrics:nil views:@&#123;@&quot;blueView&quot;:blueView&#125;];</span><br><span class="line">    [self.view addConstraints:vCons];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)verticalLayout&#123;</span><br><span class="line">    //1.添加两个控件</span><br><span class="line">    UIView *blueView = [[UIView alloc] init];</span><br><span class="line">    blueView.backgroundColor = [UIColor blueColor];</span><br><span class="line">    blueView.translatesAutoresizingMaskIntoConstraints = NO;</span><br><span class="line">    [self.view addSubview:blueView];</span><br><span class="line"></span><br><span class="line">    UIView *redView = [[UIView alloc] init];</span><br><span class="line">    redView.backgroundColor = [UIColor redColor];</span><br><span class="line">    redView.translatesAutoresizingMaskIntoConstraints = NO;</span><br><span class="line">    [self.view addSubview:redView];</span><br><span class="line"></span><br><span class="line">    //2.添加约束</span><br><span class="line">    //2.1水平方向的约束</span><br><span class="line">    NSString *hVFL = @&quot;H:|-30-[blueView]-30-|&quot;;</span><br><span class="line">    NSArray *hCons = [NSLayoutConstraint constraintsWithVisualFormat:hVFL options:0 metrics:nil views:@&#123;@&quot;blueView&quot;:blueView&#125;];</span><br><span class="line">    [self.view addConstraints:hCons];</span><br><span class="line"></span><br><span class="line">    //2.2垂直方向的约束</span><br><span class="line">    NSString *vVFL = @&quot;V:|-30-[blueView(50)]-30-[redView(==blueView)]&quot;;</span><br><span class="line">    NSArray *vCons = [NSLayoutConstraint constraintsWithVisualFormat:vVFL options:NSLayoutFormatAlignAllRight metrics:nil views:@&#123;@&quot;blueView&quot;:blueView, @&quot;redView&quot;:redView&#125;];</span><br><span class="line">    [self.view addConstraints:vCons];</span><br><span class="line">    NSLayoutConstraint *redLeftCon = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:blueView attribute:NSLayoutAttributeCenterX multiplier:1.0 constant:0];</span><br><span class="line">    [self.view addConstraint:redLeftCon];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>最后对格式的字符串作一个总结介绍：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>表达式</th>
</tr>
</thead>
<tbody><tr>
<td>水平方向</td>
<td>H:</td>
</tr>
<tr>
<td>垂直方向</td>
<td>V:</td>
</tr>
<tr>
<td>Views</td>
<td>[view]</td>
</tr>
<tr>
<td>SuperView</td>
<td>竖线符号</td>
</tr>
<tr>
<td>关系</td>
<td>&gt;&#x3D;,&#x3D;&#x3D;,&lt;&#x3D;</td>
</tr>
<tr>
<td>空间，间隙</td>
<td>-</td>
</tr>
<tr>
<td>优先级</td>
<td>@value</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>objc</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>均匀分布随机函数的实现</title>
    <url>/2016-04-30-uniform-random/</url>
    <content><![CDATA[<p>随机函数可以说是用途很广。可是，系统提供的random函数，一般符合正态分布，所以说，这是伪随机函数。甚至在一些场合是非随机函数。为了满足项目需要，必须实现均匀分布。在此，分享博主实现均匀随机函数的实现过程与方法。</p>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随机函数就是产生数的函数，C语言里使用rand(),srand()等随机函数实现随机数生成。
 </p>
<h1 id="函数简介"><a href="#函数简介" class="headerlink" title="函数简介"></a>函数简介</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int rand( void );</span><br></pre></td></tr></table></figure>

<p>返回的是一个界于0～32767（0x7FFF）之间的伪随机数，包括0和32767。<br>C预先生成一组随机数，每次调用随机函数时从指针所指向的位置开始取值，因此使用rand()重复运行程序产生的随机数都是相同的，可以通过srand()函数来改变指针位置。<br>srand()会设置供rand()使用的随机数种子。如果在第一次使用rand()之前没有调用srand()，那么系统会自动调用srand()。而使用同种子相同的数调用 rand()会导致相同的随机数序列被生成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void srand( unsigned int seed );</span><br></pre></td></tr></table></figure>
<p>改变随机数表的指针位置（用seed变量控制）。<br>使用系统定时&#x2F;计数器的值作为随机种子。每个种子对应一组根据算法预先生成的随机数，所以，在相同的平台环境下，不同时间产生的随机数会是不同的，相应的，若将srand（unsigned）time(NULL)改为srand(TP)（TP为任一常量），则无论何时运行、运行多少次得到的“随机数”都会是一组固定的序列，因此srand生成的随机数是伪随机数。<br>一般配合time(NULL)使用，因为时间每时每刻都在改变，产生的seed值都不同。
 </p>
<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>使用rand函数生成的随机数严格满足正态分布。而在很多时候，我们希望随机数的生成不要满足正态分布，特别是在处理网络通信报文的时候。<br>例如，我们需要在交换机处理到海量报文时，能够使远端的从设备尽可能的分段同时向局端回应报文，以减轻局<del>部</del>端报文处理压力。
 </p>
<h1 id="均匀分布随机函数实现"><a href="#均匀分布随机函数实现" class="headerlink" title="均匀分布随机函数实现"></a>均匀分布随机函数实现</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p><img src="/assets/images/tech/uniform-random-1.jpg" alt="开发环境"></p>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1）打开Qt Creater，创建GUI工程</p>
<p><img src="/assets/images/tech/uniform-random-2.jpg" alt="创建GUI工程"></p>
<p><img src="/assets/images/tech/uniform-random-3.jpg" alt="项目文件结构"></p>
<p>2）在mainwindow.h中添加函数声明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void paintEvent(QPaintEvent *);</span><br></pre></td></tr></table></figure>

<p>3）在mainwindow.cpp中添加函数实现</p>
<p>导入头文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;QPainter&gt;</span><br></pre></td></tr></table></figure>

<p> <br>实现<code>void paintEvent(QPaintEvent *)</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> *Qt中函数paintEvent(QPaintEvent*)是被系统自动调用。</span><br><span class="line"> *paintEvent(QPaintEvent *)函数是QWidget类中的虚函数，用于ui的绘制，会在多种情况下被其他函数自动调用。</span><br><span class="line">*/</span><br><span class="line">void MainWindow::paintEvent(QPaintEvent *)</span><br><span class="line">&#123;</span><br><span class="line">    QPainter painter(this);</span><br><span class="line">    QPen pen; //画笔</span><br><span class="line">    pen.setColor(QColor(255,0,0)); //设置画笔颜色</span><br><span class="line">    painter.setPen(pen); //添加画笔</span><br><span class="line"></span><br><span class="line">    long int r[kSum] = &#123;0&#125;;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line"></span><br><span class="line">    do&#123;</span><br><span class="line">        r[i] = Uniform(0, 300);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;while(i &lt; kSum);</span><br><span class="line"></span><br><span class="line">    while((j + 30) &lt; (kSum + 30))&#123;</span><br><span class="line">        painter.drawPoint(j, r[j]);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <br>4）添加随机函数实现代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">#define kSum 1000</span><br><span class="line">//算法一</span><br><span class="line">/*</span><br><span class="line"> *均匀分布随机函数均匀化</span><br><span class="line">*/</span><br><span class="line">double _uniform(double min, double max, long int *seed) &#123;</span><br><span class="line">    double t = 0;</span><br><span class="line">    *seed = 2045 * (*seed) + 1;</span><br><span class="line">    *seed = *seed - (*seed / 1048576) * 1048576;</span><br><span class="line">    t = (*seed) / 1048576.0;</span><br><span class="line">    t = min + (max - min) * t;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *均匀分布随机函数产生随机数</span><br><span class="line">*/</span><br><span class="line">long int Uniform(double min, double max) &#123;</span><br><span class="line">    long int s = 0;</span><br><span class="line">    double r = 0;</span><br><span class="line"></span><br><span class="line">    //srand((unsigned int)time(NULL)); /*同一个时间种子可能会从产生相同的随机数列*/</span><br><span class="line">    s = rand();</span><br><span class="line">    r = _uniform(min, max, &amp;s);</span><br><span class="line"></span><br><span class="line">    return ((long int)r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//算法二</span><br><span class="line">double AverageRandom(double min, double max) &#123;</span><br><span class="line">    int minInteger = (int)(min * 10000);</span><br><span class="line">    int maxInteger = (int)(max * 10000);</span><br><span class="line">    int randInteger = rand() * rand();</span><br><span class="line">    int diffInteger = maxInteger - minInteger;</span><br><span class="line">    int resultInteger = randInteger % diffInteger + minInteger;</span><br><span class="line"></span><br><span class="line">    return (resultInteger/10000.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> </p>
<h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p><img src="/assets/images/tech/uniform-random-4.jpg" alt="实现效果">
 </p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>从图中可以看出，使用上述函数生成的随机数符合均匀分布。<br>本案例主要使用了Qt的绘图功能，用来直观展示生成随机数的效果。检验随机函数生成随机数的效果。
 </p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>最后附上该算法实现的全部代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//mainwindow.h</span><br><span class="line">#ifndef MAINWINDOW_H</span><br><span class="line">#define MAINWINDOW_H</span><br><span class="line"></span><br><span class="line">#include &lt;QMainWindow&gt;</span><br><span class="line"></span><br><span class="line">namespace Ui &#123;</span><br><span class="line">class MainWindow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MainWindow : public QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit MainWindow(QWidget *parent = 0);</span><br><span class="line">    ~MainWindow();</span><br><span class="line">    void paintEvent(QPaintEvent *);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // MAINWINDOW_H</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//mainwindow.cpp</span><br><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &quot;ui_mainwindow.h&quot;</span><br><span class="line">#include &lt;QPainter&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">#define kSum 1000</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent) :</span><br><span class="line">    QMainWindow(parent),</span><br><span class="line">    ui(new Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">    delete ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *均匀分布随机函数均匀化</span><br><span class="line">*/</span><br><span class="line">double _uniform(double min, double max, long int *seed) &#123;</span><br><span class="line">    double t = 0;</span><br><span class="line">    *seed = 2045 * (*seed) + 1;</span><br><span class="line">    *seed = *seed - (*seed / 1048576) * 1048576;</span><br><span class="line">    t = (*seed) / 1048576.0;</span><br><span class="line">    t = min + (max - min) * t;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *均匀分布随机函数产生随机数</span><br><span class="line">*/</span><br><span class="line">long int Uniform(double min, double max) &#123;</span><br><span class="line">    long int s = 0;</span><br><span class="line">    double r = 0;</span><br><span class="line"></span><br><span class="line">    //srand((unsigned int)time(NULL)); /*同一个时间种子可能会从产生相同的随机数列*/</span><br><span class="line">    s = rand();</span><br><span class="line">    r = _uniform(min, max, &amp;s);</span><br><span class="line"></span><br><span class="line">    return ((long int)r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *Qt中函数paintEvent(QPaintEvent*)是被系统自动调用。</span><br><span class="line"> *paintEvent(QPaintEvent *)函数是QWidget类中的虚函数，用于ui的绘制，会在多种情况下被其他函数自动调用。</span><br><span class="line">*/</span><br><span class="line">void MainWindow::paintEvent(QPaintEvent *)</span><br><span class="line">&#123;</span><br><span class="line">    QPainter painter(this);</span><br><span class="line">    QPen pen; //画笔</span><br><span class="line">    pen.setColor(QColor(255,0,0)); //设置画笔颜色</span><br><span class="line">    painter.setPen(pen); //添加画笔</span><br><span class="line"></span><br><span class="line">    long int r[kSum] = &#123;0&#125;;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line"></span><br><span class="line">    do&#123;</span><br><span class="line">        r[i] = Uniform(0, 300);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;while(i &lt; kSum);</span><br><span class="line"></span><br><span class="line">    while((j + 30) &lt; (kSum + 30))&#123;</span><br><span class="line">        painter.drawPoint(j, r[j]);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//main.cpp</span><br><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &lt;QApplication&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication a(argc, argv);</span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.show();</span><br><span class="line"></span><br><span class="line">    return a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>欢迎大家加入移动开发交流Q群交流讨论，Q群号：811237468</p>
<p><img src="/assets/images/Q811237468.jpg" alt="Q811237468"></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>flappy bird 游戏实现</title>
    <url>/2016-05-05-flappy-bird-game/</url>
    <content><![CDATA[<p>在博主还是学生的时候，flappyBird这款游戏非常火爆，最后等到Android版的出来之后，也是很痴迷的玩了一把。可是，博主游戏天赋一直平平，几度玩得想摔手机。本文主要介绍如何开发iOS平台的flappyBird，游戏中使用了原本软件的图片资源，仅作学习交流使用。博主实现的flappyBird游戏包含游戏等级设定，排行榜，音效等功能。</p>
<span id="more"></span>

<h1 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h1><p>flappyBird是单机游戏，主要涉及界面逻辑、图片资源、游戏动画、得分排行。</p>
<p>为了实现这几个功能，需要使用以下几个技术框架：</p>
<ul>
<li>AVFoundation</li>
<li>归档</li>
<li>模态视图</li>
<li>NSTimer</li>
<li>视图控件，包括UIImageView、UILabel、UITableView等</li>
</ul>
<h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><p>1、创建工程</p>
<p>1）打开Xcode，点击新建工程，选择Single View Application模板</p>
<p><img src="/assets/images/tech/flappy-bird-game-1.png" alt="create"></p>
<p> 2）填写工程信息</p>
<p><img src="/assets/images/tech/flappy-bird-game-2.png" alt="fill"></p>
<p>2、移除Main.storyboard文件</p>
<p><img src="/assets/images/tech/flappy-bird-game-3.png" alt="remove"></p>
<p>上图是flappyBird的文件目录，因为Xcode6使用模板创建工程时会自动生成Main.storyboard文件，而工程中本人使用代码布局，所以可以移除Main.storyboard文件。具体操作方法可以参看本人另一篇文章：<br><a href="http://www.cnblogs.com/chars/p/5150155.html">《iOS学习之移除Main.storyboard》</a></p>
<p>3、游戏界面布局</p>
<p>整体效果图如下</p>
<p><img src="/assets/images/tech/flappy-bird-game-4.gif" alt="result"></p>
<p>需要说明的是，Game Over这个界面，首先需要隐藏或者等到游戏结束才创建。本人是选择在游戏判定结束时才创建并显示。</p>
<p>4、游戏运行<br>这款游戏的两个关键点：</p>
<ul>
<li>使用定时器驱动游戏界面运行，即游戏界面中的柱子高低变化与柱子的消失与产生。</li>
<li>游戏结束的判定，这里涉及两个问题，一是碰撞检测，二是计分统计。</li>
</ul>
<h1 id="具体实现部分代码"><a href="#具体实现部分代码" class="headerlink" title="具体实现部分代码"></a>具体实现部分代码</h1><p>1、计分统计</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(void)columnLabelClick &#123;    </span><br><span class="line">    if (topPipeFrame.origin.x == (100 + 30 - 70)) &#123;</span><br><span class="line">        columnNumber++;</span><br><span class="line">        columnLabel.text = [NSString stringWithFormat:@&quot;%zi&quot;,columnNumber];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、绘制柱子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(void)pipe &#123;</span><br><span class="line">    //通道高度</span><br><span class="line">    NSInteger tunnelHeight = 0;</span><br><span class="line">    //根据游戏难度设定通道高度</span><br><span class="line">    if([[DataTool stringForKey:kRateKey] isEqualToString:@&quot;ordinary&quot;]) &#123;</span><br><span class="line">        tunnelHeight = 100;</span><br><span class="line">    &#125;else if([[DataTool stringForKey:kRateKey] isEqualToString:@&quot;general&quot;]) &#123;</span><br><span class="line">        tunnelHeight = 90;</span><br><span class="line">    &#125;else if([[DataTool stringForKey:kRateKey] isEqualToString:@&quot;difficult&quot;]) &#123;</span><br><span class="line">        tunnelHeight = 80;</span><br><span class="line">    &#125;else if([[DataTool stringForKey:kRateKey] isEqualToString:@&quot;hard&quot;]) &#123;</span><br><span class="line">        tunnelHeight = 75;</span><br><span class="line">    &#125; else if([[DataTool stringForKey:kRateKey] isEqualToString:@&quot;crazy&quot;]) &#123;</span><br><span class="line">        tunnelHeight = 70;</span><br><span class="line">    &#125;    </span><br><span class="line">    //柱子图像</span><br><span class="line">    NSInteger tall = arc4random() % 200 + 40;</span><br><span class="line">    </span><br><span class="line">    topPipe = [[UIImageView alloc]initWithFrame:CGRectMake(320, -20, 70, tall)];</span><br><span class="line">    topPipe.image = [UIImage imageNamed:@&quot;pipe&quot;];</span><br><span class="line">    [self.view addSubview:topPipe];</span><br><span class="line"></span><br><span class="line">    bottomPipe = [[UIImageView alloc]initWithFrame:CGRectMake(320, tall + tunnelHeight, 70, 400)];</span><br><span class="line">    bottomPipe.image = [UIImage imageNamed:@&quot;pipe&quot;];</span><br><span class="line">    [self.view addSubview:bottomPipe];</span><br><span class="line">    //把底部图片视图放在柱子视图上面    </span><br><span class="line">    [self.view insertSubview:roadView aboveSubview:bottomPipe];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、使用定时器，驱动游戏界面运行，并进行碰撞检测</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//添加定时器</span><br><span class="line">timer = [NSTimer scheduledTimerWithTimeInterval:0.01 target:self selector:@selector(onTimer) userInfo:nil repeats:YES];</span><br><span class="line">//定时器操作</span><br><span class="line">-(void)onTimer &#123;</span><br><span class="line">    //底部动画移动</span><br><span class="line">    CGRect frame = roadView.frame;</span><br><span class="line">    if (frame.origin.x == -15) &#123;</span><br><span class="line">        frame.origin.x = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    frame.origin.x--;</span><br><span class="line">    roadView.frame = frame;    </span><br><span class="line">    //上升</span><br><span class="line">    if (isTap == NO) &#123;</span><br><span class="line">        CGRect frame = birdsView.frame;</span><br><span class="line">        frame.origin.y -= 3;</span><br><span class="line">        number += 3;</span><br><span class="line">        birdsView.frame = frame;</span><br><span class="line">        if (number &gt;= 60) &#123;</span><br><span class="line">            isTap = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    //下降</span><br><span class="line">    if(isTap == YES &amp;&amp; birdsView.frame.origin.y &lt; 370)&#123;</span><br><span class="line">        CGRect frame = birdsView.frame;</span><br><span class="line">        frame.origin.y++;</span><br><span class="line">        number -= 2;</span><br><span class="line">        birdsView.frame = frame;</span><br><span class="line">        number = 0;</span><br><span class="line">    &#125;    </span><br><span class="line">    //柱子移动</span><br><span class="line">    topPipeFrame = topPipe.frame;</span><br><span class="line">    CGRect bottomPipeFrame = bottomPipe.frame;</span><br><span class="line">    topPipeFrame.origin.x--;</span><br><span class="line">    bottomPipeFrame.origin.x--;</span><br><span class="line">    topPipe.frame = topPipeFrame;</span><br><span class="line">    bottomPipe.frame = bottomPipeFrame;</span><br><span class="line">    if (topPipeFrame.origin.x &lt; -70) &#123;</span><br><span class="line">        [self pipe];</span><br><span class="line">    &#125;    </span><br><span class="line">    //碰撞检测（交集）</span><br><span class="line">    bool topRet = CGRectIntersectsRect(birdsView.frame, topPipe.frame);</span><br><span class="line">    bool bottomRet = CGRectIntersectsRect(birdsView.frame, bottomPipe.frame);</span><br><span class="line">    if (topRet == true || bottomRet == true) &#123;</span><br><span class="line">        [self.soundTool playSoundByFileName:@&quot;punch&quot;];</span><br><span class="line">        [self onStop];</span><br><span class="line">    &#125;</span><br><span class="line">    if (topPipeFrame.origin.x == (100 + 30 - 70)) &#123;</span><br><span class="line">        [self.soundTool playSoundByFileName:@&quot;pipe&quot;];</span><br><span class="line">        [self columnLabelClick];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、更新分数，更新最佳分数与排行榜分数，并使用归档将数据持久化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(void)updateScore &#123;</span><br><span class="line">    //更新最佳成绩</span><br><span class="line">    if (columnNumber &gt; [DataTool integerForKey:kBestScoreKey]) &#123;</span><br><span class="line">        [DataTool setInteger:columnNumber forKey:kBestScoreKey];</span><br><span class="line">    &#125;</span><br><span class="line">    //更新本局分数    </span><br><span class="line">    [DataTool setInteger:columnNumber forKey:kCurrentScoreKey];</span><br><span class="line">    //更新排行榜</span><br><span class="line">    NSArray *ranks = (NSArray *)[DataTool objectForKey:kRankKey];</span><br><span class="line">    NSMutableArray *newRanksM = [NSMutableArray array];</span><br><span class="line">    NSInteger count = ranks.count;</span><br><span class="line">    BOOL isUpdate = NO;</span><br><span class="line">    for (NSInteger i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        NSString *scoreStr = ranks[i];</span><br><span class="line">        NSInteger score = [scoreStr integerValue];</span><br><span class="line">        if (score &lt; columnNumber &amp;&amp; isUpdate == NO) &#123;</span><br><span class="line">            scoreStr = [NSString stringWithFormat:@&quot;%zi&quot;, columnNumber];</span><br><span class="line">            [newRanksM addObject:scoreStr];</span><br><span class="line">            isUpdate = YES;</span><br><span class="line">            i--;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            scoreStr = [NSString stringWithFormat:@&quot;%zi&quot;, score];</span><br><span class="line">            [newRanksM addObject:scoreStr];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (newRanksM.count &gt; count) &#123;</span><br><span class="line">        [newRanksM removeLastObject];</span><br><span class="line">    &#125;</span><br><span class="line">    [DataTool setObject:newRanksM forKey:kRankKey];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、绘制GameOver提示显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(void)pullGameOver &#123;</span><br><span class="line">    //游戏结束操作界面</span><br><span class="line">    gameOver = [[GameOverView alloc] initWithFrame:CGRectMake(20, 160, 280, 300)];</span><br><span class="line">    gameOver.delegate = self;</span><br><span class="line">    [self.view addSubview:gameOver];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、游戏停止操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(void)onStop &#123;</span><br><span class="line">    //更新分数    </span><br><span class="line">    [self updateScore];</span><br><span class="line">    //停止定时器    </span><br><span class="line">    [timer setFireDate:[NSDate distantFuture]];</span><br><span class="line">    //弹出游戏结束操作界面    </span><br><span class="line">    [self pullGameOver];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这款游戏的实现还是很简单的，主要使用UIImageView自带的动画实现方式，即可实现bird的动画效果。使用NSTimer即可实现游戏场景的柱子移动，至于柱子的高度，则可以使用随机数方式在一定范围内实现高低变化。最后可以使用CGRectIntersectsRect来实现边界碰撞检测来判定游戏是否结束。</p>
<p>以上是博主开发iOS版flappyBird的简要过程介绍，其中只包含了关键点的代码实现，具体完整游戏源代码地址：<a href="https://github.com/CharsDavy/flappyBird">https://github.com/CharsDavy/flappyBird</a></p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>application</tag>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>GCD（Grand Central Dispatch）</title>
    <url>/2016-04-14-grand-central-dispatch/</url>
    <content><![CDATA[<p>GCD（Grand Central Dispatch），是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如NSThread,NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术。文章分享关于GCD的种种概念以及使用。</p>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>GCD（Grand Central Dispatch），是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如NSThread,NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术。</p>
<p>GCD 和 block 的配合使用，可以方便地进行多线程编程。</p>
<h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><p>1）  苹果官方为多核的并行运算提出的解决方案。</p>
<p>2）  会自动利用更多的CPU内核。</p>
<p>3）  会自动管理线程的生命周期（创建线程、调度任务、销毁线程）。
 </p>
<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><p>1）  任务：执行什么操作。block</p>
<p>2）  队列：用来存放任务。</p>
<p>串行队列：顺序，一个一个执行。一个任务执行完毕后才执行下一个任务。</p>
<p>并发队列：同时，同时执行很多个任务。自动开启多个线程同时执行任务。并发功能只有在异步函数下才生效。
 </p>
<h1 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h1><p>1）  定制任务</p>
<p>确定想要做的事情。</p>
<p>2）  将任务添加到队列中</p>
<p>GCD会自动将队列中的任务取出，放到对应的线程中执行。</p>
<p>任务的取出原则遵循队列的原则：先进先出，后进后出。
 </p>
<h1 id="执行任务的函数"><a href="#执行任务的函数" class="headerlink" title="执行任务的函数"></a>执行任务的函数</h1><p>1）同步方式　　</p>
<p>dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</p>
<p>queue:队列</p>
<p>block:任务</p>
<p>2）异步方式</p>
<p>dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</p>
<p>queue:队列</p>
<p>block:任务</p>
<p><strong>同步和异步的区别：</strong></p>
<p>同步：在当前线程中执行。</p>
<p>异步：在另一条线程中执行。</p>
<p><strong>同步任务的作用：</strong></p>
<p>1）  用户登录</p>
<p>2）  下载任务1</p>
<p>3）  下载任务2
 </p>
<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>1）  同步和异步决定了是否要开辟新线程。</p>
<p>同步：在当前线程中执行任务，不具备开启新线程的能力。</p>
<p>异步：在新的线程中执行任务，具备开启新线程的能力。</p>
<p>2）  并发和串行决定了任务执行的方式。</p>
<p>并发：多个任务同时执行。</p>
<p>串行：一个任务执行完毕后，再执行下一个任务。
 </p>
<h1 id="代码使用"><a href="#代码使用" class="headerlink" title="代码使用"></a>代码使用</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*串行队列*/</span><br><span class="line">/*创建队列</span><br><span class="line">参数：1.队列标签。 2.队列属性。</span><br><span class="line">*/</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(”dengw”,DISPATCH_QUEUE_SERIAL);</span><br><span class="line">/*同步执行任务，不会开辟新线程，在当前线程中顺序执行。</span><br><span class="line">一般只要使用“同步”执行，串行队列对添加的同步任务，立马执行*/</span><br><span class="line">dispatch_sync(queue, ^&#123;</span><br><span class="line">    NSLog(@”%@”, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">/*异步执行任务，开辟新线程，在新线程中执行。开辟新线程的数量与队列模式有关。串行队列中异步执行只会开启一个新线程。*/</span><br><span class="line">for(int I = 0; I &lt; 10; I++)&#123;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@”%@”, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">　　</span><br><span class="line">/*并发队列：需要程序员释放。*/</span><br><span class="line">/*创建队列</span><br><span class="line">参数：1.队列标签。 2.队列属性。</span><br><span class="line">*/</span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(”dengw”,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">/*异步执行任务，开辟新线程，在新线程中执行。开辟新线程的数量程序员无法控制。*/</span><br><span class="line">for(int I = 0; I &lt; 10; I++)&#123;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@”%@”, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">/*同步执行任务，不开辟新线程，顺序执行*/</span><br><span class="line">for(int I = 0; I &lt; 10; I++)&#123;</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@”%@”, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*主队列，专门负责在主线程上调度任务。程序启动以后至少有一个主线程，则会创建主队列。*/</span><br><span class="line">/*主队列不允许开辟新线程。不会在子线程调度任务。*/</span><br><span class="line">/*获得主队列*/</span><br><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">/*异步执行任务，在主队列中，只能顺序执行。*/</span><br><span class="line">for(int I = 0; I &lt; 10; I++)&#123;</span><br><span class="line">/*异步：把任务放到主队列中，但不需要马上执行。*/</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@”%@”, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">/*同步执行任务*/</span><br><span class="line">for(int I = 0; I &lt; 10; I++)&#123;</span><br><span class="line">/*同步：把任务放到主队列中，需要马上执行。*/</span><br><span class="line">/*阻塞*/</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@”%@”, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*全局队列：本质是并发队列。</span><br><span class="line">与并发队列的区别：</span><br><span class="line">1）全局队列没有名字，而并发队列有名字。</span><br><span class="line">2）全局队列，是供所有的应用程序使用。</span><br><span class="line">3）在MRC中，全局队列不需要释放，并发队列需要释放。*/</span><br><span class="line">/*获得全局队列</span><br><span class="line">参数：</span><br><span class="line">参数1</span><br><span class="line">iOS7中</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_HEGH    2 高优先级</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_DEFAULT  0 默认优先级</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_LOW   (-2) 低优先级</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_BACKGROUND    INT16_MIN 后台优先级（最低）</span><br><span class="line">iOS8中</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_HEGH:QOS_CLASS_USER_INITIATED</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_DEFAULT:QOS_CLASS_USER_DEFAULT</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_LOW:QOS_CLASS_USER_UTILITY</span><br><span class="line">DISPATCH_QUEUE_PRIORITY_BACKGROUND: QOS_CLASS_USER_BACKGROUND</span><br><span class="line">参数2</span><br><span class="line">保留参数。*/</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(QOS_CLASS_USER_DEFAULT,0);</span><br><span class="line">/*异步执行任务*/</span><br><span class="line">for(int I = 0; I &lt; 10; I++)&#123;</span><br><span class="line">    dispatch_async(queue, ^&#123;</span><br><span class="line">        NSLog(@”%@”, [NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="各队列的执行效果"><a href="#各队列的执行效果" class="headerlink" title="各队列的执行效果"></a>各队列的执行效果</h1><p> </p>
<p>| | 全局并行队列 | 手动创建串行队列 | 主队列 |<br>| — | — | — |<br>| 同步（sync） | 没有开启新线程。串行执行任务。| 没有开启新线程。串行执行任务。 | 会死锁 |<br>| 异步（async）| 有开启新线程。并行执行任务。| 有开启新线程。串行执行任务。| 没有开启新线程。串行执行任务。|
 </p>
<h1 id="队列的选择"><a href="#队列的选择" class="headerlink" title="队列的选择"></a>队列的选择</h1><p>1）串行队列异步执行</p>
<p>开一条线程，顺序执行。</p>
<p>效率不高，执行比较慢，资源占用小，省电。</p>
<p>应用场景：一般3G网络，对性能要求不高。</p>
<p>2）并发队列异步执行</p>
<p>开启多条线程，并发执行。</p>
<p>效率高，执行快，资源消耗大，费电。</p>
<p>应用场景：WIFI网络，或需要快速响应，用户体验要求高，对任务执行顺序没有要求。</p>
<p>3）  同步任务</p>
<p>一般只会在并发队列，需要阻塞后续任务，必须等待同步任务执行完毕，再去执行其他任务。“依赖关系” 
 </p>
<h1 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*从子线程回到主线程*/</span><br><span class="line">dispatch_async(</span><br><span class="line">    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    //执行耗时的异步操作…</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    //回到主线程，执行UI刷新操作</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> </p>
<h1 id="延时操作"><a href="#延时操作" class="headerlink" title="延时操作"></a>延时操作</h1><p>1）方式一，调用NSObject的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//2秒后再调用run方法</span><br><span class="line">[self performSelector:@selector(run) withObject:nil afterDelay:2.0];</span><br></pre></td></tr></table></figure>

<p>2）方式二，使用GCD函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)),dispatch_get_main_queue(), ^&#123;    </span><br><span class="line">    //2秒后再异步执行这里的代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> </p>
<h1 id="调度组（分组）"><a href="#调度组（分组）" class="headerlink" title="调度组（分组）"></a>调度组（分组）</h1><p>应用场景：开发的时候，有的时候出现多个网络请求（每一个网络请求时间长短不一），都完成以后统一更新UI或通知用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*实例化一个调度组*/</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line">//队列</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">//将任务添加到队列</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    NSLog(@”A %@”, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    NSLog(@”B %@”, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">//获得所有调度组里面的异步任务完成的通知</span><br><span class="line">/*在调度组完成通知里，可以跨队列通信*/</span><br><span class="line">dispatch_group_notifity(group, queue, ^&#123;</span><br><span class="line">    //异步的</span><br><span class="line">    NSLog(@”finished”);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p> </p>
<h1 id="一次性执行"><a href="#一次性执行" class="headerlink" title="一次性执行"></a>一次性执行</h1><p>常见于单例模型中代码使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    //只执行一次</span><br><span class="line">    NSLog(@”hi”);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub 使用</title>
    <url>/2016-05-20-github-using/</url>
    <content><![CDATA[<p>GitHub就是程序员的facebook，在这个开源、大神云集的地方，小菜是可以学到，找到很多很棒的资源的。那么，如何进入这个圈子呢？我们从使用开始。这篇文章主要讲解如何使用GitHub托管自己的代码，注意，托管是公开的喔，私有的要付费的。</p>
<span id="more"></span>

<h1 id="下载github客户端软件"><a href="#下载github客户端软件" class="headerlink" title="下载github客户端软件"></a>下载github客户端软件</h1><ol>
<li>官网<a href="https://help.github.com/">下载</a></li>
<li>Google搜索，一般用于windows7以前的系统</li>
</ol>
<h1 id="安装github软件"><a href="#安装github软件" class="headerlink" title="安装github软件"></a>安装github软件</h1><p>根据软件安装指导，按步骤安装即可。</p>
<h1 id="使用git命令提交"><a href="#使用git命令提交" class="headerlink" title="使用git命令提交"></a>使用git命令提交</h1><h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>安装Git后首先要做的事情是设置用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Chars Davy&quot;</span><br><span class="line">git config --global user.email chars_d@example.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重申一遍，只需要做一次这个设置。如果传递了 <code>--global</code> 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要<code>--global</code>选项。</p>
<p><strong>注意：</strong></p>
<p>默认git对大小写是不敏感的，可以通过命令关掉其配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config core.ignorecase false</span><br></pre></td></tr></table></figure>

<h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p>这是一种较为简单的初始化方式，当你已经有一个远程的Git版本库，只需要在本地克隆一份:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git  clone  git://github.com/someone/some_project.git   some_project </span><br></pre></td></tr></table></figure>

<p>上面的命令就是将<code>git://github.com/someone/some_project.git</code>这个URL地址的远程版本库，完全克隆到本地some_project目录下。</p>
<h2 id="git-init-和-git-remote"><a href="#git-init-和-git-remote" class="headerlink" title="git init 和 git remote"></a>git init 和 git remote</h2><p>这种方式稍微复杂一些，当你本地创建了一个工作目录，你可以进入这个目录，使用<code>git init</code>命令进行初始化；Git以后就会对该目录下的文件进行版本控制，这时候如果你需要将它放到远程服务器上，可以在远程服务器上创建一个目录，并把可访问的URL记录下来，此时你就可以利用<code>git remote add</code>命令来增加一个远程服务器端，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git  remote  add  origin  git://github.com/someone/another_project.git</span><br></pre></td></tr></table></figure>

<p>上面的命令就会增加URL地址为<code>git: //github.com/someone/another_project.git</code>，名称为origin的远程服务器，以后提交代码的时候只需要使用 origin别名即可。</p>
<h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p>将当前更改或者新增的文件加入到Git的索引中，加入到Git的索引中就表示记入了版本历史中，这也是提交之前所需要执行的一步，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add app/model/user.rb</span><br></pre></td></tr></table></figure>

<p>就会增加<code>app/model/user.rb</code>文件到Git的索引中，该功能类似于SVN的add，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>上面的命令会将所有改动过的文件及文件夹迭代全部添加进本地代码仓库。</p>
<h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p>提交当前工作空间的修改内容，类似于SVN的commit命令，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m story #3, add user model</span><br></pre></td></tr></table></figure>

<p>提交的时候必须用-m来输入一条提交信息，该功能类似于SVN的commit，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit –m beta</span><br></pre></td></tr></table></figure>

<p>上面的命令会将beta作为log显示在代码提交记录中。</p>
<h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>将本地commit的代码更新到远程版本库中，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin</span><br></pre></td></tr></table></figure>

<p>上面的命令就会将本地的代码更新到名为orgin的远程版本库中。</p>
<h1 id="git代码提交中可能遇到的问题"><a href="#git代码提交中可能遇到的问题" class="headerlink" title="git代码提交中可能遇到的问题"></a>git代码提交中可能遇到的问题</h1><p>问题1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You can&#x27;t push to git://github.com/example/example_pro.git</span><br><span class="line">Use https://github.com/ example/example_pro.git</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote remove origin</span><br><span class="line">git remote add origin git@github.com:user_name/user_repo.git</span><br><span class="line">git push origin</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<p>如果在<code>git clone</code>的时候用的是<code>git://github.com:xx/xxx.git</code> 的形式, 那么就会出现这个问题，因为这个protocol是不支持push的，而使用<code>git clone git@github.com:lujinjianst/myNCCL.git</code>就可以用git push。</p>
<p>问题2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Permission denied(publickey).</span><br><span class="line">fatal:Could not read from remote repository.</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<p>在终端输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;chars&quot;//注意,chars为用户名</span><br></pre></td></tr></table></figure>

<p>如果执行成功。返回:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Generating public/private rsa key pair. </span><br><span class="line">Enter file in which to save the key (/home/forwhat.cn/.ssh/id_rsa): </span><br></pre></td></tr></table></figure>

<p>在这里就是设置存储地址了.反正我是直接按的回车,然后还会返回:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):</span><br></pre></td></tr></table></figure>

<p>再次直接回车。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure>

<p>再次回车。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your identification has been saved in /home/forwhat.cn/.ssh/id_rsa. </span><br><span class="line">Your public key has been saved in /home/forwhat.cn/.ssh/id_rsa.pub. </span><br><span class="line">The key fingerprint is:</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The key&#x27;s randomart image is: </span><br><span class="line">+--[ RSA 2048]----+ </span><br><span class="line">|                 | </span><br><span class="line">|                 | </span><br><span class="line">|                 | </span><br><span class="line">|    o            | </span><br><span class="line">|   + .  S        | </span><br><span class="line">|  . = .  o       | </span><br><span class="line">|   o + +o.o      | </span><br><span class="line">|E o . o.=+.      | </span><br><span class="line">|.+   ==+ooo.     | </span><br><span class="line">+-----------------+ </span><br></pre></td></tr></table></figure>
<p>这样SSH key就生成了。直接cat一下就好了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:~/a$ cat /home/forwhat.cn/.ssh/id_rsa.pub </span><br></pre></td></tr></table></figure>
<p>把显示出来的直接添加到github账户设置里边的SSH keys。<br>回来再git pull就开始远程拷贝代码了。</p>
<p>原因：</p>
<p>没有在github账号添加SSH key。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 并发概念浅析</title>
    <url>/2016-05-26-ios-simultaneously/</url>
    <content><![CDATA[<p>并发（concurrency）是一个常用且较好的解决APP的流畅度方法，但并发涉及串行、并发、并行、同步、异步、多线程、GCD、NSOperation和NSOperationQueue等诸多容易混淆的概念。本文主要分享对一些易混淆概念的理解。</p>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在进行iOS开发过程中，我们常会遇到网络请求、复杂计算、数据存取等比较耗时的操作，如果处理不合理，将对APP的流畅度产生较大影响。除了优化APP架构，并发（concurrency）是一个常用且较好的解决方法，但并发涉及串行、并发、并行、同步、异步、多线程、GCD、NSOperation和NSOperationQueue等诸多容易混淆的概念。接下来，主要分享对一些易混淆概念的理解。</p>
<h1 id="一、线程和任务"><a href="#一、线程和任务" class="headerlink" title="一、线程和任务"></a>一、线程和任务</h1><p>线程（thread） 和任务（task）是其他并发概念的基础，因此也是首要需理清的概念，以下是其要点，详细可参考<a href="https://en.wikipedia.org/wiki/Thread_%28computing%29">Thread (computing)</a>和<a href="https://en.wikipedia.org/wiki/Task_%28computing">Task (computing)</a>。</p>
<h2 id="1）任务（task）"><a href="#1）任务（task）" class="headerlink" title="1）任务（task）"></a>1）任务（task）</h2><p>a）任务（task）是从程序中划分出来，可以独立执行的代码片段；</p>
<p>b）任务间可以添加依赖关系，如B任务依赖A任务，taskB.addDependency(taskA)，这意味着B任务的执行以A任务完成为前提。</p>
<p>需要注意的是一个任务是否可以添加依赖，完全取决于任务封装类和其相关管理类的具体实现，GCD不支持任务依赖，NSOperationQueue就支持任务依赖。</p>
<p>下面的代码是对一个任务的简单封装，并支持任务间的依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Task是一个任务的简单封装类</span><br><span class="line">class Task &#123;</span><br><span class="line">    let taskBlock: () -&gt; ()</span><br><span class="line">    var dependencies = [Task]() </span><br><span class="line">    init(block: () -&gt; ()) &#123;</span><br><span class="line">        taskBlock = block</span><br><span class="line">    &#125; </span><br><span class="line">    func addDependency(task: Task) &#123;</span><br><span class="line">        dependencies.append(task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//初始化两个自定义任务</span><br><span class="line">var taskA = Task()&#123;</span><br><span class="line">    //自定义任务A，自定义需要执行的代码</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line">var taskB = Task()&#123;</span><br><span class="line">    //自定义任务B，自定义需要执行的代码</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line">//添加依赖关系</span><br><span class="line">taskB.addDependency(taskA)</span><br></pre></td></tr></table></figure>


<h2 id="2）线程（thread）"><a href="#2）线程（thread）" class="headerlink" title="2）线程（thread）"></a>2）线程（thread）</h2><p>a）线程（thread）是代码执行的独立路径，一条线程只能同时执行一行代码（一行代码，其实就是一条处理器命令）。</p>
<p>b）线程中代码管理是以任务（task）为单位，一条线程逐行执行一个任务中的代码（任务可以取消），完成后再逐行执行下一个任务中的代码。</p>
<p>c）一条线程跳出一个任务的执行，即意味着这个任务的完成。因此，一条线程不能执行taskA一段时间后，还未完成就开始执行taskB，然后又返回执行taskA（这其实是单线程内的并发，与单核处理器的并发概念相同，具体实践中不存在线程内并发）。</p>
<h1 id="二、概念释疑"><a href="#二、概念释疑" class="headerlink" title="二、概念释疑"></a>二、概念释疑</h1><h2 id="1）并行（parallelism）和并发（concurrency）"><a href="#1）并行（parallelism）和并发（concurrency）" class="headerlink" title="1）并行（parallelism）和并发（concurrency）"></a>1）并行（parallelism）和并发（concurrency）</h2><p>并发和并行都是指多个任务可以同时执行，都属于多线程编程概念，因此二者必然十分相近，容易混淆。二者区别只有一点，即是否多任务执行于严格的同一时刻。并发不是，而并行是。</p>
<p>单核处理器时代（一个处理器同一时刻只能执行一条命令），为了实现多任务的同时执行，系统利用时间分片（time-slicing）技术，将处理器的执行时间切分为多个小片段，一会执行threadA，一会执行threadB，一会再执行threadA，即在多个线程（任务是在线程上执行的）之间来回跳动执行。虽不是真的多线程多任务同时执行，但由于处理器的处理速度非常快，在用户看来，仍然是同时执行的。这种伪多线程就是并发。</p>
<p>多核处理器时代（不同处理器相互独立，可以同时执行各自的命令），多条线程完全可以严格同一时刻执行，这种真多线程就是并行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//三个线程的并发</span><br><span class="line">thread1 -&gt; |---A---|             -&gt;|---A---|</span><br><span class="line">thread2 ------&gt;    -&gt;|------B----|</span><br><span class="line">thread3 ------------------------------------&gt; |------C------|</span><br></pre></td></tr></table></figure>
<p>上述代码是三个线程的并发执行，可以看出thread1、thread2和thread3不可能严格同一时刻执行，但也都获得了处理器的一小段执行时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//三个线程的并行</span><br><span class="line">thread1 -&gt; |-----A-----|</span><br><span class="line">thread2 -&gt;       |------B----|</span><br><span class="line">thread3 -&gt;     |------C------|</span><br></pre></td></tr></table></figure>
<p>上述代码是三个线程的并行执行，可以看出thread1、thread2和thread3有一段时间同时执行。</p>
<p>现在的终端设备无论是手机还是PC的处理器，大多都已是多核处理器，可以实现并行计算，但为了最大化的利用处理器的性能，现代处理器还是融合了time-slicing技术和多核技术，因此实际运行中，有时并发，有时并行。但相对来说，并发是个更广泛的概念，因此Apple的多线程编程叫做concurrency programming并发编程。汉语中，并发和并行的区别其实没那么清晰，可以互用，而且有时用并行更加明确，如串并行比串行、并发针对性更强。（为概念清晰起见，下文中有时会用并行，其实即是并发。）</p>
<h2 id="2）串并行与线程"><a href="#2）串并行与线程" class="headerlink" title="2）串并行与线程"></a>2）串并行与线程</h2><h3 id="串行（serial）和并行"><a href="#串行（serial）和并行" class="headerlink" title="串行（serial）和并行"></a>串行（serial）和并行</h3><p>串行和并行主要区别在于一个任务的执行是否以上一个任务的完成为前提。串行中，一个任务的执行必须以上一个任务执行结束为前提；并行中，一个任务的执行与上一个任务的执行状态无关。以排队买票为例，串行像单个买票队伍，单个卖票窗口，必须一个一个来；串行像单个买票队伍，多个卖票窗口，多个人可以同时买票。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//三个串行任务</span><br><span class="line">|-----A-----||------B--------||----C--|</span><br></pre></td></tr></table></figure>
<p>上文为三个串行任务，任务A完成后，才执行任务B，B结束后，才最后执行任务C。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//三个并发任务</span><br><span class="line">|-----A-----|</span><br><span class="line">      |------B----|</span><br><span class="line">   |--C---|</span><br></pre></td></tr></table></figure>
<p>上文为三个并行任务，任务A早于任务C开始，却晚于任务C结束。</p>
<h3 id="串并行与线程"><a href="#串并行与线程" class="headerlink" title="串并行与线程"></a>串并行与线程</h3><p>串并行主要关注多个任务之间的相互依赖关系，与线程无关。但实际中，任务是在线程中执行的，是否串行一定在单线程上执行，并行一定在多个线程中执行呢？并非如此。</p>
<p>单线程既可以实现串行，也可以实现并行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//单线程串行</span><br><span class="line">1 thread -&gt;   |----A-----||-----B-----------||-------C------|</span><br><span class="line">//单线程并行（理论上，实际中不可行）</span><br><span class="line">         A-Start ---------------------------------------- A-End  </span><br><span class="line">           | B-Start ----------------------------------------|--- B-End  </span><br><span class="line">           |   |     C-Start -------------------- C-End      |     |  </span><br><span class="line">           V   V       V                           V         V     V      </span><br><span class="line">1 thread-&gt; |-A-|---B---|-C-|-A-|-C-|--A--|-B-|--C--|---A-----|--B--|</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要指出的是单线程内的并行已经类似单核处理器，并不是本文提及的常规线程，现实中也不常见。</p>
<p>多线程既可以实现串行，也可以实现并行，实际上，多线程串行和并行都很常见。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//多线程串行</span><br><span class="line">thread1 -&gt; |----A-----|  </span><br><span class="line">                       \  </span><br><span class="line">thread2 ---------------&gt;|-----B-----------|  </span><br><span class="line">                                           \  </span><br><span class="line">thread3 -----------------------------------&gt;|-------C------|</span><br><span class="line">//多线程并发</span><br><span class="line">thread1 -&gt;     |----A-----|</span><br><span class="line">thread2 -----&gt;     |-----B-----------|</span><br><span class="line">thread3 ---------&gt;     |-------C----------|</span><br></pre></td></tr></table></figure>

<h2 id="3）同步（synchronize）、异步（asynchronous）与线程"><a href="#3）同步（synchronize）、异步（asynchronous）与线程" class="headerlink" title="3）同步（synchronize）、异步（asynchronous）与线程"></a>3）同步（synchronize）、异步（asynchronous）与线程</h2><p>同步和异步是站在当前线程的角度，考察添加任务到新线程后，何时返回到当前线程执行下面的代码的问题，也即新添加的线程阻不阻塞当前线程。</p>
<ul>
<li>同步</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">override viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span><br><span class="line">    dispatch_sync(queue) &#123;</span><br><span class="line">        //block1</span><br><span class="line">        print(&quot;-----1-----&quot;) //1</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;-----2-----&quot;) //2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>block1是添加到系统全局队列中的新任务，由于是同步的，因此block1执行返回后，才会回到当前主线程，执行&#x2F;&#x2F;2及以后的代码。输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----1-----</span><br><span class="line">-----2-----</span><br></pre></td></tr></table></figure>

<ul>
<li>异步</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//viewDidLoad()在主线程中执行，因此当前线程为主线程</span><br><span class="line">override viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span><br><span class="line">    dispatch_async(queue) &#123;</span><br><span class="line">        //block1</span><br><span class="line">        print(&quot;-----1-----&quot;) //1</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;-----2-----&quot;) //2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>block1是添加到系统全局队列中的新任务，由于是异步的，因此block1添加全局队列后（会在另外一个线程上执行），不等到执行完成，就会返回到当前主线程，执行&#x2F;&#x2F;2及以后的代码，所以输出结果可能为 21 12。但由于block1和主线程中的任务都是不耗时的简单任务，而创建新的线程是要消耗一定时间的（主线程一直存在，不用新创建），因此很可能的输出结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----2-----</span><br><span class="line">-----1-----</span><br></pre></td></tr></table></figure>
<ul>
<li>同异步结合的情形</li>
</ul>
<p>如果同异步结合:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//viewDidLoad()在主线程中执行，因此当前线程为主线程</span><br><span class="line">override viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span><br><span class="line">    dispatch_async(queue) &#123;</span><br><span class="line">        //block1</span><br><span class="line">        print(&quot;-----A-----&quot;) //1</span><br><span class="line">        dispatch_async(dispatch_get_main_queue()) &#123;</span><br><span class="line">            //block2</span><br><span class="line">            print(&quot;-----B-----&quot;) //2</span><br><span class="line">        &#125;</span><br><span class="line">        print(&quot;-----C-----&quot;) //3</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;-----D-----&quot;) //4</span><br><span class="line">    while(true) &#123; &#125; //5</span><br><span class="line">    print(&quot;-----E-----&quot;) //6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>block1是添加到系统全局队列中的新任务，由于是异步的，因此block1添加全局队列后（会在另外一个线程上执行），不等到执行完成，就返回到当前主线程，执行&#x2F;&#x2F;4及以后的代码，结果是block1所在的线程与主线程同时执行，因此理论上，D和A谁先输出不一定。但由于block1和主线程中的任务都是不耗时的简单任务，而创建新的线程是要消耗一定时间的（主线程一直存在，不用新创建），因此一般输出结果为DA。</p>
<p>block1所在线程输出完A后，将block2添加到主调度队列中，由于是异步的，因此block2添加主调度队列后（会在主线程上执行），不等到执行完成，就返回到block2所在的线程，继续执行，因此A和C一定会输出，且C一定在A之后输出。但block2却不一定能执行，因为block1在执行时，主线程也在执行（主线程是串行单线程，任务按顺序一个一个执行），如果此时主线程执行到&#x2F;&#x2F;5对应的死循环，则block2一定不能被执行，B一定不能被输出，如果此时主线程尚未执行到&#x2F;&#x2F;5对应的死循环，block2已经添加到主线程中，则block2会被执行，B能被输出。但由于主线程无需另外创建，block1（所对应的线程需另外创建）执行到添加block2到主调度队列时，主线程很可能已经执行到&#x2F;&#x2F;5对应的死循环，因此block2很可能不被执行。</p>
<p>&#x2F;&#x2F;6前有个死循环，因此E一定不会被输出。</p>
<p>因此可能的输出结果是；DAC ADC ADCB DACB ACDB ACBD ABDC ABCD</p>
<p>但很可能的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----D-----</span><br><span class="line">-----A-----</span><br><span class="line">-----C-----</span><br></pre></td></tr></table></figure>


<h2 id="4）同异步与串并行"><a href="#4）同异步与串并行" class="headerlink" title="4）同异步与串并行"></a>4）同异步与串并行</h2><p>串行和同步，并行和异步似是完全不同的概念，一个关注任务的独立关系，一个看中的是返回的时机。但事实上，串行和同步近似，并发和异步相同，他们指代的事情几乎完全相同。<br>就同步和串行而言，需要任务执行结束后才能返回，其实就是一个任务执行完成后，才能执行其他的任务，反应的就是串行依赖关系。</p>
<p>而异步和并行就更相同了，不等任务执行完成，就直接返回，反应的就是并发任务之间的独立性。</p>
<p>当然，同异步所暗含的串行和并行是当前线程的任务与新线程的任务之间的相互关系。</p>
<h1 id="三、GCD与NSOperationQueue"><a href="#三、GCD与NSOperationQueue" class="headerlink" title="三、GCD与NSOperationQueue"></a>三、GCD与NSOperationQueue</h1><p>GCD(grand central dispatch)和NSOperationQueue二者均是系统级的多线程封装，在使用时，我们只需创建任务队列即可，其他的如线程创立、任务分配等，均由系统自动处理。不得不说，这让多线程编程变得更高效，更简单，当然并不是没有坑。<br>需要强调的是，GCD和NSOperationQueue的使用核心是任务（task）和任务队列（task queue），暂时可以忘了线程（thread）这烦人的概念。</p>
<p>关于GCD和NSOperationQueue网上已经有不少高质量的文章对其详细介绍，推荐<a href="http://www.cocoachina.com/ios/20160201/15179.html">《iOS并行开发：从NSOperation和调度队列开始》</a>，其对基本概念、使用方法等的介绍非常清晰详尽，这里就不再赘述，只写一些个人认为容易忽略却影响认知深度的小知识点。当然如果你英语过硬，去直接看官方文档<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html">《ConcurrencyProgrammingGuide》</a>是最好的。</p>
<h2 id="1）GCD"><a href="#1）GCD" class="headerlink" title="1）GCD"></a>1）GCD</h2><p>GCD是基于C的API，因此比较底层。</p>
<p>GCD所管理的调度队列（dispatch queue）主要有三类：串行队列（private dispatch queue）、并发队列 （global dispatch queue，又称全局调度队列）和主队列（main dispatch queue）。</p>
<p>我们常用的 dispatch_get_global_queue(_: _:)所获得的dispatch queue就是全局调度队列(global dispatch queue)，并发，而且全局调度队列是全局共用的，每一个优先级的全局调度队列只有一个实体。四种不同优先级的全局调度队列对应的四种优先级的线程，同一个优先级的全局调度队列可以同时拥有多条相应优先级的线程。</p>
<p>dispatch_get_main_queue()所获得的dispatch queue是主调度队列，主调度队列是串行队列。</p>
<h2 id="2）NSOperationQueue"><a href="#2）NSOperationQueue" class="headerlink" title="2）NSOperationQueue"></a>2）NSOperationQueue</h2><p>NSOperationQueue是对GCD的Objective-C封装，相对于GCD具有更多先进的特性，如可以添加NSOperation依赖，取消NSOperation等。</p>
<p>NSOperationQueue是并发队列，且不遵循先进先出（FIFO）排序原则。</p>
<h1 id="四、总结与感悟"><a href="#四、总结与感悟" class="headerlink" title="四、总结与感悟"></a>四、总结与感悟</h1><p>1）串并行、同异步与线程无关，单线程、多线程都可以实现串并行和同异步。</p>
<p>2）串行和同步相同，异步和并行相同，他们只是看待同一件事物的角度不同。</p>
<p>3）GCD和NSOperationQueue的使用核心是任务（task）和任务队列（task queue）。</p>
<p>4）全局调度队列(global dispatch queue)是全局共用的，系统有时也会向这些调度队列添加系统任务。</p>
<ol start="5">
<li>App的主调度队列是串行单线程队列。</li>
</ol>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手教 GitHub + Hexo 搭建博客</title>
    <url>/2016-05-31-build-blog-by-hexo/</url>
    <content><![CDATA[<p>本文章主要介绍使用hexo框架搭建博客，使用GitHub免费托管自己的博客代码，并使用GitHub Pages提供的免费服务。换句话说，就是使用免费资源搭建属于自己的博客网站。</p>
<span id="more"></span>


<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在很久以前，博主就想着要有自主的博客专栏或者网站。经历了博客园这个需要所谓的编辑审核，一直比较困惑，这些编辑是什么出身，怎么知道技术博客的价值性。</p>
<p>接下来找到了开源中国，这个可以自由发言的地方。不过，不知道是不是受众面不广，访问量都不是很理想。</p>
<p>再然后就来自己动手开始搭建博客。从手写html发布文章，到使用jekyll，最后到了hexo阵营。</p>
<p>终于，有种找到家的赶脚。hexo不仅搭建方便，而且在后续的功能扩展以及文章发布都是非常方便的。不仅如此，还可以本地调试，预览效果。最方便的是支持markdown编写文档。</p>
<p>本文就是介绍如何安装使用hexo搭建属于自己的博客。从此不再担心投稿被莫名拒绝。可以在自己的一亩三分地讲述着自己的故事。</p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>MAC OS X 是自带Git命令行工具。</p>
<p>Windows 可以安装Git Bash。</p>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>前往<a href="https://nodejs.org/en/">官网地址</a>，根据教程安装即可。</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<h1 id="使用hexo"><a href="#使用hexo" class="headerlink" title="使用hexo"></a>使用hexo</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建hexo文件夹</span><br><span class="line">$ mkdir hexo</span><br><span class="line"></span><br><span class="line"># 进入hexo文件夹</span><br><span class="line">$ cd hexo</span><br><span class="line"></span><br><span class="line"># 初始化hexo</span><br><span class="line">$ hexo init</span><br><span class="line"></span><br><span class="line"># 安装依赖包</span><br><span class="line">$ npm install</span><br><span class="line"></span><br><span class="line"># 本地查看</span><br><span class="line"># 先运行下面的命令，再在浏览器输入localhost:4000即可</span><br><span class="line">$ hexo server</span><br><span class="line"></span><br><span class="line"># 问题：执行hexo server提示找不到该指令</span><br><span class="line"># 解决办法：在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：</span><br><span class="line">$ npm install hexo -server --save</span><br></pre></td></tr></table></figure>

<h2 id="生成静态网站"><a href="#生成静态网站" class="headerlink" title="生成静态网站"></a>生成静态网站</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── .deploy #需要部署的文件</span><br><span class="line">├── node_modules #Hexo插件</span><br><span class="line">├── public #生成的静态网页文件</span><br><span class="line">├── scaffolds #模板</span><br><span class="line">├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里</span><br><span class="line">| ├── _drafts #草稿</span><br><span class="line">| └── _posts #文章</span><br><span class="line">├── themes #主题</span><br><span class="line">├── _config.yml #全局配置文件</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>

<h2 id="全局配置-config-yml"><a href="#全局配置-config-yml" class="headerlink" title="全局配置 _config.yml"></a>全局配置 _config.yml</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: http://hexo.io/docs/configuration.html</span><br><span class="line">## Source: https://github.com/hexojs/hexo/</span><br><span class="line"># Site #站点信息</span><br><span class="line">title:  #标题</span><br><span class="line">subtitle:  #副标题</span><br><span class="line">description:  #站点描述，给搜索引擎看的</span><br><span class="line">author:  #作者</span><br><span class="line">email:  #电子邮箱</span><br><span class="line">language: zh-CN #语言</span><br><span class="line"># URL #链接格式</span><br><span class="line">url:  #网址</span><br><span class="line">root: / #根目录</span><br><span class="line">permalink: :year/:month/:day/:title/ #文章的链接格式</span><br><span class="line">tag_dir: tags #标签目录</span><br><span class="line">archive_dir: archives #存档目录</span><br><span class="line">category_dir: categories #分类目录</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">permalink_defaults:</span><br><span class="line"># Directory #目录</span><br><span class="line">source_dir: source #源文件目录</span><br><span class="line">public_dir: public #生成的网页文件目录</span><br><span class="line"># Writing #写作</span><br><span class="line">new_post_name: :title.md #新文章标题</span><br><span class="line">default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）</span><br><span class="line">titlecase: false #标题转换成大写</span><br><span class="line">external_link: true #在新选项卡中打开连接</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">highlight: #语法高亮</span><br><span class="line">  enable: true #是否启用</span><br><span class="line">  line_number: true #显示行号</span><br><span class="line">  tab_replace:</span><br><span class="line"># Category &amp; Tag #分类和标签</span><br><span class="line">default_category: uncategorized #默认分类</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"># Archives</span><br><span class="line">2: 开启分页</span><br><span class="line">1: 禁用分页</span><br><span class="line">0: 全部禁用</span><br><span class="line">archive: 2</span><br><span class="line">category: 2</span><br><span class="line">tag: 2</span><br><span class="line"># Server #本地服务器</span><br><span class="line">port: 4000 #端口号</span><br><span class="line">server_ip: localhost #IP 地址</span><br><span class="line">logger: false</span><br><span class="line">logger_format: dev</span><br><span class="line"># Date / Time format #日期时间格式</span><br><span class="line">date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/</span><br><span class="line">time_format: H:mm:ss</span><br><span class="line"># Pagination #分页</span><br><span class="line">per_page: 10 #每页文章数，设置成 0 禁用分页</span><br><span class="line">pagination_dir: page</span><br><span class="line"># Disqus #Disqus评论，替换为多说</span><br><span class="line">disqus_shortname:</span><br><span class="line"># Extensions #拓展插件</span><br><span class="line">theme: landscape-plus #主题</span><br><span class="line">exclude_generator:</span><br><span class="line">plugins: #插件，例如生成 RSS 和站点地图的</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">- hexo-generator-sitemap</span><br><span class="line"># Deployment #部署，将 lmintlcx 改成用户名</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: github创库地址.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<ul>
<li>配置文件的冒号“:”后面有一个空格</li>
<li>repo: github创库地址.git</li>
</ul>
<h1 id="hexo命令行使用"><a href="#hexo命令行使用" class="headerlink" title="hexo命令行使用"></a>hexo命令行使用</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常用命令：</span><br><span class="line">hexo help #查看帮助</span><br><span class="line">hexo init #初始化一个目录</span><br><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成网页，可以在 public 目录查看整个网站的文件</span><br><span class="line">hexo server #本地预览，&#x27;Ctrl+C&#x27;关闭</span><br><span class="line">hexo deploy #部署.deploy目录</span><br><span class="line">hexo clean #清除缓存，强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹</span><br><span class="line"></span><br><span class="line">简写：</span><br><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>

<h1 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h1><h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p>前往GitHub官网注册账号，按照网站提示注册。</p>
<h2 id="创建代码仓库"><a href="#创建代码仓库" class="headerlink" title="创建代码仓库"></a>创建代码仓库</h2><p>这个仓库的名字需要和你的账号对应。格式: yourname.github.io</p>
<p>具体使用GitHub可以参考：<a href="/blog/github-using">《GitHub 使用》</a></p>
<h1 id="编辑文章"><a href="#编辑文章" class="headerlink" title="编辑文章"></a>编辑文章</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 新建文章</span><br><span class="line">$ hexo new &quot;标题&quot;</span><br></pre></td></tr></table></figure>
<p>在 _posts 目录下会生成文件标题.md</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2015-07-30 07:56:29 #发表日期，一般不改动</span><br><span class="line">categories: hexo #文章文类</span><br><span class="line">tags: [hexo,github] #文章标签，多于一项时用这种格式</span><br><span class="line">---</span><br><span class="line">正文，使用Markdown语法书写</span><br></pre></td></tr></table></figure>

<p>编辑完后保存, 预览</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<h1 id="hexo部署"><a href="#hexo部署" class="headerlink" title="hexo部署"></a>hexo部署</h1><p>执行下列指令完成部署</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>以下提示说明部署成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[info] Deploy done: git</span><br></pre></td></tr></table></figure>

<h1 id="hexo插件使用"><a href="#hexo插件使用" class="headerlink" title="hexo插件使用"></a>hexo插件使用</h1><h2 id="添加rss订阅功能"><a href="#添加rss订阅功能" class="headerlink" title="添加rss订阅功能"></a>添加rss订阅功能</h2><p>安装hexo-generator-feed插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>

<p>安装完后，会在node_modules目录下生成hexo-generator-feed目录。然后将其配置到根目录的_config.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: http://hexo.io/plugins/</span><br><span class="line">#RSS订阅</span><br><span class="line">plugin:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">#Feed Atom</span><br><span class="line">feed: #可选项，可以不填</span><br><span class="line">type: atom</span><br><span class="line">path: atom.xml</span><br><span class="line">limit: 20</span><br></pre></td></tr></table></figure>

<p>最后，在你当前主题下的_config.yml下，添加RSS订阅链接即可，这里博主用的是Yilia主题，subnav下添加rss：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># SubNav</span><br><span class="line">subnav:</span><br><span class="line">rss: &quot;/atom.xml&quot;</span><br></pre></td></tr></table></figure>

<p>至此，博客搭建完成，基本使用介绍完毕。希望对大家有所帮助。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>你和日本的距离只差5mm</title>
    <url>/2016-06-01-chopsticks-using/</url>
    <content><![CDATA[<p>世界上使用筷子的国家并不是很多，很多人都认为能够使用筷子是件很神奇的事情。那么，不同的国家地区使用筷子的讲究也有所不同。这里主要说说日本使用筷子的禁忌，有些也很符合天朝国情的。</p>
<p>日本在使用筷子的时候，也有很大的「箸（はし）」学问，有什么禁忌是千万不要犯的呢？！</p>
<span id="more"></span>

<p>✖握り箸（にぎりばし）——握筷子，这是初级错误，一般来说只有初学使用筷子的孩子和外国人会犯。</p>
<p>✖クロス箸——两根筷子交叉，很不雅观。 </p>
<p>✖迷い箸（まよいばし）——拿起筷子犹豫不决，前后左右晃动，似乎在挑拣食物。</p>
<p>✖移り箸（うつりばし）——前面食物的味道还残留在口中，就取另外的食物。</p>
<p>✖こじ箸——在碗底翻腾取食物。</p>
<p>✖寄せ箸（よせばし）——用筷子拨动、移动盘子。</p>
<p>✖刺し箸（さしばし）——用筷子扎取食物（对于不会用筷子的人来说，吃丸子的时候不这样会很难~）。</p>
<p>✖涙箸——“泪筷子”，这个名称很形象，筷子夹起食物滴滴答答的流汤。</p>
<p>✖かき箸——把碗放在嘴边，用筷子把食品拨拉到嘴里。</p>
<p>✖込み箸（こみばし）——筷子进嘴塞食。</p>
<p>✖持ち箸（もちばし）——把筷子拿在手里，端起碗吸食，日本农民 。</p>
<p>✖ねぶり箸——把筷子放在嘴里吸允。</p>
<p>✖渡し箸（わたしばし）——把筷子架在碗上。</p>
<p>✖叩き箸（はたきばし）——用筷子敲碗催促他人（这样真的很招人烦）。</p>
<p>✖指さし箸（ゆびさしばし）——用筷子指人（用手指人也是很不好的）。</p>
<p>✖直箸（じかばし）——有公筷不用，直接使用自己的筷子在盘内取食。</p>
<p>✖立箸——把筷子插在米饭碗里。</p>
<p>✖そろえ箸——用舌头、嘴唇或者其他平面整理、理顺两根筷子（为什么不用手，这样多累啊）。 </p>
<p>✖探り箸（さぐりばし）——用筷子在盘子里搅拌、寻找食物（瞄准一个直接吃得了，在那ba la啥）。</p>
<p>✖せせり箸——把筷子当牙签使（小花儿表示：她的牙缝没这么大）。</p>
<p>✖かみ箸——用牙齿咬筷子。</p>
<p>✖振り箸（ふりばし）——甩手抖落筷子上的汤汁（轻微洁癖真的有点接受不了）。</p>
<p>✖洗い箸（あらい）——在碗盘汤中涮洗筷子。</p>
<p>✖箸渡し（はしわたし）——用筷子向他人的筷子递送食品。</p>
<p>✖そら箸——筷子靠近了盘子，却又不取食品。</p>
<p>以上是25条使用筷子的禁忌。</p>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>日语</tag>
      </tags>
  </entry>
  <entry>
    <title>七牛云存储应用</title>
    <url>/2016-06-02-qiniu-using/</url>
    <content><![CDATA[<p>七牛云存储，是专为移动时代开发者打造的数据管理平台，为互联网网站和移动App提供数据的在线托管、传输加速以及图片、音视频等富媒体的云处理服务。本文讲述如何使用七牛云存储来作为自己APP的数据云存储空间。</p>
<span id="more"></span>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>七牛云存储，是专为移动时代开发者打造的数据管理平台，为互联网网站和移动App提供数据的在线托管、传输加速以及图片、音视频等富媒体的云处理服务。<br>七牛云官网<a href="http://www.qiniu.com/">http://www.qiniu.com/</a> ，进入开发者平台，浏览了所有的开发指南，可是却是没有具体清晰的操作步骤。今天自己试着通过网络，实现了使用七牛云存储文件。现在，将操作步骤记录如下。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>1.注册七牛云账号。</p>
<p>2.创建空间。</p>
<p>3.获取Access Key。</p>
<p>4.获取Secret Key。</p>
<p>5.获取官方SDK（<a href="https://github.com/qiniu/objc-sdk">https://github.com/qiniu/objc-sdk</a> ）。</p>
<h1 id="导入工程"><a href="#导入工程" class="headerlink" title="导入工程"></a>导入工程</h1><p>1.打开Xcode创建Project。</p>
<p>2.从获取的官方SDK导入库，如下图</p>
<p><img src="/assets/images/tech/qiniu-using-1.png" alt="import"></p>
<p>3.获取token</p>
<p>这一步，网上大家都说得很简单，在这一步卡壳许久。现在说说自己使用的方法：</p>
<p>1）获取服务器代码，编译工程，以备生成token。</p>
<p>服务器代码地址：<a href="https://github.com/CharsDavy/QiNiuGenertorToken">https://github.com/CharsDavy/QiNiuGenertorToken</a></p>
<p>2）使用Eclipse导入上述服务器代码</p>
<p><img src="/assets/images/tech/qiniu-using-2.png" alt="import"></p>
<p>在Test.java文件中，修改自己的空间名称，Access Key和Secret Key。运行程序，即可获得token。</p>
<p>这种方式生成的token的有效期是可以自己设定的，如果你想，设定1000年过期也是可以的。</p>
<p>4.使用代码上传文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;QiniuSDK.h&gt;</span><br><span class="line">...</span><br><span class="line">    NSString token = @&quot;从服务端SDK获取&quot;;</span><br><span class="line">    QNUploadManager *upManager = [[QNUploadManager alloc] init];</span><br><span class="line">    NSData *data = [@&quot;Hello, World!&quot; dataUsingEncoding : NSUTF8StringEncoding];</span><br><span class="line">    [upManager putData:data key:@&quot;hello&quot; token:token</span><br><span class="line">        complete: ^(QNResponseInfo *info, NSString *key, NSDictionary *resp) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, info);</span><br><span class="line">        NSLog(@&quot;%@&quot;, resp);</span><br><span class="line">    &#125; option:nil];</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>工程导入之后，可能会出现以下几种可能的错误。</p>
<p>1.若报 <code>Undefined symbols for architecture x86_64: &quot;_crc32&quot;, referenced from:</code>，项目中需导入 libz.dylib。(Build Phases—Link Binary With Libraries)</p>
<p>2.若报<code>&quot;_res_9_ninit&quot;, referenced from: _setup_dns_server in QNResolver.o</code>等，</p>
<p>1）项目中需导入 libresolv.dylib或libresolv.9.dylib。(Build Phases— Link Binary With Libraries)；</p>
<p>2）或 (Build Settings— Linking— Other Linker Flags) 添加 -lresolv选项。</p>
<p>3.若报 Thread 1: EXC_BAD_ACCESS(code&#x3D;1,address&#x3D;0x180f4beb8)类似错误，将 QN打头的都设置 arc (Build Phases — Compile Sources)</p>
<p>4.可能需要修改部分内容，如 <code>#import &lt;AFNetworking/AFNetworking.h&gt;</code>改为 <code>#import &quot;AFNetworking.h&quot;</code></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>以上就是本人在工程中使用七牛云进行文件云存储的过程，本文中使用的仅仅是上传文件，更多其他操作功能请参照官方文档。</p>
<p>最后，附上一个使用七牛云存储的软件，源码地址：<a href="https://github.com/CharsDavy/MyNotes">https://github.com/CharsDavy/MyNotes</a></p>
<p>其实，对于获取token来完成上载操作，也可以参考官方文档，地址<br><a href="http://developer.qiniu.com/docs/v6/api/reference/security/put-policy.html">http://developer.qiniu.com/docs/v6/api/reference/security/put-policy.html</a></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 使用 - 远程操作</title>
    <url>/2016-06-05-git-using-remote/</url>
    <content><![CDATA[<p>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git的读音为&#x2F;gɪt&#x2F;。</p>
<p><a href="https://zh.wikipedia.org/wiki/Git">Git</a>是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<p>Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper，后者之前一直是Linux 内核开发人员在全球使用的主要源代码工具。开放源码社区中的有些人觉得 BitKeeper 的许可证并不适合开放源码社区的工作，因此 Torvalds 决定着手研究许可证更为灵活的版本控制系统。尽管最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是我们已经发现在很多其他自由软件项目中也使用了 Git。例如 最近就迁移到 Git 上来了，很多 Freedesktop 的项目也迁移到了 Git 上。</p>
<p>Git有很多优势，其中之一就是远程操作非常简单。但是，Git也是一把双刃剑，使用得当，将会尽享Git的便利与强大。本文将主要介绍几个常用的Git远程操作命令。</p>
<p><img src="/assets/images/tech/git-using-remote1.jpg" alt="introduction"></p>
<span id="more"></span>

<h1 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h1><p>远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到<code>git clone</code>命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone &lt;版本库的网址&gt;</span><br></pre></td></tr></table></figure>

<p>比如，克隆Weibo的版本库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/charsdavy/iWeibo.git</span><br></pre></td></tr></table></figure>

<p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为<code>git clone</code>命令的第二个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br></pre></td></tr></table></figure>
<p><code>git clone</code>支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone http[s]://example.com/path/to/repo.git/</span><br><span class="line">$ git clone ssh://example.com/path/to/repo.git/</span><br><span class="line">$ git clone git://example.com/path/to/repo.git/</span><br><span class="line">$ git clone /opt/git/project.git </span><br><span class="line">$ git clone file:///opt/git/project.git</span><br><span class="line">$ git clone ftp[s]://example.com/path/to/repo.git/</span><br><span class="line">$ git clone rsync://example.com/path/to/repo.git/</span><br></pre></td></tr></table></figure>
<p>SSH协议还有另一种写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone [user@]example.com:path/to/repo.git/</span><br></pre></td></tr></table></figure>
<p>通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考<a href="http://git-scm.com/book/en/Git-on-the-Server-The-Protocols">官方文档</a>。</p>
<h1 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h1><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。<code>git remote</code>命令就用于管理主机名。</p>
<p>不带选项的时候，<code>git remote</code>命令列出所有远程主机。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<p>使用-v选项，可以参看远程主机的网址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:charsdavy/iWeibo.git (fetch)</span><br><span class="line">origin  git@github.com:charsdavy/iWeibo.git (push)</span><br></pre></td></tr></table></figure>
<p>上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。</p>
<p>克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用<code>git clone</code>命令的-o选项指定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone -o Weibo https://github.com/charsdavy/iWeibo.git</span><br><span class="line">$ git remote</span><br><span class="line">Weibo</span><br></pre></td></tr></table></figure>
<p>上面命令表示，克隆的时候，指定远程主机叫做Weibo。</p>
<ul>
<li><p>git remote show命令加上主机名，可以查看该主机的详细信息。</p>
<p>  <code>$ git remote show &lt;主机名&gt;</code></p>
</li>
<li><p>git remote add命令用于添加远程主机。</p>
<p>  <code>$ git remote add &lt;主机名&gt; &lt;网址&gt;</code></p>
</li>
<li><p>git remote rm命令用于删除远程主机。</p>
<p>  <code>$ git remote rm &lt;主机名&gt;</code></p>
</li>
<li><p>git remote rename命令用于远程主机的改名。</p>
<p>  <code>$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</code></p>
</li>
</ul>
<h1 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h1><p>一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到<code>git fetch</code>命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git fetch &lt;远程主机名&gt;</span><br></pre></td></tr></table></figure>
<p>上面命令将某个远程主机的更新，全部取回本地。</p>
<p><code>git fetch</code>命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。</p>
<p>默认情况下，<code>git fetch</code>取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure>
<p>比如，取回origin主机的master分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git fetch origin master</span><br></pre></td></tr></table></figure>
<p>所取回的更新，在本地主机上要用”远程主机名&#x2F;分支名”的形式读取。比如origin主机的master，就要用origin&#x2F;master读取。</p>
<p><code>git branch</code>命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch -r</span><br><span class="line">origin/master</span><br><span class="line"></span><br><span class="line">$ git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure>
<p>上面命令表示，本地主机的当前分支是master，远程分支是origin&#x2F;master。</p>
<p>取回远程主机的更新以后，可以在它的基础上，使用<code>git checkout</code>命令创建一个新的分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -b newBrach origin/master</span><br></pre></td></tr></table></figure>
<p>上面命令表示，在origin&#x2F;master的基础上，创建一个新分支。</p>
<p>此外，也可以使用<code>git merge</code>命令或者<code>git rebase</code>命令，在本地分支上合并远程分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git merge origin/master</span><br><span class="line"># 或者</span><br><span class="line">$ git rebase origin/master</span><br></pre></td></tr></table></figure>
<p>上面命令表示在当前分支上，合并origin&#x2F;master。</p>
<h1 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h1><p><code>git pull</code>命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>
<p>比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull origin next:master</span><br></pre></td></tr></table></figure>
<p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull origin next</span><br></pre></td></tr></table></figure>
<p>上面命令表示，取回origin&#x2F;next分支，再与当前分支合并。实质上，这等同于先做<code>git fetch</code>，再做<code>git merge</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">$ git merge origin/next</span><br></pre></td></tr></table></figure>
<p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在<code>git clone</code>的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin&#x2F;master分支。</p>
<p>Git也允许手动建立追踪关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream master origin/next</span><br></pre></td></tr></table></figure>
<p>上面命令指定master分支追踪origin&#x2F;next分支。</p>
<p>如果当前分支与远程分支存在追踪关系，<code>git pull</code>就可以省略远程分支名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull origin</span><br></pre></td></tr></table></figure>
<p>上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。</p>
<p>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure>
<p>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p>
<p>如果合并需要采用rebase模式，可以使用–rebase选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>
<p>如果远程主机删除了某个分支，默认情况下，<code>git pull</code> 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止由于其他人操作了远程主机，导致<code>git pull</code>不知不觉删除了本地分支。</p>
<p>但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull -p</span><br><span class="line"># 等同于下面的命令</span><br><span class="line">$ git fetch --prune origin </span><br><span class="line">$ git fetch -p</span><br></pre></td></tr></table></figure>
<h1 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h1><p><code>git push</code>命令用于将本地分支的更新，推送到远程主机。它的格式与<code>git pull</code>命令相仿。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以<code>git pull</code>是&lt;远程分支&gt;:&lt;本地分支&gt;，而<code>git push</code>是&lt;本地分支&gt;:&lt;远程分支&gt;。</p>
<p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。</p>
<p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin :master</span><br><span class="line"># 等同于</span><br><span class="line">$ git push origin --delete master</span><br></pre></td></tr></table></figure>
<p>上面命令表示删除origin主机的master分支。</p>
<p>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin</span><br></pre></td></tr></table></figure>
<p>上面命令表示，将当前分支推送到origin主机的对应分支。</p>
<p>如果当前分支只有一个追踪分支，那么主机名都可以省略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push</span><br></pre></td></tr></table></figure>
<p>如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<p>上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用<code>git push</code>了。</p>
<p>不带任何参数的<code>git push</code>，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用<code>git config</code>命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global push.default matching</span><br><span class="line"># 或者</span><br><span class="line">$ git config --global push.default simple</span><br></pre></td></tr></table></figure>
<p>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push --all origin</span><br></pre></td></tr></table></figure>
<p>上面命令表示，将所有本地分支都推送到origin主机。</p>
<p>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做<code>git pull</code>合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push --force origin </span><br></pre></td></tr></table></figure>
<p>上面命令使用–force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用–force选项。</p>
<p>最后，<code>git push</code>不会推送标签（tag），除非使用–tags选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure>

<h1 id="git-fetch-1"><a href="#git-fetch-1" class="headerlink" title="git fetch"></a>git fetch</h1><p>最近工作上有点忙，不免回家之后还需要办公，可是工作用公司的设备。回家之后只能使用自己的MAC。不过，如何在两台设备同步代码就成了问题。需要能够在一个文件夹不断的同步新的分支，而不会产生新的文件夹。这里，分享博主的解决办法。</p>
<p>1）从远端获取分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git fetch origin</span><br></pre></td></tr></table></figure>

<p>2）基于远端分支创建本地分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -b local_branch_name origin/remote_branch_name</span><br></pre></td></tr></table></figure>
<p>这样，就会在本地创建一个基于远端分支的分支。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>State 模式</title>
    <url>/2016-06-10-state-pattern/</url>
    <content><![CDATA[<p>State模式在实际使用中比较多,适合”状态的切换”.因为我们经常会使用if else if else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式了.不只是根据状态,也有根据属性.如果某个对象的属性不同,对象的行为就不一样,这点在数据库系统中出现频率比较高,我们经常会在一个数据表的尾部,加上property属性含义的字段,用以标识记录中一些特殊性质的记录,这种属性的改变(切换)又是随时可能发生的,就有可能要使用State.文章主要分享State模式相关内容.</p>
<p><img src="/assets/images/tech/state-pattern-1.png" alt="State模式图"></p>
<span id="more"></span>

<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>不同的状态,不同的行为;或者说,每个状态有着相应的行为.</p>
<h1 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h1><p>State模式在实际使用中比较多,适合”状态的切换”.因为我们经常会使用 if else if else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式了.</p>
<p>不只是根据状态,也有根据属性.如果某个对象的属性不同,对象的行为就不一样,这点在数据库系统中出现频率比较高,我们经常会在一个数据表的尾部,加上property属性含义的字段,用以标识记录中一些特殊性质的记录,这种属性的改变(切换)又是随时可能发生的,就有可能要使用State.</p>
<p>参考网址：<br><a href="http://www.jdon.com/designpatterns/designpattern_State.htm">http://www.jdon.com/designpatterns/designpattern_State.htm</a></p>
<p>举例来说：一个人具有生气，高兴和抓狂等状态，在这些状态下做同一个事情可能会有不同的结果，一个人的心情可能在这三种状态中循环转变。使用一个moodState类表示一个人的心情，使用mad,Happy,Angry类代表不同的心情。使用UML图表示如下所示：</p>
<p><img src="/assets/images/tech/state-pattern-2.png" alt="State模式UML图"></p>
<p>适用性：在下面的两情况下均可以使用State模式：</p>
<ul>
<li><p>一个对象的行为取决于它的状态，并且必须在运行时刻根据状态改变它的行为。</p>
</li>
<li><p>一个操作中含有庞大的多分支的条件豫剧，并且这些分支依赖于该对象的状态，这个状态通常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构，State模式将每一个条件分支放入一个单独的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。</p>
</li>
</ul>
<p>参与者：	</p>
<ul>
<li><p>Context(环境，Person)定义客户感兴趣的类。</p>
</li>
<li><p>State(Moodstate)：定义一个接口以封装与Context的一个特定状态相关的行为</p>
</li>
<li><p>ConcreteState Subclasses(具体状态子类，如Angry)每一个子类实现一个与Context的状态相关的行为。</p>
</li>
</ul>
<p>他们的协作关系是：</p>
<ul>
<li><p>Context将于状态相关的请求委托给当前的ConcreteState对象处理。</p>
</li>
<li><p>Context可将自身作为一个参数传递给处理该请求的状态对象，这使得状态对象在必要的时候可访问Context。</p>
</li>
<li><p>Context是客户使用的主要接口，客户可用状态对象来配置一个Context，一旦一个Context配置完毕，他的客户不再需要直接与状态对象打交道。</p>
</li>
<li><p>Context或者ConcreteState子类都可以决定哪个状态是另外那个状态的后继者，以及是在何种条件下进行状态转换。</p>
</li>
</ul>
<h1 id="相应的代码："><a href="#相应的代码：" class="headerlink" title="相应的代码："></a>相应的代码：</h1><p>MoodState代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package state;</span><br><span class="line">public interface MoodState&#123;</span><br><span class="line">	public void doSomething();</span><br><span class="line">	public void changeState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Angry代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package state;</span><br><span class="line">public class </span><br><span class="line">implements MoodState&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	public Angry(Person p)&#123;</span><br><span class="line">		this.p = p;</span><br><span class="line">	&#125;</span><br><span class="line">	public void doSomething()&#123;</span><br><span class="line">		System.out.println(&quot;I&#x27;m angry!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void changeState()&#123;</span><br><span class="line">		p.setState(new Happy(p));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Happy代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package state;</span><br><span class="line">public class Happy implements MoodState&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	public Happy(Person p)&#123;</span><br><span class="line">		this.p = p;</span><br><span class="line">	&#125;</span><br><span class="line">	public void doSomething()&#123;</span><br><span class="line">		System.out.println(&quot;I&#x27;m happy!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void changeState()&#123;</span><br><span class="line">		p.setState(new Mad(p));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mad代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package state;</span><br><span class="line">public class Mad implements MoodState&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	public Mad(Person p)&#123;</span><br><span class="line">		this.p=p;</span><br><span class="line">	&#125;</span><br><span class="line">	public void doSomething()&#123;</span><br><span class="line">		System.out.println(&quot;I&#x27;m Mad&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void changeState()&#123;</span><br><span class="line">		p.setState( new Angry(p));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package state;</span><br><span class="line">public class Person&#123;</span><br><span class="line">	private MoodState state;</span><br><span class="line">	public Person()&#123;</span><br><span class="line">		state = new Mad(this);</span><br><span class="line">	&#125;</span><br><span class="line">	public void setState(MoodState state)&#123;</span><br><span class="line">		this.state = state;</span><br><span class="line">	&#125;</span><br><span class="line">	public void doSomething()&#123;</span><br><span class="line">		state.doSomething();</span><br><span class="line">		state.changeState();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package state;</span><br><span class="line">public class Client&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Person p = new Person();</span><br><span class="line">		for(int i=0;i&lt;10;i++)</span><br><span class="line">			p.doSomething();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>状态模式将与特定状态相关的行为局部化，并且将不同状态的行为分割开来，使得状态转换显式化并且可以被共享。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>简单聊聊 iOS 中的网络加密</title>
    <url>/2016-06-15-ios-network-encrypt/</url>
    <content><![CDATA[<p>公司的接口一般会两种协议的，一种HTTP，一种HTTPS的，HTTP 只要请求，服务器就会响应，如果我们不对请求和响应做出加密处理，所有信息都是会被检测劫持到的，是很不安全的，客户端加密可以使用本文这套工具类进行处理。</p>
<span id="more"></span>


<h1 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h1><p>公司的接口一般会两种协议的，一种HTTP，一种HTTPS的，HTTP 只要请求，服务器就会响应，如果我们不对请求和响应做出加密处理，所有信息都是会被检测劫持到的，是很不安全的，客户端加密可以使用本文这套工具类进行处理。</p>
<p>但是不论在任何时候，都应该将服务置于HTTPS上，因为它可以避免中间人攻击的问题，还自带了基于非对称密钥的加密通道。</p>
<h1 id="HTTPS交互原理"><a href="#HTTPS交互原理" class="headerlink" title="HTTPS交互原理"></a>HTTPS交互原理</h1><p>简答说，HTTPS 就是 HTTP协议加了一层SSL协议的加密处理，SSL 证书就是遵守 SSL协议，由受信任的数字证书颁发机构CA（如GlobalSign，wosign），在验证服务器身份后颁发，这是需要花钱滴，签发后的证书作为公钥一般放在服务器的根目录下，便于客户端请求返回给客户端，私钥在服务器的内部中心保存，用于解密公钥。</p>
<p>HTTPS 客户端与服务器交互过程：</p>
<p>1）客户端发送请求，服务器返回公钥给客户端；</p>
<p>2）客户端生成对称加密秘钥，用公钥对其进行加密后，返回给服务器；</p>
<p>3）服务器收到后，利用私钥解开得到对称加密秘钥，保存；</p>
<p>4）之后的交互都使用对称加密后的数据进行交互。</p>
<h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>简单说，证书有两种，一种是正经的：</p>
<p>CA颁发的证书</p>
<p>一种是不正经的：</p>
<p>自己生成签发的证书</p>
<h1 id="我们需要做什么"><a href="#我们需要做什么" class="headerlink" title="我们需要做什么"></a>我们需要做什么</h1><p>如果遇到正经的证书，我们直接用AFNetworking 直接请求就好了，AFNetworking 内部帮我们封装了HTTPS的请求方式，但是大部分公司接口都是不正经的证书，这时需要我们做以下几步：</p>
<p>1）将服务器的公钥证书拖到Xcode中</p>
<p>2）修改验证模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">manager.securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModePublicKey];</span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>简单来说，就是你本可以修改AFN这个设置来允许客户端接收服务器的任何证书，但是这么做有个问题，就是你无法验证证书是否是你的服务器后端的证书，给中间人攻击，即通过重定向路由来分析伪造你的服务器端打开了大门。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AFSecurityPolicy *securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line">securityPolicy.allowInvalidCertificates = YES;</span><br></pre></td></tr></table></figure>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>AFNetworking是允许内嵌证书的，通过内嵌证书，AFNetworking就通过比对服务器端证书、内嵌的证书、站点域名是否一致来验证连接的服务器是否正确。由于CA证书验证是通过站点域名进行验证的，如果你的服务器后端有绑定的域名，这是最方便的。将你的服务器端证书，如果是pem格式的，用下面的命令转成cer格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -in &lt;你的服务器证书&gt;.pem -outform der -out server.cer</span><br></pre></td></tr></table></figure>

<p>然后将生成的server.cer文件，如果有自建ca，再加上ca的cer格式证书，引入到app的bundle里，AFNetworking在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AFSecurityPolicy *securityPolicy = [AFSecurityPolicy AFSSLPinningModeCertificate];</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AFSecurityPolicy *securityPolicy = [AFSecurityPolicy AFSSLPinningModePublicKey];</span><br></pre></td></tr></table></figure>

<p>情况下，会自动扫描bundle中.cer的文件，并引入，这样就可以通过自签证书来验证服务器唯一性了。</p>
<h1 id="AFSecurityPolicy三种验证模式"><a href="#AFSecurityPolicy三种验证模式" class="headerlink" title="AFSecurityPolicy三种验证模式"></a>AFSecurityPolicy三种验证模式</h1><ul>
<li><p>AFSSLPinningModeNone<br>这个模式表示不做SSL pinning，<br>只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书就不会通过。</p>
</li>
<li><p>AFSSLPinningModeCertificate<br>这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。</p>
</li>
<li><p>AFSSLPinningModePublicKey<br>这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，<br>只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。</p>
</li>
</ul>
<p>参考</p>
<p><a href="http://www.jianshu.com/p/75d96b72bfb1">http://www.jianshu.com/p/75d96b72bfb1</a></p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>网络</tag>
        <tag>框架</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 博客功能扩展 - 添加回滚到顶部按钮</title>
    <url>/2016-06-24-hexo-extern-scroll-top/</url>
    <content><![CDATA[<p>承接前文<a href="/blog/build-blog-by-hexo">《手把手教 GitHub + Hexo 搭建博客》</a> ，对现有博客进行功能扩展。因为随着文章的发表，页面变得很长，长文章也较多，偶尔需要立即回到顶部，这个时候，就需要添加新的快捷方式。于是乎，诞生了这个功能扩展。文章主要分享实现滚动到顶部按钮功能。</p>
<p>** 以Yilia主题为例，不同的主题可以类比找到对应的文件地址。 **</p>
<span id="more"></span>

<h1 id="添加html代码"><a href="#添加html代码" class="headerlink" title="添加html代码"></a>添加html代码</h1><p>打开文件夹<code>/themes/Yilia/layout/_partial</code>在此文件夹下，新建文件<code>totop.ejs</code>，并向其中加入如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;totop&quot; style=&quot;position:fixed;bottom:50px;right:30px;cursor: pointer;&quot;&gt;</span><br><span class="line">&lt;a title=&quot;返回顶部&quot;&gt;&lt;img src=&quot;/img/scrollup.png&quot;/&gt;&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>注意： 文件的编码格式为<code>utf-8</code>。</p>
<h1 id="添加js代码"><a href="#添加js代码" class="headerlink" title="添加js代码"></a>添加js代码</h1><p>打开文件夹<code>/themes/Yilia/source/js</code>，新建文件<code>totop.js</code>，将如下代码复制其中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function($) &#123;</span><br><span class="line">    // When to show the scroll link</span><br><span class="line">    // higher number = scroll link appears further down the page</span><br><span class="line">    var upperLimit = 1000;</span><br><span class="line"></span><br><span class="line">    // Our scroll link element</span><br><span class="line">    var scrollElem = $(&#x27;#totop&#x27;);</span><br><span class="line"></span><br><span class="line">    // Scroll to top speed</span><br><span class="line">    var scrollSpeed = 1600;</span><br><span class="line"></span><br><span class="line">    // Show and hide the scroll to top link based on scroll position</span><br><span class="line">    scrollElem.hide();</span><br><span class="line">    $(window).scroll(function () &#123;</span><br><span class="line">        var scrollTop = $(document).scrollTop();</span><br><span class="line">        if ( scrollTop &gt; upperLimit ) &#123;</span><br><span class="line">            $(scrollElem).stop().fadeTo(300, 1); // fade back in</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            $(scrollElem).stop().fadeTo(300, 0); // fade out</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // Scroll to top animation on click</span><br><span class="line">    $(scrollElem).click(function()&#123;</span><br><span class="line">        $(&#x27;html, body&#x27;).animate(&#123;scrollTop:0&#125;, scrollSpeed); return false;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure>

<p>可以对<code>upperLimit</code>和<code>scrollSpeed</code>参数进行修改，控制显示位置和回滚速度。</p>
<h1 id="添加文件引用"><a href="#添加文件引用" class="headerlink" title="添加文件引用"></a>添加文件引用</h1><p>打开文件<code>/themes/Yilia/layout/_partial/after_footer.ejs</code>，在文件的末尾添加以下两行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%- partial(&#x27;totop&#x27;) %&gt;</span><br><span class="line">&lt;script src=&quot;&lt;%- config.root %&gt;js/totop.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>将下面的图片复制到<code>/themes/Yilia/source/img</code>目录下，文件名为<code>scrollup.png</code>，页面足够长时，就可以看见按钮出现。</p>
<p><img src="/assets/images/tech/hexo-extern-scroll-top.png" alt="scrollup.png"></p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>说说升级Xcode中SDK与真机调试版本</title>
    <url>/2016-06-30-xcode-update-sdk-devicesupport/</url>
    <content><![CDATA[<p>相信作为一名iOS开发者，每当WWDC开始，iOS升级时，那种切肤之痛，是只有开发者才能体会而又无言的一种沉默抗议。</p>
<p>Apple很残暴的将MAC OS、iOS、Xcode牢固的捆绑在一起。如果需要真机调试，那么Xcode的SDK版本一定不能低于真机，Xcode版本的安装有MAC OS的版本要求，这样一来，只要升级一下iOS版本，那么恭喜你，很有可能你需要升级MAC OS和Xcode。而对于动辄数十个G的文件，在天朝的绿色网络保护下，是一件多么伤神的事情啊。更甚的是，现在的MAC OS系统越来越不好用了，我很是怀恋之前的版本，无奈胳膊拗不过大腿。</p>
<p>现在，终于有了可行的办法，能够解决上述神伤，在此总结分享给大家。</p>
<span id="more"></span>


<h1 id="下载Xcode历史版本"><a href="#下载Xcode历史版本" class="headerlink" title="下载Xcode历史版本"></a>下载Xcode历史版本</h1><p>Apple提供了官方下载地址：</p>
<p><a href="https://developer.apple.com/download/more">https://developer.apple.com/download/more</a></p>
<p>打开链接，登录账户，即可看见下图所示：</p>
<p><img src="/assets/images/tech/xcode-update-sdk-devicesupport-1-xcode.png" alt="下载历史版本Xcode"></p>
<p>根据左侧栏，筛选自己需要的软件，下载即可。</p>
<h1 id="升级Xcode真机调试版本"><a href="#升级Xcode真机调试版本" class="headerlink" title="升级Xcode真机调试版本"></a>升级Xcode真机调试版本</h1><p>1）在一台已经安装好的高版本中，获取需要的文件。</p>
<p>2）替换自己的电脑上的Xcode对应的文件。</p>
<p>步骤如下：</p>
<p>1）找到应用程序，显示包中的文件</p>
<p><img src="/assets/images/tech/xcode-update-sdk-devicesupport-2.png" alt="显示包文件"></p>
<p>2）进入路径</p>
<p><code>/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport</code></p>
<p><img src="/assets/images/tech/xcode-update-sdk-devicesupport-3.png" alt="文件目录"></p>
<p>拷贝需要的文件，如 9.3文件夹。</p>
<p>粘贴至自己电脑对应的位置即可。</p>
<h1 id="升级Xcode的SDK"><a href="#升级Xcode的SDK" class="headerlink" title="升级Xcode的SDK"></a>升级Xcode的SDK</h1><p>延续上述步骤，只需要进入文件路径</p>
<p><code>/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs</code></p>
<p>拷贝SDKs文件夹，粘贴至自己电脑相对应位置即可。</p>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Git可视化比较工具P4Merge</title>
    <url>/2016-07-12-git-diff-p4merge/</url>
    <content><![CDATA[<p>在转战Mac之后，BeyondCompare 不再那么容易免费使用，今天终于让我找到了一个Git的GUI比较工具P4Merge，免费的，支持中文，还不错，推荐一下</p>
<p><img src="/assets/images/tech/git-diff-p4merge.png" alt="效果图"></p>
<span id="more"></span>

<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>打开这个链接: <a href="https://www.perforce.com/product/components/perforce-visual-merge-and-diff-tools">perforce-visual-merge-and-diff-tools</a>，点左上角的 <code>FREE DOWNLOAD P4Merge</code> , 找到 <code>Perforce Clients</code> 中的 <code>P4Merge: Visual Merge Tool</code> 项，在右边的第二行选择<code>Mac OS 10.6+ (64bit）</code> ，点下面橙色的 <code>Accept and Download</code>，选择跳过 <code>Skip Registration</code> ，就会开始下载了。</p>
<p>下载到<code>P4V.dmg</code>文件后，双击打开，拖动<code>P4Merge</code>到<code>Application</code>文件夹上就可以完成安装了。</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global diff.tool p4merge</span><br><span class="line">git config --global difftool.p4merge.cmd /Applications/p4merge.app/Contents/MacOS/p4merge</span><br><span class="line">git config --global difftool.p4merge.cmd &quot;/Applications/p4merge.app/Contents/Resources/launchp4merge \$LOCAL \$REMOTE&quot;</span><br></pre></td></tr></table></figure>

<p>如果直接复制原文的代码，运行上面的代码时会提示：<br>error: key does not contain a section: -global<br>跟别人的命令比较一下，就会发现应该是—global（要两个短横连在一起的），原文的短横线有问题</p>
<p>现在敲<code>git difftool</code>命令执行时，会提示：</p>
<p><code>/usr/libexec/git-core/mergetools/p4merge: line 2: p4merge: command not found</code></p>
<p>原因是路径还需要再配置一下，如下</p>
<p><code>git config --global difftool.p4merge.path &quot;/Applications/p4merge.app/Contents/Resources/launchp4merge&quot; </code><br>以后想要比较Git中的代码时，敲<code>git difftool filepath</code> 即可</p>
<p>Linux、Windows下也都可以使用这个工具进行比较代码，只是需要另行配置了。P4Merge除了有比较功能，还有合并功能，怎么配置可以借鉴下面给出的参考链接。另外还有一个可视化比较工具meld，据说也不错，有时间试试.</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://blog.csdn.net/ccf0703/article/details/7661789">《Mac os x下git merge工具P4Merge的安装与配置》</a></p>
<p><a href="http://nieyong.github.io/wiki_ny/git%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95.html">《Git 用户信息》</a></p>
<p><a href="https://gist.github.com/tony4d/3454372">《Setup p4merge as a visual diff and merge tool for git》</a></p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>git</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>在Finder中打开终端</title>
    <url>/2016-07-13-finder-open-terminal/</url>
    <content><![CDATA[<p>在Mac中，如果要在终端中进入在Finder中打开的目录，常用的方法是在终端中先敲入一个”cd “，然后在Finer中选中文件夹拖入到终端中，再回车即可实现。不过这样做终究还是麻烦了点，下面介绍如何直接在Finder中直接操作。</p>
<p>在终端里打开Finder很简单，使用<code>open .</code>即可</p>
<span id="more"></span>

<h1 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h1><p>在Finder打开terminal这个功能其实是有的，但是系统默认没有打开，我们可以通过如下方法将其打开</p>
<p>进入<code>系统偏好设置</code>-&gt;<code>键盘</code>-&gt;<code>快捷键</code>-&gt;<code>服务</code>。</p>
<p>在右边<code>新建位于文件夹位置的终端窗口</code>上打勾。</p>
<p>如此设置后，在Finder中右击某文件，在出现的菜单中找到服务，然后点击<code>新建位于文件夹位置的终端窗口</code>即可。</p>
<h1 id="Go2Shell"><a href="#Go2Shell" class="headerlink" title="Go2Shell"></a>Go2Shell</h1><p>在Mac App Store中下载 Go2Shell 软件，下载后在”应用程序“里找到Go2Shell软件，按住Cmd键，将其拖动到Finder的工具栏上。</p>
<p>打开Go2Shell设置的方法是：在终端中输入命令 <code>open -a Go2Shell --args config</code>，然后回车。</p>
<p>优点：可以不需要选中文件夹，直接点Go2Shell按钮就可以打开终端。</p>
<p>缺点：每次都是在新的终端窗口中打开，而不是在新的终端标签中打开。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>打造自己的 Mac 环境</title>
    <url>/2016-07-17-custom-myself-develop-tool/</url>
    <content><![CDATA[<p>作为一个程序猿，每天接触最多的就是自己的“女朋友”，那么猿们肯定都有自己的一套撸具，我们都会根据自己的喜好配置自己的万能功能。无非是对于terminal的使用与配置。</p>
<p>文章主要分享记录博主自己搭建环境的过程。</p>
<span id="more"></span>

<h1 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h1><p>罗列一下博主 Mac 上的盆友们，顺便来个简要介绍。</p>
<p>1）开发类</p>
<ul>
<li>Xcode：苹果官方开发工具</li>
<li>PaintCode：可视化设计转代码神器</li>
<li>GitX：git可视化工具，<strong>开源</strong></li>
<li>SimPholders：直接打开模拟器App文件神器</li>
</ul>
<p>2）工具类</p>
<ul>
<li>奇妙清单：云记事本</li>
<li>Beyond Compare：文件比较神器，<strong>付费</strong></li>
<li>Charles：网络抓包神器，<strong>付费</strong></li>
<li>Go2Shell：命令行打开工具，可以实现Finder下打开terminal</li>
<li>Navicat Premium：数据库可视化工具，<strong>付费</strong></li>
<li>Chrome：谷歌浏览器</li>
<li>The Unarchiver：文件解压缩工具</li>
<li>DaisyDisk：磁盘清理工具，<strong>付费</strong></li>
<li>MindNode Pro：思维导图，<strong>付费</strong></li>
</ul>
<p>3）文本编辑类</p>
<ul>
<li>Sublime Text：文本编辑神器</li>
<li>Pages：苹果官方办公工具</li>
<li>Mou：markdown语法文本编辑器</li>
</ul>
<p>4）阅读类</p>
<ul>
<li>Reeder：博客订阅</li>
<li>Pocket：文章收藏</li>
<li>Dash：离线开发文档阅读</li>
<li>Skim：PDF阅读，<strong>开源</strong></li>
<li>CHM View：chm文件阅读</li>
</ul>
<p>5）图像类</p>
<ul>
<li>Acorn：轻量级PhotoShop</li>
<li>ScreenFlow：录屏，生成视频文件，<strong>付费</strong></li>
<li>licecap：录屏，生成.gif文件</li>
<li>Snip：截图</li>
</ul>
<h1 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h1><p>配置命令打开 Sublime Text</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s &quot;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&quot; /usr/local/bin/subl</span><br></pre></td></tr></table></figure>

<p>之后使用时，使用如下命令即可打开：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ subl</span><br></pre></td></tr></table></figure>

<p>实际上这就是一个软链接的应用。</p>
<h3 id="JSON代码格式化"><a href="#JSON代码格式化" class="headerlink" title="JSON代码格式化"></a>JSON代码格式化</h3><p>网上有很多工具可用，博主自己现在使用一个 Tidy 的插件，效果还是蛮不错的。</p>
<p><img src="/assets/images/tech/custom-myself-develop-tool-subl-1.png" alt="效果图"></p>
<p>1.打开链接<a href="https://gist.github.com/charsdavy/cd2324f9483ff83425bbacf85a6ea9be">https://gist.github.com/charsdavy/cd2324f9483ff83425bbacf85a6ea9be</a>，下载文件。</p>
<p>2.将解压后的文件夹中的 <code>prettify_json.py</code> 和 <code>tidy_xml.py</code> 问价拷贝到 <code>~/Library/Application Support/Sublime Text 2/Packages/User</code> 路径</p>
<p><img src="/assets/images/tech/custom-myself-develop-tool-subl-2.png" alt="路径文件夹"></p>
<p>3.打开 Sublime Text，从菜单中打开“Key-Bindings Default”文件</p>
<p><img src="/assets/images/tech/custom-myself-develop-tool-subl-3.png" alt="打开Key-Bindings Default文件"></p>
<p>4.添加快捷键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &quot;keys&quot;: [&quot;ctrl+shift+x&quot;], &quot;command&quot;: &quot;tidy_xml&quot; &#125;,</span><br><span class="line">&#123; &quot;keys&quot;: [&quot;ctrl+shift+j&quot;], &quot;command&quot;: &quot;prettify_json&quot; &#125;, </span><br></pre></td></tr></table></figure>

<p><img src="/assets/images/tech/custom-myself-develop-tool-subl-4.png" alt="添加快捷键"></p>
<p>5.使用</p>
<p>全选，然后按下 <code>Control + shift + j</code> 键即可。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 中 Git 命令自动补全</title>
    <url>/2016-07-17-git-auto-completion-mac/</url>
    <content><![CDATA[<p>转战iOS开发已经有一段时间了，现在使用Mac，对于命令行的使用，真的是越来越喜欢，但是，在使用Git命令的时候，不能使用【Tab】来自动补全，为此，博主找寻方法，来完善Git命令补全功能。本文分享此功能实现。</p>
<span id="more"></span>

<h1 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h1><p>使用Homebrew安装的git，如何安装Honebrew及其使用在此就跳过，烦请自行查看(<a href="http://brew.sh/index_zh-cn.html)%E3%80%82">http://brew.sh/index_zh-cn.html)。</a></p>
<h1 id="安装bash-completion"><a href="#安装bash-completion" class="headerlink" title="安装bash-completion"></a>安装bash-completion</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ brew list</span><br></pre></td></tr></table></figure>

<p>查看是否已经安装了”bash-completion”，如果没有，继续往下看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ brew install bash-completion</span><br><span class="line">#####安装完成之后######</span><br><span class="line">$ brew info bash-completion 　</span><br><span class="line">#####下边这句话很重要#######</span><br><span class="line">==&gt; Caveats</span><br><span class="line">Add the following lines to your ~/.bash_profile:</span><br><span class="line">if [ -f $(brew --prefix)/etc/bash_completion ]; then</span><br><span class="line">. $(brew --prefix)/etc/bash_completion</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>将if…then…那一句添加到~&#x2F;.bash_profile（如果没有该文件，新建一个）</p>
<h1 id="获取git-completion-bash"><a href="#获取git-completion-bash" class="headerlink" title="获取git-completion.bash"></a>获取git-completion.bash</h1><p>将git源码clone到本地</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/git/git.git</span><br></pre></td></tr></table></figure>

<p>找到”contrib&#x2F;completion&#x2F;“目录下的git-completion.bash，将该文件拷贝到~&#x2F;下并重命名为.git-completion.bash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cp git-completion.bash ~/.git-completion.bash</span><br></pre></td></tr></table></figure>

<h1 id="配置git-completion-bash"><a href="#配置git-completion-bash" class="headerlink" title="配置git-completion.bash"></a>配置git-completion.bash</h1><p>在~&#x2F;.bash_profile文件（该目录下如果没有，新建一个）中添加下边的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.git-completion.bash</span><br></pre></td></tr></table></figure>

<p>重启终端即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git --h[tab][tab]</span><br><span class="line">--help        --html-path</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈iOS App打包发布</title>
    <url>/2016-07-21-ios-app-distribution/</url>
    <content><![CDATA[<p>来到 ZAKER 工作已经有一段时间了，博主也开始了自己的 iOS 开发之旅，因为博主是自学的，难免有些知识点的遗漏，很巧的是，关于App打包发布就是其中之一。而在最近，机缘巧合之下，需要自己打包上传到公司自己服务器用来做demo演示。在此，博主分享一下有关iOS App打包的过程。</p>
<span id="more"></span>

<p>1.安装发布证书</p>
<ul>
<li>自己去Apple开发者中心配置</li>
<li>找其他已经有证书的小伙伴导出p12文件</li>
</ul>
<p>2.设置Scheme</p>
<p><code>Xcode-&gt;Product-&gt;Scheme-&gt;Edit Scheme</code></p>
<p><img src="/assets/images/tech/ios-app-distribution-1.png" alt="setting-scheme"></p>
<p>3.设置软件版本号</p>
<p>版本号格式：<code>数字.数字-字符(驼峰式).数字</code></p>
<p>示例：<code>1.1-beta.1</code> , <code>1.1.1-beta</code></p>
<p><strong>说明：</strong>版本号从0开始，不过一般版本号为0的数字省略。</p>
<p>4.Archive</p>
<p><strong>注意：</strong>选择<code>真机</code>或者<code>Generic iOS Device</code></p>
<p><code>Product-&gt;Archive</code></p>
<p>5.Export</p>
<p><img src="/assets/images/tech/ios-app-distribution-2.png" alt="export-1"></p>
<p><img src="/assets/images/tech/ios-app-distribution-3.png" alt="export-2"></p>
<p><img src="/assets/images/tech/ios-app-distribution-4.png" alt="export-3"></p>
<p><img src="/assets/images/tech/ios-app-distribution-5.png" alt="export-4"></p>
<p><img src="/assets/images/tech/ios-app-distribution-6.png" alt="export-5"></p>
<p><img src="/assets/images/tech/ios-app-distribution-7.png" alt="export-6"></p>
<p>6.安装企业应用证书</p>
<p>7.上传到ZAKER服务器</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>application</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode 常用插件</title>
    <url>/2016-08-02-xcode-plugin-list/</url>
    <content><![CDATA[<blockquote>
<p>工欲善其事，必先利其器</p>
</blockquote>
<p>这里主要罗列一些常用的 Xcode 插件。</p>
<span id="more"></span>

<ul>
<li>BBUncrustify</li>
</ul>
<p>代码格式化</p>
<p><a href="https://github.com/benoitsan/BBUncrustifyPlugin-Xcode">https://github.com/benoitsan/BBUncrustifyPlugin-Xcode</a></p>
<ul>
<li>Backlight</li>
</ul>
<p>光标选中行高亮</p>
<p><a href="https://github.com/limejelly/Backlight-for-XCode">https://github.com/limejelly/Backlight-for-XCode</a></p>
<ul>
<li>HighlightSelectedString</li>
</ul>
<p>代码变量选中高亮</p>
<p><a href="https://github.com/keepyounger/HighlightSelectedString">https://github.com/keepyounger/HighlightSelectedString</a></p>
<ul>
<li>VVDocumenter</li>
</ul>
<p>快捷注释</p>
<p><a href="https://github.com/onevcat/VVDocumenter-Xcode">https://github.com/onevcat/VVDocumenter-Xcode</a></p>
<ul>
<li>KSImageNamed</li>
</ul>
<p>根据图片名，输入代码时图片预览</p>
<p><a href="https://github.com/ksuther/KSImageNamed-Xcode">https://github.com/ksuther/KSImageNamed-Xcode</a></p>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>配色和排版（基础篇）</title>
    <url>/2016-08-05-design-harmonize-colours/</url>
    <content><![CDATA[<blockquote>
<p>在什么样的团队就能成为什么样的人</p>
</blockquote>
<p>来到公司已经有一段时间了，在这段时间里，自我感觉是快速成长的。今天，终于决定扯来公司这张虎皮来给自己镀镀金，这里主要分享一下公司设计团队的设计技巧，希望对大家有帮助。</p>
<span id="more"></span>

<h1 id="基本颜色"><a href="#基本颜色" class="headerlink" title="基本颜色"></a>基本颜色</h1><ul>
<li>暖色</li>
</ul>
<p><img src="/assets/images/tech/design-harmonize-colours-1.png" alt="暖色"></p>
<ul>
<li>冷色</li>
</ul>
<p><img src="/assets/images/tech/design-harmonize-colours-2.png" alt="冷色"></p>
<ul>
<li>中性色</li>
</ul>
<p><img src="/assets/images/tech/design-harmonize-colours-3.png" alt="中性色"></p>
<p>以上色块示例只是日常使用中的基础颜色，各种颜色可以延伸出较多的相近色。这个需要根据内容主题来搭配颜色。<br><strong>所有的颜色搭配都是为了突出和强调主题。</strong></p>
<h1 id="颜色搭配基础"><a href="#颜色搭配基础" class="headerlink" title="颜色搭配基础"></a>颜色搭配基础</h1><ul>
<li>暖色</li>
</ul>
<p>暖色系的搭配包括深色+浅色，也可以使用少量冷色衬托。</p>
<p><img src="/assets/images/tech/design-harmonize-colours-4.png" alt="暖色搭配"></p>
<ul>
<li>冷色</li>
</ul>
<p>冷色系的搭配包括深色+浅色，也可以使用少量暖色衬托。</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/design-harmonize-colours-5.png?imageView/2/w/600" alt="冷色搭配"></p>
<ul>
<li>对比色</li>
</ul>
<p>对比色是深色和浅色，暖色和冷色的搭配。</p>
<p><img src="/assets/images/tech/design-harmonize-colours-6.png" alt="对比色搭配"></p>
<ul>
<li>中性色</li>
</ul>
<p>中性色可以搭配冷色、暖色。</p>
<p><img src="/assets/images/tech/design-harmonize-colours-7.png" alt="中性色搭配"></p>
<h1 id="图文排版基础"><a href="#图文排版基础" class="headerlink" title="图文排版基础"></a>图文排版基础</h1><ul>
<li>左对齐</li>
</ul>
<p>左对齐分两种：</p>
<p>1）文字位于整张图片左侧，图片内容居右。</p>
<p>2）文字位于整张图片中间，但文字还是左对齐。</p>
<p><img src="/assets/images/tech/design-harmonize-colours-8.png" alt="左对齐"></p>
<ul>
<li>居中对齐</li>
</ul>
<p>居中对齐是文字位于整张图片中间，背景加入素材作为衬托。</p>
<p><img src="/assets/images/tech/design-harmonize-colours-9.png" alt="居中对齐"></p>
<ul>
<li>右对齐</li>
</ul>
<p>文字位于整张图片右侧，图片内容居左。</p>
<p><img src="/assets/images/tech/design-harmonize-colours-10.png" alt="右对齐"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>配色是否协调需要长期观摩。排版需要注意适当的留白。</p>
<p><img src="/assets/images/tech/design-harmonize-colours-11.png" alt="ZAKER"></p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac OS 开发 (一) 准备工作</title>
    <url>/2016-08-12-mac-os-develop-prepare/</url>
    <content><![CDATA[<blockquote>
<p>程序猿，一个另类的物种。</p>
</blockquote>
<p>其实很多时候，懒懒的程序猿因为自己的需要，或者是因为使用别人的工具并不满意，而催发出自己解决问题的想法。这个 Mac OS 开发系列，就是因为博主自己写博客是需要上传图片，而目前的 App 并不满意的情况下，决心自己学习，自己开发出喜欢的 App 而诞生的。</p>
<span id="more"></span>

<p>本文章为该系列开篇，循序渐进，从基础开始。</p>
<h1 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h1><p>这是开发的基础，至于是 Mac Book Pro，还是iMac，或者Mac mini 就随个人喜欢和实际状况。总之，不建议使用黑苹果。</p>
<h1 id="Xcode"><a href="#Xcode" class="headerlink" title="Xcode"></a>Xcode</h1><p>这是毫无置疑的开发工具，具体如何使用，Google 一大把，这里就不再详说，以后若是博主自己写了相关内容，会后续放上链接跳转。</p>
<h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><p>启动Xcode，选择Create a new Xcode project，(非首次运行Xcode，从菜单File-New-&gt;Project) 进入工程模版选择界面，选择OSX-&gt;Application-&gt;Cocoa Application</p>
<p><img src="/assets/images/tech/mac-os-develop-prepare-1.png" alt="创建"></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="info-plist"><a href="#info-plist" class="headerlink" title="info.plist"></a>info.plist</h2><p><img src="/assets/images/tech/mac-os-develop-prepare-2.png" alt="配置"></p>
<p><code>Application is agent(UIElement)</code> 字段可以控制App的MainMenu是否显示，Logo在Dock是否显示。</p>
<h2 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h2><p><img src="/assets/images/tech/mac-os-develop-prepare-3.png" alt="Capabilities"></p>
<p>这里我们重点关注下App Sandbox，Apple现在要求上架Mac AppStore的应用必须使用沙盒，所以发布到Mac商店的应用你必须选择打开。</p>
<p>如果你的应用要访问服务器的API接口，必须打开Outgoing Connections。</p>
<p>Hardware里面必须选择打开Printing，否则审核不通过。</p>
<p>File Accedd:如果你需要让用户选择访问本地的文件，User Selected File 中选择读&#x2F;写权限。</p>
<p><img src="/assets/images/tech/mac-os-develop-prepare-4.png" alt="File"></p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>简单聊聊大小端问题</title>
    <url>/2016-08-13-memory-big-little-endian/</url>
    <content><![CDATA[<p>在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器）。另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。</p>
<span id="more"></span>

<p>先来看一段代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> bits32;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> bytes[<span class="number">4</span>];</span><br><span class="line">&#125;value;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLittleEndian</span><span class="params">()</span>&#123;</span><br><span class="line">        value.bytes[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        value.bytes[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        value.bytes[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        value.bytes[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value.bits32 == <span class="number">256</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( isLittleEndian())</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;is little endian! &quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;is big endian! &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓的<strong>大端模式</strong>，是指数据的低位（就是权值较小的后面那几位）保存在内存的高地址中，而数据的高位，保存在内存的低地址中。这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；</p>
<p>所谓的<strong>小端模式</strong>，是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。 </p>
<p><strong>为什么会有大小端模式之分呢？</strong></p>
<p>这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器）。另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。</p>
<p>例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。<br>下面这段代码可以用来测试一下你的编译器是大端模式还是小端模式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> <span class="type">int</span> x; </span><br><span class="line"><span class="type">char</span> x0, x1; </span><br><span class="line">x = <span class="number">0x1122</span>; </span><br><span class="line">x0 = ((<span class="type">char</span>*)&amp;x)[<span class="number">0</span>]; <span class="comment">//低地址单元 </span></span><br><span class="line">x1 = ((<span class="type">char</span>*)&amp;x)[<span class="number">1</span>]; <span class="comment">//高地址单元 </span></span><br></pre></td></tr></table></figure>

<p>若x0&#x3D;0x11,则是大端; 若x0&#x3D;0x22,则是小端。</p>
<p>上面的程序还可以看出，数据寻址时，用的是低位字节的地址。</p>
<p><strong>什么是字节对齐，为什么要对齐?</strong></p>
<p>现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。</p>
<p><strong>对齐的作用和原因</strong>：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。</p>
<p><strong>字节对齐对程序的影响？</strong></p>
<p>先让我们看几个例子(32bit，x86环境，gcc编译器)：<br>设结构体如下定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在已知32位机器上各种数据类型的长度如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char:1(有符号无符号同) </span><br><span class="line">short:2(有符号无符号同) </span><br><span class="line">int:4(有符号无符号同) </span><br><span class="line">long:4(有符号无符号同) </span><br><span class="line">float:4    double:8</span><br></pre></td></tr></table></figure>

<p>那么上面两个结构大小如何呢?</p>
<p>结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sizeof(strcut A)值为8</span><br><span class="line">sizeof(struct B)的值却是12</span><br></pre></td></tr></table></figure>

<p>结构体A中包含了4字节长度的int一个，1字节长度的char一个和2字节长度的short型数据一个,B也一样；按理说A，B大小应该都是7字节。之所以出现上面的结果是因为编译器要对数据成员在空间上进行对齐。上面是按照编译器的默认设置进行对齐的结果，那么我们是不是可以改变编译器的这种默认对齐设置呢，当然可以。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma pack (2) /*指定按2字节对齐*/</span><br><span class="line">struct C</span><br><span class="line">&#123;</span><br><span class="line">    char b;</span><br><span class="line">    int a;</span><br><span class="line">    short c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</span><br><span class="line">sizeof(struct C)值是8。</span><br><span class="line">修改对齐值为1：</span><br><span class="line">#pragma pack (1) /*指定按1字节对齐*/</span><br><span class="line">struct D</span><br><span class="line">&#123;</span><br><span class="line">    char b;</span><br><span class="line">    int a;</span><br><span class="line">    short c;</span><br><span class="line">&#125;;</span><br><span class="line">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</span><br><span class="line">sizeof(struct D)值为7。</span><br></pre></td></tr></table></figure>

<p><strong>编译器是按照什么样的原则进行对齐的?</strong></p>
<p>先让我们看四个重要的基本概念：</p>
<p>1.数据类型自身的对齐值：</p>
<p>对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，单位字节。</p>
<p>2.结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。</p>
<p>3.指定对齐值：#pragma pack (value)时的指定对齐值value。</p>
<p>4.数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。</p>
<p>有了这些值，我们就可以很方便的来讨论具体数据结构的成员和其自身的对齐方式。有效对齐值N是最终用来决定数据存放地址方式的值，最重要。有效对齐N，就是表示“对齐在N上”，也就是说该数据的“存放起始地址%N&#x3D;0”。而数据结构中的数据变量都是按定义的先后顺序来排放的。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐排放，结构体本身也要根据自身的有效对齐值圆整(就是结构体成员变量占用总长度需要是对结构体有效对齐值的整数倍，结合下面例子理解)。这样就不难理解上面的几个例子的值了。</p>
<p>例子分析：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">short</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>假设B从地址空间0x0000开始排放。该例子中没有定义指定对齐值，在笔者环境下，该值默认为4。第一个成员变量b的自身对齐值是1，比指定或者默认指定对齐值4小，所以其有效对齐值为1，所以其存放地址0x0000符合0x0000%1&#x3D;0。第二个成员变量a，其自身对齐值为4，所以有效对齐值也为4，所以只能存放在起始地址为0x0004到0x0007这四个连续的字节空间中，复核0x0004%4&#x3D;0,且紧靠第一个变量。第三个变量c，自身对齐值为2，所以有效对齐值也是2，可以存放在0x0008到0x0009这两个字节空间中，符合0x0008%2&#x3D;0。所以从0x0000到0x0009存放的都是B内容。再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b）所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求，0x0009到0x0000&#x3D;10字节，（10＋2）％4＝0。所以0x000A到0x000B也为结构体B所占用。故B从0x0000到0x000B共有12个字节，sizeof(struct B)&#x3D;12;其实如果就这一个就来说它已经满足字节对齐了，因为它的起始地址是0，因此肯定是对齐的。之所以在后面补充2个字节，是因为编译器为了实现结构数组的存取效率，试想如果我们定义了一个结构B的数组，那么第一个结构起始地址是0没有问题，但是第二个结构呢?按照数组的定义，数组中所有元素都是紧挨着的，如果我们不把结构的大小补充为4的整数倍，那么下一个结构的起始地址将是0x000A，这显然不能满足结构的地址对齐了，因此我们要把结构补充成有效对齐大小的整数倍。其实诸如：对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，这些已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知了，所以他们的自身对齐值也就已知了。</p>
<p>同理，分析下面例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma pack (2) /*指定按2字节对齐*/</span><br><span class="line">struct C</span><br><span class="line">&#123;</span><br><span class="line">    char b;</span><br><span class="line">    int a;</span><br><span class="line">    short c;</span><br><span class="line">&#125;;</span><br><span class="line">#pragma pack () /*取消指定对齐，恢复缺省对齐*/</span><br></pre></td></tr></table></figure>

<p>第一个变量b的自身对齐值为1，指定对齐值为2，所以，其有效对齐值为1，假设C从0x0000开始，那么b存放在0x0000，符合0x0000%1&#x3D;0；第二个变量，自身对齐值为4，指定对齐值为2，所以有效对齐值为2，所以顺序存放在0x0002、0x0003、0x0004、0x0005四个连续字节中，符合0x0002%2&#x3D;0。第三个变量c的自身对齐值为2，所以有效对齐值为2，顺序存放在0x0006、0x0007中，符合0x0006%2&#x3D;0。所以从0x0000到0x00007共八字节存放的是C的变量。又C的自身对齐值为4，所以C的有效对齐值为2。又8%2&#x3D;0，C只占用0x0000到0x0007的八个字节。所以sizeof(struct C)&#x3D;8。</p>
<p><strong>如何修改编译器的默认对齐值?</strong></p>
<p>1.在VC IDE中，可以这样修改：[Project]|[Settings],c&#x2F;c++选项卡Category的Code Generation选项的Struct Member Alignment中修改，默认是8字节。</p>
<p>2.在编码时，可以这样动态修改：#pragma pack。注意：是pragma而不是progma。</p>
<p><strong>针对字节对齐，我们在编程中如何考虑?</strong></p>
<p>如果在编程的时候要考虑节约空间的话,那么我们只需要假定结构的首地址是0，然后各个变量按照上面的原则进行排列即可，基本的原则就是把结构中的变量按照类型大小从小到大声明，尽量减少中间的填补空间。还有一种就是为了以空间换取时间的效率，我们显示的进行填补空间进行对齐，比如：有一种使用空间换时间做法是显式的插入reserved成员：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> a;</span><br><span class="line">	<span class="type">char</span> reserved[<span class="number">3</span>];<span class="comment">//使用空间换时间</span></span><br><span class="line">	<span class="type">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reserved成员对我们的程序没有什么意义，它只是起到填补空间以达到字节对齐的目的。当然即使不加这个成员，通常编译器也会给我们自动填补对齐，我们自己加上它只是起到显式的提醒作用。</p>
<p><strong>字节对齐可能带来的隐患？</strong></p>
<p>代码中关于对齐的隐患，很多是隐式的。比如在强制类型转换的时候。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p=<span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *p1=<span class="literal">NULL</span>;</span><br><span class="line">p=&amp;i;</span><br><span class="line">*p=<span class="number">0x00</span>;</span><br><span class="line">p1=(<span class="type">unsigned</span> <span class="type">short</span> *)(p+<span class="number">1</span>);</span><br><span class="line">*p1=<span class="number">0x0000</span>;</span><br></pre></td></tr></table></figure>

<p>最后两句代码，从奇数边界去访问unsigned short型变量，显然不符合对齐的规定。在x86上，类似的操作只会影响效率，但是在MIPS或者sparc上，可能就是一个error，因为它们要求必须字节对齐。</p>
<p><strong>如何查找与字节对齐方面的问题？</strong></p>
<p>如果出现对齐或者赋值问题首先查看:</p>
<ol>
<li>编译器的big little端设置；</li>
<li>看这种体系本身是否支持非对齐访问；</li>
<li>如果支持，看设置了对齐与否；如果没有，则看访问时需要加某些特殊的修饰来标志其特殊访问操作。</li>
</ol>
<p><strong>ARM下的对齐处理？</strong></p>
<p>对齐的使用：</p>
<p>1.__align(num)</p>
<p>这个用于修改最高级别对象的字节边界。在汇编中使用LDRD或者STRD时，就要用到此命令__align(8)进行修饰限制来保证数据对象是相应对齐。这个修饰对象的命令最大是8个字节限制，可以让2字节的对象进行4字节对齐，但是不能让4字节的对象2字节对齐。__align是存储类修改，它只修饰最高级类型对象，不能用于结构或者函数对象。</p>
<p>2.__packed </p>
<p>__packed是进行一字节对齐</p>
<p>1）不能对packed的对象进行对齐；</p>
<p>2）所有对象的读写访问都进行非对齐访问；</p>
<p>3）float及包含float的结构联合及未用__packed的对象将不能字节对齐；</p>
<p>4）__packed对局部整型变量无影响；</p>
<p>5）强制由unpacked对象向packed对象转化是未定义，整型指针可以合法定义为packed。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__packed int* p;  //__packed int 则没有意义</span><br></pre></td></tr></table></figure>

<p>6）对齐或非对齐读写访问带来问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__packed struct STRUCT_TEST</span><br><span class="line">&#123;</span><br><span class="line">   char a;</span><br><span class="line">   int b;</span><br><span class="line">   char c;</span><br><span class="line">&#125;;    //定义如下结构此时b的起始地址一定是不对齐的</span><br><span class="line">       //在栈中访问b可能有问题,因为栈上数据肯定是对齐访问[from CL]</span><br><span class="line">//将下面变量定义成全局静态不在栈上 </span><br><span class="line">static char* p;</span><br><span class="line">static struct STRUCT_TEST a;</span><br><span class="line">void Main()</span><br><span class="line">&#123;</span><br><span class="line">__packed int* q;  //此时定义成__packed来修饰当前q指向为非对齐的数据地址下面的访问则可以</span><br><span class="line">p = (char*)&amp;a;          </span><br><span class="line">q = (int*)(p+1);      </span><br><span class="line"></span><br><span class="line">*q = 0x87654321; </span><br><span class="line">/*   </span><br><span class="line">得到赋值的汇编指令很清楚</span><br><span class="line">ldr      r5,0x20001590 ; = #0x12345678</span><br><span class="line">[0xe1a00005]   mov      r0,r5</span><br><span class="line">[0xeb0000b0]   bl       __rt_uwrite4  //在此处调用一个写4byte的操作函数 </span><br><span class="line">      </span><br><span class="line">[0xe5c10000]   strb     r0,[r1,#0]   //函数进行4次strb操作然后返回保证了数据正确的访问</span><br><span class="line">[0xe1a02420]   mov      r2,r0,lsr #8</span><br><span class="line">[0xe5c12001]   strb     r2,[r1,#1]</span><br><span class="line">[0xe1a02820]   mov      r2,r0,lsr #16</span><br><span class="line">[0xe5c12002]   strb     r2,[r1,#2]</span><br><span class="line">[0xe1a02c20]   mov      r2,r0,lsr #24</span><br><span class="line">[0xe5c12003]   strb     r2,[r1,#3]</span><br><span class="line">[0xe1a0f00e]   mov      pc,r14</span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line">如果q没有加__packed修饰则汇编出来指令是这样直接会导致奇地址处访问失败</span><br><span class="line">[0xe59f2018]   ldr      r2,0x20001594 ; = #0x87654321</span><br><span class="line">[0xe5812000]   str      r2,[r1,#0]</span><br><span class="line">*/</span><br><span class="line">//这样可以很清楚的看到非对齐访问是如何产生错误的</span><br><span class="line">//以及如何消除非对齐访问带来问题</span><br><span class="line">//也可以看到非对齐访问和对齐访问的指令差异导致效率问题</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关于内存对齐的问题，可以看看<a href="/blog/memory-alignment">《内存对齐详解》</a></p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>c</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>ImageHosting 开源软件的使用说明</title>
    <url>/2016-08-22-ImageHosting-use-introduction/</url>
    <content><![CDATA[<p>博主在转战iOS开发以来，一直坚持撰写自己的技术博客。使用Github Pages + Hexo 搭建了属于自己的空间。具体搭建方法可以参考<a href="/blog/build-blog-by-hexo">《手把手教 GitHub + Hexo 搭建博客》</a> 。 然而，博客中有很多时候需要使用图片说明，俗话说“一图胜千言”，博主使用 七牛云 做图床，然每次编写博客时需要打开Web版上传图片，甚是繁琐。故此，博主自己编写了一个自己的图片上传软件。</p>
<p><img src="/assets/images/tech/ImageHosting-use-introduction-launchpad.png" alt="launchpad"></p>
<p>软件下载地址：<a href="https://github.com/charsdavy/ImageHosting/releases">ImageHosting for Mac</a></p>
<p><a href="https://github.com/charsdavy/ImageHosting">源代码地址</a></p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>遇到提示“不能安装未知来源程序”时，处理方法为，将权限改为“任何来源”即可。</p>
<h2 id="软件菜单栏"><a href="#软件菜单栏" class="headerlink" title="软件菜单栏"></a>软件菜单栏</h2><p><img src="/assets/images/tech/ImageHosting-use-introduction-stateMenu.png" alt="menu"></p>
<h2 id="打开软件配置，添加账户信息"><a href="#打开软件配置，添加账户信息" class="headerlink" title="打开软件配置，添加账户信息"></a>打开软件配置，添加账户信息</h2><p><img src="/assets/images/tech/ImageHosting-use-introduction-account.png" alt="account"></p>
<h2 id="打开文件选择页，选择文件"><a href="#打开文件选择页，选择文件" class="headerlink" title="打开文件选择页，选择文件"></a>打开文件选择页，选择文件</h2><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p><img src="/assets/images/tech/ImageHosting-use-introduction-upload-main.png" alt="main"></p>
<h2 id="上传进度提示"><a href="#上传进度提示" class="headerlink" title="上传进度提示"></a>上传进度提示</h2><p><img src="/assets/images/tech/ImageHosting-use-introduction-upload_1.png" alt="upload1"></p>
<p><img src="/assets/images/tech/ImageHosting-use-introduction-upload_2.png" alt="upload2"></p>
<p><img src="/assets/images/tech/ImageHosting-use-introduction-upload_3.png" alt="upload3"></p>
<h2 id="上传完成"><a href="#上传完成" class="headerlink" title="上传完成"></a>上传完成</h2><p><img src="/assets/images/tech/ImageHosting-use-introduction-upload-success-main.png" alt="finish"></p>
<h2 id="操作提示"><a href="#操作提示" class="headerlink" title="操作提示"></a>操作提示</h2><h3 id="未添加账户信息提示"><a href="#未添加账户信息提示" class="headerlink" title="未添加账户信息提示"></a>未添加账户信息提示</h3><p><img src="/assets/images/tech/ImageHosting-use-introduction-no-account.png" alt="no account"></p>
<h3 id="未选择上传文件提示"><a href="#未选择上传文件提示" class="headerlink" title="未选择上传文件提示"></a>未选择上传文件提示</h3><p><img src="/assets/images/tech/ImageHosting-use-introduction-no-select.png" alt="no select"></p>
<h3 id="上传文件成功提示"><a href="#上传文件成功提示" class="headerlink" title="上传文件成功提示"></a>上传文件成功提示</h3><p><img src="/assets/images/tech/ImageHosting-use-introduction-upload-success.png" alt="upload success"></p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac OS 开发 － 聊聊如何打包dmg文件</title>
    <url>/2016-09-03-mac-os-archive-app/</url>
    <content><![CDATA[<p>最近因为博主自己的需求，而App Store上的App不能满足需求，或者是说，想借此机会涉猎一下Mac OS的开发。之前一直臆想iOS开发和Mac OS差不多，实则不然。</p>
<p>BTW 推荐一款非Apple官方的App Store，<code>HackStore</code>是一款来自俄罗斯的Mac应用商店，我们可以将自己开发完的App免费发布上去，也是具有审核机制的，博主目前推广自己的<code>ImageHosting</code>，一款图床软件，目前支持七牛云存储。有需求欢迎大家使用，吐槽。 <a href="https://github.com/charsdavy/ImageHosting/releases">ImageHosting for Mac</a></p>
<p>现在，分享一下，当我们完成Mac开发，release一个<code>.app</code>文件之后，我们应该如何打包成一个dmg文件的方法。</p>
<p>言归正传，说到dmg，这个我们熟悉的格式，那么它是怎么生成的呢，跟着接下来的步骤吧。博主将它们分为<code>系统默认</code>和<code>自定义</code>，不过，两者都离不开一个工具 －－ <code>磁盘工具（Disk Utility）</code>。</p>
<span id="more"></span>

<h3 id="系统默认"><a href="#系统默认" class="headerlink" title="系统默认"></a>系统默认</h3><p>打开 <code>磁盘工具</code> －&gt; <code>文件</code> －&gt; <code>新建映像</code> －&gt; <code>来自文件夹的映像</code></p>
<p><img src="/assets/images/tech/mac-os-archive-app-default-build.png" alt="磁盘工具"></p>
<p>资源文件夹内容</p>
<p><img src="/assets/images/tech/mac-os-archive-app-default-folder.png" alt="文件夹"></p>
<p>配置 选择包括 <code>.app</code> 和 <code>Applications 替身</code> 文件夹的路径，也就是上图说的 资源文件夹 路径</p>
<p><img src="/assets/images/tech/mac-os-archive-app-default-build-config.png" alt="配置"></p>
<p>点击 <code>打开</code> ，配置相关信息 点击 <code>存储</code> 即可。</p>
<h3 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h3><p>1 准备资源，包括：背景图片，<code>.app</code> 和 <code>Applications 替身</code> 文件。</p>
<p>2 创建一个空的映像文件</p>
<p><img src="/assets/images/tech/mac-os-archive-app-build-blank-dmg.png" alt="创建"></p>
<p>配置信息</p>
<p><img src="/assets/images/tech/mac-os-archive-app-config-blank-dmg.png" alt="配置信息"></p>
<p>3 配置资源 －－ 配置背景图</p>
<p>1）打开显示选项</p>
<p><img src="/assets/images/tech/mac-os-archive-app-blank-fill-src.png" alt="显示"></p>
<p>2）配置背景图</p>
<p><img src="/assets/images/tech/mac-os-archive-app-show-view-option.png" alt="背景图"></p>
<p>3）隐藏背景图片文件</p>
<p>使用<code>mv</code>命令进行重命名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mv background.tif .background.tif</span><br></pre></td></tr></table></figure>

<p><img src="/assets/images/tech/mac-os-archive-app-hidden-bg.png" alt="mv"></p>
<p>4 配置资源 －－ 拖拽<code>.app</code> 和 <code>Applications 替身</code></p>
<p>5 转换</p>
<p><img src="/assets/images/tech/mac-os-archive-app-convert.png" alt="转换"></p>
<p>配置转换信息</p>
<p><img src="/assets/images/tech/mac-os-archive-app-convert-config.png" alt="转换信息"></p>
<p>6 效果</p>
<p><img src="/assets/images/tech/mac-os-archive-app-build-result.png" alt="效果"></p>
<h3 id="附言"><a href="#附言" class="headerlink" title="附言"></a>附言</h3><p>每次自定义类型打包dmg，都需要从零开始，不能使用上一次的未转换时的文件直接替换<code>.app</code>文件。否则，呈现的样式将不是CD样式。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 如何升级 Ruby 版本</title>
    <url>/2016-09-03-mac-ruby-update/</url>
    <content><![CDATA[<p>Ruby 是一种面向对象、命令式、函数式、动态的通用编程语言。 在20世纪90年代中期由日本人松本行弘（Matz）设计并开发。 遵守BSD许可证和Ruby License。 它的灵感与特性来自于Perl、Smalltalk、Eiffel、Ada以及Lisp语言。</p>
<p>Ruby 可运行于多种平台，如 Windows、MAC OS 和 UNIX 的各种版本。</p>
<p>Ruby用于最明显，且和Apple系列的程序员最直接关联的就是Mac的开发环境，直接关联于Cocoapods工具。但是，cocoapods工具与Ruby的版本有一定的关联性，难免不涉及到升级。</p>
<p>那么，如何升级最方便快捷呢？</p>
<p>这就是rvm大展身手的时候啦。rvm是什么？rvm是ruby版本管理器。为什么要安装rvm呢？因为rvm可以让你拥有多个版本的Ruby，并且可以在多个版本之间自由切换。</p>
<span id="more"></span>

<h3 id="第一步：安装rvm"><a href="#第一步：安装rvm" class="headerlink" title="第一步：安装rvm"></a>第一步：安装rvm</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl -L get.rvm.io | bash -s stable</span><br><span class="line">$ source ~/.profile</span><br></pre></td></tr></table></figure>

<p>等待终端加载完毕，后输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rvm -v</span><br></pre></td></tr></table></figure>

<p>如果能显示版本号,则安装成功。</p>
<h3 id="第二步：安装ruby"><a href="#第二步：安装ruby" class="headerlink" title="第二步：安装ruby"></a>第二步：安装ruby</h3><p>列出ruby可安装的版本信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rvm list known</span><br></pre></td></tr></table></figure>

<p>安装一个ruby版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rvm install 2.3</span><br></pre></td></tr></table></figure>

<p>如果想设置为默认版本，可以用这条命令来完成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rvm use 2.1.4 --default</span><br></pre></td></tr></table></figure>

<p>查看已安装的ruby</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rvm list</span><br></pre></td></tr></table></figure>

<p>卸载一个已安装ruby版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ rvm remove 2.3</span><br></pre></td></tr></table></figure>

<h3 id="第三步：更换源"><a href="#第三步：更换源" class="headerlink" title="第三步：更换源"></a>第三步：更换源</h3><p>查看已有的源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gem source -l</span><br></pre></td></tr></table></figure>

<p>显示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CURRENT SOURCES</span><br><span class="line">http://rubygems.org/</span><br></pre></td></tr></table></figure>

<p>然后我们需要修改更换源（由于国内被墙），所以要把源切换至淘宝镜像服务器，在终端执行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gem update --system</span><br><span class="line">$ gem uninstall rubygems-update</span><br><span class="line">$ gem sources -r http://rubygems.org/</span><br><span class="line">$ gem sources -a https://ruby.taobao.org</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Effective Objective-C 2.0 读书笔记 -- 熟悉Objective-C语言</title>
    <url>/2016-09-05-effective-objc-2-introduction-objc/</url>
    <content><![CDATA[<p>看到Effective这个词，大家一定会想到《Effective C++》、《Effective Java》等业界名著，那些书里汇聚了多项实用技巧，又系统而深入的讲解了各种编程知识。那么，《Effective Objective-C 2.0》也是如此。</p>
<p>作为Mac OS X与iOS应用程序的开发语言，Objective-C作为首选。那么，它有哪些需要注意的呢？</p>
<span id="more"></span>

<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>Objective-C与C++、Java一样，是面向对象的语言，是由Smalltalk演化而来。Smalltalk是消息型语言的鼻祖。消息与函数调用之间的区别看上去就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Messaging (Objective-C)</span><br><span class="line">Object *obj = [Object new];</span><br><span class="line">[obj performWith:parameter1 and:parameter2];</span><br><span class="line"></span><br><span class="line">//Function calling (C++)</span><br><span class="line">Object *obj = new Object;</span><br><span class="line">obj-&gt;perform(parameter1, parameter2);</span><br></pre></td></tr></table></figure>

<p>关键区别在于：使用消息结构的语言，其运行时所应执行的代码由运行环境来决定；而使用函数调用的语言，则由编译器决定。</p>
<p>Objective-C是C的“超集”(superset)，所以C语言中的所有功能在编写Objective-C代码时依然适用。理解C语言的内存模型(memory model)，有助于理解Objective-C的内存模型及其“引用计数”(reference counting)机制的工作原理。Objective-C语言中的指针是用来指示对象的。</p>
<h2 id="关于使用头文件"><a href="#关于使用头文件" class="headerlink" title="关于使用头文件"></a>关于使用头文件</h2><p>主要使用 <code>import</code> 关键字。然而，我们在 <code>.h</code> 文件中一般首选使用 <code>@class</code> 关键字，它能“向前声明”一个类。对于不需要知道类细节的情况下我们使用它。否则不会轻易使用 <code>import</code> 来引入整个头文件。</p>
<p>过多的引入头文件，会增加编译时间。这就是我们多使用 <code>@class</code> 关键字的直接原因。</p>
<p>除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用“向前声明”来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合(coupling)。</p>
<p>有时无法使用“向前声明”，比如要声明某个类遵循一项协议。这种情况下，尽量把“该类遵循某协议”的这条声明移至“class-continuation分类”中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。</p>
<h2 id="字面量语法"><a href="#字面量语法" class="headerlink" title="字面量语法"></a>字面量语法</h2><p>在编写Objective-C程序时，总会用到某几个类，它们属于Foundation框架。虽然从技术上来说，不用Foundation框架也能写出Objective-C代码，但是实际上却经常要用到此框架。这几个类是NSString、NUNumber、NSArray、NSDictionary。从类名上即可看出各自所表示的数据结构。</p>
<p>Objective-C以语法繁杂而著称。不过从Objective-C 1.0起，有一种简单的方式能创建NSString 对象。这就是“字符串字面量”(string literal)，其语法如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *string = <span class="string">@&quot;Effective Objective-C 2.0&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="字面数值"><a href="#字面数值" class="headerlink" title="字面数值"></a>字面数值</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *number = [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">10</span>];</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="built_in">NSNumber</span> *number = @<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>更多表示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *intNumber = @<span class="number">11</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *floatNumber = @<span class="number">2.5</span>f;</span><br><span class="line"><span class="built_in">NSNumber</span> *doubleNumber = @<span class="number">3.1415926</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *boolNumber = @YES;</span><br><span class="line"><span class="built_in">NSNumber</span> *charNumber = @<span class="string">&#x27;ABC&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>字面量语法也适用于下述表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x =5;</span><br><span class="line">float y = 6.5f</span><br><span class="line">NSNumber *expressionNumber = @(x * y);</span><br></pre></td></tr></table></figure>

<h3 id="字面量数组"><a href="#字面量数组" class="headerlink" title="字面量数组"></a>字面量数组</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSarray</span> *animals = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@&quot;cat&quot;</span>, <span class="string">@&quot;dog&quot;</span>, <span class="string">@&quot;mouse&quot;</span>, <span class="string">@&quot;badger&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">NSarray</span> *animals = @[<span class="string">@&quot;cat&quot;</span>, <span class="string">@&quot;dog&quot;</span>, <span class="string">@&quot;mouse&quot;</span>, <span class="string">@&quot;badger&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>使用数组</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *dog = [animals objectAtIndex:<span class="number">1</span>];</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">NSString</span> *dog = animals[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<h3 id="字面量字典"><a href="#字面量字典" class="headerlink" title="字面量字典"></a>字面量字典</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *personData = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAnsKeys:<span class="string">@&quot;Matt&quot;</span>, <span class="string">@&quot;firstName&quot;</span>, <span class="string">@&quot;Galloway&quot;</span>, <span class="string">@&quot;lastName&quot;</span>, [<span class="built_in">NSNumber</span> numberWithInt:<span class="number">28</span>], <span class="string">@&quot;age&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *personData = @&#123;<span class="string">@&quot;firstName&quot;</span>:<span class="string">@&quot;Matt&quot;</span>, <span class="string">@&quot;lastName&quot;</span>:<span class="string">@&quot;Galloway&quot;</span>, <span class="string">@&quot;age&quot;</span>:[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">28</span>]&#125;;</span><br></pre></td></tr></table></figure>

<p>使用字典</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *lastName = [personData objectForKey:<span class="string">@&quot;lastName&quot;</span>];</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">NSString</span> *lastName = personData[<span class="string">@&quot;lastName&quot;</span>];</span><br></pre></td></tr></table></figure>

<h3 id="可变数组和字典"><a href="#可变数组和字典" class="headerlink" title="可变数组和字典"></a>可变数组和字典</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[mutableArray replaceObjectAtIndex:<span class="number">1</span> withObject:<span class="string">@&quot;dog&quot;</span>];</span><br><span class="line">[mutableDictionary setObject:<span class="string">@&quot;Galloway&quot;</span> forKey:<span class="string">@&quot;lastName&quot;</span>];</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">mutableArray[<span class="number">1</span>] = <span class="string">@&quot;dog&quot;</span>;</span><br><span class="line">mutableDictionary[<span class="string">@&quot;lastName&quot;</span>] = <span class="string">@&quot;Galloway&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>字面量语法有个小小的限制，就是除了字符串以外，所创建出来的对象必须属于Foundation框架才行。如果自定义了这些类的子类，则无法用字面量语法创建其对象。要想创建自定义子类的实例，必须采用“非字面量语法”(nonliteral syntax)。</p>
<p>使用字面量语法创建出来的字符串、数组、字典对象都是不可变的(immutable)。若想要可变版本的对象，则需要复制一份：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *<span class="keyword">mutable</span> = [@[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>, @<span class="number">4</span>] mutableCopy];</span><br></pre></td></tr></table></figure>

<p>这么做会多调用一个方法，而且还要再创建一个对象，不过使用字面量语法所带来的好处还是多于上述缺点的。</p>
<p>用字面量语法创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值里不含nil。</p>
<h2 id="多用类型常量-少用-define预处理指令"><a href="#多用类型常量-少用-define预处理指令" class="headerlink" title="多用类型常量 少用#define预处理指令"></a>多用类型常量 少用#define预处理指令</h2><p>编写代码时经常要定义常量。掌握了Objective-C与其C语言的基础的人，也许会用这种方法来做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define ANIMATION_DURATION 0.3</span><br></pre></td></tr></table></figure>

<p>上述预处理指令会把源代码中的ANIMATION_DURATION字符串替换为0.3.预处理过程会把碰到的所有ANIMATION_DURATION一律替换成0.3，这样的话，假设此指令声明在某个头文件中，那么所有引入了这个头文件的代码，其ANIMATION_DURATION都会被替换。</p>
<p>要解决此问题，应该设法利用编译器的某些特性才对。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> kAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure>

<p>用此方式定义的常量包含类型信息，其好处的清楚地描述了常量的含义。</p>
<p>常用的命名法是：</p>
<ul>
<li>若常量局限于某”编译单元”(translation unit，也就是“实现文件”，implementation file)之内，则在前面加字母k；</li>
<li>若常量在类之外可见，则通常以类名为前缀。</li>
</ul>
<p>定义常量的位置很重要。在头文件里声明预处理指令，这样会增加常量名称互相冲突的可能性。</p>
<p>在头文件中使用extern来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区隔，通常用与之相关的类名做前缀。</p>
<h2 id="枚举使用"><a href="#枚举使用" class="headerlink" title="枚举使用"></a>枚举使用</h2><p>枚举只是一种常量命名方式。某个对象所经历的各种状态就可以定义为一个简单的枚举集(enumeration set)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IHConnectionState</span> &#123;</span></span><br><span class="line">	IHConnectionStateDisconnected,</span><br><span class="line">	IHConnectionStateConnecting,</span><br><span class="line">	IHConnectionStateConnected</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>默认情况下，枚举起始值为0，以后依次递增，1,2,3…</p>
<p>其实还可以我们自己指定枚举值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IHConnectionState</span> &#123;</span></span><br><span class="line">	IHConnectionStateDisconnected = <span class="number">1</span>,</span><br><span class="line">	IHConnectionStateConnecting,</span><br><span class="line">	IHConnectionStateConnected</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以定义为位移值：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="built_in">UIViewAutoresizing</span> &#123;</span><br><span class="line">	<span class="built_in">UIViewAutoresizing</span> = <span class="number">0</span>,</span><br><span class="line">	<span class="built_in">UIViewAutoresizingFlexibleLeftMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">	<span class="built_in">UIViewAutoresizingFlexibleWidth</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">	<span class="built_in">UIViewAutoresizingFlexibleRightMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">	<span class="built_in">UIViewAutoresizingFlexibleTopMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">	<span class="built_in">UIViewAutoresizingFlexibleHeight</span> = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">	<span class="built_in">UIViewAutoresizingFlexibleBottomMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>关于枚举，Foundation框架中定义了一些辅助的宏，用这些来定义枚举类型时，也可以指定用于保存枚举值的底层数据类型。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, IHConnectionState) &#123;</span><br><span class="line">	IHConnectionStateDisconnected = <span class="number">1</span>,</span><br><span class="line">	IHConnectionStateConnecting,</span><br><span class="line">	IHConnectionStateConnected</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, IHPermittedDirection) &#123;</span><br><span class="line">	IHPermittedDirectionUp = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">	IHPermittedDirectionDown = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">	IHPermittedDirectionLeft = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">	IHPermittedDirectionRight = <span class="number">1</span> &lt;&lt; <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这些宏的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span>(__cplusplus &amp;&amp; __cplusplus &gt;= 201103L &amp;&amp; (__has_extension(cxx_strong_enums) || __has_feature(objc_fixed_enum))) || (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum))</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> NS_ENUM(_type, _name)</span></span><br><span class="line">		<span class="class"><span class="keyword">enum</span> _<span class="title">name</span>:</span>_type _name; <span class="class"><span class="keyword">enum</span> _<span class="title">name</span>:</span>_type</span><br><span class="line">	<span class="meta">#<span class="keyword">if</span> (__cplusplus)</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> NS_OPTIONS(_type, _name)</span></span><br><span class="line">			type _name; <span class="class"><span class="keyword">enum</span>:</span>_type</span><br><span class="line">	<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> NS_OPTIONS(_type, _name)</span></span><br><span class="line">			<span class="class"><span class="keyword">enum</span> _<span class="title">name</span>:</span>_type _name; <span class="class"><span class="keyword">enum</span> _<span class="title">name</span>:</span>_type</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> NS_ENUM(_type, _name) _type _name; enum</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> NS_OPTIONS(_type, _name) _type _name; enum</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>第一个#if用于判断编译器是否支持新式枚举。如果不支持，那么就用老式语法来定义枚举。</p>
<p>在处理枚举类型的switch语句中不要实现default分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch语句并未处理所有枚举。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>objc</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS App 上架（Analysis 工具使用）</title>
    <url>/2016-11-15-apple-app-release-analysis/</url>
    <content><![CDATA[<p>随着iOS开发的流行，针对iOS开发涉及的方方面面，早有一些公司提供了专门的解决方案或工具。这些解决方案或工具包括：用户行为统计工具（友盟，Flurry，Google Analytics等), App Store销售分析工具（例如App annie)， App crash收集工具（例如Crashlytics)，App测试发布工具（Test Flight）, App Push服务等。</p>
<p>这些解决方案或工具节省了iOS开发者大量的开发时间，但是由于相关介绍文章的缺乏，许多开发者都在重复着自己一次又一次重新造轮子。所以将自己使用的相关的第三方服务使用经验，整理成一系列文章，以便广大开发者能够省去大量的重复性工作。</p>
<span id="more"></span>

<h1 id="用户习惯数据收集"><a href="#用户习惯数据收集" class="headerlink" title="用户习惯数据收集"></a>用户习惯数据收集</h1><p>了解用户的使用习惯以及相关数据信息，可以更好的帮助开发者调整产品的方向和重点。首先是数据的收集，受工作的影响，选择 <a href="https://mtj.baidu.com/">百度移动统计</a> 。不得不说，这是一款很符合国人使用习惯的工具。</p>
<p>使用方法很简单，接入过程直接根据官方文档。自定义统计事件需要自己在web端逐个添加。而页面访问统计则不需要，只需要在App上将名字传入调用接口即可。</p>
<p>百度移动统计不仅仅是做应用统计，也可以做crash分析，游戏统计分析，DSP统计，还有广告营销分析。</p>
<p>页面数据的分析，可以帮助开发者很明了的知道用户群体的习惯与流失，有助于产品成长。</p>
<h1 id="Crash-数据收集"><a href="#Crash-数据收集" class="headerlink" title="Crash 数据收集"></a>Crash 数据收集</h1><p>作为上线App，最担心的就是crash数据的收集。<a href="http://try.crashlytics.com/">Crashlytics</a> 是专门为移动应用开者发提供的保存和分析应用崩溃信息的工具。</p>
<h2 id="使用Crashlytics的好处"><a href="#使用Crashlytics的好处" class="headerlink" title="使用Crashlytics的好处"></a>使用Crashlytics的好处</h2><ul>
<li><p>Crashlytics不会漏掉任何应用崩溃信息。在iTunes Connect的后台查看不到任何崩溃信息。但是用户通过微博或者客服电话反馈应用崩溃的情况，在Crashlytics中都可以统计到。</p>
</li>
<li><p>Crashlytics可以像Bug管理工具那样，管理这些崩溃日志。例如：Crashlytics会根据每种类型的Crash的出现频率以及影响的用户量来自动设置优先级。对于每种类型的Crash，Crashlytics除了会像一般的工具提供Call Stack外，还会显示更多相关的有助于诊断的信息，例如：设备是否越狱，当时的内存量，当时的iOS版本等。对于修复掉的Crash日志，可以在Crashlytics的后台将其关掉。</p>
</li>
<li><p>Crashlytics可以每天和每周将崩溃信息汇总发到你的邮箱，所有信息一目了然。</p>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li>注册</li>
</ul>
<p>使用邮箱在<a href="http://try.crashlytics.com/">Crashlytic官网</a>注册。稍后会收到官方验证邮件，根据邮件内容及稍后提示一步步操作。</p>
<ul>
<li>接入工程</li>
</ul>
<p>根据官方接入引导<a href="https://www.fabric.io/kits">教程</a>，分为使用pod方式和手动下载sdk接入方式。具体的可以根据官方文档来操作。这里主要分享一下自己遇到的问题。</p>
<ol>
<li><p>忘记添加 Run Script ，这个步骤会导致App无法build成功。</p>
</li>
<li><p>重新配置 Crashlytics 之后，需要删除 <code>~/Library/Caches/com.crashlytics.data/</code> 和 <code>~/Library/Caches/com.crashlytics.mac/</code> 文件夹下的所有文件，重新build。</p>
</li>
<li><p>注意配置 <code>Build Settings</code> 中 <code>Debug Information Format</code> 选项将debug和release全部设置成<code>DWARF with dSYM File</code>。</p>
</li>
<li><p>如果提示 <code>missing dSYMs</code> ，就需要自行上载文件，具体<a href="https://docs.fabric.io/apple/crashlytics/missing-dsyms.html">方法教程</a> 。</p>
</li>
</ol>
<p>希望对大家有所帮助。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>application</tag>
      </tags>
  </entry>
  <entry>
    <title>常见问题</title>
    <url>/2016-11-24-niffler-help-cn/</url>
    <content><![CDATA[<p><strong>今日账单</strong>，最简洁、快速的随手记账软件，广大用户的共同选择！您的财务管家！<br>极简的记账操作流程，让您轻松上手！</p>
<p>年度趋势、月度分析、图表统计等可视化的数据展示，让您的账单一目了然！</p>
<p>下载应用请前往 @AppStore ，搜索 ‘今日账单’ 即可。</p>
<span id="more"></span>

<h3 id="为什么我无法购买黄金版"><a href="#为什么我无法购买黄金版" class="headerlink" title="为什么我无法购买黄金版"></a>为什么我无法购买黄金版</h3><p>因为我们无法确认您的购买资格或者无法连接到 App Store，这些操作需要联网和相关权限。可以参考如下步骤解决问题。</p>
<h3 id="购买或者恢复购买失败"><a href="#购买或者恢复购买失败" class="headerlink" title="购买或者恢复购买失败"></a>购买或者恢复购买失败</h3><p>请尝试按以下顺序解决问题：</p>
<p>1.检查是否已开通‘今日账单’的网络权限；</p>
<p>2.检查是否限制了 App 内购买项目；</p>
<p>3.检查当前登录的 Apple ID 是否为您购买‘今日账单’时所用的账号；</p>
<p>4.退出 App Store 登录的账号再重新登录。</p>
<p>5.换一个网络；</p>
<p>6.重新启动设备；</p>
<p>7.重置设备的网络设置。</p>
<p>如果仍然无法解决您的问题，可以尝试等待 24 小时后再操作。您也可以联系我们，联系方式可以在 App 的‘设置’页面里找到。</p>
<h3 id="怎样才算老用户"><a href="#怎样才算老用户" class="headerlink" title="怎样才算老用户"></a>怎样才算老用户</h3><p>如果您在 App Store 购买过‘今日账单’，并且购买时的版本小于 3.7，那么您就是老用户。</p>
<h3 id="图表功能"><a href="#图表功能" class="headerlink" title="图表功能"></a>图表功能</h3><ul>
<li>“趋势”页面</li>
</ul>
<p>在“图表” –&gt; “趋势”页面，点击下图中红色方框区域，可以进入某月份中开销详情页面。</p>
<p>在里面可以清晰的看到某月的所有消费记录。</p>
<p><img src="/assets/images/niffler/niffler_help_trend@3x.png" alt="趋势页面"></p>
<ul>
<li>“统计”页面</li>
</ul>
<p>在“图表” –&gt; “统计”页面，点击下图中红色方框区域，可以进入某月开销分类排行。</p>
<p>按照开销数额，降序排序，清晰掌握各类开销某月总额。</p>
<p><img src="/assets/images/niffler/niffler_help_summary@3x.png" alt="统计页面"></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本文档对应 App 版本为 3.7.4 及以上</p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>Niffler</tag>
      </tags>
  </entry>
  <entry>
    <title>FAQ</title>
    <url>/2016-11-24-niffler-help-en/</url>
    <content><![CDATA[<p><strong>Niffler</strong>, the most simple and fast easy-to-handle accounting software, the common choice of the majority of users! Your financial steward!</p>
<p>Visualize the data such as annual trends, monthly analysis, chart statistics, etc., so that your account is clear!</p>
<p>Please go to @AppStore and searching ‘Niffler’, downloading it.</p>
<span id="more"></span>

<h3 id="Why-can’t-I-purchase-Niffler’s-Golden"><a href="#Why-can’t-I-purchase-Niffler’s-Golden" class="headerlink" title="Why can’t I purchase Niffler’s Golden?"></a>Why can’t I purchase Niffler’s Golden?</h3><p>Because we can’t confirm your purchase eligibility or connect to App Store, these operations require networking and permissions. Please follow to the following steps to solve the problem.</p>
<h3 id="How-do-I-resolve-a-purchase-or-restore-purchase-failure"><a href="#How-do-I-resolve-a-purchase-or-restore-purchase-failure" class="headerlink" title="How do I resolve a purchase or restore purchase failure?"></a>How do I resolve a purchase or restore purchase failure?</h3><p>Please try to solve the problem in the following order:</p>
<p>1.Check if Niffler’s network permissions are enabled(Chinese devices only).</p>
<p>2.Check if in-app purchases are restricted.</p>
<p>3.Check if the currently logged in Apple ID is the account you used when purchasing Niffler.</p>
<p>4.Sign out of App Store and sign in again.</p>
<p>5.Change to another network.</p>
<p>6.Reboot the device.</p>
<p>7.Reset the device’s network settings.</p>
<p>If you still can’t resolve your issue, try waiting 24 hours before proceeding. You can also contact us, contact information can be found in the Niffler’s settings.</p>
<h3 id="What-is-an-old-user"><a href="#What-is-an-old-user" class="headerlink" title="What is an old user?"></a>What is an old user?</h3><p>If you have purchased Niffler in App Store and the version at the time of purchase is less than 3.7, then you are an old user.</p>
<h3 id="Chart-function"><a href="#Chart-function" class="headerlink" title="Chart function"></a>Chart function</h3><ul>
<li>Trend page</li>
</ul>
<p>On the “Chart”-&gt; “Trend” page, click on the red square area in the figure below to enter the details page for the mid-month expenses.</p>
<p>It can clearly see all the consumption records of a certain month.</p>
<p><img src="/assets/images/niffler/niffler_help_trend@3x.png" alt="Trend page"></p>
<ul>
<li>Summary page</li>
</ul>
<p>On the “Chart”-&gt; “Summary” page, click on the red box in the figure below to enter the monthly expense classification ranking.</p>
<p>Sort by the amount of expenses in descending order to clearly grasp the total amount of various expenses for a month.</p>
<p><img src="/assets/images/niffler/niffler_help_summary@3x.png" alt="Summary page"></p>
<h3 id="Postscript"><a href="#Postscript" class="headerlink" title="Postscript"></a>Postscript</h3><p>This document corresponds to App version 3.7.4 and above.</p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>Niffler</tag>
      </tags>
  </entry>
  <entry>
    <title>App 支持</title>
    <url>/2016-11-24-niffler-support-cn/</url>
    <content><![CDATA[<p>如果您对 <strong>今日账单</strong> 有任何疑问，您可以通过多种渠道联系到我。</p>
<p>下载应用请前往 @AppStore ，搜索 ‘今日账单’ 即可。</p>
<span id="more"></span>

<h3 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h3><p>邮箱：<a href="mailto:app_sev@163.com">app_sev@163.com</a></p>
<h3 id="社交网络"><a href="#社交网络" class="headerlink" title="社交网络"></a>社交网络</h3><p>微博：<a href="https://weibo.com/7368041683/profile?topnav=1&wvr=6&is_all=1">@今日账单</a></p>
<p>Twitter：<a href="https://twitter.com/Niffler_App">@Niffler_App</a></p>
<h3 id="及时聊天"><a href="#及时聊天" class="headerlink" title="及时聊天"></a>及时聊天</h3><p>QQ：<a href="https://shang.qq.com/wpa/qunwpa?idkey=6b659d16d298f355e2cbd90e0611f9fc46c3f75b29b5a55d80068c333078792a">967567398</a></p>
<p>Telegram：<a href="https://t.me/charsdavy">charsdavy</a></p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>Niffler</tag>
      </tags>
  </entry>
  <entry>
    <title>App Support</title>
    <url>/2016-11-24-niffler-support-en/</url>
    <content><![CDATA[<p>If you have any question about <strong>Niffler</strong>, you can contact me in multiple ways.</p>
<p>Please go to @AppStore , and search ‘Niffler’ , downloading it.</p>
<span id="more"></span>

<h3 id="Sending-Email"><a href="#Sending-Email" class="headerlink" title="Sending Email"></a>Sending Email</h3><p>Mail：<a href="mailto:app_sev@163.com">app_sev@163.com</a></p>
<h3 id="Social"><a href="#Social" class="headerlink" title="Social"></a>Social</h3><p>Weibo：<a href="https://weibo.com/7368041683/profile?topnav=1&wvr=6&is_all=1">@今日账单</a></p>
<p>Twitter：<a href="https://twitter.com/Niffler_App">@Niffler_App</a></p>
<h3 id="Instant-Messaging"><a href="#Instant-Messaging" class="headerlink" title="Instant Messaging"></a>Instant Messaging</h3><p>QQ：<a href="https://shang.qq.com/wpa/qunwpa?idkey=6b659d16d298f355e2cbd90e0611f9fc46c3f75b29b5a55d80068c333078792a">967567398</a></p>
<p>Telegram：<a href="https://t.me/charsdavy">charsdavy</a></p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>Niffler</tag>
      </tags>
  </entry>
  <entry>
    <title>日语-形容词的分类和变形</title>
    <url>/2016-12-26-japanese-adjective/</url>
    <content><![CDATA[<p>形容词（Adjective），很多语言中均有的主要词类中的一种。形容词主要用来描写或修饰名词或代词，表示人或事物的性质、 状态、特征<br>或属性，常用作定语，也可作表语、补语或状语。</p>
<p>日语中的形容词分为两大类，称为一类形容词和二类形容词（简称，形1和形2）。形容词所表示的事物的属性，一般具有静止的、固定的、永恒的特点。</p>
<span id="more"></span>

<h2 id="1-形容词分类"><a href="#1-形容词分类" class="headerlink" title="1 形容词分类"></a>1 形容词分类</h2><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>一类形容词（形1）</td>
<td>以い结尾的词</td>
<td>美味しい（おいしい）、暑い（あっい）</td>
</tr>
<tr>
<td>二类形容词（形2）</td>
<td>不以い结尾的词</td>
<td>元気（げんき）、暇（ひま）</td>
</tr>
</tbody></table>
<p><strong>注意特例</strong></p>
<p><code>綺麗い（きれい）、嫌い（きらい）、いっぱい</code> 是形2。</p>
<h2 id="2-形容词变形"><a href="#2-形容词变形" class="headerlink" title="2 形容词变形"></a>2 形容词变形</h2><h3 id="2-1-形容词变否定"><a href="#2-1-形容词变否定" class="headerlink" title="2.1 形容词变否定"></a>2.1 形容词变否定</h3><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>一类形容词（形1）</td>
<td>去い变成くない或者くありません</td>
<td>１）この料理は美味しくないです。２）この料理は美味しくありません。</td>
</tr>
<tr>
<td>二类形容词（形2）</td>
<td>形2＋ではありません</td>
<td>この通りはにぎやかではありません。</td>
</tr>
</tbody></table>
<p><strong>注意特例</strong></p>
<p><code>いいです</code>的否定形式是<code>よくないです</code>或<code>よくありません</code>。</p>
<h3 id="2-2-形容词变过去时"><a href="#2-2-形容词变过去时" class="headerlink" title="2.2 形容词变过去时"></a>2.2 形容词变过去时</h3><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>一类形容词（形1）</td>
<td>去い变成かった</td>
<td>よい-&gt;よかった</td>
</tr>
<tr>
<td>二类形容词（形2）</td>
<td></td>
<td>有名です-&gt;有名でした</td>
</tr>
</tbody></table>
<h3 id="2-3-形容词变过去否定时"><a href="#2-3-形容词变过去否定时" class="headerlink" title="2.3 形容词变过去否定时"></a>2.3 形容词变过去否定时</h3><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>一类形容词（形1）</td>
<td>去い变成くなかった</td>
<td>よい-&gt;よくなかった</td>
</tr>
<tr>
<td>二类形容词（形2）</td>
<td></td>
<td>有名です-&gt;有名ではありませんでした</td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<table>
<thead>
<tr>
<th>时态</th>
<th>一类形容词</th>
<th>变形</th>
<th>二类形容词</th>
<th>变形</th>
</tr>
</thead>
<tbody><tr>
<td>否定</td>
<td>よい</td>
<td>よくない</td>
<td>有名です</td>
<td>有名ではありません</td>
</tr>
<tr>
<td>过去时</td>
<td>よい</td>
<td>よかった</td>
<td>有名です</td>
<td>有名でした</td>
</tr>
<tr>
<td>过去否定时</td>
<td>よい</td>
<td>よくなかった</td>
<td>有名です</td>
<td>有名ではありませんでした</td>
</tr>
</tbody></table>
<h3 id="2-4-形容词变副词"><a href="#2-4-形容词变副词" class="headerlink" title="2.4 形容词变副词"></a>2.4 形容词变副词</h3><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>一类形容词（形1）</td>
<td>去い变成く</td>
<td>多い（おおい）-&gt;多く</td>
</tr>
<tr>
<td>二类形容词（形2）</td>
<td>直接加に</td>
<td>きれい-&gt;きれいに</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<p>名词变副词规则与形2一致。</p>
<h3 id="2-5-形容词变て形"><a href="#2-5-形容词变て形" class="headerlink" title="2.5 形容词变て形"></a>2.5 形容词变て形</h3><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>一类形容词（形1）</td>
<td>去い变成くて</td>
<td>広い（ひろい）-&gt;広くて</td>
</tr>
<tr>
<td>二类形容词（形2）</td>
<td>直接加で</td>
<td>簡単（かんたん）-&gt;簡単で</td>
</tr>
</tbody></table>
<p><strong>注意</strong><br>いい不能用来变形，要用其对应的よい进行变形。</p>
<p>名词变て形规则与形2一致。</p>
<h3 id="2-6-形容词变ば形"><a href="#2-6-形容词变ば形" class="headerlink" title="2.6 形容词变ば形"></a>2.6 形容词变ば形</h3><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>一类形容词（形1）</td>
<td>去い变成ければ</td>
<td>広い（ひろい）-&gt;広ければ</td>
</tr>
<tr>
<td>二类形容词（形2）</td>
<td>直接加なれば</td>
<td>簡単（かんたん）-&gt;簡単なれば</td>
</tr>
</tbody></table>
<h3 id="2-7-形容词名词化"><a href="#2-7-形容词名词化" class="headerlink" title="2.7 形容词名词化"></a>2.7 形容词名词化</h3><table>
<thead>
<tr>
<th>类型</th>
<th>规则</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>一类形容词（形1）</td>
<td>去い变成さ</td>
<td>多い（おおい）-&gt;多さ</td>
</tr>
<tr>
<td>二类形容词（形2）</td>
<td>直接加さ</td>
<td>きれい-&gt;きれいさ</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<p>きれい-&gt;きれいさ  ❌</p>
<p>暇-&gt;暇さ   ❌</p>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>日语</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 安装和配置 Tomcat</title>
    <url>/2017-01-02-mac-install-apache-tomcat/</url>
    <content><![CDATA[<p>Tomcat是由Apache软件基金会下属的Jakarta项目开发的一个Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。由于Tomcat本身也内含了一个HTTP服务器，它也可以被视作一个单独的Web服务器。但是，不能将Tomcat和Apache Web服务器混淆，Apache Web Server是一个用C语言实现的HTTP web server；这两个HTTP web server不是捆绑在一起的。Apache Tomcat包含了一个配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。</p>
<p>这篇文章主要介绍Mac环境下，使用Eclipse + Tomcat搭建Java EE开发环境。</p>
<span id="more"></span>

<h2 id="下载资源"><a href="#下载资源" class="headerlink" title="下载资源"></a>下载资源</h2><p>前去<a href="http://tomcat.apache.org/">官网</a>下载安装包，<code>zip</code>和<code>tar.gz</code>均可。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>解压下载的压缩包文件，将文件放置<code>/Library/Tomcat</code>路径。</p>
<p>设置权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod 755  /Library/Tomcat/bin/*.sh</span><br></pre></td></tr></table></figure>

<h2 id="启动Tomacat"><a href="#启动Tomacat" class="headerlink" title="启动Tomacat"></a>启动Tomacat</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sh /Library/Tomcat/bin/startup.sh</span><br></pre></td></tr></table></figure>

<p>成功的话会出现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tomcat started.</span><br></pre></td></tr></table></figure>

<p>打开浏览器输入：<code>localhost:8080</code> 。就可以看见Tomcat:</p>
<p><img src="/assets/images/tech/mac-install-apache-tomcat.png" alt="View"></p>
<h2 id="关闭Tomcat"><a href="#关闭Tomcat" class="headerlink" title="关闭Tomcat"></a>关闭Tomcat</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sh /Library/Tomcat/bin/shutdown.sh</span><br></pre></td></tr></table></figure>

<h2 id="创建快捷命令"><a href="#创建快捷命令" class="headerlink" title="创建快捷命令"></a>创建快捷命令</h2><p>每次按照上述的开启，关闭命令来操作，太麻烦，我们可以使用下列方法创建简洁快捷的命令。</p>
<h4 id="创建shell文件"><a href="#创建shell文件" class="headerlink" title="创建shell文件"></a>创建shell文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/bin </span><br><span class="line">sudo touch tomcat</span><br></pre></td></tr></table></figure>

<h4 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 777 /usr/local/bin/tomcat </span><br></pre></td></tr></table></figure>

<h4 id="添加shell代码"><a href="#添加shell代码" class="headerlink" title="添加shell代码"></a>添加shell代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">case $1 in</span><br><span class="line">start)</span><br><span class="line">sudo sh /Library/Tomcat/bin/startup.sh</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">sudo sh /Library/Tomcat/bin/shutdown.sh</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line">sudo sh /Library/Tomcat/bin/shutdown.sh</span><br><span class="line">sudo sh /Library/Tomcat/bin/startup.sh</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;Usage: start|stop|restart&quot;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tomcat start</span><br><span class="line">tomcat stop</span><br><span class="line">tomcat restart</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>为了便于配置Tomcat，我们需要安装Eclipse <a href="https://sourceforge.net/projects/tomcatplugin/?source=typ_redirect">Tomcat插件</a> 。</p>
<p>打开Eclipse，选择菜单中的Preferences，选择Tomcat的版本，安装路径等。</p>
<p><img src="/assets/images/tech/mac-install-apache-tomcat-02.png" alt="Preferences"></p>
<h2 id="第一个Web程序"><a href="#第一个Web程序" class="headerlink" title="第一个Web程序"></a>第一个Web程序</h2><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ol>
<li><p><code>File</code>-&gt;<code>New</code>-&gt;<code>Dynamic Web Project</code></p>
</li>
<li><p><code>File</code>-&gt;<code>New</code>-&gt;<code>JSP File</code><br> 新建JSP文件<code>index.jsp</code>，保存在<code>WebContent</code>根目录下。</p>
</li>
<li><p>添加代码至<code>index.jsp</code>文件</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">    pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;% java.util.Date d = new java.util.Date(); %&gt;</span><br><span class="line">&lt;h1&gt;</span><br><span class="line">Today&#x27;s date is &lt;%= d.toString() %&gt; and this jsp page worked!</span><br><span class="line">&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>选中项目，<code>Run As</code>-&gt;<code>Run on Server</code></p>
<p><img src="/assets/images/tech/mac-install-apache-tomcat-03.png" alt="Run"></p>
<p>运行效果：</p>
<p><img src="/assets/images/tech/mac-install-apache-tomcat-04.png" alt="Result"></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>个人作品</title>
    <url>/2017-02-02-personal-projects/</url>
    <content><![CDATA[<p>偶尔写写自己的小应用，主要有 <a href="https://itunes.apple.com/cn/app/id1188174656">Piclip</a>、<a href="https://itunes.apple.com/cn/app/id1176787145">今日账单</a> 等。</p>
<span id="more"></span>

<h2 id="今日账单"><a href="#今日账单" class="headerlink" title="今日账单"></a><a href="https://itunes.apple.com/cn/app/id1176787145">今日账单</a></h2><p>———— 清晰简洁、记录每一单</p>
<p>帐单记录与数据分析，内含云备份功能，界面简洁清爽。</p>
<p>下载地址：<a href="https://itunes.apple.com/cn/app/id1176787145">https://itunes.apple.com/cn/app/id1176787145</a></p>
<p><img src="/assets/images/tech/personal-projects-popularize_ibill.png" alt="今日账单"></p>
<h2 id="Piclip"><a href="#Piclip" class="headerlink" title="Piclip"></a><a href="https://itunes.apple.com/cn/app/id1188174656">Piclip</a></h2><p>———— 切图分享、不一样的风格</p>
<p>即兴想起的一款九宫格切图软件，当然还有六、四等宫格布局。</p>
<p>下载地址：<a href="https://itunes.apple.com/cn/app/id1188174656">https://itunes.apple.com/cn/app/id1188174656</a></p>
<p><img src="/assets/images/tech/personal-projects-popularize_piclip.png" alt="Piclip"></p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>project</tag>
      </tags>
  </entry>
  <entry>
    <title>日语-动词的变形和分类</title>
    <url>/2017-02-26-japanese-verb/</url>
    <content><![CDATA[<p>动词（Verb），简称v 。 一般就是用来表示动作或状态的词汇。基本上每个完整的句子都有一个动词，要表示第二个动作时可使用不定词、动名词、对等连接词、从属连接词或增加子句等方法连结。&lt;比如&gt; 突跃,突击,突袭等描述动作过程均属动词。中文语法中表示人或事物的动作或一种动态变化。一般出现在名词主语或主句后面。</p>
<p>日语中动词主要分为3大类，称为一类动词，二类动词和三类动词（简称，动1，动2和动3），而三类动词中又可以分为2类，即カ变和サ变动词。另外，还有一种经常用到的动词，即授受动词。</p>
<span id="more"></span>

<h2 id="1-授受动词"><a href="#1-授受动词" class="headerlink" title="1 授受动词"></a>1 授受动词</h2><h3 id="1-1-授受主体为物品"><a href="#1-1-授受主体为物品" class="headerlink" title="1.1 授受主体为物品"></a>1.1 授受主体为物品</h3><ul>
<li>あげます：我或我方给别人，常用于上对下</li>
</ul>
<p>私は小野さんにパンカチをあげます。<br>彼氏は李さんにバラをあげます。</p>
<p><strong>注意：</strong>若分不清我方和别人时，一律用这种句型。</p>
<p>父は母に本をあげます。<br>私は先生に本をあげます。</p>
<p><strong>注意：</strong>变疑问句</p>
<p>[我方]は誰（だれ）に何をあげますか。</p>
<ul>
<li>もらいます：我或我方从别人那里得到，礼貌用法</li>
</ul>
<p>私は先生から<strong>に</strong>辞書をもらいます。<br>私は会社<strong>から</strong>パソコンをもらいます。</p>
<p><strong>注意：</strong>别人为个人时，后面用に；别人为团体时，后面用から。</p>
<ul>
<li>くれます：别人给我或我方，平级间使用</li>
</ul>
<p>先生は私に辞書をくれます。<br>社長は弟におもちゃをくれます。</p>
<p><strong>注意</strong> 还有一些动词也属于授受类，例如，借东西，还东西。</p>
<p>教えます、貸します：我或我方教别人学习东西或借东西给别人。<br>習います、借ります：我或我方跟别人学习东西或从别人那里借东西。</p>
<h3 id="1-2-授受主体为动作"><a href="#1-2-授受主体为动作" class="headerlink" title="1.2 授受主体为动作"></a>1.2 授受主体为动作</h3><ul>
<li>てあげます：我或我方为别人做某事，常用于上对下</li>
</ul>
<p>おじいさんが孫(まご)に本を読んであげました。<br>分(わ)からないですか、じゃ教え(おしえ)てあげましよう。</p>
<ul>
<li>てもらいます：我或我方请别人做某事，礼貌用法</li>
</ul>
<p>冷蔵庫はもう電話して明日送(おく)ってもらいました。<br>冷蔵庫はもう電話して明日届(とど)けてもらいました。</p>
<ul>
<li>てくれます：别人为我或我方做某事，平级间使用</li>
</ul>
<p>信(しん)じてくれて。<br>ごみを出(だ)してくれますか。</p>
<h2 id="2-自动词和他动词"><a href="#2-自动词和他动词" class="headerlink" title="2 自动词和他动词"></a>2 自动词和他动词</h2><h3 id="2-1-他动词"><a href="#2-1-他动词" class="headerlink" title="2.1 他动词"></a>2.1 他动词</h3><p>带宾语才能完整表达意思。<br><strong>规律：</strong>え段＋る；以す结尾。<br>ドアを開ける、消す、話す</p>
<h3 id="2-2-自动词"><a href="#2-2-自动词" class="headerlink" title="2.2 自动词"></a>2.2 自动词</h3><p>无需带宾语就能完整表达意思。<br><strong>规律：</strong>あ段＋る；一般以く结尾。<br>ドアが開く、歩く、咲く</p>
<h3 id="2-3-分类"><a href="#2-3-分类" class="headerlink" title="2.3 分类"></a>2.3 分类</h3><ul>
<li>没有他动词的自动词</li>
</ul>
<p>歩く、帰る、行く、遊ぶ、走る</p>
<ul>
<li>没有自动词的他动词</li>
</ul>
<p>食べる、見る、話す、言う、買う、飲む</p>
<ul>
<li>既有自动词，也有他动词</li>
</ul>
<p>開ける、開く；閉める、閉まる</p>
<ul>
<li>既是自动词，又是他动词</li>
</ul>
<p>笑う（わらう）、終わる、休み</p>
<h2 id="3-动词分类"><a href="#3-动词分类" class="headerlink" title="3 动词分类"></a>3 动词分类</h2><p>| 类型 | 规则 | 示例 |<br>| —| — | — | — |<br>| 一类动词（动1）| 以う段假名结尾的词　|　行く、読む、帰る（かえる）、滑る（すべる）　|<br>| 二类动词（动2）| 以る结尾，且る前为い段假名或え段假名的词　|　寝る、見る、食べる （<strong>注意</strong>一个汉字一个音）|<br>| 三类动词（サ变）| する（万能动词）|　勉強する、電話する　|<br>| 三类动词（カ变）|　来（く）る　|　|</p>
<h2 id="4-动词变形"><a href="#4-动词变形" class="headerlink" title="4 动词变形"></a>4 动词变形</h2><h3 id="4-1-原形变ます形"><a href="#4-1-原形变ます形" class="headerlink" title="4.1 原形变ます形"></a>4.1 原形变ます形</h3><p>| 类型 | 规则 | 示例 |<br>| —| — | — | — |<br>| 一类动词 | う段-&gt;い段＋ます　|　行く-&gt;行きます　|<br>| 二类动词 | 去る-&gt;＋ます　|　見る-&gt;見ます　|<br>| 三类动词（サ变）|　する-&gt;します　|　勉強する-&gt;勉強します　|<br>| 三类动词（カ变）|　くる-&gt;きます　|　来る-&gt;来ます　|</p>
<h3 id="4-2-ます形变原形"><a href="#4-2-ます形变原形" class="headerlink" title="4.2 ます形变原形"></a>4.2 ます形变原形</h3><p>| 类型 | 规则 | 示例 |<br>| —| — | — | — |<br>| 一类动词 | 去掉ます，将ます前一个假名按行后移一个　|　あります-&gt;ある　|<br>| 二类动词 | 将ます去掉，直接换成る　|　見ます-&gt;見る　|<br>| 三类动词（サ变）|　します-&gt;する　|　勉強します-&gt;勉強する　|<br>| 三类动词（カ变）|　きます-&gt;くる　|　来ます-&gt;来る　|</p>
<h3 id="4-3-原形变命令形"><a href="#4-3-原形变命令形" class="headerlink" title="4.3 原形变命令形"></a>4.3 原形变命令形</h3><p>| 类型 | 规则 | 示例 |<br>| —| — | — | — |<br>| 一类动词 | 去掉最后一个假名按行后移到え段　|　とまります-&gt;とまれ、行く-&gt;行け、死(し)ぬ-&gt;死ね　|<br>| 二类动词 | 将る去掉，直接换成ろ　|　見る-&gt;見ろ、やめる-&gt;やめろ、逃(に)げる-&gt;逃げろ　|<br>| 三类动词（サ变）|　する-&gt;しろ　|　勉強する-&gt;勉強しろ　|<br>| 三类动词（カ变）|　来(く)る-&gt;こい　|　来る-&gt;こい　|</p>
<p>命令形一般男性使用，但是在看球赛或危险时使用。<br>女性可以使用<code>动词&lt;动词ます形去掉ます&gt;+なさい</code>语法来表达。</p>
<p>しっかりしろ。给我醒醒。</p>
<h3 id="4-4-原形变意志形（よう形）"><a href="#4-4-原形变意志形（よう形）" class="headerlink" title="4.4 原形变意志形（よう形）"></a>4.4 原形变意志形（よう形）</h3><p><code>动词よう形</code>是<code>动词ましよう</code>的口语，表示劝诱。翻译成“···吧”</p>
<p>| 类型 | 规则 | 示例 |<br>| —| — | — | — |<br>| 一类动词 | 把最后一个假名变成え段，再加ば　|　行く-&gt;行けば　|<br>| 二类动词 | 将る去掉，直接换成れば　|　見る-&gt;見れば　|<br>| 三类动词（サ变）|　する-&gt;すれば　|　勉強する-&gt;勉強すれば　|<br>| 三类动词（カ变）|　くる-&gt;くれば　|　来る-&gt;くれば　|</p>
<h3 id="4-5-原形变ば形"><a href="#4-5-原形变ば形" class="headerlink" title="4.5 原形变ば形"></a>4.5 原形变ば形</h3><p>| 类型 | 规则 | 示例 |<br>| —| — | — | — |<br>| 一类动词 | 把最后一个假名变成お段，再加う　|　行く-&gt;行こう　|<br>| 二类动词 | 将る去掉，直接换成よう　|　見る-&gt;見よう　|<br>| 三类动词（サ变）|　する-&gt;しよう　|　勉強する-&gt;勉強しよう　|<br>| 三类动词（カ变）|　くる-&gt;こよう　|　来る-&gt;来よう　|</p>
<h3 id="4-6-原形变能动态-られる"><a href="#4-6-原形变能动态-られる" class="headerlink" title="4.6 原形变能动态(られる)"></a>4.6 原形变能动态(られる)</h3><p>| 类型 | 规则 | 示例 |<br>| —| — | — | — |<br>| 一类动词 | 把最后一个假名变成え段，再加る　|　行く-&gt;行ける　|<br>| 二类动词 | 将る去掉，直接换成られる　|　見る-&gt;見られる　|<br>| 三类动词（サ变）|　する-&gt;できる　|　勉強する-&gt;勉強できる　|<br>| 三类动词（カ变）|　くる-&gt;こられる　|　来る-&gt;こられる　|</p>
<p><strong>注意：</strong> を要变が，其他不变。</p>
<h3 id="4-7-原形变被动态-される"><a href="#4-7-原形变被动态-される" class="headerlink" title="4.7 原形变被动态(される)"></a>4.7 原形变被动态(される)</h3><p>| 类型 | 规则 | 示例 |<br>| —| — | — | — |<br>| 一类动词 | 把最后一个假名变成あ段，再加れる　|　行く-&gt;行かれる、買う-&gt;買われる　|<br>| 二类动词 | 将る去掉，直接换成られる　|　見る-&gt;見られる　|<br>| 三类动词（サ变）|　する-&gt;される　|　勉強する-&gt;勉強される　|<br>| 三类动词（カ变）|　くる-&gt;こられる　|　来る-&gt;こられる　|</p>
<h3 id="4-8-原形变使役态-させる"><a href="#4-8-原形变使役态-させる" class="headerlink" title="4.8 原形变使役态(させる)"></a>4.8 原形变使役态(させる)</h3><p>| 类型 | 规则 | 示例 |<br>| —| — | — | — |<br>| 一类动词 | 把最后一个假名变成あ段，再加せる　|　行く-&gt;行かせる　|<br>| 二类动词 | 将る去掉，直接换成させる　|　見る-&gt;見させる　|<br>| 三类动词（サ变）|　する-&gt;させる　|　勉強する-&gt;勉強させる　|<br>| 三类动词（カ变）|　くる-&gt;こさせる　|　来る-&gt;こさせる　|</p>
<h3 id="4-9-原形变使役被动态-させられる"><a href="#4-9-原形变使役被动态-させられる" class="headerlink" title="4.9 原形变使役被动态(させられる)"></a>4.9 原形变使役被动态(させられる)</h3><p>| 类型 | 规则 | 示例 |<br>| —| — | — | — |<br>| 一类动词 | 把最后一个假名变成あ段，再加される&#x2F;せられる　|　行く-&gt;行かされる、行く-&gt;行かせられる　|<br>| 二类动词 | 将る去掉，直接换成させられる　|　見る-&gt;見させられる　|<br>| 三类动词（サ变）|　する-&gt;させられる　|　勉強する-&gt;勉強させられる　|<br>| 三类动词（カ变）|　くる-&gt;こさせられる　|　来る-&gt;こさせられる　|</p>
<h3 id="4-10-原形变て形"><a href="#4-10-原形变て形" class="headerlink" title="4.10 原形变て形"></a>4.10 原形变て形</h3><p>て形作用：两个动词间使用，表中顿，表相继；语法接续。</p>
<ul>
<li>一类动词变て形</li>
</ul>
<p>1）う、つ、る结尾，促音变。即去掉结尾假名变成って</p>
<p>示例：買う-&gt;買って、待つ-&gt;待って、売る（うる）-&gt;売って</p>
<p>2）ぬ、ぶ、む结尾，拨音变。即去掉结尾假名变成んで</p>
<p>示例：死ぬ-&gt;死んで、飛ぶ-&gt;飛んで、飲む-&gt;飲んで</p>
<p>3）く、ぐ结尾，い音变。即去掉结尾假名分别变成いて、いで</p>
<p>示例：歩く-&gt;歩いて、急ぐ-&gt;急いで</p>
<p>4）す变成して</p>
<p>示例：話す-&gt;話して</p>
<p><strong>特例</strong><br>行く-&gt;行って</p>
<ul>
<li>二类动词变て形</li>
</ul>
<p>去る+て</p>
<p>示例：見る-&gt;見て、食べる-&gt;食べて</p>
<ul>
<li>三类动词变て形</li>
</ul>
<p>1）する-&gt;して</p>
<p>示例：勉強する-&gt;勉強して</p>
<p>2）来る（くる）-&gt;来て（きて）</p>
<h3 id="4-11-原形变た形"><a href="#4-11-原形变た形" class="headerlink" title="4.11 原形变た形"></a>4.11 原形变た形</h3><p>变形规则和原形变て形一样，只要将て换成た即可。</p>
<h3 id="4-12-原形变ない形"><a href="#4-12-原形变ない形" class="headerlink" title="4.12 原形变ない形"></a>4.12 原形变ない形</h3><ul>
<li>一类动词变ない形</li>
</ul>
<p>变う段为あ段+ない</p>
<p>示例：行く（いく）-&gt;行か（いか）ない</p>
<p><strong>特例：</strong>う-&gt;わ</p>
<p>手伝う（てつだう）-&gt;手伝わない（てつだわない）</p>
<ul>
<li>二类动词变ない形</li>
</ul>
<p>去る+ない</p>
<p>示例：見る-&gt;見ない、食べる-&gt;食べない</p>
<ul>
<li>三类动词变ない形</li>
</ul>
<p>1）する-&gt;しない</p>
<p>示例：勉強する-&gt;勉強しない</p>
<p>2）来る（くる）-&gt;来ない（こない）</p>
<h3 id="4-13-原形变禁止形"><a href="#4-13-原形变禁止形" class="headerlink" title="4.13 原形变禁止形"></a>4.13 原形变禁止形</h3><p>动词原形+な</p>
<h2 id="5-动词规则"><a href="#5-动词规则" class="headerlink" title="5 动词规则"></a>5 动词规则</h2><ul>
<li>一类动词</li>
</ul>
<table>
<thead>
<tr>
<th>あ段</th>
<th>い段</th>
<th>う段</th>
<th>え段</th>
<th>お段</th>
</tr>
</thead>
<tbody><tr>
<td>ない形</td>
<td>ます形</td>
<td>原形</td>
<td>命令形&#x2F;能动态(え段+る)</td>
<td>意志形</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>日语</tag>
      </tags>
  </entry>
  <entry>
    <title>FMDB 代码阅读</title>
    <url>/2017-03-21-fmdb-reading/</url>
    <content><![CDATA[<p><a href="https://github.com/ccgus/fmdb">FMDB</a> 是iOS平台的SQLite数据库框架，以ObjC的方式封装了SQLite的C语言的API。FMDB使用起來更加的面向对象，省去了很多麻烦、冗余的C语言代码。相比Apple自带的Core Data框架，更加的轻量和灵活。提供了多线程安全的数据库操作的方法，有效的防止数据混乱。</p>
<span id="more"></span>

<h2 id="项目文件"><a href="#项目文件" class="headerlink" title="项目文件"></a>项目文件</h2><ul>
<li><p>FMDatabase : 一个SQLite数据库操作单例，通过它可以对数据库进行增删改查等操作。</p>
</li>
<li><p>FMResultSet : FMDatabase执行查询之后的结果集。</p>
</li>
<li><p>FMDatabaseAdditions : 拓展FMDatabase类，新增对查询结果只返回单个值的方法进行简化，对表、列是否存在，版本号，校验SQL等功能。</p>
</li>
<li><p>FMDatabaseQueue : 使用串行对列 ，操作多线程。</p>
</li>
<li><p>FMDatabasePool : 使用任务池的形式，操作多线程。</p>
</li>
</ul>
<h2 id="FMDatabase"><a href="#FMDatabase" class="headerlink" title="FMDatabase"></a>FMDatabase</h2><h3 id="打开数据库连接"><a href="#打开数据库连接" class="headerlink" title="打开数据库连接"></a>打开数据库连接</h3><ul>
<li><p><code>-(BOOL)open;</code> 其实是对sqlite3_open()函数的封装。</p>
</li>
<li><p><code>- (void)setMaxBusyRetryTimeInterval:(NSTimeInterval)timeout;</code> 设置重试时间。其实调用的是 <code>int sqlite3_busy_handler(sqlite3 *,int(*)(void *,int),void *);</code></p>
</li>
</ul>
<p>该函数的第一个参数：需要告知哪一个数据库需要设置busy handler。</p>
<p>第二个参数：需要回调的busy handler，当你调用该回调函数的时候，需要传给它一个void*的参数，也就是sqlite3_busy_handler的第三个参数。</p>
<p>第三个参数：需要传给回调函数的int参数表示这次锁事件，该回调函数被调用的次数。如果回调函数返回0时，将不再尝试再次访问数据库，而返回SQLITE_BUSY或者SQLITE_IOERR_BLOCKED。如果回调函数返回非0，将会不断尝试操作数据库。程序运行过程中，如果有其他进程或者线程在读写数据库，那么sqlite3_busy_handler会不断用用该回调函数，直到其他线程或者进程释放锁。获得锁之后，不会再调用该回调函数，从而继续向下执行下去，进行数据库操作。该函数是在获取不到锁的时候，以执行回调函数的次数來进行延时，等待其他进程或者线程操作数据库结束，从而获得锁进行操作数据库。</p>
<h3 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h3><p>executeQuery 系列函数从根本上看，其实调用的都是</p>
<p><code>- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args</code></p>
<ul>
<li><p>参数sql: 需要查詢的sql语句。</p>
</li>
<li><p>参数arrayArgs: 数组类型的参数。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FMResultSet *resultSet = [_db executeQuery:@&quot;SELECT * FROM t_student WHERE age &gt; ?&quot; withArgumentsInArray:@[@20]];</span><br></pre></td></tr></table></figure>

<ul>
<li>参数dictionaryArgs: 字典类型的参数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FMResultSet *resultSet = [_db executeQuery:@&quot;SELECT * FROM t_student WHERE age &gt; :age&quot; withParameterDictionary:@&#123;@&quot;age&quot;:@20&#125;];</span><br></pre></td></tr></table></figure>

<ul>
<li>参数args: 可变参数类型。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FMResultSet *resultSet = [_db executeQuery:@&quot;SELECT * FROM t_student WHERE age &gt; ?&quot;,@(20)];</span><br></pre></td></tr></table></figure>

<h3 id="更新数据库操作"><a href="#更新数据库操作" class="headerlink" title="更新数据库操作"></a>更新数据库操作</h3><p>这并不只是单单更新数据，而是对数据库有更改的操作，增删改都算。FMDB调用的都是<code>executeupdate</code>系列函数。这个函数基本上跟<code>executeQuery</code>系列函数的实现基本相同。只是它生成statement对象后，直接调用<code>rc = sqlite3_step(pStmt);</code>更新执行，而没有像<code>executeQuery</code>延迟到FMResultSet中的next函数中执行。</p>
<h3 id="一次性执行多条sql语句。"><a href="#一次性执行多条sql语句。" class="headerlink" title="一次性执行多条sql语句。"></a>一次性执行多条sql语句。</h3><p>使用<code>executeStatements</code>函数可以一次性执行多条sql语句。其实现方式就是对<code>sqlite3_exec</code>函数的封装。</p>
<h3 id="FMDB的加解密"><a href="#FMDB的加解密" class="headerlink" title="FMDB的加解密"></a>FMDB的加解密</h3><p>FMDataase中使用<code>- (BOOL)setKey:(NSString*)key;</code>和<code>- (BOOL)setKeyWithData:(NSData *)keyData;</code>输入数据库密码以求验证用户身份，使用<code>- (BOOL)rekey:(NSString*)key;</code>和<code>- (BOOL)rekeyWithData:(NSData *)keyData;</code>来给数据库设置密码或者清除密码。这两类函数分別对<code>sqlite3_key</code>和<code>sqlite3_rekey</code>函数进行了封装。</p>
<h2 id="FMDatabaseAdditions"><a href="#FMDatabaseAdditions" class="headerlink" title="FMDatabaseAdditions"></a>FMDatabaseAdditions</h2><h3 id="XXXForQuery系列函数"><a href="#XXXForQuery系列函数" class="headerlink" title="XXXForQuery系列函数"></a>XXXForQuery系列函数</h3><p>对查询结果只有一个值的情况进行优化，有多个值也只取第一个值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  使用FMDatabaseAdditions中的intForQuery函数查找数据,如果返回结果有多个数据只取第一条数据</span><br><span class="line"> */</span><br><span class="line">- (void)queryForIntForQuery&#123;</span><br><span class="line">    int idx = [_db intForQuery:@&quot;SELECT id FROM t_student WHERE age = ?&quot;,@(26)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据库的一些概要信息"><a href="#数据库的一些概要信息" class="headerlink" title="数据库的一些概要信息"></a>数据库的一些概要信息</h3><p><code>-(BOOL)tableExists:(NSString*)tableName;</code>数据库表是否存在。</p>
<p><code>-(BOOL)columnExists:(NSString*)columnName inTableWithName:(NSString*)tableName;</code>在tableName表中columnName是否存在。</p>
<p><code>-(FMResultSet*)getSchema;</code>数据库的一些概要信息。</p>
<h3 id="校验sql语句是否合法"><a href="#校验sql语句是否合法" class="headerlink" title="校验sql语句是否合法"></a>校验sql语句是否合法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(BOOL)validateSQL:(NSString *)sql error:(NSError **)error;</span><br></pre></td></tr></table></figure>

<h2 id="FMResultSet"><a href="#FMResultSet" class="headerlink" title="FMResultSet"></a>FMResultSet</h2><h3 id="初始化对象"><a href="#初始化对象" class="headerlink" title="初始化对象"></a>初始化对象</h3><ul>
<li>参数1：(FMStatement *)statement</li>
</ul>
<p>该对象主要是对sqlite3_stmt的封装，sqlite3_stmt * 所表示的内容可以看成是预处理过的sql语句，已经不是我们熟知的sql语句。它是一个已经把sql语句解析了，用sqlite自己表示记录的内部数据结构。</p>
<ul>
<li>参数2：(FMDatabase *)aDB<br>该结果集所属于的FMDatabase数据库操作对象。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (instancetype)resultSetWithStatement:(FMStatement *)statement usingParentDatabase:(FMDatabase*)aDB;</span><br></pre></td></tr></table></figure>

<h3 id="遍历取得所有的结果集合"><a href="#遍历取得所有的结果集合" class="headerlink" title="遍历取得所有的结果集合"></a>遍历取得所有的结果集合</h3><p><code>-(BOOL)next;</code> 其实是对 <code>-(BOOL)nextWithError:(NSError **)outErr;</code> 函数的封装。主要作用是通过sqlite3_step函数对FMStatement中的sqlite3_stmt对象进行逐行取值。</p>
<h3 id="列名与该列的列数的一一对应关系"><a href="#列名与该列的列数的一一对应关系" class="headerlink" title="列名与该列的列数的一一对应关系"></a>列名与该列的列数的一一对应关系</h3><ul>
<li><p><code>@property (readonly) NSMutableDictionary  *columnNameToIndexMap;</code> 对象中保存了列名与索引一一对应的关系的对照表。</p>
</li>
<li><p><code>-(int)columnIndexForName:(NSString *)columnName;</code> 根据列名获取该列所在第几列（列的索引）</p>
</li>
<li><p><code>-(NSString *)columnNameForIndex:(int)columnIdx;</code> 根据列的索引获取该列的名称。</p>
</li>
</ul>
<h3 id="获得每一行中每一个列字段的值。"><a href="#获得每一行中每一个列字段的值。" class="headerlink" title="获得每一行中每一个列字段的值。"></a>获得每一行中每一个列字段的值。</h3><ul>
<li><p><code>-XXXForColumnIndex:(int)columnIdx;</code> 根据列的索引获取该列的值。</p>
</li>
<li><p><code>-XXXForColumn:(NSString*)columnName;</code> 根据列的名称获取该列的值。</p>
</li>
<li><p><code>-XXXForColumnIndex:(int)columnIdx;</code> 其实是对sqlite3_column_*函数的封装。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (int)intForColumnIndex:(int)columnIdx &#123;</span><br><span class="line">    return sqlite3_column_int([_statement statement], columnIdx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取每一行中所有的结果集合"><a href="#获取每一行中所有的结果集合" class="headerlink" title="获取每一行中所有的结果集合"></a>获取每一行中所有的结果集合</h3><p><code>- (NSDictionary*)resultDictionary;</code></p>
<h2 id="FMDatabaseQueue"><a href="#FMDatabaseQueue" class="headerlink" title="FMDatabaseQueue"></a>FMDatabaseQueue</h2><p>使用实例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];</span><br><span class="line"></span><br><span class="line">[queue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line">    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:1]];</span><br><span class="line">    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:2]];</span><br><span class="line">    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:3]];</span><br><span class="line"></span><br><span class="line">    FMResultSet *rs = [db executeQuery:@&quot;select * from foo&quot;];</span><br><span class="line">    while ([rs next]) &#123;</span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[queue inTransaction:^(FMDatabase *db, BOOL *rollback) &#123;</span><br><span class="line">    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:1]];</span><br><span class="line">    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:2]];</span><br><span class="line">    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:3]];</span><br><span class="line"></span><br><span class="line">    if (whoopsSomethingWrongHappened) &#123;</span><br><span class="line">        *rollback = YES;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // etc…</span><br><span class="line">    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:4]];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>数据库中的事务也是保证数据库安全的一种手段。一段sql语句，要么全部成功，要么全部不成功。</p>
<ul>
<li>关于延时性事务和独占性事务的区别</li>
</ul>
<p>在SQLite 3.0.8或更高版本中，事务可以是延迟的，即时的或者独占的。“延迟的”即是说在数据库第一次被访问之前不获得锁。这样就会延迟事务，BEGIN语句本身不做任何事情。直到初次读取或访问数据库时才获取锁。对数据库的初次读取创建一个SHARED锁，初次写入创建一个RESERVED锁。由于锁的获取被延迟到第一次需要时，别的线程或进程可以在当前线程执行BEGIN语句之后创建另外的事务写入数据库。若事务是即时的，则执行BEGIN命令后立即获取RESERVED锁，而不等数据库被使用。在执行BEGIN IMMEDIATE之后， 你可以确保其它的线程或进程不能写入数据库或执行BEGIN IMMEDIATE或BEGIN EXCLUSIVE. 但其它进程可以获取数据库。 独占事务在所有的数据库获取EXCLUSIVE锁，在执行BEGIN EXCLUSIVE之后，你可以确保在当前事务结束前没有任何其它线程或进程能够读写数据库。</p>
<h2 id="FMDatabasePool"><a href="#FMDatabasePool" class="headerlink" title="FMDatabasePool"></a>FMDatabasePool</h2><p>FMDatabasePool : 使用任务池的形式，对多线程的操作提供支持。</p>
<p>不过官方对这种方式并不推荐使用（ONLY_USE_THE_POOL_IF_YOU_ARE_DOING_READS_OTHERWISE_YOULL_DEADLOCK_USE_FMDATABASEQUEUE_INSTEAD），优先选择FMDatabaseQueue的方式。</p>
]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>objc</tag>
        <tag>ios</tag>
        <tag>存储</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 安装配置</title>
    <url>/2017-03-22-mysql-install-config/</url>
    <content><![CDATA[<p><a href="https://www.mysql.com/">MySQL</a>是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。<br>MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。<br>MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。</p>
<span id="more"></span>

<p>以v5.6.36为例</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>拷贝<code>/usr/local/mysql/support-files/</code>中<code>my-default.cnf</code>文件，改名为<code>my.cnf</code>并放至<code>/usr/local/mysql/</code>文件夹下。</p>
<p>后续数据库的配置都可以在此文件中设置。</p>
<h2 id="密码修改"><a href="#密码修改" class="headerlink" title="密码修改"></a>密码修改</h2><p>Mac 安装完 MySQL 之后，软件会生成一个默认密码给我们。但是，当我使用Navicat来建立连接是却提示密码失效，无奈，只能修改数据库默认密码。</p>
<p>接下来，记录整个root密码修改过程。</p>
<p><strong>在开始下面的步骤之前必须先停止mysql服务！</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1, cd /usr/local/mysql/bin/</span><br><span class="line">2, sudo su</span><br></pre></td></tr></table></figure>

<p>跨过权限验证:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3, ./mysqld_safe --skip-grant-tables &amp;</span><br></pre></td></tr></table></figure>

<p>这时不要关窗口，再打开一个终端窗口。以root身份登录，因为第三步的原因不需要密码了。</p>
<p><del>4, .&#x2F;mysql -uroot</del> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4，sudo /usr/local/mysql/bin/mysql -u root</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5, use mysql;</span><br><span class="line">6, update user set authentication_string=&#x27;123456&#x27; where User=&#x27;root&#x27;;</span><br><span class="line">7, flush privileges;</span><br><span class="line">8, exit;</span><br></pre></td></tr></table></figure>

<p>网上流传的版本全部是set password ＝‘’ ，这样写一直报错说 ‘password’列不存在！<br>最终用sql命令查出来只有authentication_string字段，并没有password字段。</p>
<p>上一步执行之后本来以为已经可以登录了，可是navicat连接测试时出现了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR 1862 (HY000): Your password has expired. To log in you must</span><br><span class="line">change it using a client that supports expired passwords.</span><br></pre></td></tr></table></figure>

<p>所以还需要下面步骤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1, cd /usr/local/mysql/bin/</span><br><span class="line">2, sudo su</span><br><span class="line">3, ./mysql -uroot  -p123456</span><br><span class="line">4, set password = password(&#x27;123456&#x27;)</span><br></pre></td></tr></table></figure>

<p>用户名：root，密码：123456<br>修改成功</p>
<p>关闭或启动MySQL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /usr/local/mysql/support-files/mysql.server stop</span><br><span class="line">sudo /usr/local/mysql/support-files/mysql.server start</span><br></pre></td></tr></table></figure>

<p>打开MySQL数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo /usr/local/mysql/bin/mysql -uroot  -p123456</span><br></pre></td></tr></table></figure>

<h3 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h3><p>可能在打开数据库时会出现下面错误提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Warning: Using a password on the command line interface can be insecure.</span><br><span class="line">ERROR 1045 (28000): Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: YES)</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<p>在<code>my.cnf</code>配置文件中添加账户配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">user = whatever #账户，一般配置root</span><br><span class="line">password = whatever #账户密码</span><br><span class="line">host = whatever #主机，可以为localhost</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>为了方便使用，我们可以设置几个常用的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动MySQL</span><br><span class="line">startmysql() &#123;</span><br><span class="line">	sudo /usr/local/mysql/support-files/mysql.server start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 关闭MySQL</span><br><span class="line">stopmysql() &#123;</span><br><span class="line">	sudo /usr/local/mysql/support-files/mysql.server stop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 连接MySQL</span><br><span class="line">openmysql() &#123;</span><br><span class="line">	sudo /usr/local/mysql/bin/mysql -u&quot;$1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>日语-助词</title>
    <url>/2017-03-26-japanese-auxiliary-word/</url>
    <content><![CDATA[<p>助词，又称为语助词。文法术语，指的是一种词类，属于虚词，附着在其他词汇、词组，或是句子上，作为辅助之用。通常用于句子前、中、后，表示各种语气；或是用于语句中间，表示结构上的关系。</p>
<p>日语中的助词极为丰富，而每一个助词的使用场景也非常多，不得不承认这是一大难点，也是重点。</p>
<span id="more"></span>

<h2 id="1-に用法"><a href="#1-に用法" class="headerlink" title="1 に用法"></a>1 に用法</h2><ul>
<li>1）表地点，场所名词+に+名词，具体位置</li>
</ul>
<p>部屋に机があります。</p>
<ul>
<li>2）表时间点（包含数字的时间）</li>
</ul>
<p>学校は８時半に始まります。</p>
<ul>
<li>3）表附着点</li>
</ul>
<ol>
<li>温泉に入ります。</li>
<li>船に乗ります。</li>
</ol>
<ul>
<li>4）表目的</li>
</ul>
<ol>
<li>日本へ花見に行きます。</li>
<li>土曜日か日曜日に買い物に行きます。（第一个に表示时间点，第二个に表示目的）</li>
</ol>
<ul>
<li>5）表对象，人物对象，抽象事物</li>
</ul>
<p>友達に会います。</p>
<ul>
<li>6）表频率</li>
</ul>
<ol>
<li>李さんは１週間に２回プールへ行きます。</li>
<li>李さんは週に２回プールへ行きます。</li>
</ol>
<ul>
<li>7）表目的地</li>
</ul>
<ol>
<li>日本に行きます。</li>
<li>家に帰ります。</li>
</ol>
<ul>
<li>8）表选择</li>
</ul>
<p>赤いほうがいいです。じゃあ、これにします。</p>
<ul>
<li>9）表基准（“相对而言”）</li>
</ul>
<p>体にいいです。对身体好。</p>
<ul>
<li>10）表结果</li>
</ul>
<p>中国語を日本語に訳(やく)す。</p>
<h2 id="2-で用法"><a href="#2-で用法" class="headerlink" title="2 で用法"></a>2 で用法</h2><ul>
<li>1）表交通手段</li>
</ul>
<p>上海まで飛行機で行きます。</p>
<ul>
<li>2）表地点范围，名词+で+动词</li>
</ul>
<ol>
<li>図書館で勉強します。</li>
<li>お昼は食堂（しよくどう）で食べます。</li>
<li>妹は部屋で音樂を聞きます。</li>
</ol>
<ul>
<li>3）表方式，手段</li>
</ul>
<ol>
<li>速達で送ります。</li>
<li>メールで両親と連絡します。</li>
</ol>
<ul>
<li>4）表原材料（で表示能看出原材料，から表示不能看出原材料）</li>
</ul>
<p>こむぎこでパンを作ります。</p>
<ul>
<li>5）表花费（时间，金钱）</li>
</ul>
<p>このケーキは３個で１５０円です。</p>
<ul>
<li>6）表主体</li>
</ul>
<p>みなさんで読みましょう。</p>
<ul>
<li>7）表并列（二类形容词或名词）</li>
</ul>
<p>森さんは親切（しんせつ）で優（やさ）しいです。</p>
<ul>
<li>8）表原因、理由</li>
</ul>
<p>仕事(しごと)、楊(よう)さんと会(あ)っていたんですよ。</p>
<ul>
<li>9）表状态</li>
</ul>
<p>患者(かんじゃ)でいっぱい。</p>
<h3 id="2-1-で和に的区别"><a href="#2-1-で和に的区别" class="headerlink" title="2.1 で和に的区别"></a>2.1 で和に的区别</h3><p>１）で强调后接动态动词。に强调后接静态动词。</p>
<h2 id="3-が用法"><a href="#3-が用法" class="headerlink" title="3 が用法"></a>3 が用法</h2><ul>
<li>1）表情感词前</li>
</ul>
<p>ネズミがこれい。</p>
<ul>
<li>2）表能力词前</li>
</ul>
<ol>
<li>日本語が分かる。</li>
<li>日本語ができる。</li>
</ol>
<ul>
<li>3）自动词前</li>
</ul>
<ol>
<li>足が疲れる。</li>
<li>足が痛い。</li>
</ol>
<ul>
<li>4）形容词前</li>
</ul>
<p>箱根はホテルや旅館が多いですね。</p>
<ul>
<li>5）存在句（が表听话方不知道的，は表双方都知道的）</li>
</ul>
<p>ホテルで友達の写真展があります。</p>
<ul>
<li>6）疑问词作主语</li>
</ul>
<p>この中でどの料理がいちばんおいしいですか。</p>
<h2 id="4-を用法"><a href="#4-を用法" class="headerlink" title="4 を用法"></a>4 を用法</h2><ul>
<li>1）表对象，动宾结构，名词+を+动词</li>
</ul>
<p>パンヤミルクなどを食べます。</p>
<ul>
<li>2）表范围，路线</li>
</ul>
<p>駅前を通る（とおる）。</p>
<ul>
<li>3）表出发点</li>
</ul>
<p>家をでます。</p>
<h2 id="5-から用法"><a href="#5-から用法" class="headerlink" title="5 から用法"></a>5 から用法</h2><ul>
<li>1）表时间起点</li>
</ul>
<p>來週、金曜日の夜７時から、ホテルでパーテイーがあります。</p>
<ul>
<li>2）表空间起点</li>
</ul>
<p>大阪（おおさか）から上海（シャンハイ）まで飛行機（ひこうき）で行きますか。</p>
<ul>
<li>3）表因为</li>
</ul>
<p>私はドリアンを全然食べません。嫌いですから。</p>
<h2 id="6-へ用法"><a href="#6-へ用法" class="headerlink" title="6 へ用法"></a>6 へ用法</h2><ul>
<li>1）表去向</li>
</ul>
<p>吉田さんは中国へ行きます。</p>
<h2 id="7-か用法"><a href="#7-か用法" class="headerlink" title="7 か用法"></a>7 か用法</h2><ul>
<li>1）表选择，二选一，名词+か+名词</li>
</ul>
<p>毎月（まいつき）１回か２回映画（えいが）を見ます。</p>
<h2 id="8-假设用法总结"><a href="#8-假设用法总结" class="headerlink" title="8 假设用法总结"></a>8 假设用法总结</h2><h3 id="8-1-と"><a href="#8-1-と" class="headerlink" title="8.1 と"></a>8.1 と</h3><p><strong>注意：</strong>不能和祈使语气连用。</p>
<p><code>动词原形／动词ない形+と</code>表示必然结果或假设。</p>
<h4 id="8-1-1-必然结果"><a href="#8-1-1-必然结果" class="headerlink" title="8.1.1 必然结果"></a>8.1.1 必然结果</h4><p>翻译成 “一···就···”。</p>
<ul>
<li>1）恒常状态</li>
</ul>
<ol>
<li>ボタンを押す（おす）と電源（でんげん）が入る（はいる）。</li>
<li>お金を入れ（いれ）ると、切符（きっぷ）が出る（だる）。</li>
</ol>
<ul>
<li>2）自然现象</li>
</ul>
<ol>
<li>春（はる）になると、花（はな）が咲く（さく）。</li>
<li>夜（よる）になると、気温（きおん）が下がる（さがる）。</li>
</ol>
<ul>
<li>3）习惯</li>
</ul>
<ol>
<li>彼（あれ）は家（うち）に帰ると、パソコンに向かって（むかって）いる。</li>
<li>朝起（お）きると、コーヒーを飲む。</li>
</ol>
<ul>
<li>4）意外发现</li>
</ul>
<ol>
<li>学校（がっこう）に着（つき）くと、雨（あめ）が止（や）んだ。</li>
<li>窓（まど）を開（ひら）けると、富士山が見えました。</li>
</ol>
<ul>
<li>5）客观真理</li>
</ul>
<p>道（みち）を右（みぎ）に曲がる（まがる）と、床屋（とこや）があります。</p>
<p><code>床屋：理发店</code></p>
<h4 id="8-1-2-假设"><a href="#8-1-2-假设" class="headerlink" title="8.1.2 假设"></a>8.1.2 假设</h4><p>翻译成“如果···的话”。</p>
<p>人間（にんげん）は水（みず）を飲まないと、生（い）きていけない。</p>
<h3 id="8-2-たら"><a href="#8-2-たら" class="headerlink" title="8.2 たら"></a>8.2 たら</h3><p><code>动词た形</code>&#x2F;<code>A1 かった</code>&#x2F;<code>N/A2 だった</code>+ら表示假设，意外发现，之后。</p>
<p>N&#x2F;A2 で<del>は</del>なかったら 表示假设，意外发现，之后。</p>
<p>例句：</p>
<ol>
<li><p>1億（おく）円の宝くじに当たったら、世界旅行をします。</p>
</li>
<li><p>安かったら買います。</p>
</li>
<li><p>明日暇だったら、行きません。</p>
</li>
<li><p>明日雨だったら、行きません。</p>
</li>
<li><p>明日雨で<del>は</del>なかったら、行く。</p>
</li>
<li><p>窓を開けたら、富士山が見えた。</p>
</li>
<li><p>会社へ行ったら、休みだった。</p>
</li>
<li><p>家に着いたら、電話してください。</p>
</li>
<li><p>卒業したら、どうするつもりですか。</p>
</li>
</ol>
<h3 id="8-3-ば"><a href="#8-3-ば" class="headerlink" title="8.3 ば"></a>8.3 ば</h3><p><code>&lt;条件&gt;</code></p>
<p>一般不能用于祈使语气，但是，当前后主语不一样时可以使用祈使语气。<br>前项是后项的条件。</p>
<p>例句：</p>
<ol>
<li>暇があれば行きます。“只要闲暇就去。”</li>
<li>夏になれば、海へ行く。“一到夏天就去海边。”</li>
<li>体が元気であれば、働いていきます。“如果身体健康，一直工作下去。”</li>
<li>安ければ、買う。“如果便宜就买。”</li>
<li>天気がよければ、行きます。“如果天气好就去。”</li>
<li>あなたが行げば、私も行く。“如果你去，我就去。”</li>
<li>質題があれば、聞いてください。“(你)如果有问题，请问我。”</li>
<li>雨が降らなければ、ハイキングに行きましょう。“要是不下雨，就去郊游。”</li>
<li>質題がなければ、ましょう終わり。“如果没问题，我就结束。”</li>
<li>質題がなければ、ここで終わり。“如果没问题，我就结束。”</li>
</ol>
<h3 id="8-4-なら"><a href="#8-4-なら" class="headerlink" title="8.4 なら"></a>8.4 なら</h3><p><code>&lt;话题&gt;</code></p>
<p>动词原型／名词+なら</p>
<p>“…的话”。后面多接建议、提醒。</p>
<p>例句：</p>
<ol>
<li>温泉なら箱根が最高（せいこ）だよ。“泡温泉的话，箱根最好。”</li>
<li>電気（でんき）製品を買うなら、秋葉原（あきはばら）のがいいですよ。“买电器的话，秋叶原最好。”</li>
<li>タバコを吸うなら、出てください。“如果抽烟请出去。”</li>
<li>先生なら、トイレにいます。“老师在厕所。”</li>
</ol>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>日语</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS的那些面试</title>
    <url>/2017-03-28-ios-interview/</url>
    <content><![CDATA[<p>笔试面试是程序员应聘绕不过的坎，想进大厂就一定要有知识储备量，而这个却是最佳的考察方式。笔者分享一些收集的iOS面试题，答案仅供参考，如有错误，还请指正。</p>
<span id="more"></span>

<h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><p>1.Objective-C语言的基本特点？</p>
<p>Objective-C语言是C语言的一个超集，只是在C的基础之上添加了面向对象（OO）的特性；Objective-C与Java语言相同都是单继承，这一点与C++语言不同（多重继承），这一点可以参看之前有关讲解继承的文章；Objective-C不支持命名空间，取而代之的是在类名之前添加前缀，以此来区分。</p>
<p>2.#include与#import的区别，#import与@class的区别？</p>
<p>1）#include和#import效果相同，只是后者不会引起交叉编译，确保头文件只会被导入一次。</p>
<p>2）#import会包含这个类的所有信息，包括实体变量和方法，而@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂时不用考虑，后面会再告诉你。使用#import编译效率高，防止相互包含的编译错误。</p>
<p>3.简述类目优缺点，如果覆盖本类或者父类的方法会出现什么问题？</p>
<p>优点：不需要通过增加子类而增加现有类的行为（方法），且类目中的方法与原始类方法基本没有区别。</p>
<p>缺点：无法向类目添加实例变量。覆盖原始类方法后，原始类的方法没办法调用。</p>
<p>4.简述内存管理基本原则？</p>
<p>如果使用alloc、copy（mutableCopy）或者retain一个对象时，你就有义务向它发送一条release或autorelease消息。其他方法创建的对象，不需要由你来管理内存。</p>
<p>5.什么是ARC技术？与GC是否相同？</p>
<p>ARC是Automatic Reference Counting的简称，我们称之为自动引用计数，是iOS5.0之后推出的内存管理的新特性。本质上还是使用引用计数来管理对象，只是我们在编写代码时，不需要向对象发送release或autorelease方法，也不可以调用dealloc方法，编译器会在合适的位置自动给用户生成release（autorelease）消息。GC是Garbage Collection，内存垃圾回收机制，ARC比GC性能好。</p>
<p>6.iOS中是否支持垃圾回收机制？</p>
<p>iOS开发只支持MRC与ARC，Mac开发支持GC垃圾回收机制，10.8之后弃用了GC，推荐使用ARC。</p>
<p>7.深、浅复制的基本概念以及区别？</p>
<p>浅复制：只复制对象本身，不对里面的属性复制。</p>
<p>深复制：不仅复制对象本身，对象持有的属性对象也做复制。</p>
<p>8.内存中的堆区和栈区的差别？</p>
<p>栈区（stack）由编译器自动分配释放，存放方法（函数）的参数值，局部变量的值等。</p>
<p>堆区（heap）一般由程序员分配与释放，若程序员不释放，则会内存溢出。</p>
<p>9.用户自定义了一个对象，如何实现拷贝（可变和不可变拷贝）？</p>
<p>必须实现copying和mutableCopying协议，表示返回一个不可变和可变的对象。否则，程序将会出现异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(id)copyWithZone:(NSZone *)zone &#123;</span><br><span class="line">	Person *person = [[self Class] allocWithZone:zone];</span><br><span class="line">	person-&gt;age = self.age;</span><br><span class="line">	person-&gt;name = self.name;</span><br><span class="line">	return person;</span><br><span class="line">&#125;</span><br><span class="line">-(id)mutableCopyWithZone:(NSZone *)zone;</span><br></pre></td></tr></table></figure>

<p>10.定义属性时，什么时候用assign、retain、copy和nonatomic？</p>
<p>assign：普通赋值，一般常用于基本数据类型，常见委托设计模式，以此来防止循环引用。</p>
<p>retain：保留计数，获得了对象的所有权。引用计数在原有基础上加1。</p>
<p>copy：用来复制对象，一般字符串使用，Foundation中的不可变对象使用，效果相当于retain，只是引用计数加1。</p>
<p>nonatomic：非原子性访问，不加同步，多线程并发访问会提高性能。</p>
<p>11.strong和weak，_unsafe_unretained与weak的区别？</p>
<p>strong：强引用，在ARC中告诉编译器帮助我们自动插入retain。</p>
<p>weak：弱引用，是普通赋值，相当于手动管理内存的assign。</p>
<p>_unsafe_unretained：与weak功能一致，区别在于当指向的对象销毁后，weak会将变量置为nil，防止调用野指针。</p>
<p>12.ARC存在内存泄露吗？</p>
<p>ARC中如果内存管理不当的话，同样会存在内存泄露。例如，ARC中也会循环引用导致内存泄露；Objective-C对象与CoreFoundation类之间桥接时，管理不当也会产生内存泄露。</p>
<p>13.当我们释放对象时，为什么需要调用[super dealloc]方法？</p>
<p>子类是继承自父类，那么子类中有一些实例变量（对象），是继承自父类的，因此，我们需要调用父类方法，将父类所拥有的实例进行释放。</p>
<p>14.自动释放池是什么，如何工作？</p>
<p>自动释放池是NSAutorelease类的一个实例，当向一个对象发送autorelease消息时，该对象会自动入池，待池销毁时，将会向池中所有对象发送一条release消息，释放对象。</p>
<p>15.为什么delegate（代理）属性都是assign而不是retain的？</p>
<p>防止循环引用，以至对象无法得到正确的释放。</p>
<p>16.delegate使用weak还是strong？为什么？苹果有delegate使用strong的类吗？为什么？</p>
<p>delegate一般使用weak，主要是为了避免出现循环引用。苹果官方<code>NSURLSession</code>类中的delegate使用strong引用。因为苹果要求所有的网络请求都用同一个对象去发送，那么这个对象就封装为一个单例对象。</p>
<h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><p>1.iOS开发中数据持久性有哪几种？</p>
<p>plist文件写入，对象归档，sqlite3数据库，CoreData。</p>
<p>2.什么是KVC和KVO？它们之间的关系是什么？</p>
<p>KVC：键值编码，是一种间接访问对象实例变量的机制，该机制可以不通过存取方法就可以访问对象的实例变量。</p>
<p>KVO：键值观察，是一种能使得对象获取到其他对象属性变化的通知机制。<br>实现KVO键值观察模式，被观察的对象必须使用KVC键值编码来修改它的实例变量，这样才能被观察者观察到。因此，KVC是KVO的基础或者说KVO的实现是建立在KVC的基础之上的。</p>
<p>3.简述常见的设计模式？</p>
<p>单例模式、代理设计、观察者（通知）、工厂方法、模板方法。</p>
<p>4.内存管理在dealloc方法中用release方法与self.xx&#x3D;nil哪个好？</p>
<p>使用self.xx&#x3D;nil更好，因为先调用了release方法，而且还将变量设置为nil，这样就更安全的释放对象，防止野指针调用。</p>
<p>5.线程与进程的区别和联系？</p>
<p>一般的应用程序是单个进程，也有多进程（Chrome），进程是个静态的容器，里面容纳了很多个线程，线程是一系列方法的线性执行路径。</p>
<p>6.Objective-C语言的优缺点？</p>
<p>优点：类目、动态识别、支持C语言、Objective-C与C++可以混编。</p>
<p>缺点：不支持命名空间、不支持运算符重载、不支持多重继承。</p>
<p>7.代理delegate、通知Notification与block的使用区别？</p>
<p>delegate和block一般是用于两个对象一对一之间的通信交互，delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信。block更加简洁，不需要定义繁琐的协议方法，但是如果通信事件比较多的话，建议使用delegate。<br>Notification主要用于一对多情况下通信，而且，通信对象之间不需要建立关系，但是使用通知，代码可读性差。</p>
<p>8.控制器ViewController的loadView、viewDidLoad、viewWillApear和viewDidUnload分别是在什么时候调用？</p>
<p>loadView：当控制器的根视图view为空，且此view被访问时调用。</p>
<p>viewDidLoad：loadView调用之后被调用。</p>
<p>viewWillApear：当控制器根视图view被添加到父视图上时调用。</p>
<p>viewDidUnload：iOS6.0之前，当内存警告时，先卸载视图，再调用<br>viewDidUnload来释放内存。</p>
<p>9.@synthesize和@dynamic的区别？</p>
<p>@synthesize：系统自动生成getter和setter属性声明。</p>
<p>@dynamic：告诉编译器，属性的获取与赋值方法由用户自己实现，不自动生成。</p>
<p>10.事件响应者链的概念？</p>
<p>响应者链表示一系列的响应者对象。事件被交由第一响应者对象处理，如果第一响应者不处理，事件被沿着响应者链向上传递，交给下一个响应者。一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件交由它处理，如果它不处理，事件会被传递给它的视图控制器对象（如果存在），然后是它的父视图对象（如果存在），以此类推，直到顶层视图。接下来会沿着顶层视图到窗口（UIWindow对象），再到程序（UIApplication对象）。如果整个过程都没有响应这个事件，该事件被丢弃。一般情况下，在响应者链中只要有对象处理事件，事件就停止传递。但有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。</p>
<p>11.C语言中的static变量和static函数有什么作用？</p>
<p>1）表示变量是静态存储变量，表示变量存放在静态存储区。</p>
<p>2）加在函数前面的时候表示该函数是内部连接，只在本文件中有效，别的文件中不能使用该函数。</p>
<p>12.指针题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）int a; //一个数值。</span><br><span class="line">2）int *a; //一个指向数值的指针。</span><br><span class="line">3）int **a; //一个指向指针的指针。</span><br><span class="line">4）int a[10]; //一个有10个指针的数组，该指针是指向一个整型数的。</span><br><span class="line">5）int *a[10]; //一个有10个指针的数组，该指针是指向一个整型数的。</span><br><span class="line">6）int (*a)[10]; //一个指向有10个整型数数组的指针。</span><br><span class="line">7）int (*a)(int); //一个指向函数的指针，该函数有一个整型参数并返回一个整型数。</span><br><span class="line">8）int (*a[10])(int); //一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数。</span><br></pre></td></tr></table></figure>

<p>13.写一个NSString类的实现？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+(id)initWithCString:(const char *)nullTerminatedCString encoding:(NSStringEncoding)encoding &#123;</span><br><span class="line">	NSString *obj;</span><br><span class="line">	obj = [self allocWithZone:NSDefaultMallocZone()];</span><br><span class="line">	obj = [obj initWithCString:nullTerminatedCString encoding:encoding];</span><br><span class="line">	return autorelease(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>14.Objective-C与C如何混用？Objective-C与C++如何混用？</p>
<p>实现文件的扩展名.m改成.mm即可，但cpp文件必须只能使用C&#x2F;C++代码，而且cpp文件include的头文件中，也不能出现Objective-C的代码，因为cpp只能写C++的代码。</p>
<p>15.Objective-C中有私有方法和私有变量吗？</p>
<p>使用private修饰的全局变量是私有的变量。</p>
<p>Objective-C在语法上没有设计私有的方法，不过可以通过延展在实现文件里定义方法作为私有的方法。但不是真正意义上的私有方法，也是可以调用的，只是外部不可见而已。</p>
<h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h2><p>1.下面关键字const有什么含义？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int a;</span><br><span class="line">int const a;</span><br><span class="line">const int *a;</span><br><span class="line">int * const a;</span><br></pre></td></tr></table></figure>
<p>前两个的作用是一样的，a是一个常整型数。</p>
<p>第三个意味着a是一个指向常整型数的指针（即整型数是不可修改的，但指针可以）。</p>
<p>第四个意味着a是一个指向整型数的常指针（即指针指向的整型数是可以修改的，但指针是不可修改的）。</p>
<p>2.C语言中extern的作用，extern “C”的作用？</p>
<p>1）extern可以置于变量或者函数前，以标示变量或函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。</p>
<p>2）C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。</p>
<p>3.Objective-C是如何管理内存的？</p>
<p>Objective-C语言是使用引用计数来管理一个对象的生命周期，当对象被其他“人”使用的时候引用计数加1，不使用时减1，当此对象的引用计数为0时，则对象被系统回收。</p>
<p>4.什么是动态绑定（多态）？</p>
<p>动态绑定是面向对象特性之一多态的体现，声明一个变量，在运行的时候可以绑定不同的对象，比如在方法的参数中声明这样一个变量UIView *view，运行的时候，我们可以根据不同的应用场景给view变量传入不同的对象，可以传递一个UIButton对象，也可以传入UIImageView对象。</p>
<p>5.如何理解delegate？</p>
<p>delegate，又称为委托或代理，它是一种设计模式。delegate主要用于两个对象之间的通信交互，并且解除两个通信对象的耦合性，iOS中大量使用了delegate设计，主要用于视图与使用对象之间的通信交互。</p>
<p>6.block与函数有何异同？block有何优点？</p>
<p>1）block类似于C里面的函数指针，都可以作为参数进行传递，用于回调。但是block的实现可以定义在方法中，函数则不可以。</p>
<p>2）block语法简洁，可以在方法中定义实现，这样可以访问方法中的局部变量，使代码更加的紧凑，结构化。</p>
<p>7.为什么标准头文件都有类似以下的结构？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef __INCvxWorksh</span><br><span class="line">#define __INCvxWorksh</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">/*...*/</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif /*__INCvxWorksh*/</span><br></pre></td></tr></table></figure>

<p>显然，头文件中的编译宏“#ifndef __INCvxWorksh、#define __INCvxWorksh、#endif”的作用是防止该头文件被重复引用。</p>
<p>8.CocoaTouch框架？</p>
<p>UIKit、Foundation、CoreGraphic、CoreAnimation</p>
<p>1）音频和视频：Core Audio、OpenAL、Media Library、AV Foundation</p>
<p>2）数据管理：Core Data、SQLite</p>
<p>3）图形和动画：Core Animation、OpenGL ES、Quartz 2D、Core Graphic</p>
<p>4）用户应用：Address Book、Core Location、Map Kit、Store Kit</p>
<p>9.栈结构与队列的区别？</p>
<p>栈（stack）：限定只能在表的一端进行插入和删除操作的线性表。</p>
<p>队列（queue）：限定只能在表的一端插入和在另一端进行删除操作的线性表。</p>
<p>1）队列先进先出，栈先进后出。</p>
<p>2）对插入和删除操作的“限定”不同。</p>
<p>3）遍历数据速度不同。队列遍历数据的速度要快得多。</p>
<p>10.Objective-C中有无多重继承？如何实现多重继承？</p>
<p>Objective-C是没有多重继承的。</p>
<p>Cocoa中所有的类都是NSObject的子类，多继承在这里是用protocol委托代理来实现的。</p>
<p>面向对象语言大部分都是单继承，例如：Java、C#。</p>
<p>C++支持多继承。</p>
<p>11.static全局变量与普通的全局变量的区别？局部变量呢？函数呢？</p>
<p>1）static全局变量与普通全局变量的区别：static全局变量只初始化一次，防止在其他文件单元中被引用。</p>
<p>2）static局部变量与普通局部变量的区别：static局部变量只被初始化一次，下一次依据上一次结果值。</p>
<p>3）static函数与普通函数的区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。</p>
<p>12.什么是类目与延展？</p>
<p>类目：为已知的类增加新的方法。</p>
<p>延展：通知在本类的定义里使用类目来声明私有方法。</p>
<p>13.Objective-C中的协议和Java中的接口区别？</p>
<p>协议定义的方法，可以设置可选实现和必须实现。</p>
<p>接口则是必须全部实现。</p>
<p>14.在一个对象的方法里self.name&#x3D;”object”和name&#x3D;”object”有什么不同？</p>
<p>前者调用的是设置器方法，后者是普通赋值。</p>
<p>15.单例设计模式的实现？为什么使用单例设计？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static File *instance = nil;</span><br><span class="line">@implementation File</span><br><span class="line">//获取单例的方法</span><br><span class="line">+(id)shareInstance &#123;</span><br><span class="line">	@synthesize (self) &#123;</span><br><span class="line">		if(instance == nil) &#123;</span><br><span class="line">			instance = [[File alloc] init];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return instance;</span><br><span class="line">&#125;</span><br><span class="line">//覆写allocWithZone、copyWithZone、retain、release和autorelease方法，目的是限制这个类只创建一个对象</span><br></pre></td></tr></table></figure>

<p>为什么使用单例设计？</p>
<p>1）单例设计是用来限制一个类只能创建一个对象，那么此对象中的属性可以存储全局共享的数据，所有的类都可以访问、设置此单例对象中的属性数据。</p>
<p>2）如果一个类创建的时候非常的耗费性能，那么此类如果能满足要求，可以设置为单例节约性能。</p>
<h2 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h2><p>1.层CALayer和UIView的区别是什么？</p>
<p>两者最大的区别是，图层不会直接渲染到屏幕上。UIView是iOS系统中界面元素的基础，所有的界面元素都是继承自它，它本身是由CoreAnimation来实现的，它真正绘图的部分是由一个CALayer类来管理的。UIView本身更像是一个CALayer的管理器。一个UIView上可以有多个CALayer，每个CALayer显示一种东西，增强UIView的展现能力。</p>
<p>2.什么是GCD？</p>
<p>GCD是Apple开发的一个多核编程的较新的解决方法。在Mac OS X 10.6雪豹中首次推出，并引入到iOS4.0。GCD是一个替代诸如NSThread等技术的很高效和强大的技术。GCD完全可以处理诸如数据锁定和资源泄漏等复杂的异步编程问题。</p>
<p>3.TCP&#x2F;UDP的区别和联系？</p>
<p>1）TCP的全称为传输控制协议，这种协议可以提供面向连接的、可靠的、点到点的通信。</p>
<p>2）UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。</p>
<p>3）用TCP还是UDP，需要看程序注重哪一个方面，需要可靠还是快速。</p>
<p>4.Socket连接和Http连接的区别？</p>
<p>Http连接：Http连接就是所谓的短链接，即客户端向服务器发送一次请求，服务器响应后连接即会断掉。</p>
<p>Socket连接：Socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉。</p>
<p>5.什么是TCP连接的三次握手？</p>
<p>第一次握手：客户端发送SYN包（SYN&#x3D;j）到服务器，并进入SYN_SEND状态，等待服务器确认。</p>
<p>第二次握手：服务器收到SYN包，必须确认客户的SYN（ACK&#x3D;j+1），同时自己也发送一个SYN包（SYN&#x3D;k），即SYN+ACK包，此时服务器进入SYN_RECV状态。</p>
<p>第三次握手：客户端接收到服务器的SYN+ACK包，向服务器发送确认包ACK（ACK&#x3D;k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>6.frame和bounds的区别？</p>
<p>frame指的是：该view在父view坐标系统中的位置大小（参照点是父视图的坐标系统）。</p>
<p>bounds指的是：该view在本身坐标系统中的位置和大小（参照点是本身的坐标系统）。</p>
<p>7.如何理解MVC设计模式？</p>
<p>MVC是一种架构设计，M表示数据模型，V表示视图，C表示控制器。</p>
<p>数据模型：负责存储、定义、操作数据。</p>
<p>视图：用来展示数据给用户，和用户进行操作交互。</p>
<p>控制器：它是M与V的协调者，控制器获取数据，将数据交给视图去展示。</p>
<p>8.控制器的xib是怎么加载的？</p>
<p>当UIViewController的loadView被调用时，在此方法中，通过NSBundle加载xib，先通过控制器的类名作为xib的文件名加载此xib文件。如果找到此xib文件，则加载为view对象作为控制器的根视图，如果没有xib文件，则通过alloc创建一个view对象作为根视图。</p>
<p>9.控制器如何处理系统内存不足警告？</p>
<p>内存不足时，系统会调用控制器didReceiveMemoryWaring方法通知控制器内存不足。iOS6.0与6.0之前的处理方式不一样。</p>
<p>1）iOS6.0之前：调用didReceiveMemoryWaring后，将self.view设置为nil，并且再调用viewDidUnload方法，在此方法中我们应该释放子视图。</p>
<p>2）iOS6.0之后：调用didReceiveMemoryWaring后，不再调用viewDidUnload方法，则应该在didReceiveMemoryWaring方法中手动将self.view&#x3D;nil，并且释放子视图。</p>
<p>10.iOS中对象间有哪些通信方式？</p>
<p>代理delegate、block、通知和KVO。</p>
<p>11.block在内存管理上的特点？需要注意循环引用，如何解决循环引用？</p>
<p>1）block中使用了局部对象，则会将此对象retain，引用了当前对象的属性或者方法，则会将当前对象retain。</p>
<p>2）解决循环引用：将当前对象赋值给一个局部变量，并且使用__block关键字修饰该局部变量，使用该变量访问当前对象的属性和方法。</p>
<p>12.Objective-C中有线程池（线程队列）吗？NSOperationQueue是如何管理线程的？</p>
<p>NSOperationQueue是Objective-C的线程池，线程池中可以存放多个线程。</p>
<p>NSOperationQueue可以管理线程的并发数，还可以管理线程间的优先级。</p>
<p>13.timer的间隔周期准吗？为什么？怎样实现一个精准的timer？</p>
<p>定时器timer一般都是准确的，但是当主线程有些时候难免会出现堵塞情况，这样就有可能导致定时器timer会延迟从而不准确。我们可以开发一个多线程，在此多线程上运行定时器，这样多线程只运行定时器，不会因堵塞而导致误差。</p>
<p>14.Http协议的特点？GET与POST的区别？什么是Https协议？</p>
<p>1）Http协议是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，连接则断开。</p>
<p>2）GET请求没有请求体，POST含有请求体，请求参数可以放入请求体中，所以，POST可以提交大量的数据给服务器，更加安全。</p>
<p>3）HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议，它是一个安全通信通道，它基于HTTP开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层（SSL）进行信息交换，简单来说它是HTTP的安全版。</p>
<p>15.XML数据的解析方式各有什么不同？JSON解析有哪些框架？</p>
<p>XML数据解析有两种方式：DOM解析和SAX解析。</p>
<p>DOM解析：必须完成DOM树的构造，在处理规模较大的XML文档时就很耗费内存，占用资源较多。</p>
<p>SAX解析：与DOM不同的是，SAX是用事件驱动模型，解析XML文档时每遇到一个开始或者结束标签、属性或一条指令时，程序就产生一个事件来进行相应的处理。因此，SAX相对于DOM来说更适合操作大的XML文档。</p>
<p>JSON解析：现在性能比较好的主要是第三方的JSONKit和iOS自带的JSON解析类，自带的JSON解析性能是最高的，但是只能是iOS5之后才可以使用。</p>
<h2 id="第五部分"><a href="#第五部分" class="headerlink" title="第五部分"></a>第五部分</h2><p>1.tableView是如何复用的？</p>
<p>如果屏幕上能显示10个单元格，则tableView只会创建11个单元格，也就是n+1，当滑到第12个单元格时就会复用第1个单元格对象。tableView中有个单元格池的概念，tableView调用协议方法获取单元格时，先从池子中查找是否有可复用的单元格，如果有则复用，如果没有则创建一个单元格对象。</p>
<p>2.如何优化tableView的滑动速度？</p>
<p>1）复用单元格。</p>
<p>2）使用不透明的视图，单元格中尽量少使用动画。</p>
<p>3）图片加载使用异步加载，并且设置图片加载的并发数。</p>
<p>4）滑动时不加载图片，停止滑动开始加载。</p>
<p>5）文字、图片可直接drawInRect绘制。</p>
<p>6）如非必要，减少reloadData全部cell，只reloadRowsAtIndexPaths。</p>
<p>7）如果cell是动态行高度，计算出高度后缓存。</p>
<p>8）cell高度固定的话直接用cell.rowHeight设置高度。</p>
<p>3.谈谈对Runloop的理解？</p>
<p>Run loops是线程相关的基础框架的一部分。一个run loop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。使用run loop的目的是让你的线程在有工作的时候忙于工作，而没有工作的时候处于休眠状态。</p>
<p>4.如何调用drawRect方法与layoutSubView方法？这两个方法的作用？</p>
<p>通过setNeedsLayout方法异步调用layoutSubView方法。</p>
<p>通过setNeedsDisplay方法异步调用drawRect方法。<br>drawRect方法用于绘图，layoutSubView方法用于布局子视图。</p>
<p>5.UIView与UIViewController的关系？</p>
<p>每个控制器都有一个根视图，控制器UIViewController用来管理此视图的加载和显示。</p>
<p>6.iOS中有哪些手势？</p>
<p>轻击、捏合、平移、轻扫、旋转和长按。</p>
<p>7.Http和Socket的区别？</p>
<p>Http是客户端用Http协议进行请求，发送请求时需要封装http请求头，并绑定请求的数据，服务器一般有Web服务器配合（当然也非绝对）。Http请求方式为客户端主动发起请求，服务器才能给响应，一次请求完毕后则断开连接，以节省资源。服务器不能主动给客户端响应（除非采用http长连接技术）。iPhone主要使用的类是NSURLConnection。</p>
<p>Socket是客户端跟服务器直接使用Socket套接字进行连接，并没有规定连接后断开，所以客户端和服务器可以保持连接通道，双方都可以主动发送数据。一般在游戏开发或股票开发，这种要求即时性很强并且保持发送数据量比较大的场合使用。主要使用的类是CFSocketRef。</p>
<p>8.storyboard有什么特点？</p>
<p>storyboard是iOS5新增的特性，是对xib的升级版本，引入了一个容器用于管理多个xib文件，和它们之间的跳转交互。</p>
<p>优点：不用再为每个控制器创建xib文件；可以使用静态cell，当cell固定且不多时，使用起来比较方便。</p>
<p>缺点：storyboard单个文件，不利于团队协作开发。</p>
<p>9.如何打包静态库？</p>
<p>新建一个Framework&amp;Library的项目，编译的时候会将项目中的代码文件打包成一个.a静态库文件。</p>
<p>10.APP发布的上架流程？</p>
<p>1）在苹果官网的开发者中心，新建一个APP，填写此APP相关的一些描述信息。</p>
<p>2）下载安装发布证书。</p>
<p>3）选择发布证书，使用Archive编译发布包。</p>
<p>4）使用Xcode提交发布包。</p>
<p>11.iOS5有哪些新特性？</p>
<p>iCloud、定制UI、storyboard、ARC、CoreImage滤镜、新增JSON解析类。</p>
<p>12.iOS6有哪些新特性？</p>
<p>UIRefreshControl水滴效果下拉刷新、UICollectionView控件的使用、SLComposeViewController新浪微博控件、PassKit中Passbook、AutoLayout自动布局。</p>
<p>13、iOS7有哪些新特性？</p>
<p>系统：全新的UI设计与交互；Control Center控制中心；全新的多任务Multitasking；AirDrop共享文件；全新的Safari浏览器交互式体验。</p>
<p>SDK：动态UIKit，新增了UIDynamicItem委托，用来为UIView制定动态行为；新增游戏引擎Sprite Kit Framework框架，类似于Cocos2D。</p>
<p>14.ARC有什么特点？</p>
<p>ARC是编译器特性，iOS5.0新添加的特性，使用ARC开发者不需要再retain、release、autorelease，因为编译器会在合适的地方自动插入retain、release。</p>
<p>ARC不会因少release而导致内存泄漏，过度使用release导致程序崩溃，</p>
<p>ARC可以产生更简洁的代码和更健壮的应用。</p>
<p>15.SVN、Git协作开发，怎么防止代码文件冲突？</p>
<p>防止代码冲突：不要多人同时修改同一个文件。例如，A、B都修改同一个文件，先让A修改，然后提交到服务器，然后B更新下来，再进行修改。<br>服务器上的项目文件xcodeproj，仅让一个人管理提交，其他人只更新。防止此文件产生冲突。</p>
<h2 id="第六部分"><a href="#第六部分" class="headerlink" title="第六部分"></a>第六部分</h2><p>1.什么是ARC？</p>
<p>ARC是automatic reference counting自动引用计数，在程序编译时自动加入retain&#x2F;release。在对象被创建时retain count+1，在对象被release时count-1，当count&#x3D;0时，销毁对象。程序中加入autoreleasepool对象会由系统自动加上autorelease方法，如果该对象引用计数为0，则销毁。那么ARC是为了解决MRC手动管理内存存在的一些而诞生的。</p>
<p>MRC下内存管理的缺点：</p>
<p>1）释放一个堆内存时，首先要确定指向这个堆空间的指针都被release了。(避免提前释放)</p>
<p>2）释放指针指向的堆空间，首先要确定哪些指向同一个堆，这些指针只能释放一次。(避免释放多次，造成内存泄露)</p>
<p>3）模块化操作时，对象可能被多个模块创建和使用，不能确定最后由谁释放。</p>
<p>4）多线程操作时，不确定哪个线程最后使用完毕。<br>虽然ARC给我们编程带来的很多好多，但也可能出现内存泄露。如下面两种情况：</p>
<p>1）循环参照：A有个属性参照B，B有个属性参照A，如果都是strong参照的话，两个对象都无法释放。</p>
<p>2）死循环：如果有个ViewController中有无限循环，也会导致即使ViewController对应的view消失了，ViewController也不能释放。</p>
<p>2.block一般用哪个关键字修饰，为什么？</p>
<p>block一般使用copy关键之进行修饰，block使用copy是从MRC遗留下来的“传统”，在MRC中，方法内容的block是在栈区的，使用copy可以把它放到堆区。但在ARC中写不写都行：编译器自动对block进行了copy操作。</p>
<p>3.用@property声明的NSString（或NSArray，NSDictionary）经常</p>
<p>使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？<br>用@property声明 NSString、NSArray、NSDictionary 经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>
<p>如果我们使用是strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。</p>
<p>copy此特质所表达的所属关系与strong类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。 当属性类型为NSString时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个NSMutableString类的实例。这个类是NSString的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>
<p>4.runloop、autorelease pool以及线程之间的关系？</p>
<p>每个线程(包含主线程)都有一个Runloop。对于每一个Runloop，系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个像callstack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。</p>
<p>5.@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的？</p>
<p>“属性”(property)有两大概念：ivar(实例变量)、存取方法(access method&#x3D;getter)，即@property &#x3D; ivar + getter + setter。<br>例如下面的这个类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface WBTextView :UITextView  </span><br><span class="line">@property (nonatomic,copy)NSString *placehold;  </span><br><span class="line">@property (nonatomic,copy)UIColor *placeholdColor;  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>类完成属性的定以后，编译器会自动编写访问这些属性的方法(自动合成autosynthesis)，上述代码写出来的类等效与下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface WBTextView :UITextView  </span><br><span class="line">- (NSString *)placehold;  </span><br><span class="line">-(void)setPlacehold:(NSString *)placehold;  </span><br><span class="line">-(UIColor *)placeholdColor;  </span><br><span class="line">-(void)setPlaceholdColor:(UIColor *)placeholdColor;  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>详细介绍见：<a href="http://blog.csdn.net/jasonjwl/article/details/49427377">http://blog.csdn.net/jasonjwl/article/details/49427377</a></p>
<p>6.分别写一个setter方法用于完成<code>@property (nonatomic,retain)NSString *name</code>和<code>@property (nonatomic,copy) NSString *name</code>？</p>
<p>retain属性的setter方法是保留新值并释放旧值，然后更新实例变量，令其指向新值。顺序很重要。假如还未保留新值就先把旧值释放了，而且两个值又指向同一个对象，先执行的release操作就可能导致系统将此对象永久回收。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(void)setName:(NSString *)name&#123;</span><br><span class="line">    [name retain];</span><br><span class="line">    [_name release];</span><br><span class="line">    _name = name;</span><br><span class="line">&#125;</span><br><span class="line">-(void)setName:(NSString *)name&#123;     </span><br><span class="line">    [_name release];</span><br><span class="line">    _name = [name copy];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.说说assign和weak，_block和 _weak的区别？</p>
<p>assign适用于基本数据类型，weak是适用于NSObject对象，并且是一个弱引用。</p>
<p>assign其实也可以用来修饰对象，那么为什么不用它呢？因为被assign修饰的对象在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil。如果在后续内存分配中，刚巧分到了这块地址，程序就会崩溃掉。而weak修饰的对象在释放之后，指针地址会被置为nil。</p>
<p><code>_block</code>是用来修饰一个变量，这个变量就可以在block中被修改。</p>
<p><code>_block</code>:使用_block修饰的变量在block代码块中会被retain(ARC下，MRC下不会retain)。</p>
<p>_weak:使用_weak修饰的变量不会在block代码块中被retain。</p>
<p>8.请说出下面代码是否有问题，如果有问题请修改？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">        for (int i=0; i&lt;largeNumber; i++) &#123;</span><br><span class="line">            Person *per = [[Person alloc] init];</span><br><span class="line">            [per autorelease];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>内存管理的原则：如果对一个对象使用了alloc、copy、retain，那么你必须使用相应的release或者autorelease。咋一看，这道题目有alloc，也有autorelease，两者对应起来，应该没问题。但autorelease虽然会使引用计数减一，但是它并不是立即减一，它的本质功能只是把对象放到离他最近的自动释放池里。当自动释放池销毁了，才会向自动释放池中的每一个对象发送release消息。这道题的问题就在autorelease。因为largeNumber是一个很大的数，autorelease又不能使引用计数立即减一，所以在循环结束前会造成内存溢出的问题。</p>
<p>解决方案如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">        for (int i=0; i&lt;100000; i++) &#123; </span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">            Person *per = [[Person alloc] init];</span><br><span class="line">            [per autorelease];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在循环内部再加一个自动释放池，这样就能保证每创建一个对象就能及时释放。</p>
<p>9.请问下面代码是否有问题，如有问题请修改？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">        NSString *str = [[NSString alloc] init];</span><br><span class="line">        [str retain];</span><br><span class="line">        [str retain];</span><br><span class="line">        str = @&quot;jxl&quot;;</span><br><span class="line">        [str release];</span><br><span class="line">        [str release];</span><br><span class="line">        [str release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题跟第8题一样存在内存泄露问题，</p>
<p>1）内存泄露 ；</p>
<p>2）指向常量区的对象不能release。</p>
<p>指针变量str原本指向一块开辟的堆区空间，但是经过重新给str赋值，str的指向发生了变化，由原来指向堆区空间，到指向常量区。常量区的变量根本不需要释放，这就导致了原来开辟的堆区空间没有释放，造成内存泄露。</p>
<p>10.什么情况下使用weak关键字，相比assign有什么不同？什么情况使用weak关键字？</p>
<p>1）在ARC中，在有可能出现循环引用的时候，往往要通过让其中一端使用weak来解决。比如delegate代理。</p>
<p>2）自身已经对它进行一次强引用，没有必要再强引用一次，此时也会使用weak，自定义控件属性一般也使用weak。</p>
<p>不同点：</p>
<p>1）weak此特性表明该属性定义了一种“非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特性与assign一样，然而在属性所指的对象遭到销毁时，属性值也会清空。而assign的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。</p>
<p>2）assign可以用非OC对象，而weak必须用于OC对象。</p>
<p>11.内存管理语义(assign、strong、weak等的区别)?</p>
<p>1）assign “设置方法” 只会执行针对“纯量”的简单赋值操作。</p>
<p>2）strong  此特性表明该属性定义了一种“拥有关系”。为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。</p>
<p>3）weak 此特性表明该属性定义了一种“非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特性同assign类似，然而在属性所指的对象遭到销毁时，属性值也会清空。</p>
<p>4）unsafe_unretained  此特性的语义和assign相同，但是它适用于“对象类型”，该特性表达一种“非拥有关系”，当目标对象遭到销毁时，属性值不会自动清空，这一点与weak有区别。</p>
<p>5）copy 此特性所表达的所属关系与strong类似。然而设置方法并不保留新值，而是将其“拷贝”。当属性类型为NSString*时，经常用此特性来保护其封装性，因为传递给设置方法的新值有可能指向一个NSMutableString类的实例。这个类是NSString的子类，表示一种可以修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变”的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的”，就应该在设置新属性值时拷贝一份。</p>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C中的NSPredicate</title>
    <url>/2017-03-28-objective-c-NSPredicate/</url>
    <content><![CDATA[<p>编写软件时，经常需要获取一个对象集合，并通过某些已经条件计算该集合的值。你需要保留符合某个条件的对象，删除那些不满足条件的对象，从而提供一些有意义的对象。</p>
<p>在使用软件iPhoto的过程中，经常会看到这种现象，如果通知iPhoto仅显示等级为三星级或三星级以上的图片，则指定的条件为“照片的等级必须为三星级或三星级以上”。这样，所有照片都需要经过该过滤器过滤。满足条件的对象通过了过滤器，而其他对象被筛除了。最后，iPhoto将显示出所有高质量的图片。</p>
<p>Cocoa提供了一个名为NSPredicate的类，它用于指定过滤器的条件。可以创建NSPredicate对象，通过该对象准确地描述所需的条件，对每个对象通过谓词进行筛选，判断它们是否与条件相匹配。这里的“谓词”通常用在数学和计算机科学概念中，表示计算真值或假值的函数。</p>
<p>Cocoa用NSPredicate描述查询的方式，原理类似于在数据库中进行查询。可以在数据库风格的API中使用NSPredicate类，例如Core Data和Spotlight。可以将NSPredicate看成另一种间接操作方式。例如，如果需要查询满足条件的机器人，可以使用谓词对象进行检查，而不必使用代码进行显示查询。通过交换谓词对象，可以使用通用代码对数据进行过滤，而不必对相关条件进行硬编码。</p>
<span id="more"></span>

<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>1）方式一</p>
<p>创建许多对象，并将它们组合起来。如果正在构建通用用户接口来指定查询，采用这种方式比较简单。</p>
<p>2）方式二</p>
<p>查询代码中的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Car *car;</span><br><span class="line">Car = makeCar(@&quot;Herbie&quot;, @&quot;Honda&quot;, @&quot;CRX&quot;,  1984, 2, 110000, 58);</span><br><span class="line">[garage addCar:car];</span><br><span class="line">/*构建的汽车：品牌为Herbie，型号为双门1984Honda CRX，马力引擎为58，已经行驶距离为110000英里*/</span><br><span class="line">/*创建谓词*/</span><br><span class="line">NSPredicate *predicate;</span><br><span class="line">predicate = [NSPredicate predicateWithFormat:@&quot;name == &#x27;Herbie&#x27;&quot;];</span><br></pre></td></tr></table></figure>

<p>计算谓词</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOOL match = [predicate evaluateWithObject:car];</span><br><span class="line">NSLog(@&quot;%s&quot;,(match) ? &quot;YES&quot;:&quot;NO&quot;);</span><br></pre></td></tr></table></figure>

<p>另外一个谓词：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;engine.horsepower &gt;150&quot;];</span><br><span class="line">/*查看车库中哪些车的功率最大，可以循环测试每个汽车的谓词*/</span><br><span class="line">NSArray *cars = [garage cars];</span><br><span class="line">for(Car *car in cars)&#123;</span><br><span class="line">    if([predicate evaluateWithObject:car])&#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, car.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>如果我们不必像上文那样编写for循环和if语句，这有什么不好？实际上，某些类别将谓词过滤方法添加到了Cocoa集合类中。<code>-filteredArrayUsingPredicate:</code>是NSArray数组中的一种类别方法，它将循环过滤数组内容，根据谓词计算每个对象的值，并将值为YES的对象累积到将被返回的新数组中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSArray *results;</span><br><span class="line">results = [cars filteredArrayUsingPredicate:predicate];</span><br><span class="line">NSLog(@&quot;%@&quot;,results);</span><br></pre></td></tr></table></figure>

<p>假如有一个可变数组，你需要剔除不属于该数组的所有项目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSMutableArray *carsCopy = [cars mutableCopy];</span><br><span class="line">[carsCopyfilterUsingPredicate:predicate];</span><br></pre></td></tr></table></figure>

<h2 id="格式说明符"><a href="#格式说明符" class="headerlink" title="格式说明符"></a>格式说明符</h2><p>资深编程人员都知道，硬编码并非好方法，因此，我们可以通过格式符构建谓词：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSPredicate  *predicate = [NSPredicate predicateWithFormat:@&quot;engine.horsepower &gt; %d&quot;, 50];</span><br></pre></td></tr></table></figure>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>NSPredicate的格式字符串包含大量不同的运算符。</p>
<p>1）比较和逻辑运算符</p>
<p>谓词字符串语法支持C语言中一些常用的运算符，例如等号运算符&#x3D;&#x3D;和&#x3D;。<br>不等号运算符具有各种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;：大于</span><br><span class="line">&gt;=和=&gt;：大于或等于</span><br><span class="line">&lt;：小于</span><br><span class="line">&lt;=和=&lt;：小于或等于</span><br><span class="line">!=和&lt;&gt;：不等于</span><br></pre></td></tr></table></figure>

<p>此外，谓词字符串语法还支持括号表达式和AND、OR、NOT逻辑运算符或者C样式的等效表达式&amp;&amp;、||和!。</p>
<p>2）数组运算符</p>
<p>谓词字符串“(engine.horsepower&gt; 50) OR (engine.horsepower &lt; 200)”是一种十分常见的模式。等效于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">predicate= [NSPredicate predicateWithFormat:@&quot;engine.horespower BETWEEN &#123;50,200&#125;&quot;];</span><br></pre></td></tr></table></figure>

<p>花括号表示数组，BETWEEN将数组中第一个元素看成是数组的下界，第二个元素看成是数组的上界。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSArray *betweens = [NSArray arrayWithObjects:[NSNumber numberWithInt:50],[NSNumber   numberWithInt:200], nil];</span><br><span class="line">predicate = [NSPredicate predicateWithFormat:@&quot;engine.horsepower BETWEEN %@&quot;,betweens];</span><br></pre></td></tr></table></figure>

<p>数组不仅仅用来指定某个区间的端点值。你可以使用IN运算符查找数组中是否含有某个特定值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">predicate = [NSPredicate predicateWithFormat:@&quot;name IN &#123;&#x27;Herbie&#x27;, &#x27;Snugs&#x27;, &#x27;Badger&#x27;,&#x27;Flap&#x27;&#125;&quot;];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>objc</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>想说说文章版权</title>
    <url>/2017-03-29-article-copyright/</url>
    <content><![CDATA[<p>文章版权，这个词汇以前笔者以前是不怎么有体会的，认为在当今互联网的时代，随便网上Google一下很多地方的文章如出一辙，而作者也是千奇百怪，甚至都不清楚谁才是作者。这篇文章，笔者是遇见了真实的事件，现在很想说一说，看看大家是否也是一样，认为一个版权意识高的视界里，资源与时间都是高效的。不用在看一条，两条都是一样的，浪费时间和资源。</p>
<span id="more"></span>

<p>不知道是否有人明白什么叫“版权”。说实在的，笔者并不是很清楚它的定义。这里引入百科的解释：</p>
<blockquote>
<p>版权（copyright）是用来表述创作者因其文学和艺术作品而享有的权利的一个法律用语。</p>
</blockquote>
<blockquote>
<p>版权是对计算机程序、文学著作、音乐作品、照片、电影等的复制权利的合法所有权。除非转让给另一方，版权通常被认为是属于作者的。大多数计算机程序不仅受到版权的保护，还受软件许可证的保护。版权只保护思想的表达形式，而不保护思想本身。算法、数学方法、技术或机器的设计均不在版权的保护之列。</p>
</blockquote>
<p>这个是属于法律领域了，只不过在天朝，大家都不认为这是事儿。不过现在好了，慢慢的付费阅读，付费视频等等开始流行，这样大家虽然花了米米，不过质量却是有了保证。</p>
<p>说回这篇文章的初衷，就是在这两天，笔者遇到了自己博客网站的文章别他人拿去分享，并攫取了利益。更巧的是，被笔者知道了。曾经在知乎一个问答里看见，关于招聘，面试官会直接pass掉那些抄袭他们文章的应聘者。看到之后笔者将自己转载，并备注了“转载”二字的文章删除干净。不错，或许笔者没有从中获利，不过确实有些文章是没有联系到作者的，虽然给了原链接，可是确实吸引了眼球。</p>
<p>现在，保证文章都是原创，无论深浅文雅如何，总归是自己的作品。相反，在不断撰写过程中，会发现很多自身的漏洞。网络已经很发达了，大家都能在网上找到自己需要的文章，干嘛还要做搬运工呢，笔者认为，高手应该转载于无形，即看懂原文加上自己的思考，想必比简单的复制拷贝要有价值得多。</p>
<p>笔者之前在一个“同行说”的平台分享自己的文章，后来转行了，渐渐时间少了，也就远离了一段时间的撰文。现在，又要安利大家了，这款 <a href="https://toutiao.io/">开发者头条</a>，内容不错，文章也很是有质量，笔者使用pocket已经收藏了不少好文。不过，这篇文章的始因也是源于此平台。平台有激励作者自荐的机制，积分商城应该算得上为数不多的几家良心公司。为此，笔者有空会创作原创，因为这样才能登上文章精选的列表。</p>
<p>可是，不得不说的一点是，平台没有很好的原创保护机制。笔者作为一个技术人员。看到几点问题：</p>
<p>1.平台有精选文章缓存。这样的后果就是，即使作者发现了自己文章的错误，修改之后还是不能同步到精选文章列表。</p>
<p>2.对于原创和非原创没有好的保护与甄别，除非巧合遇到像笔者这样的情况，且还是个较真的人。</p>
<p>3.软件聊天体验有待提高。emoji发送太麻烦，iOS平台必须依赖系统键盘的发送。Android端没有用过不清楚。</p>
<p>第一个问题，笔者建议可以使用定时机制，一段时间检测分享链接的内容，这样也能很好的保护原创。当原创作者发现自己的文章被他人肆意分享，只需改变文章地址即可令其失效。这样也就不存在原创甄别问题了。还保证了文章内容的同步。</p>
<p>第二个问题，技术不是问题，关键是否会为这个的细节付出时间。</p>
<p>不过，笔者自己也想过使用什么方式能够避免这样的问题，URL混淆？反爬虫？不知道是否可行。不过迫于无奈，现在笔者的文章顶部都加了一条申明。其实就是小偷和锁的问题，是否有效只取决于剽窃者。</p>
<p>最后，很感谢平台的及时沟通和处理，为笔者补回了损失。不过，却便宜了剽窃者。</p>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>sublime text 实用技巧</title>
    <url>/2017-03-30-sublime-text-tool/</url>
    <content><![CDATA[<p>Sublime Text 是一个代码编辑器（Sublime Text 2是收费软件，但可以无限期试用），也是HTML和散文先进的文本编辑器。Sublime Text是由程序员Jon Skinner于2008年1月份所开发出来，它最初被设计为一个具有丰富扩展功能的Vim。</p>
<p>笔者整理了一些使用快捷方式，以及一些常用插件，分享一下。</p>
<span id="more"></span>

<h2 id="安装包控制（Package-Control）"><a href="#安装包控制（Package-Control）" class="headerlink" title="安装包控制（Package Control）"></a>安装包控制（Package Control）</h2><p>打开Sublime Text 2，按快捷键 ctrl+&#96; 或者点击 Tools → Command Palette 调出控制台Console；<br>将以下代码复制粘贴进命令行后回车：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import urllib2,os;pf=&#x27;Package Control.sublime-package&#x27;;ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp)elseNone;open(os.path.join(ipp,pf),&#x27;wb&#x27;).write(urllib2.urlopen(&#x27;http://sublime.wbond.net/&#x27;+pf.replace(&#x27; &#x27;,&#x27;%20&#x27;)).read())</span><br></pre></td></tr></table></figure>

<p>重新启动Sublime Text 2，如果在Preferences → Package Settings 中看到 Package Control 这一项，就说明安装成功。</p>
<h2 id="安装Alignment插件"><a href="#安装Alignment插件" class="headerlink" title="安装Alignment插件"></a>安装Alignment插件</h2><p>对于喜欢整齐的码农来说，这不失为一个省事的插件。该插件可以通过上面安装好的 Package Control 来安装：</p>
<p>按ctrl + shift + P调出命令面板；</p>
<p>输入 install 调出 Package Control：Install Package 选项，并回车；</p>
<p>输入Alignment，选中并按回车安装；</p>
<p>重启Sublime Text 2，选中文本并按ctrl + alt + a 就可以进行对齐操作了。</p>
<h2 id="安装-Soda-主题"><a href="#安装-Soda-主题" class="headerlink" title="安装 Soda 主题"></a>安装 Soda 主题</h2><p>这里的主题不同于针对代码的 color scheme，而是针对Sublime Text 2该软件本身的主题，该主题也可以通过万能的 Package Control 来安装。</p>
<p>按ctrl + shift + P调出命令面板；</p>
<p>输入 install 调出 Package Control：Install Package 选项，并回车；</p>
<p>输入 theme soda 选中后回车即可安装；</p>
<p>安装完之后要激活主题，打开 Preferences → Global Settings – User，加上以下代码保存即可生效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;theme&quot;: &quot;Soda Light.sublime-theme&quot; 或者 &quot;theme&quot; : &quot;Soda Dark.sublime-theme&quot;</span><br></pre></td></tr></table></figure>

<h2 id="安装cTags插件"><a href="#安装cTags插件" class="headerlink" title="安装cTags插件"></a>安装cTags插件</h2><p>首先，从Ctags官网下载压缩包下来，解压到电脑的某个地方，比如“C:\Program Files\ctags”，然后把cTags添加到系统变量里去：<br>在“我的电脑”右键属性 → 高级 → 环境变量 → 在“系统变量”里找到“Path”，点击“编辑” → 把“;C:\Program Files\ctags”（不包括双引号）复制到最后 → 最后一路“确定”保存。</p>
<p>然后通过 Package Control 来安装 cTags 插件：</p>
<p>按ctrl + shift + P调出命令面板；</p>
<p>输入 install 调出 Package Control：Install Package 选项，并回车；</p>
<p>输入 ctags 选中后回车即可安装。</p>
<p>安装完之后，在项目的当前目录下按ctrl + t, ctrl + r，会生成.tags的文件。当光标停留在某个函数上时，按快捷键 ctrl+t, ctrl+t就可以打开函数所在的文件，并跳转到相应的位置了。</p>
<p><strong>PS</strong> 安装这个插件折腾了我蛮久，主要是不知道还要从ctags官网下载压缩包，以及修改系统的变量，后来还是一博友给我发的国外的参考资料才知道要这样配置 的。刚开始知道这软件之所以没用是因为没有像eclipse可以追踪函数的功能，后来才知道可以通过安装cTags插件来实现。装上此功能后，就更喜欢用 Sublime Text 2了。</p>
<h2 id="jsFormat插件"><a href="#jsFormat插件" class="headerlink" title="jsFormat插件"></a>jsFormat插件</h2><p>格式化js：选中一段文本，control+alt+f。</p>
<p>DocBlockr</p>
<p>在JS函数上方输入&#x2F;**，然后回车，doc就生成好了非常好用。</p>
<p>sublime-jslint</p>
<p>打开一个js文件，control+j，即可输出jsLint检查的结果。打开Packages目录，找到插件目录sublime-jslint，打开 sublime-jslint.sublime-settings文件，可以修改jsLint配置，还可以配置文件保存时自动检查等，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; // Path to the jslint jar. // Leave blank to use bundled jar. &quot;jslint_jar&quot;: &quot;&quot;,   // Options pass to jslint. // Jerry Qu注：全部可用配置参考这里，https://github.com/fbzhong/sublime-jslint/wiki/Available- jslint4java-options &quot;jslint_options&quot;: &quot;--encoding utf-8 --bitwise --browser --cap --css --devel --debug --evil --forin --fragment --on --sub --white --windows --sloppy&quot;,   // Ignore errors, regex. &quot;ignore_errors&quot;: [ // &quot;Expected an identifier and instead saw &#x27;undefined&#x27; \(a reserved word\)&quot; ],   // run jslint on save. &quot;run_on_save&quot;: false,   // debug flag. &quot;debug&quot;:false &#125;</span><br></pre></td></tr></table></figure>

<h2 id="SideBarEnhancements"><a href="#SideBarEnhancements" class="headerlink" title="SideBarEnhancements"></a>SideBarEnhancements</h2><p>推荐通过 Package Control 安装 SideBarEnhancements 这个插件，可以大大加强在侧栏目录树中右键的选项</p>
<h2 id="推荐插件："><a href="#推荐插件：" class="headerlink" title="推荐插件："></a>推荐插件：</h2><p>1）Zen Coding</p>
<p>2）jQuery Package for sublime Text</p>
<p>3）Clipboard History</p>
<p>4）Bracket Highlighter</p>
<p>5）GBK to UTF8</p>
<p>6）Git</p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table>
<thead>
<tr>
<th>按键组合</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Command+Shift+L</td>
<td>选中多行即可可以同时编辑这些行</td>
</tr>
<tr>
<td>control + Command +G</td>
<td>可以一次性选择全部相同的文件进行同时编辑</td>
</tr>
<tr>
<td>Ctrl+D</td>
<td>选词（反复按快捷键，即可继续向下同时选中下一个相同的文本进行同时编辑）</td>
</tr>
<tr>
<td>Ctrl+G</td>
<td>跳转到相应的行</td>
</tr>
<tr>
<td>Ctrl+J</td>
<td>合并行（已选择需要合并的多行时）</td>
</tr>
<tr>
<td>Ctrl+L</td>
<td>选择整行（按住-继续选择下行）</td>
</tr>
<tr>
<td>Ctrl+M</td>
<td>光标移动至括号内开始或结束的位置</td>
</tr>
<tr>
<td>Ctrl+T</td>
<td>词互换</td>
</tr>
<tr>
<td>Ctrl+U</td>
<td>软撤销</td>
</tr>
<tr>
<td>Ctrl+P</td>
<td>查找当前项目中的文件和快速搜索；输入@查找文件主标题&#x2F;函数；或者输入:跳转到文件某行；</td>
</tr>
<tr>
<td>Ctrl+R</td>
<td>快速列出&#x2F;跳转到某个函数</td>
</tr>
<tr>
<td>Ctrl+KBackspace</td>
<td>从光标处删除至行首</td>
</tr>
<tr>
<td>Ctrl+KB</td>
<td>开启&#x2F;关闭侧边栏</td>
</tr>
<tr>
<td>Ctrl+KK</td>
<td>从光标处删除至行尾</td>
</tr>
<tr>
<td>Ctrl+KT</td>
<td>折叠属性</td>
</tr>
<tr>
<td>Ctrl+KU</td>
<td>改为大写</td>
</tr>
<tr>
<td>Ctrl+KL</td>
<td>改为小写</td>
</tr>
<tr>
<td>Ctrl+K0</td>
<td>展开所有</td>
</tr>
<tr>
<td>Ctrl+Enter</td>
<td>插入行后（快速换行）</td>
</tr>
<tr>
<td>Ctrl+Tab</td>
<td>当前窗口中的标签页切换</td>
</tr>
<tr>
<td>Ctrl+Shift+A</td>
<td>选择光标位置父标签对儿</td>
</tr>
<tr>
<td>Ctrl+Shift+D</td>
<td>复制光标所在整行，插入在该行之前</td>
</tr>
<tr>
<td>ctrl+shift+F</td>
<td>在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找</td>
</tr>
<tr>
<td>Ctrl+Shift+K</td>
<td>删除整行</td>
</tr>
<tr>
<td>Ctrl+Shift+L</td>
<td>鼠标选中多行（按下快捷键），即可同时编辑这些行</td>
</tr>
<tr>
<td>Ctrl+Shift+M</td>
<td>选择括号内的内容（按住-继续选择父括号）</td>
</tr>
<tr>
<td>Ctrl+Shift+P</td>
<td>打开命令面板</td>
</tr>
<tr>
<td>Ctrl+Shift+&#x2F;</td>
<td>注释已选择内容</td>
</tr>
<tr>
<td>Ctrl+Shift+↑</td>
<td>可以移动此行代码，与上行互换</td>
</tr>
<tr>
<td>Ctrl+Shift+↓</td>
<td>可以移动此行代码，与下行互换</td>
</tr>
<tr>
<td>Ctrl+Shift+[</td>
<td>折叠代码</td>
</tr>
<tr>
<td>Ctrl+Shift+]</td>
<td>展开代码</td>
</tr>
<tr>
<td>Ctrl+Shift+Enter</td>
<td>光标前插入行</td>
</tr>
<tr>
<td>Ctrl+PageDown、Ctrl+PageUp</td>
<td>文件按开启的前后顺序切换</td>
</tr>
<tr>
<td>Ctrl+Z</td>
<td>撤销</td>
</tr>
<tr>
<td>Ctrl+Y</td>
<td>恢复撤销</td>
</tr>
<tr>
<td>Ctrl+F2</td>
<td>设置书签</td>
</tr>
<tr>
<td>Ctrl+&#x2F;</td>
<td>注释整行（如已选择内容，同“Ctrl+Shift+&#x2F;”效果）</td>
</tr>
<tr>
<td>Ctrl+鼠标左键</td>
<td>可以同时选择要编辑的多处文本</td>
</tr>
<tr>
<td>Shift+鼠标右键（或使用鼠标中键）</td>
<td>可以用鼠标进行竖向多行选择</td>
</tr>
<tr>
<td>Shift+F2</td>
<td>上一个书签</td>
</tr>
<tr>
<td>Shift+Tab</td>
<td>去除缩进</td>
</tr>
<tr>
<td>Alt+Shift+1~9（非小键盘）</td>
<td>屏幕显示相等数字的小窗口</td>
</tr>
<tr>
<td>Alt+.</td>
<td>闭合当前标签</td>
</tr>
<tr>
<td>Alt+F3</td>
<td>选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑</td>
</tr>
<tr>
<td>Tab</td>
<td>缩进,自动完成</td>
</tr>
<tr>
<td>F2</td>
<td>下一个书签</td>
</tr>
<tr>
<td>F6</td>
<td>检测语法错误</td>
</tr>
<tr>
<td>F9</td>
<td>行排序(按a-z)</td>
</tr>
<tr>
<td>F11</td>
<td>全屏模式</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>日语-发音</title>
    <url>/2017-04-10-japanese-pronounce/</url>
    <content><![CDATA[<p>日语以东京音为标准音，其声调可以分为如下几种：0型，①型，②型，③型，④型，⑤型，⑥型和⑦型等。高声调表示重音，低声调表示轻音。</p>
<p>0型：表示只有第一拍低，其它各拍都高。</p>
<p>①型：表示只有第一拍高，以下其它各拍都低。</p>
<p>②型：表示只有第二拍高，第一拍和以下其它各拍都低。</p>
<p>③型：表示第二拍，第三拍高，第一拍和以下其它各拍都低。</p>
<p>④型：表示第二拍，第三拍，第四拍高，第一拍和以下其它各拍都低。</p>
<p>依此类推其它型。</p>
<span id="more"></span>

<h2 id="1-五十音图"><a href="#1-五十音图" class="headerlink" title="1 五十音图"></a>1 五十音图</h2><h3 id="1-1-清音"><a href="#1-1-清音" class="headerlink" title="1.1 清音"></a>1.1 清音</h3><table>
<thead>
<tr>
<th></th>
<th>あ段</th>
<th>い段</th>
<th>う段</th>
<th>え段</th>
<th>お段</th>
</tr>
</thead>
<tbody><tr>
<td>あ行</td>
<td>あ　ア a</td>
<td>い　イ i</td>
<td>う　ウ u</td>
<td>え　エ e</td>
<td>お　オ　o</td>
</tr>
<tr>
<td>か行 k</td>
<td>か　カ ka</td>
<td>き　キ ki</td>
<td>く　ク ku</td>
<td>け　ケ ke</td>
<td>こ　コ　ko</td>
</tr>
<tr>
<td>さ行 s</td>
<td>さ　サ sa</td>
<td>し　シ shi</td>
<td>す　ス su</td>
<td>せ セ　se</td>
<td>そ　ソ so</td>
</tr>
<tr>
<td>た行 t</td>
<td>た タ　ta</td>
<td>ち　チ chi</td>
<td>つ ツ　tsu</td>
<td>て　テ　te</td>
<td>と　ト to</td>
</tr>
<tr>
<td>な行 n</td>
<td>な　ナ na</td>
<td>に　ニ ni</td>
<td>ぬ ヌ　nu</td>
<td>ね ネ　ne</td>
<td>の　ノ no</td>
</tr>
<tr>
<td>は行 h</td>
<td>は ハ　ha</td>
<td>ひ　ヒ hi</td>
<td>ふ フ　fu</td>
<td>へ　ヘ　he</td>
<td>ほ　ホ ho</td>
</tr>
<tr>
<td>ま行 m</td>
<td>ま　マ ma</td>
<td>み　ミ　mi</td>
<td>む　ム mu</td>
<td>め　メ　me</td>
<td>も　モ　mo</td>
</tr>
<tr>
<td>や行 y</td>
<td>や　ヤ ya</td>
<td></td>
<td>ゆ　ユ yu</td>
<td></td>
<td>よ　ヨ yo</td>
</tr>
<tr>
<td>ら行 r</td>
<td>ら　ラ ra</td>
<td>り　リ ri</td>
<td>る　ル ru</td>
<td>れ　レ re</td>
<td>ろ　ロ ro</td>
</tr>
<tr>
<td>わ行 w</td>
<td>わ　ワ wa</td>
<td></td>
<td></td>
<td></td>
<td>を　ヲ wo</td>
</tr>
<tr>
<td></td>
<td>ん　ン n</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="1-2-拨音-ん"><a href="#1-2-拨音-ん" class="headerlink" title="1.2 拨音 (ん)"></a>1.2 拨音 (ん)</h3><table>
<thead>
<tr>
<th>后续音节</th>
<th>实际发音</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>ぱ、ば、ま行</td>
<td>&#x2F;m&#x2F;</td>
<td>さんぽ、しんぶん、うんめい、こんぶ、かんぶ</td>
</tr>
<tr>
<td>た、だ、ら、な行</td>
<td>&#x2F;n&#x2F;</td>
<td>ほんとう、もんだい、ほんらい、しんねん、こんど、すんな</td>
</tr>
<tr>
<td>其它或词尾</td>
<td>&#x2F;ng&#x2F;</td>
<td>へんか、あんしん、れんあい、まんが、バン、おんせん</td>
</tr>
</tbody></table>
<h3 id="1-3-浊音"><a href="#1-3-浊音" class="headerlink" title="1.3 浊音"></a>1.3 浊音</h3><table>
<thead>
<tr>
<th>が行 g</th>
<th>が　ガ ga</th>
<th>ぎ　ギ　gi</th>
<th>ぐ　グ gu</th>
<th>げ　ゲ ge</th>
<th>ご　ゴ go</th>
</tr>
</thead>
<tbody><tr>
<td>ざ行 z</td>
<td>ざ　ザ za</td>
<td>じ　ジ zi</td>
<td>ず　ズ zu</td>
<td>ぜ　ゼ ze</td>
<td>ぞ　ゾ zo</td>
</tr>
<tr>
<td>だ行 d</td>
<td>だ　ダ da</td>
<td>ぢ　ヂ zi</td>
<td>づ　ヅ zu</td>
<td>で　デ de</td>
<td>ど　ド do</td>
</tr>
<tr>
<td>ば行 b</td>
<td>ば　バ ba</td>
<td>び　ビ bi</td>
<td>ぶ　ブ bu</td>
<td>べ　ベ be</td>
<td>ぼ　ボ bo</td>
</tr>
</tbody></table>
<h3 id="1-4-半浊音"><a href="#1-4-半浊音" class="headerlink" title="1.4 半浊音"></a>1.4 半浊音</h3><table>
<thead>
<tr>
<th>ぱ行 p</th>
<th>ぱ pa</th>
<th>ぴ　pi</th>
<th>ぷ pu</th>
<th>ぺpe</th>
<th>ぽ　po</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>パ</td>
<td>ピ</td>
<td>プ</td>
<td>ペ</td>
<td>ポ</td>
</tr>
</tbody></table>
<h3 id="1-5-拗音"><a href="#1-5-拗音" class="headerlink" title="1.5 拗音"></a>1.5 拗音</h3><p>拗音是在“い段”假名后面加上复元音“や”、“ゆ”、“よ”拼成的音节。拗音符号是把“や”、“ゆ”、“よ”写在“い段”假名的右下角。把拗音自动拉长一拍就是拗长音。</p>
<table>
<thead>
<tr>
<th>きゃ　キャ kya</th>
<th>きゅ　キュ kyu</th>
<th>きょ　キョ kyo</th>
</tr>
</thead>
<tbody><tr>
<td>しゃ　シャ sha</td>
<td>しゅ　シュ shu</td>
<td>しょ　ショ sho</td>
</tr>
<tr>
<td>ちゃ　チャ cha</td>
<td>ちゅ　チュ chu</td>
<td>ちょ　チョ cho</td>
</tr>
<tr>
<td>にゃ　ニャ nya</td>
<td>にゅ　ニュ nyu</td>
<td>にょ　ニョ nyo</td>
</tr>
<tr>
<td>ひゃ　ヒャ hya</td>
<td>ひゅ　ヒュ hyu</td>
<td>ひょ　ヒョ hyo</td>
</tr>
<tr>
<td>みゃ　ミャ mya</td>
<td>みゅ　ミュ myu</td>
<td>みょ　ミョ myo</td>
</tr>
<tr>
<td>りゃ　リャ rya</td>
<td>りゅ　リュ ryu</td>
<td>りょ　リョ ryo</td>
</tr>
<tr>
<td>ぎゃ　ギャ gya</td>
<td>ぎゅ　ギュ gyu</td>
<td>ぎょ　ギョ gyo</td>
</tr>
<tr>
<td>じゃ　ジャ ja</td>
<td>じゅ　ジュ ju</td>
<td>じょ　ジョ jo</td>
</tr>
<tr>
<td>ぢゃ　ヂャ dya</td>
<td>ぢゅ　ヂュ dyu</td>
<td>ぢょ　ヂョ dyo</td>
</tr>
<tr>
<td>びゃ　ビャ bya</td>
<td>びゅ　ビュ byu</td>
<td>びょ　ビョ byo</td>
</tr>
<tr>
<td>ぴゃ　ピャ pya</td>
<td>ぴゅ　ピュ pyu</td>
<td>ぴょ　ピョ pyo</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<p>1）が行假名出现在单词首位置，发本音（浊音）；若出现在单词其他位置，发鼻浊音。</p>
<p>2）か行和た行假名出现在单词首位置，发本音（清音）；若出现在其他位置，发近对应的浊音。</p>
<p>3）ぱ行假名出现在单词首位置，发本音（半浊音）；若出现在其他位置，发ば行对应的音。</p>
<h2 id="2-促音"><a href="#2-促音" class="headerlink" title="2 促音"></a>2 促音</h2><p>发音时用发音器官某一部分堵住呼吸，形成一个短促的顿挫，然后放开堵塞使呼气急冲而出，这种音节叫“促音”，用小“つ”表示，即“っ”。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>促音+か行假名</td>
<td>かっこ、がっき、じっけん、せっけん、はっけん、みっか</td>
</tr>
<tr>
<td>促音+さ行假名</td>
<td>あっさり、けっせき、ざっし、じっせん、しっそ、ねっしん</td>
</tr>
<tr>
<td>促音+た行假名</td>
<td>ねったい、おっと、ずっと、ぜったい、はってん、まったく</td>
</tr>
<tr>
<td>促音+ぱ行假名</td>
<td>いっぱい、いっぺん、じっぴ、じっぷん、にっぽん、りっぱ</td>
</tr>
</tbody></table>
<h2 id="3-长音"><a href="#3-长音" class="headerlink" title="3 长音"></a>3 长音</h2><table>
<thead>
<tr>
<th>长音规则</th>
<th>示例</th>
<th>特例</th>
</tr>
</thead>
<tbody><tr>
<td>あ段假名后加あ</td>
<td>おかあさん</td>
<td></td>
</tr>
<tr>
<td>い段假名后加い</td>
<td>おにいさん</td>
<td></td>
</tr>
<tr>
<td>う段假名后加う</td>
<td>ゆうじん</td>
<td></td>
</tr>
<tr>
<td>え段假名后加い，个别场合加え</td>
<td>せんせい</td>
<td>おねえさん、ええ</td>
</tr>
<tr>
<td>お段假名后加う，个别场合加お</td>
<td>おとうさん</td>
<td>大きい、こお、とお</td>
</tr>
<tr>
<td>外来语用ー</td>
<td>メーデー</td>
<td></td>
</tr>
</tbody></table>
<h2 id="4-“何”发音"><a href="#4-“何”发音" class="headerlink" title="4 “何”发音"></a>4 “何”发音</h2><h3 id="4-1-なん"><a href="#4-1-なん" class="headerlink" title="4.1 なん"></a>4.1 なん</h3><p>１）だ、で、と（表内容时）、の假名前</p>
<p>何だ、これ？</p>
<p>これは何ですか。</p>
<p>何と読みますか。</p>
<p>これは何の本ですか。</p>
<p>２）数量词前</p>
<p>今日は何曜日ですか。</p>
<h3 id="4-2-なに"><a href="#4-2-なに" class="headerlink" title="4.2 なに"></a>4.2 なに</h3><p>１）に、を、が、か、も假名前</p>
<p>何にしますか。</p>
<p>何を食べますか。</p>
<p>何か食べますか。</p>
<p>何もありません。</p>
<p>何がありますか。</p>
<p>２）专用名词</p>
<p>何学校（がっこう）ですか。</p>
<h2 id="5-教室用语"><a href="#5-教室用语" class="headerlink" title="5 教室用语"></a>5 教室用语</h2><ul>
<li>1）同学们早</li>
</ul>
<p>みなさん、おはようございます。</p>
<ul>
<li>2）同学们上午（下午）好</li>
</ul>
<p>みなさん、こんにちは。</p>
<ul>
<li>3）同学们晚上好</li>
</ul>
<p>みなさん、こんばんは。</p>
<ul>
<li>4）请大声朗读</li>
</ul>
<p>大（だい）きな声（こえ）で読（よ）んでください。</p>
<ul>
<li>5）再来一次</li>
</ul>
<p>もう一度（いちど）。</p>
<ul>
<li>6）请大家写</li>
</ul>
<p>みなさん、書（か）いてください。</p>
<ul>
<li>7）明白了吗？</li>
</ul>
<p>わかりましたか。</p>
<ul>
<li>8）同学们再见</li>
</ul>
<p>みなさん、さようなら。</p>
<ul>
<li>9）老师再见</li>
</ul>
<p>先生（せんせい）、さようなら。</p>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>日语</tag>
      </tags>
  </entry>
  <entry>
    <title>聊一聊iOS的那些生命周期</title>
    <url>/2017-04-11-ios-lifecycle/</url>
    <content><![CDATA[<p>iOS应用程序的生命周期，还有程序是运行在前台还是后台，应用程序各个状态的变换，这些对于开发者来说都是很重要的。iOS系统的资源是有限的，应用程序在前台和在后台的状态是不一样的。在后台时，程序会受到系统的很多限制，这样可以提高电池的使用和用户体验。</p>
<p>本文所要说到的生命周期，也不仅仅只是应用生命周期；还包括，视图生命周期。</p>
<span id="more"></span>

<h2 id="应用生命周期"><a href="#应用生命周期" class="headerlink" title="应用生命周期"></a>应用生命周期</h2><p>iOS的应用程序一共有5种状态:</p>
<ul>
<li>Not Running(非运行状态)</li>
</ul>
<p>应用没有运行或被系统终止。</p>
<ul>
<li>Inactive(前台非活动状态)</li>
</ul>
<p>应用正在进入前台状态，但是还不能接受事件处理。</p>
<ul>
<li>Active(前台活动状态)</li>
</ul>
<p>应用进入前台状态，能接受事件处理。</p>
<ul>
<li>Background(后台状态)</li>
</ul>
<p>应用进入后台后，依然能够执行代码。如果有可执行的代码，就会执行代码，如果没有可执行的代码或者将可执行的代码执行完毕，应用会马上进入挂起状态。有的程序经过特殊的请求后可以长期处于Backgroud状态。</p>
<ul>
<li>Suspended(挂起状态)</li>
</ul>
<p>处于挂起的应用进入一种“冷冻”状态,不能执行代码。如果系统内存不够,系统就把挂起的程序清除掉，为前台程序提供更多的内存，应用会被终止。</p>
<p>作为应用程序的委托对象，AppDelegate 类在应用生命周期的不同阶段会回调不同的方法。首先，让我们先了解一下 iOS 应用的不同状态及它们彼此间的关系，如下图所示 ：</p>
<p><img src="/assets/images/tech/ios-lifecycle-ios-app-lifecycle-1.png" alt="状态"></p>
<p>在应用状态跃迁的过程中，iOS 系统会回调AppDelegate中的一些方法，并且发送一些通知。实际上，在应用的生命周期中用到的方法和通知很多，我们选取了几个主要的方法和通知进行详细介绍，具体如下表所述：</p>
<p><img src="/assets/images/tech/ios-lifecycle-ios-app-lifecycle-2.jpeg" alt="说明"></p>
<p>为了便于观察应用程序的运行状态，为AppDelegate.m中的方法添加一些日志输出，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@implementation AppDelegate </span><br><span class="line">  </span><br><span class="line">- (BOOL)application:(UIApplication *)application </span><br><span class="line">    didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;application:didFinishLaunchingWithOptions:&quot;);</span><br><span class="line"> </span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">- (void)applicationWillResignActive:(UIApplication *)application&#123;    </span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;applicationWillResignActive:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application&#123;    </span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;applicationDidEnterBackground:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)applicationWillEnterForeground:(UIApplication *)application&#123;    </span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;applicationWillEnterForeground:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)applicationDidBecomeActive:(UIApplication *)application&#123;    </span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;applicationDidBecomeActive:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)applicationWillTerminate:(UIApplication *)application&#123;    </span><br><span class="line">    NSLog(@&quot;%@&quot;, @&quot;applicationWillTerminate:&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>为了让大家更直观地了解各状态与其相应的方法、通知间的关系，下面以几个应用场景为切入点进行系统的分析。</p>
<h3 id="（一）非运行状态——应用启动场景"><a href="#（一）非运行状态——应用启动场景" class="headerlink" title="（一）非运行状态——应用启动场景"></a>（一）非运行状态——应用启动场景</h3><p>场景描述：用户点击应用图标的时候，可能是第一次启动这个应用，也可能是应用终止后再次启动。该场景的状态跃迁过程见下图，共经历两个阶段3个状态：Not running →Inactive→Active。 </p>
<ul>
<li>1)在Not running→Inactive 阶段。</li>
</ul>
<p>调用<code>application:didFinishLaunchingWithOptions:</code>方法，发出<code>UIApplicationDidFinishLaunchingNotification</code> 通知。 </p>
<ul>
<li>2)在Inactive →Active 阶段。</li>
</ul>
<p>调用 <code>applicationDidBecomeActive: </code>方法，发出<code>UIApplicationDidBecomeActiveNotification</code> 通知。</p>
<p><img src="/assets/images/tech/ios-lifecycle-ios-app-lifecycle-3.png" alt="非运行态"></p>
<h3 id="（二）点击Home键——应用退出场景"><a href="#（二）点击Home键——应用退出场景" class="headerlink" title="（二）点击Home键——应用退出场景"></a>（二）点击Home键——应用退出场景</h3><p>场景描述：应用处于运行状态（即Active状态）时，点击Home键或者有其他的应用导致当前应用中断。该场景的状态跃迁过程可以分成两种情况：可以在后台运行或者挂起，不可以在后台运行或者挂起。根据产品属性文件（如HelloWorld-Info.plist）中的相关属性Application does not run in background 是与否可以控制这两种状态。如果采用文本编辑器打开HelloWorldInfo.plist文件该设置项对应的键是UIApplicationExitsOnSuspend。　</p>
<p>状态跃迁的第一种情况：应用可以在后台运行或者挂起，该场景的状态跃迁过程见下图 ，共经历3 个阶段4个状态：Active → Inactive → Background→Suspended。 </p>
<ul>
<li>1)在Active→Inactive 阶段。</li>
</ul>
<p>调用 <code>applicationWillResignActive:</code>方法，发出<code>UIApplicationWillResignActiveNotification</code> 通知。 </p>
<ul>
<li>2)在Inactive →Background阶段。</li>
</ul>
<p>应用从非活动状态进入到后台（不涉及我们要重点说明的方法和通知）。 </p>
<ul>
<li>3)在Background→Suspended 阶段。</li>
</ul>
<p>调用<code>applicationDidEnterBackground:</code>方法，发出<code>UIApplicationDidEnterBackgroundNotification</code> 通知。</p>
<p><img src="/assets/images/tech/ios-lifecycle-ios-app-lifecycle-4.png" alt="切换"></p>
<p>状态跃迁的第二种情况：应用不可以在后台运行或者挂起，其状态跃迁情况见下图 ，共经历4个阶段5 个状态：Active  → Inactive  → Background→Suspended→Not running 。</p>
<ul>
<li>1)在Active →Inactivd 阶段。</li>
</ul>
<p>应用由活动状态转为非活动状态（不涉及我们要重点说明的方法和通知）。 </p>
<ul>
<li>2)在Inactive →Background阶段。</li>
</ul>
<p>应用从非活动状态进入到后台（不涉及我们要重点说明的方法和通知）。 </p>
<ul>
<li>3)在Background→Suspended 阶段。</li>
</ul>
<p>调用<code>applicationDidEnterBackground:</code>方法， 发出<code>UIApplicationDidEnterBackgroundNotification </code>通知。</p>
<ul>
<li>4)在Suspended →Not running阶段。</li>
</ul>
<p>调用<code>applicationWillTerminate:</code>方法，发出<code>UIApplicationWillTerminateNotification</code>通知。</p>
<p><img src="/assets/images/tech/ios-lifecycle-ios-app-lifecycle-5.png" alt="运行状态"></p>
<p>iOS 在iOS 4之前不支持多任务，点击Home键时，应用会退出并中断；而在iOS 4之后（包括iOS 4），操作系统能够支持多任务处理，点击Home键应用会进入后台但不会中断（内存不够的情况除外）。 </p>
<p>应用在后台也可以进行部分处理工作，处理完成则进入挂起状态。</p>
<h3 id="（三）挂起重新运行场景"><a href="#（三）挂起重新运行场景" class="headerlink" title="（三）挂起重新运行场景"></a>（三）挂起重新运行场景</h3><p>场景描述：挂起状态的应用重新运行。该场景的状态跃迁过程如下图所示，共经历3 个阶段4 个状态：Suspended  → Background  → Inactive  → Active 。</p>
<p><img src="/assets/images/tech/ios-lifecycle-ios-app-lifecycle-6.png" alt="挂起"></p>
<ul>
<li>1)Suspended→Background阶段。</li>
</ul>
<p>应用从挂起状态进入后台（不涉及我们讲述的这几个方法和通知）。 </p>
<ul>
<li>2)Background→Inactive 阶段。</li>
</ul>
<p>调用<code>applicationWillEnterForeground: </code>方法，发出<code>UIApplicationWillEnterForegroundNotification</code>通知。 </p>
<ul>
<li>3)Inactive →Active 阶段。</li>
</ul>
<p>调用<code>applicationDidBecomeActive:</code>方法，发出<code>UIApplicationDidBecomeActiveNotification</code> 通知。</p>
<h3 id="（四）内存清除——应用终止场景"><a href="#（四）内存清除——应用终止场景" class="headerlink" title="（四）内存清除——应用终止场景"></a>（四）内存清除——应用终止场景</h3><p>场景描述：应用在后台处理完成时进入挂起状态（这是一种休眠状态），如果这时发出低内存警告，为了满足其他应用对内存的需要，该应用就会被清除内存从而终止运行，该场景的状态跃迁见下图 。</p>
<p><img src="/assets/images/tech/ios-lifecycle-ios-app-lifecycle-7.png" alt="终止"></p>
<p>内存清除的时候应用终止运行。内存清除有两种情况，可能是系统强制清除内存，也可能是由使用者从任务栏中手动清除（即删掉应用）。内存清除后如果应用再次运行，上一次的运行状态不会被保存，相当于应用第一次运行。</p>
<p>在内存清除场景下，应用不会调用任何方法，也不会发出任何通知。</p>
<h2 id="视图生命周期"><a href="#视图生命周期" class="headerlink" title="视图生命周期"></a>视图生命周期</h2><p>视图是应用的一个重要组成部分，功能的实现与其息息相关，而视图控制器控制着视图，其重要性在整个应用中不言而喻。</p>
<h3 id="视图生命周期与视图控制器关系"><a href="#视图生命周期与视图控制器关系" class="headerlink" title="视图生命周期与视图控制器关系"></a>视图生命周期与视图控制器关系</h3><p>以视图的4 种状态为基础，我们来系统了解一下视图控制器的生命周期。在视图不同的生命周期中，视图控制器会回调不同的方法，具体如下图所示。</p>
<p><img src="/assets/images/tech/ios-lifecycle-ios-ui-lifecycle-1.png" alt="视图"></p>
<p>在视图控制器已被实例化，视图被加载到内存中时调用viewDidLoad方法，这个时候视图并未出现。在该方法中，通常进行的是对所控制的视图进行初始化处理。 </p>
<p>视图可见前后会调用<code>viewWillAppear:</code>方法和<code>viewDidAppear:</code> 方法；视图不可见前后会调用<code>viewWillDisappear:</code> 方法和<code>viewDidDisappear:</code>方法。4个方法调用父类相应的方法以实现其功能，编码时该方法的位置可根据实际情况做以调整，参见如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(void)viewWillAppear:(BOOL)animated&#123;</span><br><span class="line">    [super viewWillAppear:YES];</span><br><span class="line">    //something code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>viewDidLoad</code> 方法在应用运行的时候只调用一次，而这上述4 个方法可以被反复调用多次，它们的使用很广泛但同时也具有很强的技巧性。例如，有的应用会使用重力加速计，重力加速计会不断轮询设备以实时获得设备在z 轴、x 轴和y轴方向的重力加速度。不断的轮询必然会耗费大量电能进而影响电池使用寿命，我们通过利用这4个方法适时地打开或者关闭重力加速计来达到节约电能的目的。怎么使用这4 个方法才能做到“适时”是一个值得思考的问题。 </p>
<p>在低内存情况下，iOS 会调用<code>didReceiveMemoryWarning:</code> 和<code>viewDidUnload:</code>方法。在iOS 6 之后，就不再使用<code>viewDidUnload:</code>，而仅支持<code>didReceiveMemoryWarning：</code>。</p>
<p><code>didReceiveMemoryWarning: </code>方法的主要职能是释放内存，包括视图控制器中的一些成员变量和视图的释放。现举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    self.button = nil;</span><br><span class="line">    self.myStringD = nil; </span><br><span class="line">    [myStringC release];    //ARC内存管理情况下不用</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上述5 个方法视图控制器外，还有很多其他方法。</p>
<h3 id="iOS-UI-状态保持和恢复"><a href="#iOS-UI-状态保持和恢复" class="headerlink" title="iOS  UI 状态保持和恢复"></a>iOS  UI 状态保持和恢复</h3><p>iOS 设计规范中要求，当应用退出的时候（包括被终止运行的时候），需要保持界面中UI元素的状态，当再次进来的时候看到的状态与退出时是一样的。在iOS 之后，苹果提供以下API使得UI状态保持和恢复变得很容易。 </p>
<p>在iOS 中，我们可以在以下3种地方实现状态保持和恢复：</p>
<ul>
<li><p>应用程序委托对象 </p>
</li>
<li><p>视图控制器 </p>
</li>
<li><p>自定义视图</p>
</li>
</ul>
<p>恢复标识是iOS为了实现UI状态保持和恢复添加的设置项目。我们还需要在应用程序委托对象AppDelegate代码部分做一些修改，添加的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(BOOL) application:(UIApplication *)application shouldSaveApplicationState:(NSCoder *)coder&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">-(BOOL) application:(UIApplication *)application shouldRestoreApplicationState:(NSCoder *)coder&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">- (void)application:(UIApplication *)application willEncodeRestorableStateWithCoder:(NSCoder *)coder&#123;</span><br><span class="line">    [coder encodeFloat:2.0 forKey:@&quot;Version&quot;];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">- (void)application:(UIApplication *)application didDecodeRestorableStateWithCoder:(NSCoder *)coder&#123;</span><br><span class="line">    float lastVer = [coder decodeFloatForKey:@&quot;Version&quot;];</span><br><span class="line">    NSLog(@&quot;lastVer = %f&quot;,lastVer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中application:shouldSaveApplicationState:方法在应用退出时调用，负责控制是否允许保存状态，返回YES 情况是可以保存，NO是不保存。 </p>
<p><code>application:shouldRestoreApplicationState:</code>方法在应用启动时调用，负责控制是否恢复上次退出时的状态，返回YES 表示可以恢复，返回NO表示不可以恢复。 </p>
<p><code>application:willEncodeRestorableStateWithCoder:</code>方法在保存时调用，在这个方法中实现UI状态或数据的保存，其中<code>[coder encodeFloat:2.0 forKey:@&quot;Version&quot;]</code> 语句是保存简单数据。 </p>
<p><code>application:didDecodeRestorableStateWithCoder:</code>方法在恢复时调用，在这个方法中实现UI状态或数据的恢复，其中<code>[coder decodeFloatForKey:@&quot;Version&quot;]</code> 语句用于恢复上次保存的数据。 </p>
<p>想要实现具体界面中控件的保持和恢复，还需要在它的视图控制器中添加一些代码。我们在ViewController.m中添加的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(void)encodeRestorableStateWithCoder:(NSCoder *)coder&#123;</span><br><span class="line">    [super encodeRestorableStateWithCoder:coder];</span><br><span class="line">    [coder encodeObject:self.txtField.text forKey:kSaveKey];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">-(void)decodeRestorableStateWithCoder:(NSCoder *)coder&#123;</span><br><span class="line">    [super decodeRestorableStateWithCoder:coder];</span><br><span class="line">    self.txtField.text = [coder decodeObjectForKey:kSaveKey];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在iOS 6之后，视图控制器都添加了两个方法——<code>encodeRestorableStateWithCoder:</code> 和<code>decodeRestorableStateWithCoder:</code> ，用来实现该控制器中的控件或数据的保存和恢复。</p>
<p>其中<code>encodeRestorableStateWithCoder:</code>方法在保存时候调用，<code>[coder encodeObject:self. txtField.textforKey:kSaveKey]</code>语句是按照指定的键保存文本框的内容。</p>
<p><code>decodeRestorableStateWithCoder:</code>方法在恢复时调用，<code>[coder decodeObjectForKey:kSaveKey]</code>在恢复文本框内容时调用，保存和恢复事实上就是向一个归档文件中编码和解码的过程。</p>
<h2 id="移除Main-storyboard"><a href="#移除Main-storyboard" class="headerlink" title="移除Main.storyboard"></a>移除Main.storyboard</h2><p>每次使用Single View Application模板创建工程之后，总是会有一个Main.storyboard文件，那么，当我们使用代码布局的时候，很显然是不需要它的。那么，如何将它从工程中移除呢？只要进行如下几步即可。</p>
<h3 id="在工程配置中移除关联"><a href="#在工程配置中移除关联" class="headerlink" title="在工程配置中移除关联"></a>在工程配置中移除关联</h3><p><img src="/assets/images/tech/ios-lifecycle-ios-remove-storyboard-1.jpeg" alt="配置"></p>
<p>在TARGETS中，将Main InInterface选项中的值清空并保存设置。</p>
<h3 id="移除Main-storyboard中的关联文件"><a href="#移除Main-storyboard中的关联文件" class="headerlink" title="移除Main.storyboard中的关联文件"></a>移除Main.storyboard中的关联文件</h3><p><img src="/assets/images/tech/ios-lifecycle-ios-remove-storyboard-2.png" alt="移除"></p>
<p>选择storyboard文件。将类关联文件项清空并保存设置。</p>
<h3 id="移除Main-storyboard文件"><a href="#移除Main-storyboard文件" class="headerlink" title="移除Main.storyboard文件"></a>移除Main.storyboard文件</h3><p><img src="/assets/images/tech/ios-lifecycle-ios-remove-storyboard-3.jpeg" alt="文件"></p>
<p>从工程中移除文件。</p>
<h3 id="在AppDelegate中添加代码"><a href="#在AppDelegate中添加代码" class="headerlink" title="在AppDelegate中添加代码"></a>在AppDelegate中添加代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    // Override point for customization after application launch.   </span><br><span class="line">    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];</span><br><span class="line">    </span><br><span class="line">    ViewController *viewController = [[ViewController alloc] init];</span><br><span class="line">    self.window.rootViewController = viewController;  </span><br><span class="line">    self.window.backgroundColor = [UIColor purpleColor];</span><br><span class="line">　[self.window makeKeyAndVisible];    </span><br><span class="line">   return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成以上几步，运行工程即可，顺利运行，没有出现任何error或waring。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>objc</tag>
        <tag>ios</tag>
        <tag>application</tag>
        <tag>ui</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是iOS的安全模式</title>
    <url>/2017-04-19-ios-security-pattern/</url>
    <content><![CDATA[<p>作为iOS开发，作品App肯定需要提交到App Store审核。平心而论，App Store确实成功地将许多恶意软件拒之门外。但是，对开发者而言，应用程序的审核流程是令人沮丧的黑箱操作。</p>
<p>当然，什么是恶意程序是由Apple来定义。因为App Store的存在，所以，如果想要实现某些特定的功能，唯一的手段就是将设备越狱或者骗过App Store的审查。</p>
<p>官方的App审查永远无法抓到那些钻空子的恶意程序，所以需要另外一套高效的机制，来阻止恶意程序破坏整个操作系统的安全。</p>
<span id="more"></span>

<h2 id="安全启动"><a href="#安全启动" class="headerlink" title="安全启动"></a>安全启动</h2><p>当启动一台iOS设备时，系统首先会从只读的引导ROM中读取初始化指令，即系统引导程序。这个引导ROM包含Apple官方权威认证的公钥，它会验证底层启动加载器（LLB）的签名，一旦通过验证就启动它。</p>
<p>然后验证第二级引导程序iBoot，iBoot启动后设备就可以进入恢复模式或启动内核。在iBoot验证完成内核签名的合法性之后，整个启动程序开始步入正轨：加载驱动程序、检测设备、启动系统守护进程。</p>
<p>这个信任链确保所有的系统组件都由Apple写入、签名、分发，不能来自第三方机构，特别是那些恶意的攻击者以及企图越狱设备的黑客。App启动时也会用信任链去审查签名。所有的App都必须直接或间接由Apple签名。</p>
<p>越狱工作的原理正是攻击这一信任链。越狱工具的作者需要找到这一信任链条上的漏洞，从而禁掉链条中负责验证的组件。破解引导ROM通常是最可取的方法，因为该组件不会因Apple今后的软件更新而改变。</p>
<p>有关更多签名知识可以参看：</p>
<p><a href="http://wereadteam.github.io/2017/03/13/Signature/">《iOS App 签名的原理》</a></p>
<h2 id="沙盒机制"><a href="#沙盒机制" class="headerlink" title="沙盒机制"></a>沙盒机制</h2><p>App的沙盒机制是一种基于FreeBSD系统TrustedBSD框架的强制访问控制（MAC）机制，它采用一种类似于Lisp的配置语言来描述哪些资源系统可以访问，哪些禁止访问。这些资源主要包括文件、系统服务、网络连接、内存资源等。</p>
<p>MAC机制不同于传统的访问控制机制（比如自主访问控制（DAC）），它不允许主体（比如用户进程）操作对象（文件、套接字等）。DAC最常见的形式就是UNIX系统上的用户、组和其它权限，所有这些都可以被授予读、写或执行的权限。在DAC系统中，用户如果拥有一个对象的所有权，也就拥有该对象的修改权限。</p>
<p>MAC在沙盒中意味着App被关进了一个虚拟的容器。该容器遵循一系列的特定规则，即哪些系统资源可以访问。</p>
<p>在文件访问方面，一般只能访问App的包目录；App可以读写存储在该位置的文件。</p>
<p>Android的访问控制机制与MAC不同。Android实现了一个更加传统的DAC模型，App都有自己的用户ID和属于该ID的文件夹，其权限管理严格按照传统的UNIX文件权限管理运作。虽然这两项机制工作起来都没有问题，但MAC的扩展性总体来说还是更强一些。比如，除了App目录隔离，MAC机制还可以限制网络访问或系统守护进程的操作。</p>
<h2 id="数据保护和全盘加密"><a href="#数据保护和全盘加密" class="headerlink" title="数据保护和全盘加密"></a>数据保护和全盘加密</h2><p>数据保护和全盘加密两机制可以实现远程抹除设备数据，在设备丢失的情况下保护用户数据免于泄漏。</p>
<p>文件系统加密并不能防止从一个正在运行的设备上窃取数据的行为。如果一个App可以从磁盘中读取一个文件，那文件系统加密并没有任何用武之处，因为内核对于任何尝试读取这些文件的进程都是透明解密的。换句话说，相比那些读取文件的调用行为，文件系统加密工作都是更底层。一旦攻破者攻破了系统验证，那就能无障碍地读取任意文件。</p>
<p>全盘加密对于以下两个安全特性是必要的：安全删除文件、远程设备擦出。iOS中使用的加密密钥是分层级的，只需要简单丢弃一个加密密钥就能彻底销毁整层的数据，甚至是销毁整个文件系统。</p>
<h2 id="加密密钥的层级"><a href="#加密密钥的层级" class="headerlink" title="加密密钥的层级"></a>加密密钥的层级</h2><p>iOS文件系统中用于数据加密的密钥是分等级的，即用密钥来加密其它密钥，这样Apple就能更精确的控制数据什么时候可用。</p>
<p><img src="/assets/images/tech/ios-security-pattarn-01.png" alt="加密密钥层级图"></p>
<p>文件密钥（File Key）针对每个文件独立生成，存储在文件的元数据中。</p>
<p>层级密钥（Class Key）为数据提供不同级别的保护。</p>
<p>文件系统密钥（Filesystem Key）是一种全局加密密钥，当元数据被层级密钥加密后，使用文件系统密钥来加密涉及文件安全的元数据。</p>
<p>设备密钥（Device Key）通常被称为UID密钥，每台设备唯一，只能通过硬件的AES引擎访问，操作系统无法直接获取。它是系统的主密钥，用来加密文件系统密钥和层级密钥。</p>
<p>用户密码（User Passcode），可与设备密钥结合起来加密层级密钥。</p>
<p>一旦设置密码，这个密钥等级也允许开发者自己决定本地存储的数据该如何保护，包括在设备锁定时是否能被访问、数据能否备份到其它设备等。</p>
<h2 id="ASLR和XN及其它机制"><a href="#ASLR和XN及其它机制" class="headerlink" title="ASLR和XN及其它机制"></a>ASLR和XN及其它机制</h2><p>iOS用两套标准机制来预防代码执行攻击：地址空间结构随机化（ASLR）和XN bit（eXecute Never，标记该段内存区域不包含可执行代码）。</p>
<p>每次执行程序时，ASLR都会随机分配程序、数据、堆和栈的内存位置。而共享库的内存地址只在每次系统重启时随机设置，因为共享库需要在多个进程中使用。ALSR机制可以预防缓存区移除攻击（return-to-libc），因为函数和库的内存地址随机，而这种攻击依赖于基本库和函数的已知地址。</p>
<p>XN bit，一般对应非ARM平台的NX（No-eXecute）bit，允许操作系统将某段内存标记为不可执行，这由CPU来控制。在iOS中，这个机制默认应用在程序的栈和堆上。</p>
<p>每个程序都有一段可写可执行的内存，但是它必须是经过Apple官方签名授权系统的签名。Safari浏览器中的JavaScript即时（JIT, Just-in-time）编译器会用到这段内存。而WebView并不具备JIT功能，这样虽然可以避免代码执行攻击，但是也使得iOS平台上的Chrome无法做到像Safari那样好用。</p>
<h2 id="越狱检测"><a href="#越狱检测" class="headerlink" title="越狱检测"></a>越狱检测</h2><p>越狱的本质就是通过一系列步骤来禁掉签名机制，从而允许设备运行未经Apple官方审核的应用。黑箱测试应用程序是越狱的重要能力。</p>
<p>其实，越狱不一定要禁掉iOS的沙盒机制，它只是允许你在沙盒外安装App。安装在移动用户主目录下的App（即通过App Store安装）仍然受到沙盒限制。第三方的App需要安装在越狱设备中权限更高的<code>/Applications</code>目录下，与Apple股票应用安装在一起。</p>
<h2 id="动态修复"><a href="#动态修复" class="headerlink" title="动态修复"></a>动态修复</h2><p>一般来说，如果一段原生代码没有经过Apple发布的密钥签名认证，App则无法运行它。如果Apple的签名验证逻辑中存在bug或漏洞，可能会允许下载和执行原生代码。</p>
<p>iOS有一个特性，可以让程序分配一段没有NX保护的内存区块（该内存区块可读、可写，甚至可执行），里面运行的代码也不需要经过签名认证。这个机制在Safari上的JIT编译器上使用。这个运用场景中，就可能会产生漏洞，业界著名的例子就是Charlie Miller。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>安全</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 学习 基础篇</title>
    <url>/2017-04-22-python-basic-knowledge/</url>
    <content><![CDATA[<p>全世界大概有几百种编程语言，而其中著名的只有十几种。Python就是著名编程语言之一。它起源于“龟叔”（Guido van Rossum，荷兰人）在1989年圣诞节间的无聊，而为了打发时间所创造。</p>
<p>可见业余时间比工作时间创造出来的东西更容易出名哈，当然，这是开玩笑的。“龟叔”赋予Python“优雅、明确、简单”的特点。</p>
<p>那么，Python适合做什么呢？它主要适用领域：Web网站和各种网络服务（YouTube、Instagram、douban、openstack）；系统工具和脚本；作为“胶水”语言把其它语言开发的模块包装起来方便使用。</p>
<p>优点是显著的，但是也少不了缺点。Python不适用的领域：贴近硬件的代码（首选C）；移动开发（iOS／Android都有各自的开发语言）；因为不能做到告诉渲染，所以不适合游戏开发（首选C／C++）。</p>
<span id="more"></span>

<h2 id="Python和其它语言对比"><a href="#Python和其它语言对比" class="headerlink" title="Python和其它语言对比"></a>Python和其它语言对比</h2><table>
<thead>
<tr>
<th>语言</th>
<th>类型</th>
<th>运行速度</th>
<th>代码量</th>
</tr>
</thead>
<tbody><tr>
<td>C</td>
<td>编译为机器码</td>
<td>非常快</td>
<td>非常多</td>
</tr>
<tr>
<td>Java</td>
<td>编译为字节码</td>
<td>快</td>
<td>多</td>
</tr>
<tr>
<td>Python</td>
<td>解释执行</td>
<td>慢</td>
<td>少</td>
</tr>
</tbody></table>
<p>CPU越来越快，程序的运行速度瓶颈往往不在Python的执行，更多受到网络速度和硬盘速度的制约。</p>
<p>另外，Python发布程序即发布源代码。</p>
<h2 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h2><p>前往<a href="http://www.python.org/">官网下载</a>对应平台对应工具。另外Python2.7版本和3.3版本并不兼容，所以开发时请注意使用Python的版本。</p>
<p>作为Mac OS X使用者，其实更推荐<a href="https://www.jetbrains.com/pycharm/">PyCharm IDE</a>。安装之后直接使用即可。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：</p>
<h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>Python可以处理任意大小的整数，当然包括负整数，在Python程序中，整数的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。</p>
<p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10^9 和 12.3x10^8 是相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9 就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。</p>
<p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是以’’或””括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来。</p>
<p>布尔值可以用and、or和not运算。</p>
<p>and运算是与运算，只有所有都为 True，and运算结果才是 True。</p>
<p>or运算是或运算，只要其中有一个为 True，or 运算结果就是 True。</p>
<p>not运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。</p>
<h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p>
<p>此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型。</p>
<h2 id="print-语句"><a href="#print-语句" class="headerlink" title="print 语句"></a>print 语句</h2><p>print语句可以向屏幕上输出指定的文字。比如输出’hello, world’，用代码实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print &#x27;hello, world&#x27;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1.当我们在Python交互式环境下编写代码时，&gt;&gt;&gt;是Python解释器的提示符，不是代码的一部分。</p>
<p>2.当我们在文本编辑器中编写代码时，千万不要自己添加 &gt;&gt;&gt;。</p>
<p>print语句也可以跟上多个字符串，用逗号“,”隔开，就可以连成一串输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print &#x27;The quick brown fox&#x27;, &#x27;jumps over&#x27;, &#x27;the lazy dog&#x27;</span><br><span class="line">The quick brown fox jumps over the lazy dog</span><br></pre></td></tr></table></figure>

<p>print会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的：</p>
<p><img src="/assets/images/tech/python-basic-knowledge-1.jpg" alt="print解释图"></p>
<p>print也可以打印整数，或者计算结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print 300</span><br><span class="line">300    #运行结果</span><br><span class="line">&gt;&gt;&gt; print 100 + 200</span><br><span class="line">300    #运行结果</span><br></pre></td></tr></table></figure>

<p>因此，我们可以把计算100 + 200的结果打印得更漂亮一点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print &#x27;100 + 200 =&#x27;, 100 + 200</span><br><span class="line">100 + 200 = 300     #运行结果</span><br></pre></td></tr></table></figure>

<p>注意: 对于100 + 200，Python解释器自动计算出结果300，但是，’100 + 200 &#x3D;’是字符串而非数学公式，Python把它视为字符串，请自行解释上述打印结果。</p>
<h2 id="Python的注释"><a href="#Python的注释" class="headerlink" title="Python的注释"></a>Python的注释</h2><p>任何时候，我们都可以给程序加上注释。注释是用来说明代码的，给自己或别人看，而程序运行的时候，Python解释器会直接忽略掉注释，所以，有没有注释不影响程序的执行结果，但是影响到别人能不能看懂你的代码。</p>
<p>Python的注释以<code>#</code>开头，后面的文字直到行尾都算注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 这一行全部都是注释...</span><br><span class="line">print &#x27;hello&#x27; # 这也是注释</span><br></pre></td></tr></table></figure>

<p>注释还有一个巧妙的用途，就是一些代码我们不想运行，但又不想删除，就可以用注释暂时屏蔽掉：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 暂时不想运行下面一行代码:</span><br><span class="line"># print &#x27;hello, python.&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>在Python中，变量的概念基本上和初中代数的方程变量是一致的。</p>
<p>例如，对于方程式<code>y=x*x</code>，x就是变量。当<code>x=2</code>时，计算结果是4，当<code>x=5</code>时，计算结果是25。</p>
<p>只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p>
<p>在Python程序中，变量是用一个变量名表示，变量名必须是<strong>大小写英文、数字和下划线（_）的组合，且不能用数字开头</strong>，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 1</span><br></pre></td></tr></table></figure>

<p>变量<code>a</code>是一个整数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t_007 = &#x27;T007&#x27;</span><br></pre></td></tr></table></figure>

<p>变量<code>t_007</code>是一个字符串。</p>
<p>在Python中，等号&#x3D;是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 123    # a是整数</span><br><span class="line">print a</span><br><span class="line">a = &#x27;Chars&#x27;   # a变为字符串</span><br><span class="line">print a</span><br></pre></td></tr></table></figure>

<p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。</p>
<p>静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（&#x2F;&#x2F; 表示注释）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 123; // a是整数类型变量</span><br><span class="line">a = &quot;Chars&quot;; // 错误：不能把字符串赋给整型变量</span><br></pre></td></tr></table></figure>

<p>和静态语言相比，动态语言更灵活，就是这个原因。</p>
<p>请不要把赋值语句的等号等同于数学的等号。比如下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 10</span><br><span class="line">x = x + 2</span><br></pre></td></tr></table></figure>

<p>如果从数学上理解<code>x = x + 2</code>那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式<code>x + 2</code>，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。</p>
<p>最后，理解变量在计算机内存中的表示也非常重要。当我们写：<code>a = &#39;ABC&#39;</code>时，Python解释器干了两件事情：</p>
<ol>
<li><p>在内存中创建了一个’ABC’的字符串；</p>
</li>
<li><p>在内存中创建了一个名为a的变量，并把它指向’ABC’。</p>
</li>
</ol>
<p>也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = &#x27;ABC&#x27;</span><br><span class="line">b = a</span><br><span class="line">a = &#x27;XYZ&#x27;</span><br><span class="line">print b</span><br></pre></td></tr></table></figure>

<p>最后一行打印出变量b的内容到底是<code>&#39;ABC&#39;</code>呢还是<code>&#39;XYZ&#39;</code>？如果从数学意义上理解，就会错误地得出b和a相同，也应该是<code>&#39;XYZ&#39;</code>，但实际上b的值是<code>&#39;ABC&#39;</code>，让我们一行一行地执行代码，就可以看到到底发生了什么事：</p>
<p>执行<code>a = &#39;ABC&#39;</code>，解释器创建了字符串<code> &#39;ABC&#39;</code>和变量<code> a</code>，并把a指向<code> &#39;ABC&#39;</code>：</p>
<p><img src="/assets/images/tech/python-basic-knowledge-2.jpg" alt="变量图1"></p>
<p>执行<code>b = a</code>，解释器创建了变量 b，并把b指向 a 指向的字符串<code>&#39;ABC&#39;</code>：</p>
<p><img src="/assets/images/tech/python-basic-knowledge-3.jpg" alt="变量图2"></p>
<p>执行<code>a = &#39;XYZ&#39;</code>，解释器创建了字符串<code>&#39;XYZ&#39;</code>，并把a的指向改为<code>&#39;XYZ&#39;</code>，但b并没有更改：</p>
<p><img src="/assets/images/tech/python-basic-knowledge-4.jpg" alt="变量图3"></p>
<p>所以，最后打印变量b的结果自然是<code>&#39;ABC&#39;</code>了。</p>
<h2 id="字符串-1"><a href="#字符串-1" class="headerlink" title="字符串"></a>字符串</h2><h3 id="定义字符串"><a href="#定义字符串" class="headerlink" title="定义字符串"></a>定义字符串</h3><p>前面我们讲解了什么是字符串。字符串可以用<code>&#39;&#39;</code>或者<code>&quot;&quot;</code>括起来表示。</p>
<p>如果字符串本身包含’怎么办？比如我们要表示字符串 <code>I&#39;m OK </code>，这时，可以用<code>&quot; &quot;</code>括起来表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;I&#x27;m OK&quot;</span><br></pre></td></tr></table></figure>

<p>类似的，如果字符串包含”，我们就可以用’ ‘括起来表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;Learn &quot;Python&quot; in Chars&#x27;s Blog&#x27;</span><br></pre></td></tr></table></figure>

<p>如果字符串既包含’又包含”怎么办？</p>
<p>这个时候，就需要对字符串的某些特殊字符进行“转义”，Python字符串用<code>\</code>进行转义。</p>
<p>要表示字符串 <code>Bob said &quot;I&#39;m OK&quot;</code>.<br>由于 ‘ 和 “ 会引起歧义，因此，我们在它前面插入一个<code>\</code>表示这是一个普通字符，不代表字符串的起始，因此，这个字符串又可以表示为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;Bob said \&quot;I\&#x27;m OK\&quot;.&#x27;</span><br></pre></td></tr></table></figure>

<p>注意：转义字符 \ 不计入字符串的内容中。</p>
<p>常用的转义字符还有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\n 表示换行</span><br><span class="line">\t 表示一个制表符</span><br><span class="line">\\ 表示 \ 字符本身</span><br></pre></td></tr></table></figure>

<h3 id="raw字符串与多行字符串"><a href="#raw字符串与多行字符串" class="headerlink" title="raw字符串与多行字符串"></a>raw字符串与多行字符串</h3><p>如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀<code>r</code>，表示这是一个 raw 字符串，里面的字符就不需要转义了。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r&#x27;\(~_~)/ \(~_~)/&#x27;</span><br></pre></td></tr></table></figure>

<p>但是<code>r&#39;...&#39;</code>表示法不能表示多行字符串，也不能表示包含<code>&#39;</code>和 <code>&quot;</code>的字符串（为什么？）</p>
<p>如果要表示多行字符串，可以用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;Line 1</span><br><span class="line">Line 2</span><br><span class="line">Line 3&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>上面这个字符串的表示方法和下面的是完全一样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;Line 1\nLine 2\nLine 3&#x27;</span><br></pre></td></tr></table></figure>

<p>还可以在多行字符串前面添加<code>r</code>，把这个多行字符串也变成一个raw字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r&#x27;&#x27;&#x27;Python is created by &quot;Guido&quot;.</span><br><span class="line">It is free and easy to learn.</span><br><span class="line">Let&#x27;s start learn Python in Chars&#x27;s Blog!&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="Unicode字符串"><a href="#Unicode字符串" class="headerlink" title="Unicode字符串"></a>Unicode字符串</h3><p>字符串还有一个编码问题。</p>
<p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111&#x3D;十进制255），0 - 255被用来表示大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母 A 的编码是65，小写字母 z 的编码是122。</p>
<p>如果要表示中文，显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。</p>
<p>类似的，日文和韩文等其他语言也有这个问题。为了统一所有文字的编码，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p>
<p>Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。</p>
<p>因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码，普通的字符串’ABC’在Python内部都是ASCII编码的。</p>
<p>Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u’…’表示，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print u&#x27;中文&#x27;</span><br><span class="line">中文</span><br></pre></td></tr></table></figure>

<p>注意: 不加 u ，中文就不能正常显示。</p>
<p>Unicode字符串除了多了一个 u 之外，与普通字符串没啥区别，转义字符和多行表示法仍然有效：</p>
<p>转义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u&#x27;中文\n日文\n韩文&#x27;</span><br></pre></td></tr></table></figure>

<p>多行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u&#x27;&#x27;&#x27;第一行</span><br><span class="line">第二行&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>raw+多行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ur&#x27;&#x27;&#x27;Python的Unicode字符串支持&quot;中文&quot;,</span><br><span class="line">&quot;日文&quot;,</span><br><span class="line">&quot;韩文&quot;等多种语言&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>如果中文字符串在Python环境下遇到<code> UnicodeDecodeError</code>，这是因为.py文件保存的格式有问题。可以在第一行添加注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure>

<p>目的是告诉Python解释器，用UTF-8编码读取源代码。然后用Notepad++ 另存为… 并选择UTF-8格式保存。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="创建list"><a href="#创建list" class="headerlink" title="创建list"></a>创建list</h3><p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</p>
<p>比如，列出班里所有同学的名字，就可以用一个list表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br></pre></td></tr></table></figure>

<p>list是数学意义上的有序集合，也就是说，list中的元素是按照顺序排列的。</p>
<p>构造list非常简单，按照上面的代码，直接用 [ ] 把list的所有元素都括起来，就是一个list对象。通常，我们会把list赋值给一个变量，这样，就可以通过变量来引用list：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; classmates = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br><span class="line">&gt;&gt;&gt; classmates # 打印classmates变量的内容</span><br><span class="line">[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]</span><br></pre></td></tr></table></figure>

<p>由于Python是动态语言，所以list中包含的元素并不要求都必须是同一种数据类型，我们完全可以在list中包含各种数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&#x27;Michael&#x27;, 100, True]</span><br></pre></td></tr></table></figure>

<p>一个元素也没有的list，就是空list：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; empty_list = []</span><br></pre></td></tr></table></figure>

<h3 id="按照索引访问list"><a href="#按照索引访问list" class="headerlink" title="按照索引访问list"></a>按照索引访问list</h3><p>由于list是一个有序集合，所以，我们可以用一个list按分数从高到低表示出班里的3个同学：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;]</span><br></pre></td></tr></table></figure>

<p>那我们如何从list中获取指定第 N 名的同学呢？方法是通过索引来获取list中的指定元素。</p>
<p>需要特别注意的是，索引从 0 开始，也就是说，第一个元素的索引是0，第二个元素的索引是1，以此类推。</p>
<p>因此，要打印第一名同学的名字，用 L[0]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print L[0]</span><br><span class="line">Adam</span><br></pre></td></tr></table></figure>

<p>要打印第二名同学的名字，用 L[1]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print L[1]</span><br><span class="line">Lisa</span><br></pre></td></tr></table></figure>

<p>要打印第三名同学的名字，用 L[2]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print L[2]</span><br><span class="line">Bart</span><br></pre></td></tr></table></figure>

<p>要打印第四名同学的名字，用 L[3]:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print L[3]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure>

<p>报错了！IndexError意思就是索引超出了范围，因为上面的list只有3个元素，有效的索引是 0，1，2。</p>
<p>所以，使用索引时，<strong>千万注意不要越界</strong>。</p>
<h3 id="倒序访问list"><a href="#倒序访问list" class="headerlink" title="倒序访问list"></a>倒序访问list</h3><p>我们还是用一个list按分数从高到低表示出班里的3个同学：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;]</span><br></pre></td></tr></table></figure>

<p>这时，老师说，请分数最低的同学站出来。</p>
<p>要写代码完成这个任务，我们可以先数一数这个 list，发现它包含3个元素，因此，最后一个元素的索引是2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print L[2]</span><br><span class="line">Bart</span><br></pre></td></tr></table></figure>

<p>有没有更简单的方法？有！</p>
<p>Bart同学是最后一名，俗称倒数第一，所以，我们可以用 -1 这个索引来表示最后一个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print L[-1]</span><br><span class="line">Bart</span><br></pre></td></tr></table></figure>

<p>Bart同学表示躺枪。</p>
<p>类似的，倒数第二用 -2 表示，倒数第三用 -3 表示，倒数第四用 -4 表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print L[-2]</span><br><span class="line">Lisa</span><br><span class="line">&gt;&gt;&gt; print L[-3]</span><br><span class="line">Adam</span><br><span class="line">&gt;&gt;&gt; print L[-4]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br></pre></td></tr></table></figure>

<p>L[-4] 报错了，因为倒数第四不存在，一共只有3个元素。</p>
<p>使用倒序索引时，也要<strong>注意不要越界</strong>。</p>
<h3 id="添加新元素"><a href="#添加新元素" class="headerlink" title="添加新元素"></a>添加新元素</h3><p>现在，班里有3名同学：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;]</span><br></pre></td></tr></table></figure>

<p>今天，班里转来一名新同学 Paul，如何把新同学添加到现有的 list 中呢？</p>
<p>第一个办法是用 list 的 append() 方法，把新同学追加到 list 的末尾：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;]</span><br><span class="line">&gt;&gt;&gt; L.append(&#x27;Paul&#x27;)</span><br><span class="line">&gt;&gt;&gt; print L</span><br><span class="line">[&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;, &#x27;Paul&#x27;]</span><br></pre></td></tr></table></figure>

<p>append()总是把新的元素添加到 list 的尾部。</p>
<p>如果 Paul 同学表示自己总是考满分，要求添加到第一的位置，怎么办？</p>
<p>方法是用list的 insert()方法，它接受两个参数，第一个参数是索引号，第二个参数是待添加的新元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;]</span><br><span class="line">&gt;&gt;&gt; L.insert(0, &#x27;Paul&#x27;)</span><br><span class="line">&gt;&gt;&gt; print L</span><br><span class="line">[&#x27;Paul&#x27;, &#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;]</span><br></pre></td></tr></table></figure>

<p>L.insert(0, ‘Paul’) 的意思是，’Paul’将被添加到索引为 0 的位置上（也就是第一个），而原来索引为 0 的Adam同学，以及后面的所有同学，都自动向后移动一位。</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>Paul同学刚来几天又要转走了，那么我们怎么把Paul 从现有的list中删除呢？</p>
<p>如果Paul同学排在最后一个，我们可以用list的pop()方法删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;, &#x27;Paul&#x27;]</span><br><span class="line">&gt;&gt;&gt; L.pop()</span><br><span class="line">&#x27;Paul&#x27;</span><br><span class="line">&gt;&gt;&gt; print L</span><br><span class="line">[&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;]</span><br></pre></td></tr></table></figure>

<p>pop()方法总是删掉list的最后一个元素，并且它还返回这个元素，所以我们执行 L.pop() 后，会打印出 ‘Paul’。</p>
<p>如果Paul同学不是排在最后一个怎么办？比如Paul同学排在第三：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Paul&#x27;, &#x27;Bart&#x27;]</span><br></pre></td></tr></table></figure>

<p>要把Paul踢出list，我们就必须先定位Paul的位置。由于Paul的索引是2，因此，用 pop(2)把Paul删掉：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L.pop(2)</span><br><span class="line">&#x27;Paul&#x27;</span><br><span class="line">&gt;&gt;&gt; print L</span><br><span class="line">[&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h3><p>假设现在班里仍然是3名同学：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;]</span><br></pre></td></tr></table></figure>

<p>现在，Bart同学要转学走了，碰巧来了一个Paul同学，要更新班级成员名单，我们可以先把Bart删掉，再把Paul添加进来。</p>
<p>另一个办法是直接用Paul把Bart给替换掉：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L[2] = &#x27;Paul&#x27;</span><br><span class="line">&gt;&gt;&gt; print L</span><br><span class="line">L = [&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Paul&#x27;]</span><br></pre></td></tr></table></figure>

<p>对list中的某一个索引赋值，就可以直接用新的元素替换掉原来的元素，list包含的元素个数保持不变。</p>
<p>由于Bart还可以用 -1 做索引，因此，下面的代码也可以完成同样的替换工作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L[-1] = &#x27;Paul&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><h3 id="创建tuple"><a href="#创建tuple" class="headerlink" title="创建tuple"></a>创建tuple</h3><p>tuple是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，但是，tuple一旦创建完毕，就不能修改了。</p>
<p>同样是表示班里同学的名称，用tuple表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;)</span><br></pre></td></tr></table></figure>

<p>创建tuple和创建list唯一不同之处是用( )替代了[ ]。</p>
<p>现在，这个 t 就不能改变了，tuple没有 append()方法，也没有insert()和pop()方法。所以，新同学没法直接往 tuple 中添加，老同学想退出 tuple 也不行。</p>
<p>获取 tuple 元素的方式和 list 是一模一样的，我们可以正常使用 t[0]，t[-1]等索引方式访问元素，但是不能赋值成别的元素，不信可以试试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t[0] = &#x27;Paul&#x27;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br></pre></td></tr></table></figure>

<h3 id="创建单元素tuple"><a href="#创建单元素tuple" class="headerlink" title="创建单元素tuple"></a>创建单元素tuple</h3><p>tuple和list一样，可以包含 0 个、1个和任意多个元素。</p>
<p>包含多个元素的 tuple，前面我们已经创建过了。</p>
<p>包含 0 个元素的 tuple，也就是空tuple，直接用 ()表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t = ()</span><br><span class="line">&gt;&gt;&gt; print t</span><br><span class="line">()</span><br></pre></td></tr></table></figure>

<p>创建包含1个元素的 tuple 呢？来试试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1)</span><br><span class="line">&gt;&gt;&gt; print t</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>好像哪里不对！t 不是 tuple ，而是整数1。为什么呢？</p>
<p>因为()既可以表示tuple，又可以作为括号表示运算时的优先级，结果 (1) 被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。</p>
<p>正是因为用()定义单元素的tuple有歧义，所以 Python 规定，单元素 tuple 要多加一个逗号“,”，这样就避免了歧义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1,)</span><br><span class="line">&gt;&gt;&gt; print t</span><br><span class="line">(1,)</span><br></pre></td></tr></table></figure>

<h3 id="可变的tuple"><a href="#可变的tuple" class="headerlink" title="可变的tuple"></a>可变的tuple</h3><p>前面我们看到了tuple一旦创建就不能修改。现在，我们来看一个“可变”的tuple：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;A&#x27;, &#x27;B&#x27;])</span><br></pre></td></tr></table></figure>

<p>注意到 t 有 3 个元素：’a’，’b’和一个list：[‘A’, ‘B’]。list作为一个整体是tuple的第3个元素。list对象可以通过 t[2] 拿到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L = t[2]</span><br></pre></td></tr></table></figure>

<p>然后，我们把list的两个元素改一改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L[0] = &#x27;X&#x27;</span><br><span class="line">&gt;&gt;&gt; L[1] = &#x27;Y&#x27;</span><br></pre></td></tr></table></figure>

<p>再看看tuple的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print t</span><br><span class="line">(&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;X&#x27;, &#x27;Y&#x27;])</span><br></pre></td></tr></table></figure>

<p>不是说tuple一旦定义后就不可变了吗？怎么现在又变了？</p>
<p>别急，我们先看看定义的时候tuple包含的3个元素：</p>
<p><img src="/assets/images/tech/python-basic-knowledge-5.jpg" alt="tuple图1"></p>
<p>当我们把list的元素’A’和’B’修改为’X’和’Y’后，tuple变为：</p>
<p><img src="/assets/images/tech/python-basic-knowledge-6.jpg" alt="tuple图2"></p>
<p>表面上看，tuple的元素确实变了，但其实变的不是 tuple 的元素，而是list的元素。</p>
<p>tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p>
<p>理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。</p>
<h2 id="条件判断和循环"><a href="#条件判断和循环" class="headerlink" title="条件判断和循环"></a>条件判断和循环</h2><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。</p>
<h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，可以用if语句实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">age = 20</span><br><span class="line">if age &gt;= 18:</span><br><span class="line">    print &#x27;your age is&#x27;, age</span><br><span class="line">    print &#x27;adult&#x27;</span><br><span class="line">print &#x27;END&#x27;</span><br></pre></td></tr></table></figure>

<p>注意: Python代码的缩进规则。具有相同缩进的代码被视为代码块，上面的3，4行 print 语句就构成一个代码块（但不包括第5行的print）。如果 if 语句判断为 True，就会执行这个代码块。</p>
<p>缩进请严格按照Python的习惯写法：4个空格，不要使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。</p>
<p>注意: if 语句后接表达式，然后用:表示代码块开始。</p>
<p>如果你在Python交互环境下敲代码，还要特别留意缩进，并且退出缩进需要多敲一行回车：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; age = 20</span><br><span class="line">&gt;&gt;&gt; if age &gt;= 18:</span><br><span class="line">...     print &#x27;your age is&#x27;, age</span><br><span class="line">...     print &#x27;adult&#x27;</span><br><span class="line">...</span><br><span class="line">your age is 20</span><br><span class="line">adult</span><br></pre></td></tr></table></figure>

<h4 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a>if-else语句</h4><p>当 if 语句判断表达式的结果为 True 时，就会执行 if 包含的代码块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if age &gt;= 18:</span><br><span class="line">    print &#x27;adult&#x27;</span><br></pre></td></tr></table></figure>

<p>如果我们想判断年龄在18岁以下时，打印出 ‘teenager’，怎么办？</p>
<p>方法是再写一个 if:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if age &lt; 18:</span><br><span class="line">    print &#x27;teenager&#x27;</span><br></pre></td></tr></table></figure>

<p>或者用 not 运算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if not age &gt;= 18:</span><br><span class="line">    print &#x27;teenager&#x27;</span><br></pre></td></tr></table></figure>

<p>细心的读者可以发现，这两种条件判断是“非此即彼”的，要么符合条件1，要么符合条件2，因此，完全可以用一个 <code>if ... else ... </code>语句把它们统一起来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if age &gt;= 18:</span><br><span class="line">    print &#x27;adult&#x27;</span><br><span class="line">else:</span><br><span class="line">    print &#x27;teenager&#x27;</span><br></pre></td></tr></table></figure>

<p>利用<code>if ... else ...</code>语句，我们可以根据条件表达式的值为 True 或者 False ，分别执行 if 代码块或者 else 代码块。</p>
<p>注意: else 后面有个“:”。</p>
<h4 id="if-elif-else语句"><a href="#if-elif-else语句" class="headerlink" title="if-elif-else语句"></a>if-elif-else语句</h4><p>有的时候，一个<code>if ... else ...</code>还不够用。比如，根据年龄的划分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件1：18岁或以上：adult</span><br><span class="line">条件2：6岁或以上：teenager</span><br><span class="line">条件3：6岁以下：kid</span><br></pre></td></tr></table></figure>

<p>我们可以用一个 if age &gt;&#x3D; 18 判断是否符合条件1，如果不符合，再通过一个 if 判断 age &gt;&#x3D; 6 来判断是否符合条件2，否则，执行条件3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if age &gt;= 18:</span><br><span class="line">    print &#x27;adult&#x27;</span><br><span class="line">else:</span><br><span class="line">    if age &gt;= 6:</span><br><span class="line">        print &#x27;teenager&#x27;</span><br><span class="line">    else:</span><br><span class="line">        print &#x27;kid&#x27;</span><br></pre></td></tr></table></figure>

<p>这样写出来，我们就得到了一个两层嵌套的<code>if ... else ...</code>语句。这个逻辑没有问题，但是，如果继续增加条件，比如3岁以下是 baby：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if age &gt;= 18:</span><br><span class="line">    print &#x27;adult&#x27;</span><br><span class="line">else:</span><br><span class="line">    if age &gt;= 6:</span><br><span class="line">        print &#x27;teenager&#x27;</span><br><span class="line">    else:</span><br><span class="line">        if age &gt;= 3:</span><br><span class="line">            print &#x27;kid&#x27;</span><br><span class="line">        else:</span><br><span class="line">            print &#x27;baby&#x27;</span><br></pre></td></tr></table></figure>

<p>这种缩进只会越来越多，代码也会越来越难看。</p>
<p>要避免嵌套结构的<code> if ... else ...</code>，我们可以用<code>if ...</code>多个<code>elif ... else ... </code>的结构，一次写完所有的规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if age &gt;= 18:</span><br><span class="line">    print &#x27;adult&#x27;</span><br><span class="line">elif age &gt;= 6:</span><br><span class="line">    print &#x27;teenager&#x27;</span><br><span class="line">elif age &gt;= 3:</span><br><span class="line">    print &#x27;kid&#x27;</span><br><span class="line">else:</span><br><span class="line">    print &#x27;baby&#x27;</span><br></pre></td></tr></table></figure>

<p>elif 意思就是 else if。这样一来，我们就写出了结构非常清晰的一系列条件判断。</p>
<p>特别注意: 这一系列条件判断会从上到下依次判断，如果某个判断为 True，执行完对应的代码块，后面的条件判断就直接忽略，不再执行了。</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>list或tuple可以表示一个有序集合。如果我们想依次访问一个list中的每一个元素呢？比如 list：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L = [&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;]</span><br><span class="line">print L[0]</span><br><span class="line">print L[1]</span><br><span class="line">print L[2]</span><br></pre></td></tr></table></figure>

<p>如果list只包含几个元素，这样写还行，如果list包含1万个元素，我们就不可能写1万行print。</p>
<p>这时，循环就派上用场了。</p>
<p>Python的 for 循环就可以依次把list或tuple的每个元素迭代出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L = [&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;]</span><br><span class="line">for name in L:</span><br><span class="line">    print name</span><br></pre></td></tr></table></figure>

<p>注意:  name 这个变量是在 for 循环中定义的，意思是，依次取出list中的每一个元素，并把元素赋值给 name，然后执行for循环体（就是缩进的代码块）。</p>
<p>这样一来，遍历一个list或tuple就非常容易了。</p>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>和 for 循环不同的另一种循环是 while 循环，while 循环不会迭代 list 或 tuple 的元素，而是根据表达式判断循环是否结束。</p>
<p>比如要从 0 开始打印不大于 N 的整数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N = 10</span><br><span class="line">x = 0</span><br><span class="line">while x &lt; N:</span><br><span class="line">    print x</span><br><span class="line">    x = x + 1</span><br></pre></td></tr></table></figure>

<p>while循环每次先判断 x &lt; N，如果为True，则执行循环体的代码块，否则，退出循环。</p>
<p>在循环体内，x &#x3D; x + 1 会让 x 不断增加，最终因为 x &lt; N 不成立而退出循环。</p>
<p>如果没有这一个语句，while循环在判断 x &lt; N 时总是为True，就会无限循环下去，变成死循环，所以要特别留意while循环的退出条件。</p>
<h4 id="break退出循环"><a href="#break退出循环" class="headerlink" title="break退出循环"></a>break退出循环</h4><p>用 for 循环或者 while 循环时，如果要在循环体内直接退出循环，可以使用 break 语句。</p>
<p>比如计算1至100的整数和，我们用while来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">x = 1</span><br><span class="line">while True:</span><br><span class="line">    sum = sum + x</span><br><span class="line">    x = x + 1</span><br><span class="line">    if x &gt; 100:</span><br><span class="line">        break</span><br><span class="line">print sum</span><br></pre></td></tr></table></figure>

<p>咋一看， while True 就是一个死循环，但是在循环体内，我们还判断了 x &gt; 100 条件成立时，用break语句退出循环，这样也可以实现循环的结束。</p>
<h4 id="continue继续循环"><a href="#continue继续循环" class="headerlink" title="continue继续循环"></a>continue继续循环</h4><p>在循环过程中，可以用break退出当前循环，还可以用continue跳过后续循环代码，继续下一次循环。</p>
<p>假设我们已经写好了利用for循环计算平均分的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L = [75, 98, 59, 81, 66, 43, 69, 85]</span><br><span class="line">sum = 0.0</span><br><span class="line">n = 0</span><br><span class="line">for x in L:</span><br><span class="line">    sum = sum + x</span><br><span class="line">    n = n + 1</span><br><span class="line">print sum / n</span><br></pre></td></tr></table></figure>

<p>现在老师只想统计及格分数的平均分，就要把 x &lt; 60 的分数剔除掉，这时，利用 continue，可以做到当 x &lt; 60的时候，不继续执行循环体的后续代码，直接进入下一次循环：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for x in L:</span><br><span class="line">    if x &lt; 60:</span><br><span class="line">        continue</span><br><span class="line">    sum = sum + x</span><br><span class="line">    n = n + 1</span><br></pre></td></tr></table></figure>

<h4 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h4><p>在循环内部，还可以嵌套循环，我们来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for x in [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]:</span><br><span class="line">    for y in [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]:</span><br><span class="line">        print x + y</span><br></pre></td></tr></table></figure>

<p>x 每循环一次，y 就会循环 3 次。</p>
<h2 id="Dict类型"><a href="#Dict类型" class="headerlink" title="Dict类型"></a>Dict类型</h2><p>我们已经知道，list 和 tuple 可以用来表示顺序集合，例如，班里同学的名字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;]</span><br></pre></td></tr></table></figure>

<p>或者考试的成绩列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[95, 85, 59]</span><br></pre></td></tr></table></figure>

<p>但是，要根据名字找到对应的成绩，用两个 list 表示就不方便。</p>
<p>如果把名字和分数关联起来，组成类似的查找表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;Adam&#x27; ==&gt; 95</span><br><span class="line">&#x27;Lisa&#x27; ==&gt; 85</span><br><span class="line">&#x27;Bart&#x27; ==&gt; 59</span><br></pre></td></tr></table></figure>

<p>给定一个名字，就可以直接查到分数。</p>
<p>Python的 dict 就是专门干这件事的。用 dict 表示“名字”-“成绩”的查找表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    &#x27;Adam&#x27;: 95,</span><br><span class="line">    &#x27;Lisa&#x27;: 85,</span><br><span class="line">    &#x27;Bart&#x27;: 59</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把名字称为key，对应的成绩称为value，dict就是通过 key 来查找 value。</p>
<p>花括号 {} 表示这是一个dict，然后按照 key: value, 写出来即可。最后一个 key: value 的逗号可以省略。</p>
<p>由于dict也是集合，len() 函数可以计算任意集合的大小：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; len(d)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>注意: 一个 key-value 算一个，因此，dict大小为3。</p>
<h3 id="访问Dict"><a href="#访问Dict" class="headerlink" title="访问Dict"></a>访问Dict</h3><p>我们已经能创建一个dict，用于表示名字和成绩的对应关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    &#x27;Adam&#x27;: 95,</span><br><span class="line">    &#x27;Lisa&#x27;: 85,</span><br><span class="line">    &#x27;Bart&#x27;: 59</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，如何根据名字来查找对应的成绩呢？</p>
<p>可以简单地使用 d[key] 的形式来查找对应的 value，这和 list 很像，不同之处是，list 必须使用索引返回对应的元素，而dict使用key：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print d[&#x27;Adam&#x27;]</span><br><span class="line">95</span><br><span class="line">&gt;&gt;&gt; print d[&#x27;Paul&#x27;]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;index.py&quot;, line 11, in &lt;module&gt;</span><br><span class="line">    print d[&#x27;Paul&#x27;]</span><br><span class="line">KeyError: &#x27;Paul&#x27;</span><br></pre></td></tr></table></figure>

<p>注意: 通过 key 访问 dict 的value，只要 key 存在，dict就返回对应的value。如果key不存在，会直接报错：KeyError。</p>
<p>要避免 KeyError 发生，有两个办法：</p>
<p>一是先判断一下 key 是否存在，用 in 操作符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if &#x27;Paul&#x27; in d:</span><br><span class="line">    print d[&#x27;Paul&#x27;]</span><br></pre></td></tr></table></figure>

<p>如果 ‘Paul’ 不存在，if语句判断为False，自然不会执行 print d[‘Paul’] ，从而避免了错误。</p>
<p>二是使用dict本身提供的一个 get 方法，在Key不存在的时候，返回None：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print d.get(&#x27;Bart&#x27;)</span><br><span class="line">59</span><br><span class="line">&gt;&gt;&gt; print d.get(&#x27;Paul&#x27;)</span><br><span class="line">None</span><br></pre></td></tr></table></figure>

<h3 id="Dict特点"><a href="#Dict特点" class="headerlink" title="Dict特点"></a>Dict特点</h3><p>dict的第一个特点是查找速度快，无论dict有10个元素还是10万个元素，查找速度都一样。而list的查找速度随着元素增加而逐渐下降。</p>
<p>不过dict的查找速度快不是没有代价的，dict的缺点是占用内存大，还会浪费很多内容，list正好相反，占用内存小，但是查找速度慢。</p>
<p>由于dict是按 key 查找，所以，在一个dict中，key不能重复。</p>
<p>dict的第二个特点就是存储的key-value序对是没有顺序的！这和list不一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    &#x27;Adam&#x27;: 95,</span><br><span class="line">    &#x27;Lisa&#x27;: 85,</span><br><span class="line">    &#x27;Bart&#x27;: 59</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们试图打印这个dict时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print d</span><br><span class="line">&#123;&#x27;Lisa&#x27;: 85, &#x27;Adam&#x27;: 95, &#x27;Bart&#x27;: 59&#125;</span><br></pre></td></tr></table></figure>

<p>打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同，这说明dict内部是无序的，不能用dict存储有序的集合。</p>
<p>dict的第三个特点是作为 key 的元素必须不可变，Python的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。但是list是可变的，就不能作为 key。</p>
<p>可以试试用list作为key时会报什么样的错误。</p>
<p>不可变这个限制仅作用于key，value是否可变无所谓：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x27;123&#x27;: [1, 2, 3],  # key 是 str，value是list</span><br><span class="line">    123: &#x27;123&#x27;,  # key 是 int，value 是 str</span><br><span class="line">    (&#x27;a&#x27;, &#x27;b&#x27;): True  # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最常用的key还是字符串，因为用起来最方便。</p>
<h3 id="更新Dict"><a href="#更新Dict" class="headerlink" title="更新Dict"></a>更新Dict</h3><p>dict是可变的，也就是说，我们可以随时往dict中添加新的 key-value。比如已有dict：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d = &#123;</span><br><span class="line">    &#x27;Adam&#x27;: 95,</span><br><span class="line">    &#x27;Lisa&#x27;: 85,</span><br><span class="line">    &#x27;Bart&#x27;: 59</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要把新同学’Paul’的成绩 72 加进去，用赋值语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#x27;Paul&#x27;] = 72</span><br></pre></td></tr></table></figure>

<p>再看看dict的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print d</span><br><span class="line">&#123;&#x27;Lisa&#x27;: 85, &#x27;Paul&#x27;: 72, &#x27;Adam&#x27;: 95, &#x27;Bart&#x27;: 59&#125;</span><br></pre></td></tr></table></figure>

<p>如果 key 已经存在，则赋值会用新的 value 替换掉原来的 value：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#x27;Bart&#x27;] = 60</span><br><span class="line">&gt;&gt;&gt; print d</span><br><span class="line">&#123;&#x27;Lisa&#x27;: 85, &#x27;Paul&#x27;: 72, &#x27;Adam&#x27;: 95, &#x27;Bart&#x27;: 60&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历Dict"><a href="#遍历Dict" class="headerlink" title="遍历Dict"></a>遍历Dict</h3><p>由于dict也是一个集合，所以，遍历dict和遍历list类似，都可以通过 for 循环实现。</p>
<p>直接使用for循环可以遍历 dict 的 key：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123; &#x27;Adam&#x27;: 95, &#x27;Lisa&#x27;: 85, &#x27;Bart&#x27;: 59 &#125;</span><br><span class="line">&gt;&gt;&gt; for key in d:</span><br><span class="line">...     print key</span><br><span class="line">... </span><br><span class="line">Lisa</span><br><span class="line">Adam</span><br><span class="line">Bart</span><br></pre></td></tr></table></figure>

<p>由于通过 key 可以获取对应的 value，因此，在循环体内，可以获取到value的值。</p>
<h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><p>dict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。</p>
<p>有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set就派上用场了。</p>
<p>set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。</p>
<p>创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;])</span><br></pre></td></tr></table></figure>

<p>可以查看 set 的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print s</span><br><span class="line">set([&#x27;A&#x27;, &#x27;C&#x27;, &#x27;B&#x27;])</span><br></pre></td></tr></table></figure>

<p>请注意，上述打印的形式类似 list， 但它不是 list，仔细看还可以发现，打印的顺序和原始 list 的顺序有可能是不同的，因为set内部存储的元素是无序的。</p>
<p>因为set不能包含重复的元素，所以，当我们传入包含重复元素的 list 会怎么样呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;C&#x27;])</span><br><span class="line">&gt;&gt;&gt; print s</span><br><span class="line">set([&#x27;A&#x27;, &#x27;C&#x27;, &#x27;B&#x27;])</span><br><span class="line">&gt;&gt;&gt; len(s)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>结果显示，set会自动去掉重复的元素，原来的list有4个元素，但set只有3个元素。</p>
<h3 id="访问Set"><a href="#访问Set" class="headerlink" title="访问Set"></a>访问Set</h3><p>由于set存储的是无序集合，所以我们没法通过索引来访问。</p>
<p>访问 set中的某个元素实际上就是判断一个元素是否在set中。</p>
<p>例如，存储了班里同学名字的set：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;, &#x27;Paul&#x27;])</span><br></pre></td></tr></table></figure>

<p>我们可以用 in 操作符判断：</p>
<p>Bart是该班的同学吗？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;Bart&#x27; in s</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>Bill是该班的同学吗？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;Bill&#x27; in s</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>bart是该班的同学吗？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;bart&#x27; in s</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>看来大小写很重要，’Bart’ 和 ‘bart’被认为是两个不同的元素。</p>
<h3 id="Set的特点"><a href="#Set的特点" class="headerlink" title="Set的特点"></a>Set的特点</h3><p>set的内部结构和dict很像，唯一区别是不存储value，因此，判断一个元素是否在set中速度很快。</p>
<p>set存储的元素和dict的key类似，必须是不变对象，因此，任何可变对象是不能放入set中的。</p>
<p>最后，set存储的元素也是没有顺序的。</p>
<p>set的这些特点，可以应用在哪些地方呢？</p>
<p>星期一到星期日可以用字符串’MON’, ‘TUE’, … ‘SUN’表示。</p>
<p>假设我们让用户输入星期一至星期日的某天，如何判断用户的输入是否是一个有效的星期呢？</p>
<p>可以用 if 语句判断，但这样做非常繁琐：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = &#x27;???&#x27; # 用户输入的字符串</span><br><span class="line">if x!= &#x27;MON&#x27; and x!= &#x27;TUE&#x27; and x!= &#x27;WED&#x27; ... and x!= &#x27;SUN&#x27;:</span><br><span class="line">    print &#x27;input error&#x27;</span><br><span class="line">else:</span><br><span class="line">    print &#x27;input ok&#x27;</span><br></pre></td></tr></table></figure>

<p>注意：if 语句中的…表示没有列出的其它星期名称，测试时，请输入完整。</p>
<p>如果事先创建好一个set，包含’MON’ ~ ‘SUN’：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">weekdays = set([&#x27;MON&#x27;, &#x27;TUE&#x27;, &#x27;WED&#x27;, &#x27;THU&#x27;, &#x27;FRI&#x27;, &#x27;SAT&#x27;, &#x27;SUN&#x27;])</span><br></pre></td></tr></table></figure>

<p>再判断输入是否有效，只需要判断该字符串是否在set中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = &#x27;???&#x27; # 用户输入的字符串</span><br><span class="line">if x in weekdays:</span><br><span class="line">    print &#x27;input ok&#x27;</span><br><span class="line">else:</span><br><span class="line">    print &#x27;input error&#x27;</span><br></pre></td></tr></table></figure>

<p>这样一来，代码就简单多了。</p>
<h3 id="遍历Set"><a href="#遍历Set" class="headerlink" title="遍历Set"></a>遍历Set</h3><p>由于 set 也是一个集合，所以，遍历 set 和遍历 list 类似，都可以通过 for 循环实现。</p>
<p>直接使用 for 循环可以遍历 set 的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;])</span><br><span class="line">&gt;&gt;&gt; for name in s:</span><br><span class="line">...     print name</span><br><span class="line">... </span><br><span class="line">Lisa</span><br><span class="line">Adam</span><br><span class="line">Bart</span><br></pre></td></tr></table></figure>

<p>注意: 观察 for 循环在遍历set时，元素的顺序和list的顺序很可能是不同的，而且不同的机器上运行的结果也可能不同。</p>
<h3 id="更新Set"><a href="#更新Set" class="headerlink" title="更新Set"></a>更新Set</h3><p>由于set存储的是一组不重复的无序元素，因此，更新set主要做两件事：</p>
<p>一是把新的元素添加到set中，二是把已有元素从set中删除。</p>
<p>添加元素时，用set的add()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s.add(4)</span><br><span class="line">&gt;&gt;&gt; print s</span><br><span class="line">set([1, 2, 3, 4])</span><br></pre></td></tr></table></figure>

<p>如果添加的元素已经存在于set中，add()不会报错，但是不会加进去了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s.add(3)</span><br><span class="line">&gt;&gt;&gt; print s</span><br><span class="line">set([1, 2, 3])</span><br></pre></td></tr></table></figure>

<p>删除set中的元素时，用set的remove()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; s.remove(4)</span><br><span class="line">&gt;&gt;&gt; print s</span><br><span class="line">set([1, 2, 3])</span><br></pre></td></tr></table></figure>

<p>如果删除的元素不存在set中，remove()会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s.remove(4)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">KeyError: 4</span><br></pre></td></tr></table></figure>

<p>所以用add()可以直接添加，而remove()前需要判断。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>我们知道圆的面积计算公式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">S = πr²</span><br></pre></td></tr></table></figure>

<p>当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r1 = 12.34</span><br><span class="line">r2 = 9.08</span><br><span class="line">r3 = 73.1</span><br><span class="line">s1 = 3.14 * r1 * r1</span><br><span class="line">s2 = 3.14 * r2 * r2</span><br><span class="line">s3 = 3.14 * r3 * r3</span><br></pre></td></tr></table></figure>

<p>当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 * x * x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。</p>
<p>有了函数，我们就不再每次写s &#x3D; 3.14 * x * x，而是写成更有意义的函数调用 s &#x3D; area_of_circle(x)，而函数 area_of_circle 本身只需要写一次，就可以多次调用。</p>
<p>抽象是数学中非常常见的概念。举个例子：</p>
<p>计算数列的和，比如：1 + 2 + 3 + … + 100，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + … + 100记作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">∑n</span><br><span class="line">n=1</span><br></pre></td></tr></table></figure>

<p>这种抽象记法非常强大，因为我们看到∑就可以理解成求和，而不是还原成低级的加法运算。</p>
<p>而且，这种抽象记法是可扩展的，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">∑(n²+1)</span><br><span class="line">n=1</span><br></pre></td></tr></table></figure>

<p>还原成加法运算就变成了：</p>
<p>(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + … + (100 x 100 + 1)<br>可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。</p>
<p>写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。</p>
<p>Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。</p>
<h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><p>Python内置了很多有用的函数，我们可以直接调用。</p>
<p>要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数 abs，它接收一个参数。</p>
<p>可以直接从Python的官方网站查看文档：<br><a href="http://docs.python.org/2/library/functions.html#abs">http://docs.python.org/2/library/functions.html#abs</a><br>也可以在交互式命令行通过 help(abs) 查看abs函数的帮助信息。</p>
<p>调用 abs 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(100)</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; abs(-20)</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; abs(12.34)</span><br><span class="line">12.34</span><br></pre></td></tr></table></figure>

<p>调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(1, 2)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: abs() takes exactly one argument (2 given)</span><br></pre></td></tr></table></figure>

<p>如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(&#x27;a&#x27;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: bad operand type for abs(): &#x27;str&#x27;</span><br></pre></td></tr></table></figure>

<p>而比较函数 cmp(x, y) 就需要两个参数，如果 x&lt;y，返回 -1，如果 x&#x3D;&#x3D;y，返回 0，如果 x&gt;y，返回 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; cmp(1, 2)</span><br><span class="line">-1</span><br><span class="line">&gt;&gt;&gt; cmp(2, 1)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; cmp(3, 3)</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>Python内置的常用函数还包括数据类型转换函数，比如   int()函数可以把其他数据类型转换为整数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; int(&#x27;123&#x27;)</span><br><span class="line">123</span><br><span class="line">&gt;&gt;&gt; int(12.34)</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<p>str()函数把其他类型转换成 str：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; str(123)</span><br><span class="line">&#x27;123&#x27;</span><br><span class="line">&gt;&gt;&gt; str(1.23)</span><br><span class="line">&#x27;1.23&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="编写函数"><a href="#编写函数" class="headerlink" title="编写函数"></a>编写函数</h3><p>在Python中，定义一个函数要使用 def 语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用 return 语句返回。</p>
<p>我们以自定义一个求绝对值的 my_abs 函数为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if x &gt;= 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure>

<p>请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。</p>
<p>如果没有return语句，函数执行完毕后也会返回结果，只是结果为 None。</p>
<p>return None可以简写为return。</p>
<h3 id="返回多值"><a href="#返回多值" class="headerlink" title="返回多值"></a>返回多值</h3><p>函数可以返回多个值吗？答案是肯定的。</p>
<p>比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：</p>
<p><code># math</code>包提供了sin()和 cos()函数，我们先用<code>import</code>引用它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import math</span><br><span class="line">def move(x, y, step, angle):</span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    return nx, ny</span><br></pre></td></tr></table></figure>

<p>这样我们就可以同时获得返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)</span><br><span class="line">&gt;&gt;&gt; print x, y</span><br><span class="line">151.961524227 70.0</span><br></pre></td></tr></table></figure>

<p>但其实这只是一种假象，Python函数返回的仍然是单一值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)</span><br><span class="line">&gt;&gt;&gt; print r</span><br><span class="line">(151.96152422706632, 70.0)</span><br></pre></td></tr></table></figure>

<p>用print打印返回结果，原来返回值是一个tuple！</p>
<p>但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>
<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>
<p>举个例子，我们来计算阶乘 n! &#x3D; 1 * 2 * 3 * … * n，用函数 fact(n)表示，可以看出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fact(n) = n! = 1 * 2 * 3 * ... * (n-1) * n = (n-1)! * n = fact(n-1) * n</span><br></pre></td></tr></table></figure>

<p>所以，fact(n)可以表示为 n * fact(n-1)，只有n&#x3D;1时需要特殊处理。</p>
<p>于是，fact(n)用递归的方式写出来就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fact(n):</span><br><span class="line">    if n==1:</span><br><span class="line">        return 1</span><br><span class="line">    return n * fact(n - 1)</span><br></pre></td></tr></table></figure>

<p>上面就是一个递归函数。可以试试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; fact(1)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; fact(5)</span><br><span class="line">120</span><br><span class="line">&gt;&gt;&gt; fact(100)</span><br><span class="line">93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000L</span><br></pre></td></tr></table></figure>

<p>如果我们计算fact(5)，可以根据函数定义看到计算过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">===&gt; fact(5)</span><br><span class="line">===&gt; 5 * fact(4)</span><br><span class="line">===&gt; 5 * (4 * fact(3))</span><br><span class="line">===&gt; 5 * (4 * (3 * fact(2)))</span><br><span class="line">===&gt; 5 * (4 * (3 * (2 * fact(1))))</span><br><span class="line">===&gt; 5 * (4 * (3 * (2 * 1)))</span><br><span class="line">===&gt; 5 * (4 * (3 * 2))</span><br><span class="line">===&gt; 5 * (4 * 6)</span><br><span class="line">===&gt; 5 * 24</span><br><span class="line">===&gt; 120</span><br></pre></td></tr></table></figure>

<p>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p>
<p><strong>使用递归函数需要注意防止栈溢出。</strong>在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试计算 fact(10000)。</p>
<h3 id="定义默认参数"><a href="#定义默认参数" class="headerlink" title="定义默认参数"></a>定义默认参数</h3><p>定义函数的时候，还可以有默认参数。</p>
<p>例如Python自带的 int() 函数，其实就有两个参数，我们既可以传一个参数，又可以传两个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; int(&#x27;123&#x27;)</span><br><span class="line">123</span><br><span class="line">&gt;&gt;&gt; int(&#x27;123&#x27;, 8)</span><br><span class="line">83</span><br></pre></td></tr></table></figure>

<p>int()函数的第二个参数是转换进制，如果不传，默认是十进制 (base&#x3D;10)，如果传了，就用传入的参数。</p>
<p>可见，函数的默认参数的作用是简化调用，你只需要把必须的参数传进去。但是在需要的时候，又可以传入额外的参数来覆盖默认参数值。</p>
<p>我们来定义一个计算 x 的N次方的函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def power(x, n):</span><br><span class="line">    s = 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n = n - 1</span><br><span class="line">        s = s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure>

<p>假设计算平方的次数最多，我们就可以把 n 的默认值设定为 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def power(x, n=2):</span><br><span class="line">    s = 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n = n - 1</span><br><span class="line">        s = s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure>

<p>这样一来，计算平方就不需要传入两个参数了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5)</span><br><span class="line">25</span><br></pre></td></tr></table></figure>

<p>由于函数的参数按从左到右的顺序匹配，所以默认参数只能定义在必需参数的后面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># OK:</span><br><span class="line">def fn1(a, b=1, c=2):</span><br><span class="line">    pass</span><br><span class="line"># Error:</span><br><span class="line">def fn2(a=1, b):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<h3 id="定义可变参数"><a href="#定义可变参数" class="headerlink" title="定义可变参数"></a>定义可变参数</h3><p>如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fn(*args):</span><br><span class="line">    print args</span><br></pre></td></tr></table></figure>

<p>可变参数的名字前面有个 * 号，我们可以传入0个、1个或多个参数给可变参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; fn()</span><br><span class="line">()</span><br><span class="line">&gt;&gt;&gt; fn(&#x27;a&#x27;)</span><br><span class="line">(&#x27;a&#x27;,)</span><br><span class="line">&gt;&gt;&gt; fn(&#x27;a&#x27;, &#x27;b&#x27;)</span><br><span class="line">(&#x27;a&#x27;, &#x27;b&#x27;)</span><br><span class="line">&gt;&gt;&gt; fn(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)</span><br><span class="line">(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)</span><br></pre></td></tr></table></figure>

<p>可变参数也不是很神秘，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。</p>
<p>定义可变参数的目的也是为了简化调用。假设我们要计算任意个数的平均值，就可以定义一个可变参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def average(*args):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>这样，在调用的时候，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; average()</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; average(1, 2)</span><br><span class="line">1.5</span><br><span class="line">&gt;&gt;&gt; average(1, 2, 2, 3, 4)</span><br><span class="line">2.4</span><br></pre></td></tr></table></figure>

<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="对list进行切片"><a href="#对list进行切片" class="headerlink" title="对list进行切片"></a>对list进行切片</h3><p>取一个list的部分元素是非常常见的操作。比如，一个list如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;, &#x27;Paul&#x27;]</span><br></pre></td></tr></table></figure>

<p>取前3个元素，应该怎么做？</p>
<p>笨办法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [L[0], L[1], L[2]]</span><br><span class="line">[&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;]</span><br></pre></td></tr></table></figure>

<p>之所以是笨办法是因为扩展一下，取前N个元素就没辙了。</p>
<p>取前N个元素，也就是索引为0-(N-1)的元素，可以用循环：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; r = []</span><br><span class="line">&gt;&gt;&gt; n = 3</span><br><span class="line">&gt;&gt;&gt; for i in range(n):</span><br><span class="line">...     r.append(L[i])</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; r</span><br><span class="line">[&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;]</span><br></pre></td></tr></table></figure>

<p>对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。</p>
<p>对应上面的问题，取前3个元素，用一行代码就可以完成切片：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L[0:3]</span><br><span class="line">[&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;]</span><br></pre></td></tr></table></figure>

<p>L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</p>
<p>如果第一个索引是0，还可以省略：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:3]</span><br><span class="line">[&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;]</span><br></pre></td></tr></table></figure>

<p>也可以从索引1开始，取出2个元素出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L[1:3]</span><br><span class="line">[&#x27;Lisa&#x27;, &#x27;Bart&#x27;]</span><br></pre></td></tr></table></figure>

<p>只用一个 : ，表示从头到尾：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:]</span><br><span class="line">[&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;, &#x27;Paul&#x27;]</span><br></pre></td></tr></table></figure>

<p>因此，L[:]实际上复制出了一个新list。</p>
<p>切片操作还可以指定第三个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L[::2]</span><br><span class="line">[&#x27;Adam&#x27;, &#x27;Bart&#x27;]</span><br></pre></td></tr></table></figure>

<p>第三个参数表示每N个取一个，上面的 L[::2] 会每两个元素取出一个来，也就是隔一个取一个。</p>
<p>把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。</p>
<h3 id="倒序切片"><a href="#倒序切片" class="headerlink" title="倒序切片"></a>倒序切片</h3><p>对于list，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;, &#x27;Paul&#x27;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; L[-2:]</span><br><span class="line">[&#x27;Bart&#x27;, &#x27;Paul&#x27;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; L[:-2]</span><br><span class="line">[&#x27;Adam&#x27;, &#x27;Lisa&#x27;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; L[-3:-1]</span><br><span class="line">[&#x27;Lisa&#x27;, &#x27;Bart&#x27;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; L[-4:-1:2]</span><br><span class="line">[&#x27;Adam&#x27;, &#x27;Bart&#x27;]</span><br></pre></td></tr></table></figure>

<p>记住倒数第一个元素的索引是-1。倒序切片包含起始索引，不包含结束索引。</p>
<h3 id="对字符串切片"><a href="#对字符串切片" class="headerlink" title="对字符串切片"></a>对字符串切片</h3><p>字符串 ‘xxx’和 Unicode字符串 u’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;ABCDEFG&#x27;[:3]</span><br><span class="line">&#x27;ABC&#x27;</span><br><span class="line">&gt;&gt;&gt; &#x27;ABCDEFG&#x27;[-3:]</span><br><span class="line">&#x27;EFG&#x27;</span><br><span class="line">&gt;&gt;&gt; &#x27;ABCDEFG&#x27;[::2]</span><br><span class="line">&#x27;ACEG&#x27;</span><br></pre></td></tr></table></figure>

<p>在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</p>
<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>在Python中，如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们成为迭代（Iteration）。</p>
<p>在Python中，迭代是通过 for … in 来完成的，而很多语言比如C或者Java，迭代list是通过下标完成的，比如Java代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (i=0; i&lt;list.length; i++) &#123;</span><br><span class="line">    n = list[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，Python的for循环抽象程度要高于Java的for循环。</p>
<p>因为 Python 的 for循环不仅可以用在list或tuple上，还可以作用在其他任何可迭代对象上。</p>
<p>因此，迭代操作就是对于一个集合，无论该集合是有序还是无序，我们用 for 循环总是可以依次取出集合的每一个元素。</p>
<p>注意: 集合是指包含一组元素的数据结构，我们已经介绍的包括：</p>
<ol>
<li>有序集合：list，tuple，str和unicode；</li>
<li>无序集合：set</li>
<li>无序集合并且具有 key-value 对：dict<br>而迭代是一个动词，它指的是一种操作，在Python中，就是 for 循环。</li>
</ol>
<p>迭代与按下标访问数组最大的不同是，后者是一种具体的迭代实现方式，而前者只关心迭代结果，根本不关心迭代内部是如何实现的。</p>
<h3 id="索引迭代"><a href="#索引迭代" class="headerlink" title="索引迭代"></a>索引迭代</h3><p>Python中，迭代永远是取出元素本身，而非元素的索引。</p>
<p>对于有序集合，元素确实是有索引的。有的时候，我们确实想在 for 循环中拿到索引，怎么办？</p>
<p>方法是使用 enumerate() 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L = [&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;, &#x27;Paul&#x27;]</span><br><span class="line">&gt;&gt;&gt; for index, name in enumerate(L):</span><br><span class="line">...     print index, &#x27;-&#x27;, name</span><br><span class="line">... </span><br><span class="line">0 - Adam</span><br><span class="line">1 - Lisa</span><br><span class="line">2 - Bart</span><br><span class="line">3 - Paul</span><br></pre></td></tr></table></figure>

<p>使用 enumerate() 函数，我们可以在for循环中同时绑定索引index和元素name。但是，这不是 enumerate() 的特殊语法。实际上，enumerate() 函数把：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;, &#x27;Paul&#x27;]</span><br></pre></td></tr></table></figure>

<p>变成了类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[(0, &#x27;Adam&#x27;), (1, &#x27;Lisa&#x27;), (2, &#x27;Bart&#x27;), (3, &#x27;Paul&#x27;)]</span><br></pre></td></tr></table></figure>

<p>因此，迭代的每一个元素实际上是一个tuple：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for t in enumerate(L):</span><br><span class="line">    index = t[0]</span><br><span class="line">    name = t[1]</span><br><span class="line">    print index, &#x27;-&#x27;, name</span><br></pre></td></tr></table></figure>

<p>如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for index, name in enumerate(L):</span><br><span class="line">    print index, &#x27;-&#x27;, name</span><br></pre></td></tr></table></figure>

<p>这样不但代码更简单，而且还少了两条赋值语句。</p>
<p>可见，索引迭代也不是真的按索引访问，而是由 enumerate() 函数自动把每个元素变成 (index, element) 这样的tuple，再迭代，就同时获得了索引和元素本身。</p>
<h3 id="迭代Dict的value"><a href="#迭代Dict的value" class="headerlink" title="迭代Dict的value"></a>迭代Dict的value</h3><p>我们已经了解了dict对象本身就是可迭代对象，用 for 循环直接迭代 dict，可以每次拿到dict的一个key。</p>
<p>如果我们希望迭代 dict 对象的value，应该怎么做？</p>
<p>dict 对象有一个 values() 方法，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d = &#123; &#x27;Adam&#x27;: 95, &#x27;Lisa&#x27;: 85, &#x27;Bart&#x27;: 59 &#125;</span><br><span class="line">print d.values()</span><br><span class="line"># [85, 95, 59]</span><br><span class="line">for v in d.values():</span><br><span class="line">    print v</span><br><span class="line"># 85</span><br><span class="line"># 95</span><br><span class="line"># 59</span><br></pre></td></tr></table></figure>

<p>如果仔细阅读Python的文档，还可以发现，dict除了values()方法外，还有一个 itervalues() 方法，用 itervalues() 方法替代 values() 方法，迭代效果完全一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d = &#123; &#x27;Adam&#x27;: 95, &#x27;Lisa&#x27;: 85, &#x27;Bart&#x27;: 59 &#125;</span><br><span class="line">print d.itervalues()</span><br><span class="line"># &lt;dictionary-valueiterator object at 0x106adbb50&gt;</span><br><span class="line">for v in d.itervalues():</span><br><span class="line">    print v</span><br><span class="line"># 85</span><br><span class="line"># 95</span><br><span class="line"># 59</span><br></pre></td></tr></table></figure>

<p>那这两个方法有何不同之处呢？</p>
<ol>
<li><p>values() 方法实际上把一个 dict 转换成了包含 value 的list。</p>
</li>
<li><p>但是 itervalues() 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。</p>
</li>
<li><p>打印 itervalues() 发现它返回一个 <dictionary-valueiterator> 对象，这说明在Python中，for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。</p>
</li>
</ol>
<p>如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。</p>
<h3 id="迭代Dict的key和value"><a href="#迭代Dict的key和value" class="headerlink" title="迭代Dict的key和value"></a>迭代Dict的key和value</h3><p>我们了解了如何迭代 dict 的key和value，那么，在一个 for 循环中，能否同时迭代 key和value？答案是肯定的。</p>
<p>首先，我们看看 dict 对象的 items() 方法返回的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123; &#x27;Adam&#x27;: 95, &#x27;Lisa&#x27;: 85, &#x27;Bart&#x27;: 59 &#125;</span><br><span class="line">&gt;&gt;&gt; print d.items()</span><br><span class="line">[(&#x27;Lisa&#x27;, 85), (&#x27;Adam&#x27;, 95), (&#x27;Bart&#x27;, 59)]</span><br></pre></td></tr></table></figure>

<p>可以看到，items() 方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; for key, value in d.items():</span><br><span class="line">...     print key, &#x27;:&#x27;, value</span><br><span class="line">... </span><br><span class="line">Lisa : 85</span><br><span class="line">Adam : 95</span><br><span class="line">Bart : 59</span><br></pre></td></tr></table></figure>

<p>和 values() 有一个 itervalues() 类似， items() 也有一个对应的 iteritems()，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="列表生成"><a href="#列表生成" class="headerlink" title="列表生成"></a>列表生成</h3><p>要生成<code>list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>，我们可以用<code>range(1, 11)</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; range(1, 11)</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure>

<p>但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; L = []</span><br><span class="line">&gt;&gt;&gt; for x in range(1, 11):</span><br><span class="line">...    L.append(x * x)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure>

<p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11)]</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure>

<p>这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。</p>
<p>写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p>
<h3 id="复杂表达式"><a href="#复杂表达式" class="headerlink" title="复杂表达式"></a>复杂表达式</h3><p>使用for循环的迭代不仅可以迭代普通的list，还可以迭代dict。</p>
<p>假设有如下的dict：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d = &#123; &#x27;Adam&#x27;: 95, &#x27;Lisa&#x27;: 85, &#x27;Bart&#x27;: 59 &#125;</span><br></pre></td></tr></table></figure>

<p>完全可以通过一个复杂的列表生成式把它变成一个 HTML 表格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tds = [&#x27;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&#x27; % (name, score) for name, score in d.iteritems()]</span><br><span class="line">print &#x27;&lt;table&gt;&#x27;</span><br><span class="line">print &#x27;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&#x27;</span><br><span class="line">print &#x27;\n&#x27;.join(tds)</span><br><span class="line">print &#x27;&lt;/table&gt;&#x27;</span><br></pre></td></tr></table></figure>

<p>注：字符串可以通过 % 进行格式化，用指定的参数替代 %s。字符串的join()方法可以把一个 list 拼接成一个字符串。</p>
<p>把打印出来的结果保存为一个html文件，就可以在浏览器中看到效果了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot;&gt;</span><br><span class="line">&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;Lisa&lt;/td&gt;&lt;td&gt;85&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;Adam&lt;/td&gt;&lt;td&gt;95&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;Bart&lt;/td&gt;&lt;td&gt;59&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Name</th>
<th>Score</th>
</tr>
</thead>
<tbody><tr>
<td>Lisa</td>
<td>85</td>
</tr>
<tr>
<td>Adam</td>
<td>95</td>
</tr>
<tr>
<td>Bart</td>
<td>59</td>
</tr>
</tbody></table>
<h3 id="条件过滤"><a href="#条件过滤" class="headerlink" title="条件过滤"></a>条件过滤</h3><p>列表生成式的 for 循环后面还可以加上 if 判断。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11)]</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure>

<p>如果我们只想要偶数的平方，不改动 range()的情况下，可以加上 if 来筛选：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]</span><br><span class="line">[4, 16, 36, 64, 100]</span><br></pre></td></tr></table></figure>

<p>有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。</p>
<h3 id="多层表达式"><a href="#多层表达式" class="headerlink" title="多层表达式"></a>多层表达式</h3><p>for循环可以嵌套，因此，在列表生成式中，也可以用多层 for 循环来生成列表。</p>
<p>对于字符串 ‘ABC’ 和 ‘123’，可以使用两层循环，生成全排列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; [m + n for m in &#x27;ABC&#x27; for n in &#x27;123&#x27;]</span><br><span class="line">[&#x27;A1&#x27;, &#x27;A2&#x27;, &#x27;A3&#x27;, &#x27;B1&#x27;, &#x27;B2&#x27;, &#x27;B3&#x27;, &#x27;C1&#x27;, &#x27;C2&#x27;, &#x27;C3&#x27;]</span><br></pre></td></tr></table></figure>

<p>翻译成循环代码就像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L = []</span><br><span class="line">for m in &#x27;ABC&#x27;:</span><br><span class="line">    for n in &#x27;123&#x27;:</span><br><span class="line">        L.append(m + n)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
        <tag>读书笔记</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>日语-敬体和简体</title>
    <url>/2017-04-23-japanese-honorific-tongue/</url>
    <content><![CDATA[<p>在口语里，日语的谓语形式根据说话人之间的上下级关系、亲疏关系的不同而不同。“～ます”、“～です”是对长辈或关系不太亲密的人使用的形式。这种形式我们称为“敬体形”。与此相反，如对方是自己的同辈或晚辈，或者关系比较密切时则使用“简体形”。“简体形”是不使用“ます”、“です”的形式。</p>
<p>动词本身即具有“敬体形”和“简体形”，“～ます”、“～ません”、“～ました”、“～ませんでした”等四种礼貌的表达形式即是“敬体形”，而动词的“基本形”、“ない形”、“た形”都属于简体形。但一类形容词、二类形容词和名词本身没有“敬体形”和“简体形”之分，只有在做谓语时，其谓语形式才具有“敬体形”和“简体形”。</p>
<span id="more"></span>

<h2 id="1-动词"><a href="#1-动词" class="headerlink" title="1 动词"></a>1 动词</h2><table>
<thead>
<tr>
<th>时态</th>
<th>敬体</th>
<th>简体</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>现在时</td>
<td>〜ます</td>
<td>原形</td>
<td>あります-&gt;ある</td>
</tr>
<tr>
<td>过去时</td>
<td>〜ました</td>
<td>〜た</td>
<td>ありました-&gt;あった</td>
</tr>
<tr>
<td>否定式</td>
<td>〜ません</td>
<td>〜ない</td>
<td>ありません-&gt;<del>あらない</del>ない</td>
</tr>
<tr>
<td>过去否定式</td>
<td>〜ませんでした</td>
<td>〜なかった</td>
<td>ありませんでした-&gt;なかった</td>
</tr>
</tbody></table>
<h2 id="2-形容词"><a href="#2-形容词" class="headerlink" title="2 形容词"></a>2 形容词</h2><p>具体变形规则可以参看<a href="/blog/japanese-adjective">《日语-形容词》</a></p>
<h3 id="2-1-一类形容词"><a href="#2-1-一类形容词" class="headerlink" title="2.1 一类形容词"></a>2.1 一类形容词</h3><table>
<thead>
<tr>
<th>时态</th>
<th>敬体</th>
<th>简体</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>现在时</td>
<td>〜です</td>
<td>〜<del>です</del></td>
<td>おいしいです-&gt;おいしい</td>
</tr>
<tr>
<td>过去时</td>
<td>〜かったです</td>
<td>〜かった<del>です</del></td>
<td>おいし<del>い</del>かったです-&gt;おいし<del>い</del>かった</td>
</tr>
<tr>
<td>否定式</td>
<td>〜くないです</td>
<td>〜くない<del>です</del></td>
<td>おいし<del>い</del>くないです-&gt;おいし<del>い</del>くない</td>
</tr>
<tr>
<td>过去否定式</td>
<td>〜くなかったです</td>
<td>〜くなかった<del>です</del></td>
<td>おいし<del>い</del>くなかったです-&gt;おいし<del>い</del>くなかった</td>
</tr>
</tbody></table>
<p>おいしい（美味しい）</p>
<h3 id="2-2-二类形容词"><a href="#2-2-二类形容词" class="headerlink" title="2.2 二类形容词"></a>2.2 二类形容词</h3><table>
<thead>
<tr>
<th>时态</th>
<th>敬体</th>
<th>简体</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>现在时</td>
<td>〜です</td>
<td>〜だ</td>
<td>元気です-&gt;元気だ</td>
</tr>
<tr>
<td>过去时</td>
<td>〜でした</td>
<td>〜だった</td>
<td>元気でした-&gt;元気だった</td>
</tr>
<tr>
<td>否定式</td>
<td>〜ではありません</td>
<td>〜ではない&#x2F;〜じゃない</td>
<td>元気ではありません-&gt;元気ではない&#x2F;元気じゃない</td>
</tr>
<tr>
<td>过去否定式</td>
<td>〜ではありませんでした</td>
<td>〜ではなかった&#x2F;〜じゃなかった</td>
<td>元気ではありませんでした-&gt;元気ではなかった&#x2F;元気じゃなかった</td>
</tr>
</tbody></table>
<p>昨日、暑かった？ううん、全然暑くなかった。</p>
<p>この着物、派手（はで）？ううん、全然派手じゃないわ（此处男性使用时不加わ）。</p>
<h2 id="3-名词"><a href="#3-名词" class="headerlink" title="3 名词"></a>3 名词</h2><p>形式规则与二类形容词一致。</p>
<h2 id="4-敬语的基本型"><a href="#4-敬语的基本型" class="headerlink" title="4 敬语的基本型"></a>4 敬语的基本型</h2><h3 id="尊他语（尊敬語）"><a href="#尊他语（尊敬語）" class="headerlink" title="尊他语（尊敬語）"></a>尊他语（尊敬語）</h3><table>
<thead>
<tr>
<th>基本型</th>
<th>尊敬语</th>
</tr>
</thead>
<tbody><tr>
<td>お〜になら</td>
<td>お待ちになる　<br>　お読みになる　<br>　お書きになる　<br>　お聴きになる</td>
</tr>
<tr>
<td>ご〜になら</td>
<td>ご入学になる　<br>　ご視察になる　<br>　ご說明になる</td>
</tr>
<tr>
<td>〜れる　<br>　〜られる</td>
<td>行かれる　<br>　聞かれる　<br>　話される <br>　来られる</td>
</tr>
</tbody></table>
<h3 id="自谦语（謙譲語）"><a href="#自谦语（謙譲語）" class="headerlink" title="自谦语（謙譲語）"></a>自谦语（謙譲語）</h3><table>
<thead>
<tr>
<th>基本型</th>
<th>自谦语</th>
</tr>
</thead>
<tbody><tr>
<td>お〜する</td>
<td>お待ちする　<br>　お書きする　<br>　お聴きする</td>
</tr>
<tr>
<td>ご〜する</td>
<td>ご案內する　<br>　ご返事する　<br>　ご說明する</td>
</tr>
<tr>
<td>〜いただく(相手の動作)</td>
<td>お越しいただく　<br>　ご覽いただく</td>
</tr>
<tr>
<td>〜させていただく(自分の動作)</td>
<td>聞かせていただく　<br>　読ませていただく　<br>　出席させていただく</td>
</tr>
<tr>
<td>〜いたす</td>
<td>出席いただく　<br>　連絡させていただく</td>
</tr>
</tbody></table>
<h3 id="礼貌语（丁寧語）"><a href="#礼貌语（丁寧語）" class="headerlink" title="礼貌语（丁寧語）"></a>礼貌语（丁寧語）</h3><table>
<thead>
<tr>
<th>基本型</th>
<th>礼貌语</th>
</tr>
</thead>
<tbody><tr>
<td>〜です</td>
<td>〜です　<br>　〜ます　<br>　〜ございます</td>
</tr>
<tr>
<td>〜ます</td>
<td></td>
</tr>
<tr>
<td>〜ございます</td>
<td></td>
</tr>
</tbody></table>
<h3 id="混合表"><a href="#混合表" class="headerlink" title="混合表"></a>混合表</h3><table>
<thead>
<tr>
<th>基本型</th>
<th>尊他语</th>
<th>自谦语</th>
</tr>
</thead>
<tbody><tr>
<td>いる</td>
<td>いらっしゃいます　<br>　おいでになります</td>
<td>おります</td>
</tr>
<tr>
<td>する</td>
<td>なさいます</td>
<td>いたします</td>
</tr>
<tr>
<td>行く</td>
<td>いらっしゃいます</td>
<td>参ります</td>
</tr>
<tr>
<td>来る</td>
<td>いらっしゃいます　<br>　お見えになります <br> お越しになります</td>
<td>参ります</td>
</tr>
<tr>
<td>言う</td>
<td>おっしゃいます</td>
<td>申します　<br> 申し上げます</td>
</tr>
<tr>
<td>会う</td>
<td>お会いになる</td>
<td>お目にかかる</td>
</tr>
<tr>
<td>聞く</td>
<td>お聞きになります</td>
<td>うかがいます　<br> 承ります</td>
</tr>
<tr>
<td>見る</td>
<td>ご覧になります</td>
<td>拝見いたします</td>
</tr>
<tr>
<td>見せる</td>
<td>お見せになります</td>
<td>お目にかける　<br> お見せする</td>
</tr>
<tr>
<td>与える</td>
<td>くださいます</td>
<td>差し上げます　<br> 上げます</td>
</tr>
<tr>
<td>知っている</td>
<td>ご存知です</td>
<td>存じ上げております　<br> 存じております</td>
</tr>
<tr>
<td>持って行く</td>
<td>お持ちになら</td>
<td>持参います</td>
</tr>
<tr>
<td>食べる・飲む</td>
<td>召し上がります</td>
<td>いただきます</td>
</tr>
<tr>
<td>もらう</td>
<td></td>
<td>いただきます　<br>　頂戴いたします</td>
</tr>
<tr>
<td>着る</td>
<td>召す　<br> お召しになら</td>
<td>着る</td>
</tr>
<tr>
<td>ほめる</td>
<td>お褒めになる</td>
<td>お褒めにあずかる</td>
</tr>
<tr>
<td>借りる</td>
<td>お借りになる</td>
<td>拝借する</td>
</tr>
<tr>
<td>思う</td>
<td>おぼしめす</td>
<td>存じます</td>
</tr>
</tbody></table>
<h3 id="礼貌语的使用方法"><a href="#礼貌语的使用方法" class="headerlink" title="礼貌语的使用方法"></a>礼貌语的使用方法</h3><table>
<thead>
<tr>
<th>丁寧語の程度による使い分け</th>
<th>同僚との会話</th>
<th>普通の丁寧語</th>
</tr>
</thead>
<tbody><tr>
<td>どうする</td>
<td>どうします</td>
<td>いかがなさいますか</td>
</tr>
<tr>
<td>いいか</td>
<td>いいですか</td>
<td>いかがでございましょう</td>
</tr>
<tr>
<td>そうだ</td>
<td>そうです</td>
<td>さようでございます</td>
</tr>
<tr>
<td>これを見て</td>
<td>これを見てください</td>
<td>これをご覧くださyい</td>
</tr>
<tr>
<td>わかったか</td>
<td>わかりますか</td>
<td>お分かりいただけましたでしょうか</td>
</tr>
<tr>
<td>聞いた</td>
<td>ききました</td>
<td>うかがいました</td>
</tr>
<tr>
<td>ある</td>
<td>あります</td>
<td>ございます</td>
</tr>
<tr>
<td>いってみろ</td>
<td>話してください</td>
<td>おっしゃってください</td>
</tr>
</tbody></table>
<h3 id="そのほか-x2F-其他"><a href="#そのほか-x2F-其他" class="headerlink" title="そのほか&#x2F;其他"></a>そのほか&#x2F;其他</h3><table>
<thead>
<tr>
<th>普通語</th>
<th>丁寧語</th>
</tr>
</thead>
<tbody><tr>
<td>あっち</td>
<td>あちら</td>
</tr>
<tr>
<td>こっち</td>
<td>こちら</td>
</tr>
<tr>
<td>きょう（今日）</td>
<td>ほんじつ（本日）</td>
</tr>
<tr>
<td>きのう（昨日）</td>
<td>さくじつ（昨日）</td>
</tr>
<tr>
<td>あした（明日）</td>
<td>みょうにち（明日）</td>
</tr>
<tr>
<td>おととい（一昨日）</td>
<td>いっさくじつ（一昨日）</td>
</tr>
<tr>
<td>あさって（明後日）</td>
<td>みょうごにち（明後日）</td>
</tr>
<tr>
<td>少し</td>
<td>少少</td>
</tr>
<tr>
<td>どう</td>
<td>いかが</td>
</tr>
<tr>
<td>いくら</td>
<td>いかほど</td>
</tr>
<tr>
<td>すみません</td>
<td>相すみません</td>
</tr>
<tr>
<td>けさ（今朝）</td>
<td>こんちょう（今朝）</td>
</tr>
<tr>
<td>ゆうべ（昨夜）</td>
<td>さくや（昨夜）</td>
</tr>
<tr>
<td>ことし（今年）</td>
<td>ほんねん（本年）</td>
</tr>
<tr>
<td>きょねん（去年）</td>
<td>さくねん（昨年）</td>
</tr>
<tr>
<td>おととし（一昨年）</td>
<td>いっさくねん（一昨年）</td>
</tr>
<tr>
<td>今</td>
<td>只今</td>
</tr>
<tr>
<td>今度</td>
<td>この度</td>
</tr>
<tr>
<td>この間</td>
<td>せんじつ（先日）</td>
</tr>
<tr>
<td>どんな</td>
<td>どの樣な</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>日语</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊Objective-C的Runtime</title>
    <url>/2017-05-09-objc-runtime/</url>
    <content><![CDATA[<p>Objective-C 语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。</p>
<p>对于 Objective-C 来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。Runtime 基本上是用 C 和汇编写的，这个库使得C语言有了面向对象的能力。</p>
<p>在 Runtime 中，对象可以用 C 语言中的结构体表示，而方法可以用 C 函数来实现，另外再加上了一些额外的特性。这些结构体和函数被 runtime 函数封装后，让 Objective-C 的面向对象编程变为可能。</p>
<p>找出方法的最终执行代码：当程序执行<code>[object doSomething]</code>时，会向消息接收者(object)发送一条消息(doSomething)，runtime 会根据消息接收者是否能响应该消息而做出不同的反应。</p>
<span id="more"></span>

<h1 id="1-消息机制"><a href="#1-消息机制" class="headerlink" title="1 消息机制"></a>1 消息机制</h1><p>与古老的 C 语言不同，Objective-C 虽然源自 C 语言，但是它却是面向对象的，在这之中，消息机制发挥着重大作用。</p>
<p><strong>C语言和Objective-C编译时的区别：</strong></p>
<p>C 语言在编译的时候，已经知道调用哪一个函数。</p>
<p>Objective-C 不一样，只有在运行时才知道需要调用的方法和函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OBJC_EXPORT void objc_msgSend(void /* id self, SEL op, ... */ )</span><br><span class="line">    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0);</span><br></pre></td></tr></table></figure>

<p>使用这个方法要<code>#import &lt;objc/message.h&gt;</code>，另外，Apple 在 Xcode5 开始，不建议使用底层方法，而恰巧以上方法就是底层方法。此时，Xcode 就会报错，那么，如何解决呢？</p>
<p>解决方案如下：</p>
<ul>
<li>1）打开 Project 的<code>Build Settings</code>，搜索“msg”。</li>
<li>2）将<code>Enable Strict Checking of objc_msgSend Calls</code>的值设置为 NO。</li>
</ul>
<h2 id="发送无参消息"><a href="#发送无参消息" class="headerlink" title="发送无参消息"></a>发送无参消息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface Sample : NSObject</span><br><span class="line">+ (void)run;</span><br><span class="line">- (void)run;</span><br><span class="line">- (void)eatWithFood:(NSString *)food;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Sample</span><br><span class="line">+ (void)run</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;类方法 run&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)run</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;实例方法 run&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)eatWithFood:(NSString *)food</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;实例方法 eat：%@&quot;, food);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">- (void)test &#123;</span><br><span class="line">	Sample *t = [[Sample alloc] init];</span><br><span class="line">	objc_msgSend(t, @selector(run));</span><br><span class="line"></span><br><span class="line">	objc_msgSend([Sample class], @selector(run));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发送带参消息"><a href="#发送带参消息" class="headerlink" title="发送带参消息"></a>发送带参消息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)test &#123;</span><br><span class="line">	Sample *t = [[Sample alloc] init];</span><br><span class="line">	objc_msgSend(t, @selector(eatWithFood:), @&quot;apple&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>附加：将Objective-C转换出Runtime代码方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clang -rewrite-objc xxxx.m</span><br></pre></td></tr></table></figure>

<h2 id="交换方法的实现"><a href="#交换方法的实现" class="headerlink" title="交换方法的实现"></a>交换方法的实现</h2><p><code>class_getInstanceMethod(__unsafe_unretained Class cls, SEL name)</code>获取对象方法。</p>
<p><code>class_getClassMethod(__unsafe_unretained Class cls, SEL name)</code>获取类方法。</p>
<p><code>method_exchangeImplementations(Method m1, Method m2)</code>交换方法的实现方式。</p>
<p>常见示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSURL *url = [NSURL URLWithString:@&quot;https://charsdavy.github.io&quot;];</span><br><span class="line">[NSURLRequest requestWithURL:url];</span><br></pre></td></tr></table></figure>

<p>但<code>url</code>可能返回nil，而此段代码未能对返回值<code>url</code>进行合法判断。但每次使用以上类似代码都需要进行合法性判断，那么有什么更好的方法使<code>URLWithString:</code>能够做合法性判断呢？这个时候就需要使用Runtime的特有方法了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface NSURL (DD)</span><br><span class="line">+ (instancetype)dd_URLWithString:(NSString *)URLString;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSURL (DD)</span><br><span class="line">// 加载此分类时调用</span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    //获取方法名称</span><br><span class="line">    Method urlMethod = class_getClassMethod([NSURL class], @selector(URLWithString:));</span><br><span class="line">    Method ddUrlMethod = class_getClassMethod([NSURL class], @selector(dd_URLWithString:));</span><br><span class="line">    //交换方法的实现</span><br><span class="line">    method_exchangeImplementations(urlMethod, ddUrlMethod);</span><br><span class="line">&#125;</span><br><span class="line">//此方法与URLWithString:交换了实现方式</span><br><span class="line">+ (instancetype)dd_URLWithString:(NSString *)URLString</span><br><span class="line">&#123;</span><br><span class="line">//    NSURL *url = [NSURL URLWithString:URLString]; 此处不能再调用此方法，否则会死循环</span><br><span class="line">    NSURL *url = [NSURL dd_URLWithString:URLString];</span><br><span class="line">    if (!url) &#123;</span><br><span class="line">        NSLog(@&quot;url is nil&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return url;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="归档和解档"><a href="#归档和解档" class="headerlink" title="归档和解档"></a>归档和解档</h2><p>先来理解几个 Objective-C 中的概念：</p>
<p>序列化：将自定义的 Objective-C 的对象转化成二进制文件数据。</p>
<p>反序列化：将二进制文件数据转化成自定义的 Objective-C 的对象。</p>
<p>归档：将自定义的 Objective-C 的对象存储到本地磁盘。</p>
<p>解档：将存储在本地磁盘的数据转换成自定义的 Objective-C 的对象。</p>
<p>Ivar 类型：成员属性。</p>
<p>Method 类型：成员方法。</p>
<p>通常我们使用归档和解档的方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface Sample : NSObject&lt;NSCoding&gt;</span><br><span class="line">@property (nonatomic) NSString *name;</span><br><span class="line">@property (nonatomic) NSString *age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Sample</span><br><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder</span><br><span class="line">&#123;</span><br><span class="line">    [aCoder encodeObject:self.name forKey:@&quot;name&quot;];</span><br><span class="line">    [aCoder encodeObject:self.age forKey:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;];</span><br><span class="line">        self.age = [aDecoder decodeObjectForKey:@&quot;age&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">- (void)saveObject</span><br><span class="line">&#123;</span><br><span class="line">    Sample *p = [[Sample alloc] init];</span><br><span class="line">    p.name = @&quot;Chars&quot;;</span><br><span class="line">    p.age = @&quot;18&quot;;</span><br><span class="line">    </span><br><span class="line">    NSString *path = [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;chars.dat&quot;];</span><br><span class="line">    </span><br><span class="line">    BOOL flag = [NSKeyedArchiver archiveRootObject:p toFile:path];</span><br><span class="line">    if (flag) &#123;</span><br><span class="line">        NSLog(@&quot;success&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;falied&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;, path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)readObject</span><br><span class="line">&#123;</span><br><span class="line">    NSString *path = [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;chars.dat&quot;];</span><br><span class="line">    </span><br><span class="line">    Sample *p = [NSKeyedUnarchiver unarchiveObjectWithFile:path];</span><br><span class="line">    if (p) &#123;</span><br><span class="line">        NSLog(@&quot;name:%@,age:%@&quot;, p.name, p.age);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;falied&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;%@&quot;, path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Objective-C 中归档底层实现方式：将对象拆分为字典（键值对），然后变成二进制存入磁盘。</p>
<p>但是，当 model 中成员属性数量很多的时候，就沦为了体力劳动。那么，此时我们又能使用 Runtime 来简化工作。</p>
<p><code>class_copyIvarList(__unsafe_unretained Class cls, unsigned int *outCount)</code>获取 Class 中成员变量的个数。</p>
<p>以下就是使用 Runtime 消息机制编写的归档与解档方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)encodeWithCoder:(NSCoder *)aCoder</span><br><span class="line">&#123;   </span><br><span class="line">    unsigned int count = 0;</span><br><span class="line">    Ivar *ivars = class_copyIvarList([Sample class], &amp;count);</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        Ivar ivar = ivars[i];</span><br><span class="line">        const char *name = ivar_getName(ivar);</span><br><span class="line">        NSString *key = [NSString stringWithUTF8String:name];</span><br><span class="line">        [aCoder encodeObject:[self valueForKey:key] forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivars);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        unsigned int count = 0;</span><br><span class="line">        Ivar *ivars = class_copyIvarList([Sample class], &amp;count);</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            Ivar ivar = ivars[i];</span><br><span class="line">            const char *name = ivar_getName(ivar);</span><br><span class="line">            NSString *key = [NSString stringWithUTF8String:name];</span><br><span class="line">            id value = [aDecoder decodeObjectForKey:key];</span><br><span class="line">            [self setValue:value forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        free(ivars);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-KVO"><a href="#2-KVO" class="headerlink" title="2 KVO"></a>2 KVO</h1><p>利用 Runtime，在运行时动态创建一个对象。</p>
<p>实现原理：</p>
<ol>
<li>创建<code>NSKVONotifying_XXX:XXX</code>类(XXX为被监听者)。</li>
<li>重写属性 set 方法，调用<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>方法，进而触发调用观察者的<code>observeValueForKeyPath:ofObject:change:context:</code></li>
</ol>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface Viewer : NSObject</span><br><span class="line">@property (nonatomic) NSString *name;</span><br><span class="line">@property (nonatomic) NSString *age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Observer : NSObject</span><br><span class="line">@property (nonatomic) NSString *name;</span><br><span class="line">@property (nonatomic) NSString *age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Observer</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;object:%@, keyPath:%@, change:%@&quot;, object, keyPath, change);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">Observer *observer = [[Observer alloc] init];</span><br><span class="line">Viewr *viewer = [[Viewer alloc] init];</span><br><span class="line">//注册监听,viewer为被监听者，observer为观察者</span><br><span class="line">[viewr addObserver:observer forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br><span class="line">//触发KVO</span><br><span class="line">viewer.age = @&quot;99&quot;;</span><br></pre></td></tr></table></figure>

<h1 id="3-动态添加方法"><a href="#3-动态添加方法" class="headerlink" title="3 动态添加方法"></a>3 动态添加方法</h1><p>当方法被调用时，才被加载。</p>
<p><code>+ (BOOL)resolveClassMethod:(SEL)sel;</code>当一个类被调用了一个没有实现的方法时，则会调用此方法。</p>
<p><code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>当一个类被调用了一个没有实现的实例方法时，则会调用此方法。</p>
<p><code>class_addMethod(__unsafe_unretained Class cls, SEL name, IMP imp, const char *types)</code>动态添加方法。</p>
<p>参数<code>cls </code>：类类型。参数<code>name </code>：方法编号。参数<code>imp </code>：方法实现，就是一个函数的指针。参数<code>* types </code>：方法类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@implementation Sample</span><br><span class="line">//一个类被调用了一个没有实现的实例方法时，则会调用此方法。</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    if (sel == @selector(eat)) &#123;</span><br><span class="line">        //添加一个实例方法</span><br><span class="line">        class_addMethod([Sample class], sel, (IMP)eat, &quot;v@:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//隐式参数,self和_cmd是系统传过来的参数</span><br><span class="line">void eat(id self, SEL _cmd) &#123;</span><br><span class="line">    NSLog(@&quot;调用了%@的%@方法&quot;, self, NSStringFromSelector(_cmd));</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">[[[Sample alloc] init] performSelector:@selector(eat)];</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>objc</tag>
        <tag>ios</tag>
        <tag>读书笔记</tag>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title>与 MySQL 的零距离接触</title>
    <url>/2017-05-16-mysql-study/</url>
    <content><![CDATA[<p><a href="https://www.mysql.com/">MySQL</a>是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。</p>
<p>MySQL是一个开源的关系型数据库管理系统，分为社区版和企业版。</p>
<span id="more"></span>

<h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h1><p>直接前往官网 <a href="https://www.mysql.com/">https://www.mysql.com/</a> ，进入download页面下载所需对应安装版本。默认配置安装即可。</p>
<h1 id="2-配置"><a href="#2-配置" class="headerlink" title="2 配置"></a>2 配置</h1><p>安装成功之后，需要修改密码。详看<a href="/blog/mysql-install-config">《MySQL 安装配置》</a></p>
<p>修改编码方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">character-set-server=utf8</span><br></pre></td></tr></table></figure>

<h1 id="3-目录结构"><a href="#3-目录结构" class="headerlink" title="3 目录结构"></a>3 目录结构</h1><p>bin目录，存储可执行文件。</p>
<p>data目录，存储数据文件。</p>
<p>docs，文档。</p>
<p>include目录，存储包含的头文件。</p>
<p>lib目录，存储库文件。</p>
<p>share，错误消息和字符集文件。</p>
<h1 id="4-命令参数说明"><a href="#4-命令参数说明" class="headerlink" title="4 命令参数说明"></a>4 命令参数说明</h1><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-D,–database&#x3D;name</td>
<td>打开指定数据库</td>
</tr>
<tr>
<td>–delimiter&#x3D;name</td>
<td>指定分隔符</td>
</tr>
<tr>
<td>-h,–host&#x3D;name</td>
<td>服务器名称</td>
</tr>
<tr>
<td>-p,–password[&#x3D;name]</td>
<td>密码</td>
</tr>
<tr>
<td>-P,–port&#x3D;#</td>
<td>端口号</td>
</tr>
<tr>
<td>–prompt&#x3D;name</td>
<td>设置提示符</td>
</tr>
<tr>
<td>-u,–user&#x3D;name</td>
<td>用户名</td>
</tr>
<tr>
<td>-V,–version</td>
<td>输出版本信息并退出</td>
</tr>
</tbody></table>
<h2 id="MySQL提示符"><a href="#MySQL提示符" class="headerlink" title="MySQL提示符"></a>MySQL提示符</h2><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\D</td>
<td>完整的日期</td>
</tr>
<tr>
<td>\d</td>
<td>当前数据库</td>
</tr>
<tr>
<td>\h</td>
<td>服务器名称</td>
</tr>
<tr>
<td>\u</td>
<td>当前用户</td>
</tr>
</tbody></table>
<h2 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h2><h3 id="修改MySQL提示符"><a href="#修改MySQL提示符" class="headerlink" title="修改MySQL提示符"></a>修改MySQL提示符</h3><p>1.连接客户端时通过参数指定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -proot --prompt 提示符</span><br></pre></td></tr></table></figure>

<p>2.连接上客户端后，通过prompt命令修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt;prompt 提示符</span><br></pre></td></tr></table></figure>

<h3 id="MySQL常用命令"><a href="#MySQL常用命令" class="headerlink" title="MySQL常用命令"></a>MySQL常用命令</h3><p>1.显示当前服务器版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT VERSION();</span><br></pre></td></tr></table></figure>

<p>2.显示当前日期时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT NOW();</span><br></pre></td></tr></table></figure>

<p>3.显示当前用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT USER();</span><br></pre></td></tr></table></figure>

<h3 id="MySQL语句规范"><a href="#MySQL语句规范" class="headerlink" title="MySQL语句规范"></a>MySQL语句规范</h3><p>1.关键字与函数名称全部大写。</p>
<p>2.数据库名称、表名称、字段名称全部小写。</p>
<p>3.SQL语句必须以”;”符号结尾。</p>
<h1 id="5-SQL"><a href="#5-SQL" class="headerlink" title="5 SQL"></a>5 SQL</h1><p>结构化查询语言（英语：Structured Query Language，缩写：SQL），是一种特殊目的之编程语言，用于数据库中的标准数据查询语言。<br>不过各种通行的数据库系统在其实践过程中都对SQL规范作了某些编改和扩充。所以，实际上不同数据库系统之间的SQL不能完全相互通用。</p>
<p>具体参看文章<br><a href="/blog/mysql-sql-study">《MySQL 中的SQL》</a></p>
<h1 id="6-数据类型"><a href="#6-数据类型" class="headerlink" title="6 数据类型"></a>6 数据类型</h1><p>数据类型是指列、存储过程参数、表达式和局部变量的数据特征，它决定了数据的存储格式，代表了不同信息的类型。</p>
<h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p><img src="/assets/images/tech/mysql-study-01.png" alt="整型表"></p>
<h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>存储范围</th>
</tr>
</thead>
<tbody><tr>
<td>FLOAT[(M,D)]</td>
<td>-3.402823466E+38到-1.175494351E-38、0和1.175494351E-38到3.402823466E+38。M是数字总位数，D是小数点后面的位数。如果M和D被省略，根据硬件允许的限制来保存值。单精度浮点数精确到大约7位小数点。</td>
</tr>
<tr>
<td>DOUBLE[(M,D)]</td>
<td>-1.7976931348623157E+308到-2.2250738585072014E-308、0和2.2250738585072014E-308到1.7976931348623157E+308。</td>
</tr>
</tbody></table>
<h2 id="日期和时间型"><a href="#日期和时间型" class="headerlink" title="日期和时间型"></a>日期和时间型</h2><table>
<thead>
<tr>
<th>列类型</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>1</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
</tr>
<tr>
<td>DATE</td>
<td>3</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4</td>
</tr>
</tbody></table>
<h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><table>
<thead>
<tr>
<th>列类型</th>
<th>存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(M)</td>
<td>M个字节，0&lt;&#x3D;M&lt;&#x3D;255</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>L+1个字节，其中L&lt;&#x3D;M且0&lt;&#x3D;M&lt;&#x3D;65535</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>L+1个字节，其中L&lt;2^8</td>
</tr>
<tr>
<td>TEXT</td>
<td>L+2个字节，其中L&lt;2^16</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>L+3个字节，其中L&lt;2^24</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>L+4个字节，其中L&lt;2^32</td>
</tr>
<tr>
<td>ENUM(‘VALUE1’,’VALUE2’,…)</td>
<td>1或2个字节，取决于枚举值的个数（最多65,535个值）</td>
</tr>
<tr>
<td>SET(‘VALUE1’,’VALUE2’,…)</td>
<td>1、2、3、4或者8个字节，取决于set成员的数目（最多64个成员）</td>
</tr>
</tbody></table>
<p>更多其他MySQL使用与知识可以参见<a href="/2017/05/29/mysql-advanced-study/">《拆解 MySQL 的高阶使用与概念》</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>mysql</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 中的SQL</title>
    <url>/2017-05-19-mysql-sql-study/</url>
    <content><![CDATA[<p>结构化查询语言（英语：Structured Query Language，缩写：SQL），是一种特殊目的之编程语言，用于数据库中的标准数据查询语言，IBM公司最早使用在其开发的数据库系统中。</p>
<p>不过各种通行的数据库系统在其实践过程中都对SQL规范作了某些编改和扩充。所以，实际上不同数据库系统之间的SQL不能完全相互通用。</p>
<p>文章以MySQL数据库为演示环境，主要分享MySQL中的SQL使用。</p>
<span id="more"></span>

<h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] character_name</span><br></pre></td></tr></table></figure>

<p><code>&#123;&#125;</code>表示为必选项，即必填参数。<code>|</code>表示选项，即其中选取一项即可。<code>[]</code>表示为可选项。</p>
<p><code>character_name </code>参数为指定数据库的编码方式，不填则使用MySQL配置的字符集编码。</p>
<h3 id="查看当前服务器下的数据表列表"><a href="#查看当前服务器下的数据表列表" class="headerlink" title="查看当前服务器下的数据表列表"></a>查看当前服务器下的数据表列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW &#123;DATABASES | SCHEMAS&#125; [LIKE &#x27;pattern&#x27; | WHERE expr]</span><br></pre></td></tr></table></figure>

<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name</span><br></pre></td></tr></table></figure>

<h2 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h2><p>自动编号，且必须与主键组合使用。</p>
<p>数值型数据。</p>
<p>默认情况下，起始值为1，每次的增量为1。</p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>1.保证数据的完整性和一致性。</p>
<p>2.分为表级约束（针对两个或两个以上的字段进行约束）和列级约束（针对某一个字段进行约束）。</p>
<p>3.类型包括：</p>
<ul>
<li>NOT NULL 非空约束</li>
<li>PRIMARY KEY 主键约束</li>
<li>UNIQUE KEY 唯一约束</li>
<li>DEFAULT 默认约束</li>
<li>FOREIGN KEY 外键约束</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t6(id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY, username VARCHAR(20) NOT NULL UNIQUE KEY, sex ENUM(&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;) DEFAULT &#x27;3&#x27;);</span><br></pre></td></tr></table></figure>

<p><img src="/assets/images/tech/mysql-sql-study1.png" alt="t6表结构"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT t6 (username) VALUES (&#x27;Chars&#x27;);</span><br></pre></td></tr></table></figure>

<p><img src="/assets/images/tech/mysql-sql-study2.png" alt="t6表插入值"></p>
<h3 id="空值与非空值"><a href="#空值与非空值" class="headerlink" title="空值与非空值"></a>空值与非空值</h3><p>NULL，字段值可以为空。</p>
<p>NOT NULL，字段值禁止为空。不存在表级约束。</p>
<h3 id="PRIMARY-KEY"><a href="#PRIMARY-KEY" class="headerlink" title="PRIMARY KEY"></a>PRIMARY KEY</h3><p>主键约束。</p>
<p>每张数据表只能存在一个主键。</p>
<p>主键保证记录的唯一性。</p>
<p>主键自动为NOT NULL。</p>
<p><strong>注意：</strong></p>
<p><code>AUTO_INCREMENT</code>必须与<code>PRIMARY KEY</code>一起使用。但是，<code>PRIMARY KEY</code>不一定与<code>AUTO_INCREMENT</code>一起使用。</p>
<h3 id="UNIQUE-KEY"><a href="#UNIQUE-KEY" class="headerlink" title="UNIQUE KEY"></a>UNIQUE KEY</h3><p>唯一约束。</p>
<p>唯一约束可以保证记录的唯一性。</p>
<p>唯一约束的字段可以为空值（NULL）。</p>
<p>每张数据表可以存在多个唯一约束。</p>
<p><strong>注意：UNIQUE KEY与PRIMARY KEY区别</strong></p>
<p>PRIMARY KEY每张数据表只能有一个，且不能为空。</p>
<p>UNIQUE KEY每张数据表可以有多个，且可以为空。</p>
<h3 id="DEFAULT"><a href="#DEFAULT" class="headerlink" title="DEFAULT"></a>DEFAULT</h3><p>默认值。</p>
<p>当插入记录时，如果没有明确为字段赋值，则自动赋予默认值。</p>
<p>不存在表级约束。</p>
<h3 id="FOREIGN-KEY"><a href="#FOREIGN-KEY" class="headerlink" title="FOREIGN KEY"></a>FOREIGN KEY</h3><p>保持数据一致性，完整性。</p>
<p>实现一对一或一对多关系。</p>
<p>关系型数据库名称的来源。</p>
<h4 id="外键约束的要求"><a href="#外键约束的要求" class="headerlink" title="外键约束的要求"></a>外键约束的要求</h4><p>1.父表和子表必须使用相同的存储引擎，而且禁止使用临时表。</p>
<p>2.数据表的存储引擎只能为InnoDB。</p>
<p>3.外键列和参照列必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度则可以不同。</p>
<p>4.外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL将自动创建索引。</p>
<h4 id="外键约束的参照操作"><a href="#外键约束的参照操作" class="headerlink" title="外键约束的参照操作"></a>外键约束的参照操作</h4><p>1.CASCADE：从父表删除或更新且自动删除或更新子表中匹配的行。</p>
<p>2.SET NULL：从父表删除或更新行，并设置子表中的外键列为NULL。如果使用该选项，必须保证子表列没有指定NOT NULL。</p>
<p>3.RESTRICT：拒绝对父表的删除或更新操作。</p>
<p>4.NO ACTION：标准SQL的关键字，在MySQL中与RESTRICT相同。</p>
<p><strong>注意：</strong>物理外键即使用FOREIGN KEY关键字定义表。逻辑外键即定义表的时候按照某种联系，但是不使用FOREIGN KEY关键字修饰。</p>
<h4 id="编辑数据表的默认存储引擎"><a href="#编辑数据表的默认存储引擎" class="headerlink" title="编辑数据表的默认存储引擎"></a>编辑数据表的默认存储引擎</h4><p>MySQL配置文件</p>
<p><code>default-storage-engine=INNODB</code></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table provinces(id smallint unsigned primary key auto_increment, pname varchar(20) not null);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table users(id smallint unsigned primary key auto_increment, username varchar(10) not null, pid bigint, foreign key(pid) references provinces(id));</span><br><span class="line"></span><br><span class="line"># 报错</span><br><span class="line"># ERROR 1215 (HY000): Cannot add foreign key constraint</span><br><span class="line"># 因为类型不匹配</span><br><span class="line"></span><br><span class="line"># 正确命令应该是：</span><br><span class="line">create table users(id smallint unsigned primary key auto_increment, username varchar(10) not null, pid smallint unsigned, foreign key(pid) references provinces(id));</span><br></pre></td></tr></table></figure>

<p><img src="/assets/images/tech/mysql-sql-study3.png" alt="provinces表索引结构"></p>
<p><img src="/assets/images/tech/mysql-sql-study4.png" alt="users表索引结构"></p>
<h3 id="表级约束和列级约束"><a href="#表级约束和列级约束" class="headerlink" title="表级约束和列级约束"></a>表级约束和列级约束</h3><p>对一个数据列建立的约束，称为列级约束。</p>
<p>对多个数据列建立的约束，称为表级约束。</p>
<p>列级约束既可以在列定义时声明，也可以在列定义后声明。</p>
<p>表级约束只能在列定义后声明。</p>
<h2 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h2><p>数据表（或称表）是数据库最重要的组成部分之一，是其它对象的基础。数据表即二维表，行称为记录，列称为字段。</p>
<h3 id="USE"><a href="#USE" class="headerlink" title="USE"></a>USE</h3><p>打开数据库</p>
<p><code>USE 数据库名称;</code></p>
<h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE [IF NOT EXISTS] table_name (column_name data_type, ...)</span><br></pre></td></tr></table></figure>

<h3 id="查看数据表列表"><a href="#查看数据表列表" class="headerlink" title="查看数据表列表"></a>查看数据表列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLES [FROM db_name] [LIKE &#x27;pattern&#x27; | WHERE expr]</span><br></pre></td></tr></table></figure>

<h3 id="查看数据表结构"><a href="#查看数据表结构" class="headerlink" title="查看数据表结构"></a>查看数据表结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW COLUMNS FROM tbl_name</span><br></pre></td></tr></table></figure>

<h3 id="插入表记录"><a href="#插入表记录" class="headerlink" title="插入表记录"></a>插入表记录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT [INTO] tbl_name [(col_name,...)] VALUES(val,...)</span><br></pre></td></tr></table></figure>

<p>如果省略col_name就需要写全数据表所有的值。</p>
<h3 id="记录查找"><a href="#记录查找" class="headerlink" title="记录查找"></a>记录查找</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT expr,... FROM tbl_name</span><br></pre></td></tr></table></figure>

<h3 id="添加单列（数据表字段）"><a href="#添加单列（数据表字段）" class="headerlink" title="添加单列（数据表字段）"></a>添加单列（数据表字段）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tbl_name ADD [COLUMN] col_name column_definition [FIRST|AFTER col_name]</span><br></pre></td></tr></table></figure>

<p>省略[FIRST|AFTER col_name]参数将位于所有列的最后面。</p>
<h3 id="添加多列（数据表字段）"><a href="#添加多列（数据表字段）" class="headerlink" title="添加多列（数据表字段）"></a>添加多列（数据表字段）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tbl_name ADD [COLUMN] (col_name column_definition, ...)</span><br></pre></td></tr></table></figure>

<h3 id="删除列（数据表字段）"><a href="#删除列（数据表字段）" class="headerlink" title="删除列（数据表字段）"></a>删除列（数据表字段）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tbl_name DROP [COLUMN] col_name</span><br></pre></td></tr></table></figure>

<h3 id="添加主键约束"><a href="#添加主键约束" class="headerlink" title="添加主键约束"></a>添加主键约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_col_name, ...)</span><br></pre></td></tr></table></figure>

<h3 id="添加唯一约束"><a href="#添加唯一约束" class="headerlink" title="添加唯一约束"></a>添加唯一约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] UNIQUE [INDEX|KEY] [index_name] [index_type] (index_col_name, ...)</span><br></pre></td></tr></table></figure>

<h3 id="添加外键约束"><a href="#添加外键约束" class="headerlink" title="添加外键约束"></a>添加外键约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] FOREIGN KEY [index_name] (index_col_name, ...) reference_definition</span><br></pre></td></tr></table></figure>

<h3 id="添加／删除默认约束"><a href="#添加／删除默认约束" class="headerlink" title="添加／删除默认约束"></a>添加／删除默认约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tbl_name ALTER [COLUMN] col_name &#123;SET DEFAULT literal | DROP DEFAULT&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除主键约束"><a href="#删除主键约束" class="headerlink" title="删除主键约束"></a>删除主键约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tbl_name DROP PRIMARY KEY</span><br></pre></td></tr></table></figure>

<h3 id="删除唯一约束"><a href="#删除唯一约束" class="headerlink" title="删除唯一约束"></a>删除唯一约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tbl_name DROP &#123;INDEX | KEY&#125; index_name</span><br></pre></td></tr></table></figure>

<h3 id="删除外键约束"><a href="#删除外键约束" class="headerlink" title="删除外键约束"></a>删除外键约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol</span><br></pre></td></tr></table></figure>

<h3 id="修改列定义"><a href="#修改列定义" class="headerlink" title="修改列定义"></a>修改列定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tbl_name MODIFY [COLUMN] col_name column_definition [FIRST | AFTER col_name]</span><br></pre></td></tr></table></figure>

<h3 id="修改列名称"><a href="#修改列名称" class="headerlink" title="修改列名称"></a>修改列名称</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tbl_name CHANGE [COLUMN] old_col_name new_col_name column_definition [FIRST | AFTER col_name]</span><br></pre></td></tr></table></figure>

<h3 id="数据表更名"><a href="#数据表更名" class="headerlink" title="数据表更名"></a>数据表更名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 方法1</span><br><span class="line">ALTER TABLE tbl_name RENAME [TO|AS] new_tbl_name</span><br><span class="line"></span><br><span class="line"># 方法2</span><br><span class="line">RENAME TABLE tbl_name TO new_tbl_name [, tbl_name2 TO new_tbl_name2] ...</span><br></pre></td></tr></table></figure>

<h2 id="数据表数据操作"><a href="#数据表数据操作" class="headerlink" title="数据表数据操作"></a>数据表数据操作</h2><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 插入记录（可以插入多条记录）</span><br><span class="line">INSERT [INTO] tbl_name [(col_name, ...)] &#123;VALUES|VALUE&#125; (&#123;expr|DEFAULT&#125;, ...), (...), ...</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 插入记录（不可以插入多条记录）</span><br><span class="line">INSERT [INTO] tbl_name SET col_name = &#123;expr|DEFAULT&#125;, ...</span><br><span class="line"></span><br><span class="line"># 说明：与前一种方式的区别在于，此方法可以使用子查询（SubQuery）。由比较运算引发子查询（SubQuery）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 插入记录</span><br><span class="line">INSERT [INTO] tbl_name [(col_name, ...)] SELECT ...</span><br><span class="line"></span><br><span class="line"># 说明：此方法可以将查询结果插入到指定数据表。</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建“商品分类”表</span><br><span class="line">CREATE TABLE IF NOT EXISTS tdb_goods_cates(cate_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,cate_name VARCHAR(40));</span><br><span class="line"></span><br><span class="line">2.查询tdb_goods表的所有记录，并且按&quot;类别&quot;分组</span><br><span class="line">SELECT goods_cate FROM tdb_goods GROUP BY goods_cate;</span><br><span class="line"></span><br><span class="line">3.将分组结果写入到tdb_goods_cates数据表</span><br><span class="line">INSERT tdb_goods_cates (cate_name) SELECT goods_cate FROM tdb_goods GROUP BY goods_cate;</span><br></pre></td></tr></table></figure>

<h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 更新记录（单表更新）</span><br><span class="line">UPDATE [LOW_PRIORITY] [IGNORE] table_reference SET col_name1 = &#123;expr|DEFAULT&#125; [, col_name2 = &#123;expr|DEFAULT&#125;] ... [WHERE where_condition]</span><br></pre></td></tr></table></figure>

<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除记录（单表删除）</span><br><span class="line">DELETE FROM tbl_name [WHERE where_condition]</span><br></pre></td></tr></table></figure>

<h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查找记录</span><br><span class="line">SELECT select_expr [, select_expr ...] </span><br><span class="line">[</span><br><span class="line">	FROM table_references</span><br><span class="line">	[WHERE where_condition]</span><br><span class="line">	[GROUP BY &#123;col_name|position&#125; [ASC|DESC], ... ]</span><br><span class="line">	[HAVING where_condition]</span><br><span class="line">	[ORDER BY &#123;col_name|expr|position&#125; [ASC|DESC], ...]</span><br><span class="line">	[LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="select-expr-查询表达式"><a href="#select-expr-查询表达式" class="headerlink" title="select_expr 查询表达式"></a>select_expr 查询表达式</h4><p>每一个表达式表示想要的一列，必须至少有一个。</p>
<p>多个列之间以英文逗号分隔。</p>
<p>星号（<code>*</code>）表示多有列。<code>tbl_name.*</code>可以表示命名表的所有列。</p>
<p>查询表达式可以使用[AS] alias_name为其赋予别名。</p>
<p>别名可用于GROUP BY，ORDER BY或HAVING子句。</p>
<h4 id="WHERE-条件表达式"><a href="#WHERE-条件表达式" class="headerlink" title="WHERE 条件表达式"></a>WHERE 条件表达式</h4><p>对记录进行过滤，如果没有指定WHERE子句，则显示所有记录。</p>
<p>在WHERE表达式中，可以使用MySQL支持的函数或运算符。</p>
<h4 id="GROUP-BY-查询结果分组"><a href="#GROUP-BY-查询结果分组" class="headerlink" title="GROUP BY 查询结果分组"></a>GROUP BY 查询结果分组</h4><p><code>[GROUP BY &#123;col_name|position&#125; [ASC|DESC], ... ]</code><br>ASC：生序，默认值。<br>DESC：降序。</p>
<h4 id="HAVING-分组条件"><a href="#HAVING-分组条件" class="headerlink" title="HAVING 分组条件"></a>HAVING 分组条件</h4><p><code>[HAVING where_condition]</code><br><code>where_condition</code>中要么使用聚合函数，要么出现的字段一定要在SELECT中出现。</p>
<p>聚合函数：count() …</p>
<h4 id="ORDER-BY-对查询结果进行排序"><a href="#ORDER-BY-对查询结果进行排序" class="headerlink" title="ORDER BY 对查询结果进行排序"></a>ORDER BY 对查询结果进行排序</h4><p><code>[ORDER BY &#123;col_name|expr|position&#125; [ASC|DESC], ...]</code></p>
<h4 id="LIMIT-限制查询返回的数量"><a href="#LIMIT-限制查询返回的数量" class="headerlink" title="LIMIT 限制查询返回的数量"></a>LIMIT 限制查询返回的数量</h4><p><code>[LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;]</code><br>offset是从0开始的。</p>
<h3 id="CREATE-…-SELECT"><a href="#CREATE-…-SELECT" class="headerlink" title="CREATE … SELECT"></a>CREATE … SELECT</h3><p>创建数据表同时将查询结果写入到数据表<br><code>CREATE TABLE [IF NOT EXISTS] tbl_name [(create_definition, ...)] select_statement</code></p>
<p>示例：</p>
<ul>
<li>通过CREATE…SELECT来创建数据表并且同时写入记录<br><code>CREATE TABLE tdb_goods_brands (brand_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,brand_name VARCHAR(40) NOT NULL) SELECT brand_name FROM tdb_goods GROUP BY brand_name;</code></li>
</ul>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询（Subquery）是指出现在其他SQL语句内的SELECT子句。例如：<br><code>SELECT * FROM t1 WHERE col1=(SELECT col2 FROM t2);</code><br>其中<code>SELECT * FROM t1</code>称为Outer Query&#x2F;Outer Statement。<code>SELECT col2 FROM t2</code>称为SubQuery。</p>
<p>子查询指嵌套在查询内部，且必须始终出现在圆括号内。子查询可以包含多个关键字或条件，如DISTINCT、GROUP BY、ORDER BY、LIMIT函数等。子查询外层的查询可以是：SELECT、INSERT、UPDATE、SET或DO。</p>
<p>子查询可以返回标量、一行、一列或子查询。</p>
<h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>1.创建表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table tdb_goods (</span><br><span class="line">	goods_id smallint unsigned primary key auto_increment,</span><br><span class="line">	goods_name varchar(150) not null, </span><br><span class="line">	goods_cate varchar(40) not null, </span><br><span class="line">	brand_name varchar(40) not null,</span><br><span class="line">	goods_price decimal(15,3) unsigned default 0 not null, </span><br><span class="line">	is_show boolean default 1 not null, </span><br><span class="line">	is_saleoff boolean default 0 not null);</span><br></pre></td></tr></table></figure>

<p>2.添加数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES(&#x27;Mac Pro MD878CH/A 专业级台式电脑&#x27;,&#x27;服务器/工作站&#x27;,&#x27;苹果&#x27;,&#x27;28888&#x27;,DEFAULT,DEFAULT);</span><br><span class="line"> </span><br><span class="line">INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES(&#x27; HMZ-T3W 头戴显示设备&#x27;,&#x27;笔记本配件&#x27;,&#x27;索尼&#x27;,&#x27;6999&#x27;,DEFAULT,DEFAULT);</span><br><span class="line"></span><br><span class="line">INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES(&#x27;商务双肩背包&#x27;,&#x27;笔记本配件&#x27;,&#x27;索尼&#x27;,&#x27;99&#x27;,DEFAULT,DEFAULT);</span><br><span class="line"></span><br><span class="line">INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES(&#x27;X3250 M4机架式服务器 2583i14&#x27;,&#x27;服务器/工作站&#x27;,&#x27;IBM&#x27;,&#x27;6888&#x27;,DEFAULT,DEFAULT);</span><br></pre></td></tr></table></figure>

<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="使用比较运算符的子查询"><a href="#使用比较运算符的子查询" class="headerlink" title="使用比较运算符的子查询"></a>使用比较运算符的子查询</h4><p><code>=、&gt;、&lt;、&gt;=、&lt;=、&lt;&gt;、!=、&lt;=&gt; ...</code></p>
<p>语法结构<br><code>operand comparison_operator subquery</code></p>
<p>示例：</p>
<ul>
<li><p>求所有电脑产品的平均价格,并且保留两位小数，AVG,MAX,MIN、COUNT、SUM为聚合函数<br><code>SELECT ROUND(AVG(goods_price),2) AS avg_price FROM tdb_goods;</code></p>
</li>
<li><p>查询所有价格大于平均价格的商品，并且按价格降序排序<br><code>SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price &gt; 5845.10 ORDER BY goods_price DESC;</code></p>
</li>
<li><p>使用子查询来实现<br><code>SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price &gt; (SELECT ROUND(AVG(goods_price),2) AS avg_price FROM tdb_goods) ORDER BY goods_price DESC;</code></p>
</li>
</ul>
<h5 id="用ANY、SOME或ALL修饰的比较运算符"><a href="#用ANY、SOME或ALL修饰的比较运算符" class="headerlink" title="用ANY、SOME或ALL修饰的比较运算符"></a>用ANY、SOME或ALL修饰的比较运算符</h5><p><code>operand comparison_operator ANY(subquery)</code><br><code>operand comparison_operator SOME(subquery)</code><br><code>operand comparison_operator ALL(subquery)</code></p>
<p>ANY、SOME、ALL关键字</p>
<p><img src="/assets/images/tech/mysql-sql-study5.png"></p>
<p>示例：</p>
<ul>
<li>查询价格大于或等于”超级本”价格的商品，并且按价格降序排列<br><code>SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price = ANY(SELECT goods_price FROM tdb_goods WHERE goods_cate = &#39;超级本&#39;) ORDER BY goods_price DESC;</code></li>
</ul>
<h4 id="使用-NOT-IN的子查询"><a href="#使用-NOT-IN的子查询" class="headerlink" title="使用[NOT]IN的子查询"></a>使用[NOT]IN的子查询</h4><p>语法结构<br><code>operand comparison_operator [NOT]IN(subquery)</code><br>&#x3D;ANY运算符与IN等效。<br>!&#x3D;ALL或&lt;&gt;ALL运算符与NOT IN等效。</p>
<p>示例：</p>
<ul>
<li>&#x3D; ANY 或 &#x3D; SOME 等价于 IN<br><code>SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price IN (SELECT goods_price FROM tdb_goods WHERE goods_cate = &#39;超级本&#39;) ORDER BY goods_price DESC;</code></li>
</ul>
<h4 id="使用-NOT-EXISTS的子查询"><a href="#使用-NOT-EXISTS的子查询" class="headerlink" title="使用[NOT]EXISTS的子查询"></a>使用[NOT]EXISTS的子查询</h4><p>如果子查询返回任何行，EXISTS将返回TRUE；否则为FALSE。</p>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>MySQL在SELECT语句、多表更新、多表删除语句中支持JOIN操作。</p>
<h3 id="多表更新"><a href="#多表更新" class="headerlink" title="多表更新"></a>多表更新</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE table_references SET col_name1 = &#123;expr1|DEFAULT&#125; [, col_name2 = &#123;expr2|DEFAULT&#125;] ... [WHERE where_condition]</span><br></pre></td></tr></table></figure>

<p><code>table_references </code>的语法结构：<br><code>&#123;[INNER|CROSS] JOIN | &#123;LEFT|RIGHT&#125; [OUTER] JOIN&#125; table_reference ON conditional_expr</code></p>
<h4 id="数据表参照"><a href="#数据表参照" class="headerlink" title="数据表参照"></a>数据表参照</h4><p>table_references<br><code>tbl_name [[AS] alias]|table_subquery [AS] alias</code><br>数据表可以使用<code>tbl_name AS alias_name</code>或<code>tbl_name alias_name</code>赋予别名。<br><code>table_subquery</code>可以作为子查询使用在FROM子句中，这样的子查询必须为其赋予别名。</p>
<h4 id="连接类型"><a href="#连接类型" class="headerlink" title="连接类型"></a>连接类型</h4><p>INNER JOIN，内连接。在MySQL中，JOIN，CROSS JOIN和INNER JOIN是等价的。<br>LEFT [OUTER] JOIN，左外连接。<br>RIGHT [OUTER] JOIN，右外连接。</p>
<p>示例：</p>
<ul>
<li>通过tdb_goods_cates数据表来更新tdb_goods表<br><code>UPDATE tdb_goods INNER JOIN tdb_goods_cates ON goods_cate = cate_name SET goods_cate = cate_id ;</code></li>
</ul>
<h3 id="多表删除"><a href="#多表删除" class="headerlink" title="多表删除"></a>多表删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE tbl_name [.*] [, tbl_name [.*]] ... FROM table_references [WHERE where_condition]</span><br></pre></td></tr></table></figure>

<h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>显示左表及右表符合连接条件的记录。即仅显示符合连接条件的内容。</p>
<p><img src="/assets/images/tech/mysql-sql-study6.png" alt="内连接"></p>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>A LEFT JOIN B join_condition.<br>数据表B的结果集依赖数据表A。<br>数据表A的结果集根据左连接条件依赖所有数据表（B表除外）。<br>左外连接条件决定如何检索数据表B（在没有指定WHERE条件的情况下）。<br>如果数据表A的某条记录符合WHERE条件，但是在数据表B不存在符合连接条件的记录，将生成一个所有列为空的额外的B行。<br>如果使用内连接查找的记录在连接数据表中不存在，并且在WHERE子句中尝试以下操作：col_name IS NULL时，如果col_name被定义为NOT NULL，MySQL将在找到符合连接条件的记录后停止搜索更多的行。</p>
<ul>
<li>左外连接<br>显示左表的全部记录及右表符合连接条件的记录。</li>
</ul>
<p><img src="/assets/images/tech/mysql-sql-study7.png" alt="左外连接"></p>
<ul>
<li>右外连接<br>显示右表的全部记录及左表符合连接条件的记录。</li>
</ul>
<p><img src="/assets/images/tech/mysql-sql-study8.png" alt="右外连接"></p>
<h3 id="连接条件"><a href="#连接条件" class="headerlink" title="连接条件"></a>连接条件</h3><p>使用ON关键字来设定连接条件，也可以使用WHERE来代替。<br>通常使用ON关键字来设定连接条件，使用WHERE关键字进行结果集记录的过滤。</p>
<h3 id="无限级分类表设计"><a href="#无限级分类表设计" class="headerlink" title="无限级分类表设计"></a>无限级分类表设计</h3><ul>
<li><p>无限分类的数据表设计<br><code>CREATE TABLE tdb_goods_types(    type_id   SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,    type_name VARCHAR(20) NOT NULL,    parent_id SMALLINT UNSIGNED NOT NULL DEFAULT 0 );</code></p>
</li>
<li><p>插入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&#x27;家用电器&#x27;,DEFAULT);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&#x27;电脑、办公&#x27;,DEFAULT);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&#x27;大家电&#x27;,1);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&#x27;生活电器&#x27;,1);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&#x27;平板电视&#x27;,3);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&#x27;空调&#x27;,3);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&#x27;电风扇&#x27;,4);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&#x27;饮水机&#x27;,4);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&#x27;电脑整机&#x27;,2);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&#x27;电脑配件&#x27;,2);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&#x27;笔记本&#x27;,9);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&#x27;超级本&#x27;,9);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&#x27;游戏本&#x27;,9);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&#x27;CPU&#x27;,10);</span><br><span class="line">INSERT tdb_goods_types(type_name,parent_id) VALUES(&#x27;主机&#x27;,10);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h3><p>同一个数据表对其自身进行连接。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>mysql</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>拆解 MySQL 的高阶使用与概念</title>
    <url>/2017-05-29-mysql-advanced-study/</url>
    <content><![CDATA[<p>前面我们主要分享了MySQL中的常见知识与使用。这里我们主要分享一下MySQL中的高阶使用，主要包括：函数、存储过程和存储引擎。</p>
<p>对于MySQL中的基础知识，可以参见</p>
<p><a href="/blog/mysql-study">《与 MySQL 的零距离接触》</a></p>
<span id="more"></span>

<h1 id="1-函数"><a href="#1-函数" class="headerlink" title="1 函数"></a>1 函数</h1><p>函数可以返回任意类型的值，也可以接收这些类型的参数。</p>
<h2 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h2><table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONCAT()</td>
<td>字符连接</td>
</tr>
<tr>
<td>CONCAT_WS()</td>
<td>使用指定的分隔符进行字符连接</td>
</tr>
<tr>
<td>FORMAT()</td>
<td>数字格式化</td>
</tr>
<tr>
<td>LOWER()</td>
<td>转换成小写字母</td>
</tr>
<tr>
<td>UPPER()</td>
<td>转换成大写字母</td>
</tr>
<tr>
<td>LEFT()</td>
<td>获取左侧字符</td>
</tr>
<tr>
<td>RIGHT()</td>
<td>获取右侧字符</td>
</tr>
<tr>
<td>LENGTH()</td>
<td>获取字符串长度</td>
</tr>
<tr>
<td>LTRIM()</td>
<td>删除前导空格</td>
</tr>
<tr>
<td>RTRIM()</td>
<td>删除后续空格</td>
</tr>
<tr>
<td>TRIM()</td>
<td>删除前导和后续空格</td>
</tr>
<tr>
<td>SUBSTRING()</td>
<td>字符串截取</td>
</tr>
<tr>
<td>[NOT] LIKE</td>
<td>模式匹配</td>
</tr>
<tr>
<td>REPLACE()</td>
<td>字符串替换</td>
</tr>
</tbody></table>
<p>函数可以嵌套使用。<br><code>%</code>（百分号）：代表任意个字符。<br><code>_</code>（下划线）：代表任意一个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除前导&#x27;?&#x27;符号</span><br><span class="line">SELECT TRIM(LEADING &#x27;?&#x27; FROM &#x27;??MySQL???&#x27;);</span><br><span class="line"># 删除后续&#x27;?&#x27;符号</span><br><span class="line">SELECT TRIM(TRAILING &#x27;?&#x27; FROM &#x27;??MySQL???&#x27;);</span><br><span class="line"># 删除前后&#x27;?&#x27;符号</span><br><span class="line">SELECT TRIM(BOTH &#x27;?&#x27; FROM &#x27;??My??SQL???&#x27;);</span><br><span class="line"># 将&#x27;?&#x27;符号替换成&#x27;!&#x27;符号</span><br><span class="line">SELECT REPLACE(&#x27;??My??SQL???&#x27;, &#x27;?&#x27;, &#x27;!&#x27;);</span><br><span class="line"># 从中&#x27;MySQL&#x27;第1个开始，截取2个字符</span><br><span class="line">SELECT SUBSTRING(&#x27;MySQL&#x27;, 1, 2);</span><br><span class="line"># 从中&#x27;MySQL&#x27;截取最后1个字符</span><br><span class="line">SELECT SUBSTRING(&#x27;MySQL&#x27;, -1);</span><br><span class="line"># 从中&#x27;MySQL&#x27;第2个开始，截取至结尾</span><br><span class="line">SELECT SUBSTRING(&#x27;MySQL&#x27;, 2);</span><br></pre></td></tr></table></figure>

<h2 id="数值运算符函数"><a href="#数值运算符函数" class="headerlink" title="数值运算符函数"></a>数值运算符函数</h2><table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CEIL()</td>
<td>进一取整</td>
</tr>
<tr>
<td>DIV</td>
<td>整数除法</td>
</tr>
<tr>
<td>FLOOR()</td>
<td>舍一取整</td>
</tr>
<tr>
<td>MOD</td>
<td>取余数（取模）</td>
</tr>
<tr>
<td>POWER()</td>
<td>幂运算</td>
</tr>
<tr>
<td>ROUND()</td>
<td>四舍五入</td>
</tr>
<tr>
<td>TRUNCATE()</td>
<td>数字截取</td>
</tr>
</tbody></table>
<h2 id="比较运算符函数"><a href="#比较运算符函数" class="headerlink" title="比较运算符函数"></a>比较运算符函数</h2><table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[NOT]BETWEEN…AND..</td>
<td>[不]在范围之内</td>
</tr>
<tr>
<td>[NOT]IN()</td>
<td>[不]在列出值范围内</td>
</tr>
<tr>
<td>IS[NOT]NULL</td>
<td>[不]为空</td>
</tr>
</tbody></table>
<h2 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数"></a>日期时间函数</h2><table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>NOW()</td>
<td>当前日期和时间</td>
</tr>
<tr>
<td>CURDATE()</td>
<td>当前日期</td>
</tr>
<tr>
<td>CURTIME()</td>
<td>当前时间</td>
</tr>
<tr>
<td>DATE_ADD()</td>
<td>日期变化</td>
</tr>
<tr>
<td>DATEDIFF()</td>
<td>日期差值</td>
</tr>
<tr>
<td>DATE_FORMAT()</td>
<td>日期格式化</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 时间增加1年</span><br><span class="line">SELECT DATE_ADD(&#x27;2016-05-28&#x27;, INTERVAL 365 DAY);</span><br><span class="line"># 时间减少1年</span><br><span class="line">SELECT DATE_ADD(&#x27;2016-05-28&#x27;, INTERVAL -365 DAY);</span><br><span class="line"># 时间增加3周</span><br><span class="line">SELECT DATE_ADD(&#x27;2016-05-28&#x27;, INTERVAL 3 WEEK);</span><br><span class="line"># 日期格式化</span><br><span class="line">SELECT DATE_FORMAT(&#x27;2016-05-28&#x27;, &#x27;%m/%d/%Y&#x27;);</span><br><span class="line"># 更多时间格式可以前往MySQL官网查看手册</span><br></pre></td></tr></table></figure>

<h2 id="信息函数"><a href="#信息函数" class="headerlink" title="信息函数"></a>信息函数</h2><table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CONNECTION_ID()</td>
<td>连接ID</td>
</tr>
<tr>
<td>DATEBASE()</td>
<td>当前数据库</td>
</tr>
<tr>
<td>LAST_INSERT_ID()</td>
<td>最后插入记录的ID号</td>
</tr>
<tr>
<td>USER()</td>
<td>当前用户</td>
</tr>
<tr>
<td>VERSION()</td>
<td>版本信息</td>
</tr>
</tbody></table>
<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AVG()</td>
<td>平均值</td>
</tr>
<tr>
<td>COUNT()</td>
<td>计数</td>
</tr>
<tr>
<td>MAX()</td>
<td>最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>最小值</td>
</tr>
<tr>
<td>SUM()</td>
<td>求和</td>
</tr>
</tbody></table>
<h2 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h2><table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>MD5()</td>
<td>信息摘要算法</td>
</tr>
<tr>
<td>PASSWORD()</td>
<td>密码算法</td>
</tr>
</tbody></table>
<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>用户自定义函数（user-defined function，UDF）是一种对MySQL扩展的途径，其用法与内置函数相同。UDF是对MySQL扩展的一种途径。</p>
<h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ul>
<li>参数：可以有零个或多个</li>
<li>返回值：只能有一个</li>
</ul>
<p>参数和返回值没有必然的联系。</p>
<h3 id="创建自定义函数"><a href="#创建自定义函数" class="headerlink" title="创建自定义函数"></a>创建自定义函数</h3><p><code>CREATE FUNCTION function_name RETURNS &#123;STRING|INTEGER|REAL|DECIMAL&#125; routine_body</code></p>
<h4 id="函数体（routine-body）"><a href="#函数体（routine-body）" class="headerlink" title="函数体（routine_body）"></a>函数体（routine_body）</h4><ul>
<li>函数体由合法的SQL语句构成；</li>
<li>函数体可以是简单的SELECT或INSERT语句；</li>
<li>函数体如果为复合结构则使用BEGIN…END语句；</li>
<li>复合结构可以包含声明，循环，控制结构。</li>
</ul>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 不带参数</span><br><span class="line">CREATE FUNCTION f1() RETURNS VARCHAR(30) RETURN DATE_FORMAT(NOW(), &#x27;%Y-%m-%d %H:%i:%s&#x27;);</span><br><span class="line"></span><br><span class="line"># 带参数</span><br><span class="line">CREATE FUNCTION f2(num1 SMALLINT UNSIGNED, num2 SMALLINT UNSIGNED) RETURNS FLOAT(10, 2) UNSIGNED RETURN (num1 + num2) / 2;</span><br><span class="line"></span><br><span class="line"># 具有复合结构函数体</span><br><span class="line"># 可能需要使用DELIMITER命令修改分隔符</span><br><span class="line">CREATE FUNCTION f3(username VARCHAR(20)) RETURNS INT UNSIGNED </span><br><span class="line">BEGIN </span><br><span class="line">INSERT test(username) VALUES(username);</span><br><span class="line">RETURN LAST_INSERT_ID();</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h1 id="2-存储过程"><a href="#2-存储过程" class="headerlink" title="2 存储过程"></a>2 存储过程</h1><p><img src="/assets/images/tech/mysql-advanced-study-1.png" alt="命令执行流程"><br>存储过程是SQL语句和控制语句的预编译集合，以一个名称存储作为一个单元处理。可以由用户调用执行，允许用户声明变量以及进行流程控制。存储过程可以接收输入类型的参数，也可以接收输出类型的参数，并可以存在多个返回值。执行效率比单一的SQL语句高。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>增强SQL语句的功能和灵活性</li>
</ul>
<p>在存储过程中可以写控制语句具有很强的灵活性，可以完成复杂的判断及较复杂的运算。</p>
<ul>
<li>实现较快的执行速度</li>
</ul>
<p>如果某一操作包含了大量的SQL语句，那么这些SQL语句都将被MySQL引擎执行语法分析、编译、执行，所以效率相对过低。而存储过程是预编译的，当客户端第一次调用存储过程时，MySQL的引擎将对它进行语法分析、编译等操作，然后把这个编译的结果存储到内存中，所以说第一次使用的时候效率和以前是相同的。但是以后客户端再次调用这个存储过程时，直接从内存中执行，所以说效率比较高，速度比较快。</p>
<ul>
<li>减少网络流量</li>
</ul>
<p>如果通过客户端每一个单独发送SQL语句让服务器来执行，那么通过http协议来提交的数据量相对来说较大。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [DEFINER = &#123;user|CURRENT_USER&#125;] PROCEDURE sp_name ([proc_parameter[, ...]]) [characteristic ...] routine_body</span><br></pre></td></tr></table></figure>

<p><code>proc_parameter </code>:<br><code>[IN | OUT | INOUT] param_name type</code></p>
<p>参数：<br><code>IN</code>，表示该参数的值必须在调用存储过程时指定。<br><code>OUT</code>，表示该参数值可以被存储过程改变，并且可以返回。<br><code>INOUT</code>，表示该参数的调用时指定，并且可以被改变和返回。</p>
<p>特性：<br><code>COMMENT</code>注释<br><code>CONTAINS SQL</code>包含SQL语句，但不包含读或写数据的语句。<br><code>NO SQL</code>不包含SQL语句。<br><code>READS SQL DATA</code>包含读写数据的语句。<br><code>MODIFIES SQL DATA</code>包含写数据的语句。<br><code>SQL SECURITY &#123;DEFINER | INVOKER&#125;</code>指明谁有权限来执行。</p>
<h2 id="过程体"><a href="#过程体" class="headerlink" title="过程体"></a>过程体</h2><ul>
<li>过程体由合法的SQL语句构成；</li>
<li>过程体可以是任意SQL语句；<br>不能通过存储过程来创建数据表、数据库。可以通过存储过程对数据进行增、删、改、查和多表连接操作。</li>
<li>过程体如果为复合结构则使用BEGIN…END语句；</li>
<li>复合结构中可以包含声明、循环、控制结构。</li>
</ul>
<h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL sp_name ([parameter[, ...]])</span><br><span class="line">CALL sp_name[()]</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE [IF EXISTS] sp_name</span><br></pre></td></tr></table></figure>

<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER PROCEDURE sp_name [characteristic ...] COMMENT &#x27;string&#x27;</span><br><span class="line">| &#123;CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA&#125;</span><br><span class="line">| SQL SECURITY &#123;DEFINER | INVOKER&#125;</span><br></pre></td></tr></table></figure>

<h2 id="存储过程与自定义函数的区别"><a href="#存储过程与自定义函数的区别" class="headerlink" title="存储过程与自定义函数的区别"></a>存储过程与自定义函数的区别</h2><ul>
<li>存储过程实现的功能要复杂一些，而函数的针对性更强。</li>
<li>存储过程可以返回多个值，函数只能有一个返回值。</li>
<li>存储过程一般独立执行，函数可以作为其他SQL语句的组成部分来实现。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建不带参数的存储过程</span><br><span class="line">CREATE PROCEDURE sp1() SELECT VERSION();</span><br><span class="line"></span><br><span class="line"># 创建带有IN类型参数的存储过程(users为数据表名)</span><br><span class="line"># 参数的名字不能和数据表中的记录名字一样</span><br><span class="line">CREATE PROCEDURE removeUserById(IN p_id INT UNSIGNED)</span><br><span class="line">BEGIN</span><br><span class="line">DELETE FROM users WHERE id = p_id;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"># 创建带有IN和OUT类型参数的存储过程(users为数据表名)</span><br><span class="line">CREATE PROCEDURE removeUserAndReturnUserNumsById(IN p_id INT UNSIGNED, OUT userNums INT UNSIGNED)</span><br><span class="line">BEGIN</span><br><span class="line">DELETE FROM users WHERE id = p_id;</span><br><span class="line">SELECT COUNT(id) FROM users INTO userNums;</span><br><span class="line">END</span><br><span class="line"></span><br><span class="line"># 创建带有多个OUT类型参数的存储过程(users为数据表名)</span><br><span class="line">CREATE PROCEDURE removeUserAndReturnInfosByAge(IN p_age SMALLINT UNSIGNED, OUT delUser SMALLINT UNSIGNED,  OUT userNums SMALLINT UNSIGNED)</span><br><span class="line">BEGIN</span><br><span class="line">DELETE FROM users WHERE age = p_age;</span><br><span class="line">SELECT ROW_COUNT INTO delUser;</span><br><span class="line">SELECT COUNT(id) FROM users INTO userNums;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<h1 id="3-存储引擎"><a href="#3-存储引擎" class="headerlink" title="3 存储引擎"></a>3 存储引擎</h1><p>MySQL可以将数据以不同的技术存储在文件（内存）中，这种技术就称为存储引擎。<br>每一种存储引擎使用不同的存储机制、索引技巧、锁定水平，最终提供广泛且不同的功能。</p>
<ul>
<li><p>锁<br>共享锁（读锁）：在同一时间段内，多个用户可以读取同一个资源，读取过程中数据不会发生任何变化。<br>排他锁（写锁）：在任何时候只能有一个用户写入资源，当进行写锁时会阻塞其他的读锁或者写锁操作。</p>
</li>
<li><p>锁颗粒<br>表锁：是一种开销最小的锁策略。<br>行锁：是一种开销最大的锁策略。</p>
</li>
<li><p>并发控制<br>当多个连接记录进行修改时保证数据的一致性和完整性。</p>
</li>
<li><p>事务<br>事务用于保证数据库的完整性。</p>
</li>
</ul>
<p>举例：用户银行转账<br><code>用户A</code> 转账200元 <code>用户B</code><br>实现步骤：<br>1）从当前账户减掉200元（账户余额大于等于200元）。<br>2）在对方账户增加200元。</p>
<p><strong>事务特性：</strong><br>1）原子性（atomicity）<br>2）一致性（consistency）<br>3）隔离性（isolation）<br>4）持久性（durability）</p>
<ul>
<li><p>外键<br>是保证数据一致性的策略。</p>
</li>
<li><p>索引<br>是对数据表中一列或多列的值进行排序的一种结构。</p>
</li>
</ul>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>MySQL主要支持以下几种引擎类型：</p>
<ul>
<li>MyISAM</li>
<li>InnoDB</li>
<li>Memory</li>
<li>CSV</li>
<li>Archive</li>
</ul>
<p>各类存储引擎特点</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>Memory</th>
<th>Archive</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>256TB</td>
<td>64TB</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>事务安全</td>
<td>-</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>支持索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>锁颗粒</td>
<td>表锁</td>
<td>行锁</td>
<td>表锁</td>
<td>行锁</td>
</tr>
<tr>
<td>数据压缩</td>
<td>支持</td>
<td>-</td>
<td>-</td>
<td>支持</td>
</tr>
<tr>
<td>支持外键</td>
<td>-</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>CSV:实际上是由逗号分隔的数据引擎，在数据库子目录为每一个表创建一个<code>.csv</code>的文件，这是一种普通的文本文件，每一个数据行占用一个文本行。不支持索引。</p>
<p>BlackHole：黑洞引擎，写入的数据都会消失，一般用于做数据复制的中继。</p>
<p>MyISAM：适用于事务的处理不多的情况。</p>
<p>InnoDB：适用于事务处理比较多，需要有外键支持的情况。</p>
<p>索引分类：普通索引、唯一索引、全文索引、btree索引、hash索引…</p>
<h2 id="修改存储引擎"><a href="#修改存储引擎" class="headerlink" title="修改存储引擎"></a>修改存储引擎</h2><ul>
<li>通过修改MySQL配置文件<br><code>default-storage-engine=engine_name</code></li>
<li>通过创建数据表命令实现<br><code>CREATE TABLE table_name(...)ENGINE=engine_name</code></li>
<li>通过修改数据表命令实现<br><code>ALTER TABLE table_name ENGINE[=]engine_name</code></li>
</ul>
<h1 id="4-管理工具"><a href="#4-管理工具" class="headerlink" title="4 管理工具"></a>4 管理工具</h1><ul>
<li><p>phpMyAdmin<br>需要有PHP环境</p>
</li>
<li><p>Navicat</p>
</li>
<li><p>MySQL Workbench</p>
</li>
<li><p>Sequel Pro</p>
</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>mysql</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>初探 TensorFlow</title>
    <url>/2017-06-07-tensorflow-primer-guide/</url>
    <content><![CDATA[<p>TensorFlow 是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。</p>
<p><img src="/assets/images/tech/tensorflow-primer-guide-tensors_flowing.gif" alt="tensors_flowing"></p>
<span id="more"></span>

<h2 id="什么是数据流图（Data-Flow-Graph）"><a href="#什么是数据流图（Data-Flow-Graph）" class="headerlink" title="什么是数据流图（Data Flow Graph）"></a>什么是数据流图（Data Flow Graph）</h2><p>数据流图用“结点”(nodes)和“线”(edges)的有向图来描述数学计算。“节点” 一般用来表示施加的数学操作，但也可以表示数据输入(feed in)的起点&#x2F;输出(push out)的终点，或者是读取&#x2F;写入持久变量(persistent variable)的终点。“线”表示“节点”之间的输入&#x2F;输出关系。这些数据“线”可以输运“size可动态调整”的多维数据数组，即“张量”(tensor)。张量从图中流过的直观图像是这个工具取名为“Tensorflow”的原因。一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。</p>
<h2 id="TensorFlow的特征"><a href="#TensorFlow的特征" class="headerlink" title="TensorFlow的特征"></a>TensorFlow的特征</h2><ul>
<li>高度的灵活性</li>
<li>真正的可移植性（Portability）</li>
<li>将科研和产品联系在一起</li>
<li>自动求微分</li>
<li>多语言支持</li>
<li>性能最优化</li>
</ul>
<h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># --recurse-submodules 参数是必须的, 用于获取 TesorFlow 依赖的 protobuf 库</span><br><span class="line">$ git clone --recurse-submodules https://github.com/tensorflow/tensorflow</span><br></pre></td></tr></table></figure>

<h4 id="Linux-安装"><a href="#Linux-安装" class="headerlink" title="Linux 安装"></a>Linux 安装</h4><h5 id="安装-Bazel"><a href="#安装-Bazel" class="headerlink" title="安装 Bazel"></a>安装 Bazel</h5><p>首先依照 <a href="https://bazel.build/versions/master/docs/install.html">教程</a> 安装 Bazel 的依赖. 然后使用下列命令下载和编译 Bazel 的源码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/bazelbuild/bazel.git</span><br><span class="line">$ cd bazel</span><br><span class="line">$ git checkout tags/0.1.0</span><br><span class="line">$ ./compile.sh</span><br></pre></td></tr></table></figure>

<p>上面命令中拉取的代码标签为 0.1.0, 兼容 Tensorflow 目前版本. bazel 的HEAD 版本 (即最新版本) 在这里可能不稳定.</p>
<p>将执行路径 <code>output/bazel</code> 添加到 <code>$PATH</code> 环境变量中.</p>
<h5 id="安装其他依赖"><a href="#安装其他依赖" class="headerlink" title="安装其他依赖"></a>安装其他依赖</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install python-numpy swig python-dev</span><br></pre></td></tr></table></figure>

<h4 id="Mac-OS-X-安装"><a href="#Mac-OS-X-安装" class="headerlink" title="Mac OS X 安装"></a>Mac OS X 安装</h4><p>Mac 和 Linux 需要的软件依赖完全一样, 但是安装过程区别很大. 以下链接用于帮助你 在 Mac OS X 上安装这些依赖:</p>
<h5 id="Bazel"><a href="#Bazel" class="headerlink" title="Bazel"></a>Bazel</h5><p>参见<a href="https://bazel.build/versions/master/docs/install.html">网页</a>的 Mac OS X 安装指南.</p>
<h5 id="SWIG"><a href="#SWIG" class="headerlink" title="SWIG"></a>SWIG</h5><p><a href="http://www.swig.org/Doc3.0/Preface.html#Preface_osx_installation">Mac OS X 安装教程</a></p>
<p>注意: 你需要安装<a href="ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/">PCRE</a>, 而不是 PCRE2.</p>
<h5 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h5><p>参见<a href="https://docs.scipy.org/doc/numpy/user/install.html">安装教程</a>.</p>
<h5 id="创建-pip-包并安装"><a href="#创建-pip-包并安装" class="headerlink" title="创建 pip 包并安装"></a>创建 pip 包并安装</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ bazel build -c opt //tensorflow/tools/pip_package:build_pip_package</span><br><span class="line"></span><br><span class="line">$ bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg</span><br><span class="line"></span><br><span class="line"># .whl 文件的实际名字与你所使用的平台有关</span><br><span class="line">$ pip install /tmp/tensorflow_pkg/tensorflow-0.5.0-cp27-none-linux_x86_64.whl</span><br></pre></td></tr></table></figure>

<h3 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h3><p>TensorFlow Python API 依赖 Python 2.7 版本.</p>
<p>在 Linux 和 Mac 下最简单的安装方式, 是使用 <a href="https://pypi.python.org/pypi/pip">pip</a> 安装.</p>
<p>为了简化安装步骤, 建议使用 virtualenv, 具体安装方法在后文具体说明.</p>
<h4 id="Ubuntu-x2F-Linux"><a href="#Ubuntu-x2F-Linux" class="headerlink" title="Ubuntu&#x2F;Linux"></a>Ubuntu&#x2F;Linux</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 仅使用 CPU 的版本</span><br><span class="line">$ pip install https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.5.0-cp27-none-linux_x86_64.whl</span><br><span class="line"></span><br><span class="line"># 开启 GPU 支持的版本 (安装该版本的前提是已经安装了 CUDA sdk)</span><br><span class="line">$ pip install https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.5.0-cp27-none-linux_x86_64.whl</span><br></pre></td></tr></table></figure>

<h4 id="Mac-OS-X"><a href="#Mac-OS-X" class="headerlink" title="Mac OS X"></a>Mac OS X</h4><p>在 OS X 系统上, 推荐先安装 <a href="https://brew.sh/">homebrew</a>, 然后执行 <code>brew install python</code>, 以便能够使用 homebrew 中的 Python 安装 TensorFlow. 另外一种推荐的方式是在 virtualenv 中安装 TensorFlow.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 当前版本只支持 CPU</span><br><span class="line">$ pip install https://storage.googleapis.com/tensorflow/mac/tensorflow-0.5.0-py2-none-any.whl</span><br></pre></td></tr></table></figure>

<h4 id="基于-VirtualEnv-的安装"><a href="#基于-VirtualEnv-的安装" class="headerlink" title="基于 VirtualEnv 的安装"></a>基于 VirtualEnv 的安装</h4><p>推荐使用 <a href="https://pypi.python.org/pypi/virtualenv">virtualenv</a> 创建一个隔离的容器, 来安装 TensorFlow. 这是可选的, 但是这样做能使排查安装问题变得更容易.</p>
<p>首先, 安装所有必备工具:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在 Linux 上:</span><br><span class="line">$ sudo apt-get install python-pip python-dev python-virtualenv</span><br><span class="line"></span><br><span class="line"># 在 Mac 上:</span><br><span class="line">$ sudo easy_install pip  # 如果还没有安装 pip</span><br><span class="line">$ sudo pip install --upgrade virtualenv</span><br></pre></td></tr></table></figure>

<p>接下来, 建立一个全新的 virtualenv 环境. 为了将环境建在 ~&#x2F;tensorflow 目录下, 执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ virtualenv --system-site-packages ~/tensorflow</span><br><span class="line">$ cd ~/tensorflow</span><br></pre></td></tr></table></figure>
<p>然后, 激活 virtualenv:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ source bin/activate  # 如果使用 bash</span><br><span class="line">$ source bin/activate.csh  # 如果使用 csh</span><br><span class="line">(tensorflow)$  # 终端提示符应该发生变化</span><br></pre></td></tr></table></figure>
<p>在 virtualenv 内, 安装 TensorFlow:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(tensorflow)$ pip install --upgrade &lt;$url_to_binary.whl&gt;</span><br></pre></td></tr></table></figure>
<p>接下来, 使用类似命令运行 TensorFlow 程序:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(tensorflow)$ cd tensorflow/models/image/mnist</span><br><span class="line">(tensorflow)$ python convolutional.py</span><br><span class="line"></span><br><span class="line"># 当使用完 TensorFlow</span><br><span class="line">(tensorflow)$ deactivate  # 停用 virtualenv</span><br><span class="line"></span><br><span class="line">$  # 你的命令提示符会恢复原样</span><br></pre></td></tr></table></figure>

<h2 id="运行-TensorFlow"><a href="#运行-TensorFlow" class="headerlink" title="运行 TensorFlow"></a>运行 TensorFlow</h2><p>打开一个 python 终端:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; import tensorflow as tf</span><br><span class="line">&gt;&gt;&gt; hello = tf.constant(&#x27;Hello, TensorFlow!&#x27;)</span><br><span class="line">&gt;&gt;&gt; sess = tf.Session()</span><br><span class="line">&gt;&gt;&gt; print sess.run(hello)</span><br><span class="line">Hello, TensorFlow!</span><br><span class="line">&gt;&gt;&gt; a = tf.constant(10)</span><br><span class="line">&gt;&gt;&gt; b = tf.constant(32)</span><br><span class="line">&gt;&gt;&gt; print sess.run(a+b)</span><br><span class="line">42</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ml</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tensorflow</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊「二叉搜索树」的那些事儿</title>
    <url>/2017-06-10-binary-search-tree/</url>
    <content><![CDATA[<p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 它的左、右子树也分别为二叉排序树。“中序遍历”可以让节点有序。</p>
<p><img src="/assets/images/tech/binary-search-tree.png" alt="binary search tree"></p>
<span id="more"></span>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>二叉排序树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉排序树的存储结构。中序遍历二叉排序树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉排序树变成一个有序序列，构造树的过程即为对无序序列进行排序的过程。每次插入的新的节点都是二叉排序树上新的叶子节点，在进行插入操作时，不必移动其它节点，只需改动某个节点的指针，由空变为非空即可。搜索，插入，删除的复杂度等于树高，O(log(n))。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="树节点"><a href="#树节点" class="headerlink" title="树节点"></a>树节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">/** 二叉树节点 */</span><br><span class="line">@interface DDBinaryTreeNode : NSObject</span><br><span class="line"></span><br><span class="line">/** 值 */</span><br><span class="line">@property (nonatomic, assign) NSInteger value;</span><br><span class="line">/** 左节点 */</span><br><span class="line">@property (nonatomic, strong) DDBinaryTreeNode *leftNode;</span><br><span class="line">/** 右节点 */</span><br><span class="line">@property (nonatomic, strong) DDBinaryTreeNode *rightNode;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>二叉排序树的创建无非就是不断查找和插入的过程，当我们查找某个值没有找到时，我们就会将该值插入到二叉排序树中。因为在查找的过程中可以确定该结点要插入的合适位置，所以插入就显得比较简单了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@class DDBinaryTreeNode;</span><br><span class="line"></span><br><span class="line">@interface DDBinarySearchTreeHandler : NSObject</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  创建二叉排序树</span><br><span class="line"> *  二叉排序树：左节点值全部小于根节点值，右节点值全部大于根节点值</span><br><span class="line"> *</span><br><span class="line"> *  @param values 数组</span><br><span class="line"> *</span><br><span class="line"> *  @return 二叉树根节点</span><br><span class="line"> */</span><br><span class="line">+ (DDBinaryTreeNode *)createTreeWithValues:(NSArray *)values;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  向二叉排序树节点添加一个节点</span><br><span class="line"> *</span><br><span class="line"> *  @param treeNode 根节点</span><br><span class="line"> *  @param value	值</span><br><span class="line"> *</span><br><span class="line"> *  @return 根节点</span><br><span class="line"> */</span><br><span class="line">+ (DDBinaryTreeNode *)addTreeNode:(DDBinaryTreeNode *)treeNode value:(NSInteger)value;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  二叉搜索树中某个值的节点</span><br><span class="line"> *</span><br><span class="line"> *  @param value	值</span><br><span class="line"> *  @param rootNode 树根节点</span><br><span class="line"> *</span><br><span class="line"> *  @return 节点</span><br><span class="line"> */</span><br><span class="line">+ (DDBinaryTreeNode *)searchTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (DDBinaryTreeNode *)createTreeWithValues:(NSArray *)values</span><br><span class="line">&#123;</span><br><span class="line">    DDBinaryTreeNode *root = nil;</span><br><span class="line">    for (NSInteger i = 0; i &lt; values.count; i++) &#123;</span><br><span class="line">        NSInteger value = [(NSNumber *)[values objectAtIndex:i] integerValue];</span><br><span class="line">        root = [DDBinarySearchTreeHandler addTreeNode:root value:value];</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>根据查找树的性质我们可以很简单的写出添加的代码，一个一个的比较，注意每插入的一个总是叶子节点。再进行调整。最终形成的效果图如下：</p>
<p><img src="/assets/images/tech/binary-search-tree-01.png" alt="添加节点"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (DDBinaryTreeNode *)addTreeNode:(DDBinaryTreeNode *)treeNode value:(NSInteger)value</span><br><span class="line">&#123;</span><br><span class="line">    if (!treeNode) &#123;</span><br><span class="line">        treeNode = [[DDBinaryTreeNode alloc] init];</span><br><span class="line">        treeNode.value = value;</span><br><span class="line">        NSLog(@&quot;node:%td&quot;, value);</span><br><span class="line">    &#125; else if (value &lt;= treeNode.value) &#123;</span><br><span class="line">        NSLog(@&quot;to left&quot;);</span><br><span class="line">        //值小于根节点，则插入到左子树</span><br><span class="line">        treeNode.leftNode = [DDBinarySearchTreeHandler addTreeNode:treeNode.leftNode value:value];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        NSLog(@&quot;to right&quot;);</span><br><span class="line">        //值大于根节点，则插入到右子树</span><br><span class="line">        treeNode.rightNode = [DDBinarySearchTreeHandler addTreeNode:treeNode.rightNode value:value];</span><br><span class="line">    &#125;</span><br><span class="line">    return treeNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (DDBinaryTreeNode *)searchTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode</span><br><span class="line">&#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (rootNode.value == value) &#123;</span><br><span class="line">        return rootNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (value &lt; rootNode.value) &#123;</span><br><span class="line">        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.leftNode];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.rightNode];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>对于树来说，删除是最复杂的，主要需要考虑4种情况：叶子节点，只有左子树，只有右子树和左右子树都有。</p>
<h4 id="叶子节点"><a href="#叶子节点" class="headerlink" title="叶子节点"></a>叶子节点</h4><p>删除的节点没有左子树也没有右子树，也就是删除的节点为叶子节点。这种情况下我们有可以细分为两类，一种是该叶子节点就是二叉排序树的根节点，也就是二叉排序树中只有一个节点的情况。只需要将root指针置为空即可。再一种情况是删除的叶子节点有父节点，直接将父节点连接该删除节点的指针置空即可。</p>
<h4 id="只有一个子节点"><a href="#只有一个子节点" class="headerlink" title="只有一个子节点"></a>只有一个子节点</h4><p>如果删除的节点有左子树那就把左子树顶上去，如果有右子树就把右子树顶上去即可。</p>
<p><img src="/assets/images/tech/binary-search-tree-03.png" alt="左子树节点"></p>
<h4 id="左右子树都有"><a href="#左右子树都有" class="headerlink" title="左右子树都有"></a>左右子树都有</h4><p>首先可以这么想象，如果我们要删除一个数组的元素，那么我们在删除后会将其后面的一个元素顶到被删除的位置。</p>
<p><img src="/assets/images/tech/binary-search-tree-04.png" alt="双孩子节点1"></p>
<p>那么二叉树操作同样也是一样，我们根据”中序遍历“找到要删除节点的后一个节点，然后顶上去就行了，原理跟”数组”一样一样的。</p>
<p><img src="/assets/images/tech/binary-search-tree-05.png" alt="双孩子节点2"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (void)deleteTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode</span><br><span class="line">&#123;</span><br><span class="line">    DDBinaryTreeNode *parent = rootNode;</span><br><span class="line">    DDBinaryTreeNode *current = rootNode;</span><br><span class="line">    // 记录被找到的节点是父节点的左子节点还是右子节点</span><br><span class="line">    BOOL isLeftChild = false;</span><br><span class="line">    // 循环直到找到目标节点的位置,否则返回</span><br><span class="line">    while (current.value != value) &#123;</span><br><span class="line">        parent = current;</span><br><span class="line">        if (current.value &gt; value) &#123;</span><br><span class="line">            isLeftChild = true;</span><br><span class="line">            current = current.leftNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            isLeftChild = false;</span><br><span class="line">            current = current.rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        if (current == nil) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果待删除的节点没有任何子节点</span><br><span class="line">    // 直接将该节点的原本指向该节点的指针设置为nil</span><br><span class="line">    if (current.leftNode == nil &amp;&amp; current.rightNode == nil) &#123;</span><br><span class="line">        if (current == rootNode) &#123;</span><br><span class="line">            rootNode = nil;</span><br><span class="line">        &#125;</span><br><span class="line">        if (isLeftChild == true) &#123;</span><br><span class="line">            parent.leftNode = nil;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parent.rightNode = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果待删除的节点有一个子节点,且其为左子节点</span><br><span class="line">    else if (current.rightNode == nil) &#123;</span><br><span class="line">        // 判断当前节点是否为根节点</span><br><span class="line">        if (current == rootNode) &#123;</span><br><span class="line">            rootNode = current.leftNode;</span><br><span class="line">        &#125; else if (isLeftChild) &#123;</span><br><span class="line">            // 挂载到父节点的左子树</span><br><span class="line">            parent.leftNode = current.leftNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 挂载到父节点的右子树</span><br><span class="line">            parent.rightNode = current.leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (current.leftNode == nil) &#123;</span><br><span class="line">        if (current == rootNode) &#123;</span><br><span class="line">            rootNode = current.rightNode;</span><br><span class="line">        &#125; else if (isLeftChild) &#123;</span><br><span class="line">            parent.leftNode = current.rightNode;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parent.rightNode = current.rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果待删除的节点有两个子节点</span><br><span class="line">    else if (current.leftNode != nil &amp;&amp; current.rightNode != nil) &#123;</span><br><span class="line">        // 寻找右子树中的最小值</span><br><span class="line">        DDBinaryTreeNode *successor = [DDBinarySearchTreeHandler successor:current];</span><br><span class="line">        if (current == rootNode) &#123;</span><br><span class="line">            rootNode = successor;</span><br><span class="line">        &#125; else if (isLeftChild) &#123;</span><br><span class="line">            parent.leftNode = successor;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            parent.rightNode = successor;</span><br><span class="line">        &#125;</span><br><span class="line">        successor.leftNode = current.leftNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 在树中查找最合适的节点</span><br><span class="line"> */</span><br><span class="line">+ (DDBinaryTreeNode *)successor:(DDBinaryTreeNode *)node &#123;</span><br><span class="line">    DDBinaryTreeNode *successsor = nil;</span><br><span class="line">    DDBinaryTreeNode *successsorParent = nil;</span><br><span class="line">    DDBinaryTreeNode *current = node.rightNode;</span><br><span class="line">    while (current != nil) &#123;</span><br><span class="line">        successsorParent = successsor;</span><br><span class="line">        successsor = current;</span><br><span class="line">        current = current.leftNode;</span><br><span class="line">    &#125;</span><br><span class="line">    if (successsor != node.rightNode) &#123;</span><br><span class="line">        successsorParent.leftNode = successsor.rightNode;</span><br><span class="line">        successsor.rightNode = node.rightNode;</span><br><span class="line">    &#125;</span><br><span class="line">    return successsor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>欢迎大家加入移动开发交流Q群交流讨论，Q群号：811237468</p>
<p><img src="/assets/images/Q811237468.jpg" alt="Q811237468"></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>objc</tag>
        <tag>tree</tag>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的那些使用</title>
    <url>/2017-06-13-binary-tree-guide/</url>
    <content><![CDATA[<p>在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支(不存在分支度大于2的节点)的树结构。通常分支被称作“左子树”和“右子树”。二叉树的分支具有左右次序，不能颠倒。</p>
<p>二叉树的第i层至多拥有 2^(i-1) 个节点数；深度为k的二叉树至多总共有 2^(k+1) - 1 个节点数，而总计拥有节点数匹配的，称为“满二叉树”；深度为k有n个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度k的满二叉树，序号为1到n的节点一对一对应时，称为“完全二叉树”。对任何一棵非空的二叉树T，如果其叶片(终端节点)数为n0，分支度为2的节点数为n2，则n0 &#x3D; n2 + 1。</p>
<p>与普通树不同，普通树的节点个数至少为1，而二叉树的节点个数可以为0；普通树节点的最大分支度没有限制，而二叉树节点的最大分支度为2；普通树的节点无左、右次序之分，而二叉树的节点有左、右次序之分。</p>
<span id="more"></span>

<p>二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉查找树和二元堆积，并应用于高效率的搜索和排序。</p>
<p>相对于普通二叉树，还有一些特殊二叉树，它们诞生于特殊的场景需求。例如，二叉搜索树就是因搜索需求而诞生的一种特殊的树。</p>
<p>具体可以参见<br><a href="/blog/binary-search-tree">《聊聊「二叉搜索树」的那些事儿》</a></p>
<p>本文初衷是因为Homebrew 的作者<a href="https://twitter.com/mxcl/status/608682016205344768">@Max Howell</a>的一条twitter</p>
<blockquote>
<p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.</p>
</blockquote>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="1-完全二叉树"><a href="#1-完全二叉树" class="headerlink" title="(1)完全二叉树"></a>(1)完全二叉树</h3><p>若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的节点数都达到最大个数，第h层有叶子节点，并且叶子节点都是从左到右依次排布，这就是完全二叉树。</p>
<h3 id="2-满二叉树"><a href="#2-满二叉树" class="headerlink" title="(2)满二叉树"></a>(2)满二叉树</h3><p>除了叶节点外每一个节点都有左右子叶且叶子节点都处在最底层的二叉树。</p>
<h3 id="3-平衡二叉树"><a href="#3-平衡二叉树" class="headerlink" title="(3)平衡二叉树"></a>(3)平衡二叉树</h3><p>平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><p>树的节点：包含一个数据元素及若干指向子树的分支。</p>
<p>孩子节点：节点的子树的根称为该节点的孩子。</p>
<p>双亲节点：B 节点是A 节点的孩子，则A节点是B 节点的双亲。</p>
<p>兄弟节点：同一双亲的孩子节点； </p>
<p>堂兄节点：同一层上节点。</p>
<p>祖先节点: 从根到该节点的所经分支上的所有节点。</p>
<p>子孙节点：以某节点为根的子树中任一节点都称为该节点的子孙。</p>
<p>节点层：根节点的层定义为1；根的孩子为第二层节点，依此类推。</p>
<p>树的深度：树中最大的节点层。</p>
<p>节点的度：节点子树的个数。</p>
<p>树的度： 树中最大的节点度。</p>
<p>叶子节点：也叫终端节点，是度为 0 的节点。</p>
<p>分支节点：度不为0的节点。</p>
<p>有序树：子树有序的树，如：家族树。</p>
<p>无序树：不考虑子树的顺序。</p>
<h2 id="树的结构"><a href="#树的结构" class="headerlink" title="树的结构"></a>树的结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">/** 二叉树节点 */</span><br><span class="line">@interface DDBinaryTreeNode : NSObject</span><br><span class="line"></span><br><span class="line">/** 值 */</span><br><span class="line">@property (nonatomic, assign) NSInteger value;</span><br><span class="line">/** 左节点 */</span><br><span class="line">@property (nonatomic, strong) DDBinaryTreeNode *leftNode;</span><br><span class="line">/** 右节点 */</span><br><span class="line">@property (nonatomic, strong) DDBinaryTreeNode *rightNode;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有节点，使每一个节点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个节点转换成为一个线性序列来表示。</p>
<p>设L、D、R分别表示遍历左子树、访问根节点和遍历右子树， 则对一棵二叉树的遍历有三种情况：DLR（称为先序遍历），LDR（称为中序遍历），LRD （称为后序遍历）。</p>
<h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (void)preOrderTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (handler) &#123;</span><br><span class="line">        handler(rootNode);</span><br><span class="line">    &#125;</span><br><span class="line">    [self preOrderTraverseTree:rootNode.leftNode handler:handler];</span><br><span class="line">    [self preOrderTraverseTree:rootNode.rightNode handler:handler];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (void)inOrderTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void (^)(DDBinaryTreeNode *treeNode))handler</span><br><span class="line">&#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [self inOrderTraverseTree:rootNode.leftNode handler:handler];</span><br><span class="line">    if (handler) &#123;</span><br><span class="line">        handler(rootNode);</span><br><span class="line">    &#125;</span><br><span class="line">    [self inOrderTraverseTree:rootNode.rightNode handler:handler];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (void)postOrderTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [self postOrderTraverseTree:rootNode.leftNode handler:handler];</span><br><span class="line">    [self postOrderTraverseTree:rootNode.rightNode handler:handler];</span><br><span class="line">    if (handler) &#123;</span><br><span class="line">        handler(rootNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="广度优先遍历-Breadth-First-Search"><a href="#广度优先遍历-Breadth-First-Search" class="headerlink" title="广度优先遍历(Breadth First Search)"></a>广度优先遍历(Breadth First Search)</h3><p>从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。<br>按照从上到下、从左到右的次序进行遍历。先遍历完一层，再遍历下一层。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (void)levelTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列</span><br><span class="line">    [queueArray addObject:rootNode]; //压入根节点</span><br><span class="line">    while (queueArray.count &gt; 0) &#123;</span><br><span class="line">        DDBinaryTreeNode *node = [queueArray firstObject];</span><br><span class="line">        if (handler) &#123;</span><br><span class="line">            handler(node);</span><br><span class="line">        &#125;</span><br><span class="line">        [queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先出原则</span><br><span class="line">        if (node.leftNode) &#123;</span><br><span class="line">            [queueArray addObject:node.leftNode]; //压入左节点</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.rightNode) &#123;</span><br><span class="line">            [queueArray addObject:node.rightNode]; //压入右节点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="深度优先遍历-Depth-First-Search"><a href="#深度优先遍历-Depth-First-Search" class="headerlink" title="深度优先遍历(Depth First Search)"></a>深度优先遍历(Depth First Search)</h3><p>DFS是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。<br>当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。<br>如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (void)depthTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler</span><br><span class="line">&#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (handler) &#123;</span><br><span class="line">        handler(rootNode);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [self depthTraverseTree:rootNode.leftNode handler:handler];</span><br><span class="line">    [self depthTraverseTree:rootNode.rightNode handler:handler];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树的翻转"><a href="#树的翻转" class="headerlink" title="树的翻转"></a>树的翻转</h2><p>翻转二叉树，又叫求二叉树的镜像，就是把二叉树的左右子树对调。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (DDBinaryTreeNode *)invertBinaryTree:(DDBinaryTreeNode *)rootNode &#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) &#123;</span><br><span class="line">        return rootNode;</span><br><span class="line">    &#125;</span><br><span class="line">    [self invertBinaryTree:rootNode.leftNode];</span><br><span class="line">    [self invertBinaryTree:rootNode.rightNode];</span><br><span class="line">    DDBinaryTreeNode *tempNode = rootNode.leftNode;</span><br><span class="line">    rootNode.leftNode = rootNode.rightNode;</span><br><span class="line">    rootNode.rightNode = tempNode;</span><br><span class="line">    return rootNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树的查找"><a href="#树的查找" class="headerlink" title="树的查找"></a>树的查找</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (DDBinaryTreeNode *)searchTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode</span><br><span class="line">&#123;</span><br><span class="line">    if (!rootNode) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (rootNode.value == value) &#123;</span><br><span class="line">        return rootNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (value &lt; rootNode.value) &#123;</span><br><span class="line">        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.leftNode];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.rightNode];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关链接：<br><a href="http://www.cocoachina.com/programmer/20151015/13687.html">《百度的校园招聘面试经历》</a></p>
<p><a href="http://blog.devtang.com/2015/06/16/talk-about-tech-interview/">《你会翻转二叉树吗》</a></p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>欢迎大家加入移动开发交流Q群交流讨论，Q群号：811237468</p>
<p><img src="/assets/images/Q811237468.jpg" alt="Q811237468"></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>objc</tag>
        <tag>tree</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>从iOS的图片圆角想到渲染</title>
    <url>/2017-07-03-ios-corner-radius/</url>
    <content><![CDATA[<p>圆角是一种很常见的视图效果，相比于直角，它更加柔和优美，易于接受。设置圆角会带来一定的性能损耗，如何提高性能是一个需要重点讨论的话题。</p>
<p>大家常见的圆角代码<code>x.layer.cornerRadius = xx; x.clipsToBounds = YES;</code>这两行确实实现了圆角视觉效果。其实使用<code>x.layer.cornerRadius = xx;</code>已经实现了圆角，只不过在某些控件是不生效的，因为某些图层在被切割圆角图层之上而被显示出来了。而<code>x.clipsToBounds = YES;</code>带来的后果就是产生<code>离屏渲染</code>。可以使用instruments中的CoreAnimation工具，打开<code>Color Offscren-Rednered Yellow</code>选项，可见黄色区域部分即是离屏渲染部分。</p>
<p>那么离屏渲染会带来什么？当然后资源损耗，可能产生卡顿。因为在iPhone设备的硬件资源有差异，当离屏渲染不多时，并不是很明显感觉到它的缺点。</p>
<span id="more"></span>

<h2 id="什么是像素"><a href="#什么是像素" class="headerlink" title="什么是像素"></a>什么是像素</h2><p>像素，为视频显示的基本单位，译自英文“pixel”，pix是英语单词picture的常用简写，加上英语单词“元素”element，就得到pixel，故“像素”表示“画像元素”之意，有时亦被称为pel（picture element）。每个这样的消息元素不是一个点或者一个方块，而是一个抽象的取样。像素是由红，绿，蓝三种颜色组件构成的。因此，位图数据有时也被叫做 RGB 数据。</p>
<h2 id="显示机制"><a href="#显示机制" class="headerlink" title="显示机制"></a>显示机制</h2><p>一个像素是如何绘制到屏幕上去的？有很多种方式将一些东西映射到显示屏上，他们需要调用不同的框架、许多功能和方法的结合体。这里我们大概看一下屏幕之后发生的事情。</p>
<p>图像想显示到屏幕上使人肉眼可见都需借助像素的力量。它们密集的排布在手机屏幕上，将任何图形通过不同的色值表现出来。计算机显示的流程大致可以描述为将图像转化为一系列像素点的排列然后打印在屏幕上，由图像转化为像素点的过程又可以称之为光栅化，就是从矢量的点线面的描述，变成像素的描述。</p>
<p><img src="/assets/images/tech/ios-corner-radius-display-screen.png" alt="display screen"></p>
<p>回溯历史，可以从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。</p>
<h3 id="关于卡顿的简单原理解释"><a href="#关于卡顿的简单原理解释" class="headerlink" title="关于卡顿的简单原理解释"></a>关于卡顿的简单原理解释</h3><p>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。</p>
<p>CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p>
<h2 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h2><p>当像素映射到屏幕上的时候，后台发生了很多事情。但一旦它们显示到屏幕上，每一个像素均由三个颜色组件构成：红，绿，蓝。三个独立的颜色单元会根据给定的颜色显示到一个像素上。在 iPhoneSE 的显示器上有1,136×640&#x3D;727,040个像素，因此有2,181,120个颜色单元。在一些Retina屏幕上，这一数字将达到百万以上。所有的图形堆栈一起工作以确保每次正确的显示。当你滚动整个屏幕的时候，数以百万计的颜色单元必须以每秒60次的速度刷新，这就是一个很大的工作量。</p>
<p>简单来说，iOS的显示机制大致如此：<br><img src="/assets/images/tech/ios-corner-radius-pixels-software-stack.png" alt="pixels software stack"></p>
<p>Display 的上一层便是图形处理单元 GPU，GPU 是一个专门为图形高并发计算而量身定做的处理单元。这也是为什么它能同时更新所有的像素，并呈现到显示器上。它的并发本性让它能高效的将不同纹理合成起来。所以，开发中我们应该尽量让CPU负责主线程的UI调动，把图形显示相关的工作交给GPU来处理。</p>
<p>GPU Driver 是直接和 GPU 交流的代码块。不同的GPU是不同的性能怪兽，但是驱动使它们在下一个层级上显示的更为统一，典型的下一层级有 OpenGL&#x2F;OpenGL ES.</p>
<p>OpenGL(Open Graphics Library) 是一个提供了 2D 和 3D 图形渲染的 API。GPU 是一块非常特殊的硬件，OpenGL 和 GPU 密切的工作以提高GPU的能力，并实现硬件加速渲染。</p>
<p>OpenGL 之上扩展出很多东西。在 iOS 上，几乎所有的东西都是通过 Core Animation 绘制出来，然而在 OS X 上，绕过 Core Animation 直接使用 Core Graphics 绘制的情况并不少见。对于一些专门的应用，尤其是游戏，程序可能直接和 OpenGL&#x2F;OpenGL ES 交流。</p>
<p>需要强调的是，GPU 是一个非常强大的图形硬件，并且在显示像素方面起着核心作用。它连接到 CPU。从硬件上讲两者之间存在某种类型的总线，并且有像 OpenGL，Core Animation 和 Core Graphics 这样的框架来在 GPU 和 CPU 之间精心安排数据的传输。为了将像素显示到屏幕上，一些处理将在 CPU 上进行。然后数据将会传送到 GPU，最终像素显示到屏幕上。</p>
<p><img src="/assets/images/tech/ios-corner-radius-pixels-hardware.png" alt="pixels hardware"></p>
<p>正如上图显示，GPU 需要将每一个 frame 的纹理(位图)合成在一起(一秒60次)。每一个纹理会占用 VRAM(video RAM)，所以需要给 GPU 同时保持纹理的数量做一个限制。GPU 在合成方面非常高效，但是某些合成任务却比其他更复杂，并且 GPU在 16.7ms(1&#x2F;60s)内能做的工作也是有限的。</p>
<p>另外一个问题就是将数据传输到 GPU 上。为了让 GPU 访问数据，需要将数据从 RAM 移动到 VRAM 上。这就是提及到的上传数据到 GPU。这些看起来貌似微不足道，但是一些大型的纹理却会非常耗时。</p>
<p>最终，CPU 开始运行程序。你可能会让 CPU 从 bundle 加载一张 PNG 的图片并且解压它。这所有的事情都在 CPU 上进行。然后当你需要显示解压缩后的图片时，它需要以某种方式上传到 GPU。一些看似平凡的，比如显示文本，对 CPU 来说却是一件非常复杂的事情，这会促使 Core Text 和 Core Graphics 框架更紧密的集成来根据文本生成一个位图。一旦准备好，它将会被作为一个纹理上传到 GPU 并准备显示出来。当你滚动或者在屏幕上移动文本时，同样的纹理能够被复用，CPU 只需简单的告诉 GPU 新的位置就行了,所以 GPU 就可以重用存在的纹理了。CPU 并不需要重新渲染文本，并且位图也不需要重新上传到 GPU。</p>
<p>在图形世界中，合成是一个描述不同位图如何放到一起来创建你最终在屏幕上看到图像的过程。屏幕上一切事物皆纹理。一个纹理就是一个包含 RGBA 值的长方形，比如，每一个像素里面都包含红、绿、蓝和透明度的值。在 Core Animation 世界中这就相当于一个 CALayer。</p>
<p>每一个 layer 是一个纹理，所有的纹理都以某种方式堆叠在彼此的顶部。对于屏幕上的每一个像素，GPU 需要算出怎么混合这些纹理来得到像素 RGB 的值。这就是合成。</p>
<p>如果我们所拥有的是一个和屏幕大小一样并且和屏幕像素对齐的单一纹理，那么屏幕上每一个像素相当于纹理中的一个像素，纹理的最后一个像素也就是屏幕的最后一个像素。</p>
<p>如果我们有第二个纹理放在第一个纹理之上，然后GPU将会把第二个纹理合成到第一个纹理中。有很多种不同的合成方法，但是如果我们假定两个纹理的像素对齐，并且使用正常的混合模式，我们便可以用公式来计算每一个像素：<code>R = S + D * ( 1 – Sa )</code><br>结果的颜色是源色彩(顶端纹理)+目标颜色(低一层的纹理)*(1-源颜色的透明度)。在这个公式中所有的颜色都假定已经预先乘以了它们的透明度。</p>
<p>接着我们进行第二个假定，两个纹理都完全不透明，比如 alpha&#x3D;1。如果目标纹理(低一层的纹理)是蓝色(RGB&#x3D;0,0,1)，并且源纹理(顶层的纹理)颜色是红色(RGB&#x3D;1,0,0)，因为 Sa 为1，所以结果为：<code>R = S</code><br>结果是源颜色的红色。这正是我们所期待的(红色覆盖了蓝色)。如果源颜色层为50%的透明，比如 alpha&#x3D;0.5，既然 alpha 组成部分需要预先乘进 RGB 的值中，那么 S 的 RGB 值为(0.5, 0, 0)，公式看起来便会像这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                       0.5   0               0.5</span><br><span class="line">R = S + D * (1 - Sa) = 0   + 0 * (1 - 0.5) = 0</span><br><span class="line">                       0     1               0.5</span><br></pre></td></tr></table></figure>

<p>我们最终得到RGB值为(0.5, 0, 0.5),是一个紫色。这正是我们所期望将透明红色合成到蓝色背景上所得到的。</p>
<p>记住我们刚刚只是将纹理中的一个像素合成到另一个纹理的像素上。当两个纹理覆盖在一起的时候，GPU需要为所有像素做这种操作。正如你所知道的一样，许多程序都有很多层，因此所有的纹理都需要合成到一起。尽管GPU是一块高度优化的硬件来做这种事情，但这还是会让它非常忙碌。</p>
<h3 id="为何图片缩放会增加GPU工作量"><a href="#为何图片缩放会增加GPU工作量" class="headerlink" title="为何图片缩放会增加GPU工作量"></a>为何图片缩放会增加GPU工作量</h3><p>当所有的像素是对齐的时候我们得到相对简单的计算公式。每当 GPU 需要计算出屏幕上一个像素是什么颜色的时候，它只需要考虑在这个像素之上的所有 layer 中对应的单个像素，并把这些像素合并到一起。或者，如果最顶层的纹理是不透明的(即图层树的最底层)，这时候 GPU 就可以简单的拷贝它的像素到屏幕上。</p>
<p>当一个 layer 上所有的像素和屏幕上的像素完美的对应整齐，那这个 layer 就是像素对齐的。主要有两个原因可能会造成不对齐。第一个便是滚动，当一个纹理上下滚动的时候，纹理的像素便不会和屏幕的像素排列对齐。另一个原因便是当纹理的起点不在一个像素的边界上。</p>
<p>在这两种情况下，GPU 需要再做额外的计算。它需要将源纹理上多个像素混合起来，生成一个用来合成的值。当所有的像素都是对齐的时候，GPU 只剩下很少的工作要做。</p>
<p>Core Animation 工具和模拟器有一个<code>Color Misaligned Images </code>选项，当这些在你的 CALayer 实例中发生的时候，这个功能便可向你展示。</p>
<p>关于iOS设备的一些尺寸限制可以看这里：<a href="http://iosres.com/">iOSRes</a></p>
<h2 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h2><p>On-Screen Rendering意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。<br>Off-Screen Rendering意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</p>
<p>当图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制时，屏幕外渲染就被唤起了。屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。</p>
<p>离屏渲染可以被 Core Animation 自动触发，或者被应用程序强制触发。屏幕外的渲染会合并&#x2F;渲染图层树的一部分到一个新的缓冲区，然后该缓冲区被渲染到屏幕上。</p>
<h3 id="特殊的“离屏渲染”：CPU渲染"><a href="#特殊的“离屏渲染”：CPU渲染" class="headerlink" title="特殊的“离屏渲染”：CPU渲染"></a>特殊的“离屏渲染”：CPU渲染</h3><p>如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。<br>整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。</p>
<h3 id="离屏渲染的体现"><a href="#离屏渲染的体现" class="headerlink" title="离屏渲染的体现"></a>离屏渲染的体现</h3><p>相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：</p>
<ul>
<li>1 创建新缓冲区<br>要想进行离屏渲染，首先要创建一个新的缓冲区。</li>
<li>2 上下文切换<br>离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。</li>
</ul>
<h3 id="触发离屏渲染"><a href="#触发离屏渲染" class="headerlink" title="触发离屏渲染"></a>触发离屏渲染</h3><p>1、drawRect<br>2、layer.shouldRasterize &#x3D; true;<br>3、有mask或者是阴影(layer.masksToBounds, layer.shadow*)；<br> 3.1) shouldRasterize（光栅化）<br> 3.2) masks（遮罩）<br> 3.3) shadows（阴影）<br> 3.4) edge antialiasing（抗锯齿）<br> 3.5) group opacity（不透明）<br>4、Text（UILabel, CATextLayer, Core Text, etc）…<br>注：layer.cornerRadius，layer.borderWidth，layer.borderColor并不会Offscreen Render，因为这些不需要加入Mask。</p>
<h2 id="圆角优化"><a href="#圆角优化" class="headerlink" title="圆角优化"></a>圆角优化</h2><p>前面说了那么多，这里就给上实际可行方案。圆角的优化目前考虑两方面：一是，从图片入手，将图片切割成指定圆角样式。二是，使用贝塞尔曲线，利用CALayer层绘制指定圆角样式的mask遮盖View。</p>
<p>UIImage切割：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);</span><br><span class="line">CGContextScaleCTM(context, 1, -1);</span><br><span class="line">CGContextTranslateCTM(context, 0, -rect.size.height);</span><br><span class="line"></span><br><span class="line">CGFloat minSize = MIN(self.size.width, self.size.height);</span><br><span class="line">if (borderWidth &lt; minSize / 2.0) &#123;</span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectInset(rect, borderWidth, borderWidth) byRoundingCorners:corners cornerRadii:CGSizeMake(radius, borderWidth)];</span><br><span class="line">    CGContextSaveGState(context);</span><br><span class="line">    [path addClip];</span><br><span class="line">    CGContextDrawImage(context, rect, self.CGImage);</span><br><span class="line">    CGContextRestoreGState(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">image = [image dd_imageByCornerRadius:radius borderedColor:borderColor borderWidth:borderWidth corners:corners];</span><br><span class="line">UIGraphicsEndImageContext();</span><br></pre></td></tr></table></figure>

<p>图片绘制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);</span><br><span class="line">[self drawAtPoint:CGPointZero];</span><br><span class="line">CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);</span><br><span class="line">CGFloat strokeInset = borderWidth / 2.0;</span><br><span class="line">CGRect strokeRect = CGRectInset(rect, strokeInset, strokeInset);</span><br><span class="line">UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:strokeRect byRoundingCorners:corners cornerRadii:CGSizeMake(radius, borderWidth)];</span><br><span class="line">path.lineWidth = borderWidth;</span><br><span class="line">[borderColor setStroke];</span><br><span class="line">[path stroke];</span><br><span class="line">UIImage *result = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br></pre></td></tr></table></figure>

<p>具体源码可以转至github进行star <a href="https://github.com/charsdavy/DDCornerRadius">DDCornerRadius</a> 欢迎issue。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>objc</tag>
        <tag>ios</tag>
        <tag>ui</tag>
        <tag>优化</tag>
        <tag>渲染</tag>
      </tags>
  </entry>
  <entry>
    <title>那些设计iOS API需要知道的事</title>
    <url>/2017-07-09-ios-design-api-guide/</url>
    <content><![CDATA[<p>为了能够将我们项目中的代码能够在后续开发者使用（重用代码），通常使用的方法是将代码按照功能模块编写成API。那么我们就很有必要了解Objective-C语言中常见的编程范式（paradigm），同时还需了解各种可能碰到的陷阱。</p>
<span id="more"></span>

<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h3 id="命名冲突的问题"><a href="#命名冲突的问题" class="headerlink" title="命名冲突的问题"></a>命名冲突的问题</h3><p>Objective-C没有其他语言的那种内置命名空间（namespace）机制。因此，我们只能自己想办法来解决命名冲突问题。最常用的解决方式就是，仿照其他语言（C++）建立自己的namespace，例如，使用前缀。</p>
<p>所选前缀可以是与公司、应用程序或二者皆有关联之名。例如，ZAKER User Interface可以使用ZUI作为前缀。使用Cocoa创建应用程序时一定要注意，Apple宣称其保留使用所有“两字母前缀”(two-letter prefix)的权利，所以开发者选用的前缀应该是三个字母的。如果开发者使用了两个字母作前缀，那么很有可能开发者自定义的API和Apple的API冲突。</p>
<p>不仅仅是类名，应用程序中的所有名称都应该加前缀。如果要为既有类新增“分类”(category)，那么一定要给“分类”及“分类”中的方法加上前缀。另外，类的实现文件中所用的纯C函数及全局变量也应该注意添加前缀。</p>
<p>如果使用了第三方库编写自己的代码，并准备将其发布为程序库供他人开发应用程序所用，则尤其要注意重复符号问题。这种情况下为了避免使用者使用了与你相同的第三方库，应该为第三方库都加上你自己的前缀。</p>
<p><img src="/assets/images/tech/ios-design-api-guide-1.png" alt="第三方库引入使用前缀"></p>
<h3 id="命名方式"><a href="#命名方式" class="headerlink" title="命名方式"></a>命名方式</h3><p>类、方法和变量的命名是Objective-C编程的重要环节。如果命名方式好，可以提高代码可读性，减少不必要的注释。<br>初学者通常会觉得Objective-C是门很繁琐的语言，因为其语法结构使得代码读起来和句子一样。命名中一般都带有“in”、“for”、“with”等介词，特别是在命名时还要讲究英文语法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *text = @&quot;This is a good idea.&quot;;</span><br><span class="line">NSString *newText = [text stringByReplacingOccurrencesOfString:@&quot;idea&quot; withString:@&quot;think&quot;];</span><br></pre></td></tr></table></figure>

<p>上面的代码虽然用了比较啰嗦的方式描述一个看上去很简单的表达式。对于执行替换的那个方法，代码读起来就像日常语言里的那个句子：“Take text and give me a new string by replacing the occurrences of the string ‘idea’ with the string ‘think’”。<br>这个句子准确描述了开发者想做的事。在命名不像Objective-C这般繁琐的语言中，类似的程序可能会写成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string text = &quot;This is a good idea.&quot;;</span><br><span class="line">string new Text = text.replace(&quot;idea&quot;, &quot;think&quot;);</span><br></pre></td></tr></table></figure>

<p>上面代码这样写，看起来方法名简洁很多，但是带来的代码不可读性却是非常大的。首先，我们不知道 text.replace 方法的两个参数到底按照什么顺序解读（除非查看方法声明）；再者，这两个参数谁替换谁？</p>
<p>另外，和大多数语言一样，Objective-C也是采用“驼峰式大小写命名法”（camel casing）——以小写字母开头，其后每个单词首字母大写。</p>
<h4 id="方法命名"><a href="#方法命名" class="headerlink" title="方法命名"></a>方法命名</h4><p>清晰的方法名从左至右读起来好似一段文章。并不是说非得按照那些命名规则来给方法起名，不过这样做可以令代码变得更好维护，使他人更容易读懂。<br>虽然类似C++或Java中那种函数命名简单，但是，若想知道每个参数的用途，就得查看函数原型，这会令代码难于读懂。<br>NSString这个类展示了一套良好的命名习惯。下面列举几个方法及命名缘由：</p>
<p>1）<code>+ (instancetype)string;</code><br>工厂方法（factory method），用于创建新的空字符串。方法名清晰地描述了返回值的类型。</p>
<p>2）<code>+ (instancetype)stringWithString:(NSString *)string;</code><br>工厂方法，根据某字符串创建出与之内容相同的新字符串。与创建空字符串所用的那个工厂方法一样，方法名的第一个单词也指明了返回类型。</p>
<p>3）<code>+ (instancetype)localizedStringWithFormat:(NSString *)format, ...;</code><br>工厂方法，根据特定格式创建出新的“本地化字符串”（localized string）。返回值类型是方法名的第二个单词（string），因为其前面还有个修饰语（localized）用来描述其逻辑含义。此方法的返回值依然是“字符串”（string），只不过是一种经过本地化处理的特殊字符串。</p>
<p>4）<code>- (NSUInteger)lengthOfBytesUsingEncoding:(NSStringEncoding)enc;</code><br>若字符串是以给定的编码格式（ASCII、UTF8、UTF16）来编码的，则返回其字节数组长度。此方法与length相似，但该方法还需一个参数，该参数紧跟着方法名中描述其类型的那个名词（encoding）。</p>
<p>因此，我们可以总结成几条方法命名规则：</p>
<p>1）如果方法的返回值是新创建的，那么方法名的首个词应该是返回值的类型，除非前面还有修饰语，例如localizedString。属性的存取方法不遵循这种命名方式，因为一般认为这些方法不会创建新对象。即便有时返回内部对象的一份拷贝，我们也认为那相当于原有对象。这些存取方法应该按照其所对应的属性来命名。</p>
<p>2）应该把表示参数类型的名词放在参数前面。</p>
<p>3）如果方法要在当前对象上执行操作，那么就应该包含动词；若执行操作时还需要参数，则应该在动词后面加上一个或多个名词。</p>
<p>4）不要使用str这种简称，应该使用string这样的全称。</p>
<p>5）boolean属性应加is前缀。如果某方法返回非属性的boolean值，那么应该根据其功能，选用has或is当前缀。</p>
<p>6）将get这个前缀留给那些借由“输出参数”来保存返回值的方法，比如说，把返回值填充到“C语言式数组”（C-style array）里的那种方法就可以使用这个词做前缀。</p>
<h4 id="类与协议命名"><a href="#类与协议命名" class="headerlink" title="类与协议命名"></a>类与协议命名</h4><p>不仅仅是方法，类和协议也应该加上前缀，避免命名空间冲突。例如：</p>
<ul>
<li>UIView</li>
<li>UIViewController</li>
<li>UITableViewDelegate</li>
</ul>
<h2 id="错误模型"><a href="#错误模型" class="headerlink" title="错误模型"></a>错误模型</h2><p>目前有很多编程语言都有“异常”(exception)机制，Objective-C也不例外。</p>
<p>“自动引用计数”(ARC, Automatic Reference Counting)在默认情况下不是“异常安全的”。这意味着：如果抛出异常，那么本应该在作用域末尾释放的对象现在却不会自动释放了。如果想生成“异常安全”的代码，可以通过设置编译器的标志来实现，不过这将引入额外代码，在不抛出异常时，也照样要执行这部分代码。需要打开的编译器标志叫做<code>-fobjc-arc-exception</code>。</p>
<p>Objective-C现在所采用的办法是：只在极其罕见的情况下抛出异常，异常抛出之后，无须考虑恢复问题，而且应用程序此时也应该退出。这就是说，不用再编写复杂的“异常安全”代码了。</p>
<p>异常只应该用于极其严重的错误，比如，你编写了某个抽象基类，它的正确用法是先从中继承一个子类，然后使用这个子类。在这种情况下，如果有人直接使用了这个抽象基类，那么可以考虑抛出异常。与其他语言不同，Objective-C中没办法将某个类标识为“抽象类”。要想达成类似效果，最好的办法是在那些子类必须覆写的超类方法里抛出异常。</p>
<p>异常只用于处理严重错误(fatal error)，对于其他错误，Objective-C语言所用的编程范式为：令方法返回nil&#x2F;0，或使用NSError，以表明有错误发生。</p>
<p>NSError对象里封装了三条信息：</p>
<ul>
<li>Error domain (错误范围，其类型为字符串)</li>
</ul>
<p>错误发生的范围，也就是产生错误的根源，通常用一个特有的全局变量来定义。例如，URL-handling-subsystem，在从URL中解析或获取数据时如果出错了，那么就使用NSURLErrorDomain来表示错误范围。</p>
<ul>
<li>Error code (错误码，其类型为整数)</li>
</ul>
<p>独有的错误码，用以指明在某个范围内具体发生了何种错误。某个特定范围内可能会发生一系列相关错误，这些错误情况通常采用enum来定义。</p>
<ul>
<li>User info (用户信息，其类型为字典)</li>
</ul>
<p>有关此错误的额外信息，其中或许包含一段“本地化描述”，或许还包含有导致该错误发生的另外一个错误，经由此种信息，可将相关错误串成一条“错误链”。</p>
<h2 id="使用不可变对象"><a href="#使用不可变对象" class="headerlink" title="使用不可变对象"></a>使用不可变对象</h2><p>设计类的时候，应充分使用属性来封装数据。而在使用属性时，则可将其声明为<code>readonly</code>。默认情况下，属性是<code>readwrite</code>。</p>
<p>因为如果把可变对象(mutable object)放入collection之后又修改其内容，那么很容易就会破坏set的内部数据结构，使其失去固有的语义。故此，我们应该尽量减少对象中的可变内容。具体到编程实践中，则应该尽量把对外公布出来的属性设为<code>readonly</code>，而且只在有必要时才将属性对外公布。</p>
<p>定义类的公共API时，需要注意，对象里表示各种collection的那些属性究竟应该设成可变的，还是不可变的。如果某个属性可以为外界所增删，那么这个属性就需要用可变的set来实现。在这种情况下，通常应该提供一个readonly属性供外界使用，该属性将返回不可变的set，而此set则是内部那个可变set的一份拷贝。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  ZKRPointOfInterest.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ZKRPointOfInterest : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy, readonly) NSString *identifier;</span><br><span class="line">@property (nonatomic, copy, readonly) NSString *title;</span><br><span class="line">@property (nonatomic, assign, readonly) CGFloat latitude;</span><br><span class="line">@property (nonatomic, assign, readonly) CGFloat longitude;</span><br><span class="line">@property (nonatomic, strong, readonly) NSSet *locations;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithIdentifier:(NSString *)identifier</span><br><span class="line">                             title:(NSString *)title</span><br><span class="line">                          latitude:(CGFloat)latitude</span><br><span class="line">                         longitude:(CGFloat)longitude;</span><br><span class="line"></span><br><span class="line">- (void)addLocation:(ZKRPointOfInterest *)location;</span><br><span class="line">- (void)removeLocation:(ZKRPointOfInterest *)location;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  ZKRPointOfInterest.m</span><br><span class="line"></span><br><span class="line">#import &quot;ZKRPointOfInterest.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZKRPointOfInterest</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableSet *_internalLocations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithIdentifier:(NSString *)identifier</span><br><span class="line">                             title:(NSString *)title</span><br><span class="line">                          latitude:(CGFloat)latitude</span><br><span class="line">                         longitude:(CGFloat)longitude</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSSet *)locations</span><br><span class="line">&#123;</span><br><span class="line">    return [_internalLocations copy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addLocation:(ZKRPointOfInterest *)location</span><br><span class="line">&#123;</span><br><span class="line">    if (location) &#123;</span><br><span class="line">        [_internalLocations addObject:location];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeLocation:(ZKRPointOfInterest *)location</span><br><span class="line">&#123;</span><br><span class="line">    [_internalLocations removeObject:location];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>不要在返回的对象上查询类型以确定其是否可变。(即使不用<code>isKindOfClass:</code>方法来判断返回值类型是否可变)</p>
<h2 id="description方法"><a href="#description方法" class="headerlink" title="description方法"></a>description方法</h2><p>在调试程序时，经常需要打印并查看对象信息。一种办法是编写代码把对象的全部属性都log到日志中。<code>NSLog(@&quot;object=%@&quot;, object);</code></p>
<p>在构建需要打印到日志的字符串时，object对象会收到description消息，该方法所返回的描述信息将取代“格式字符串”(format string)里的“%@”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSArray *obj = @[@&quot;A string&quot;, @(123)];</span><br><span class="line">NSLog(@&quot;object=%@&quot;, obj);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object=(</span><br><span class="line">	&quot;A string&quot;,</span><br><span class="line">	123</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果在自定义类上这么做，那么则输出的信息却是如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object=&lt;ZKRSqure: 0x7656d8a90060&gt;</span><br></pre></td></tr></table></figure>

<p>如果想要像上面NSArray那样打印出有用的信息，那么我们就应该在自己的类中覆写description方法，否则打印信息时就会调用NSObject类所实现的默认方法。此方法定义在NSObject协议里，不过NSObject类也实现了它。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (NSString *)description</span><br><span class="line">&#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;&lt;%@: %p, \&quot;%f %f\&quot;&gt;&quot;, [self class], self, _width, _height];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ZKRRectangle *rectangle = [[ZKRRectangle alloc] initWithWidth:5.0 height:7.0];</span><br><span class="line">NSLog(@&quot;%@&quot;, rectangle);</span><br><span class="line"></span><br><span class="line">//Output</span><br><span class="line">&lt;ZKRRectangle: 0x60000002fc20, &quot;5.000000 7.000000&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>NSObject协议中还有个需要注意的方法，就是<code>debugDescription</code>，此方法用意与<code>description</code>相似。二者区别在于，<code>debugDescription</code>方法是开发者在调试器(debugger)中以控制台命令打印对象时才调用的。在NSObject类的默认实现中，它只是直接调用<code>description</code>。</p>
<h2 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h2><p>所有对象均要初始化，在初始化时，有些对象可能无须开发者向其提供额外信息，不过一般来说还是需要提供的。通常情况下，对象若不知道必要的信息，则无法完成其工作。例如，UITAbleViewCell类初始化该类对象时，需要指明其样式及标识符，标识符能够区分不同类型的单元格。由于这种对象的创建成本较高，所以绘制表格时可依照标识符来复用，以提升程序效率。这种可为对象提供必要信息以便其能完成工作的初始化方法叫做“全能初始化方法”(designated initializer)。</p>
<p>如果创建类实例的方式不止一种，那么这个类就会有多个初始化方法。但是，我们仍然需要选定一个作为全能初始化方法，令其他初始化方法都来调用它。例如，NSDate类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (instancetype)init NS_DESIGNATED_INITIALIZER;</span><br><span class="line">- (instancetype)initWithTimeIntervalSinceReferenceDate:(NSTimeInterval)ti NS_DESIGNATED_INITIALIZER;</span><br><span class="line">- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;</span><br><span class="line">- (instancetype)initWithTimeIntervalSinceNow:(NSTimeInterval)secs;</span><br><span class="line">- (instancetype)initWithTimeIntervalSince1970:(NSTimeInterval)secs;</span><br><span class="line">- (instancetype)initWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date;</span><br></pre></td></tr></table></figure>

<p>在上面几个初始化方法中，<code>initWithTimeIntervalSinceReferenceDate:</code>是全能初始化方法。只有在全能初始化方法中，才会存储内部数据。这样的话，当底层数据存储机制改变时，只需修改此方法的代码就好，无须改动其他初始化方法。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  ZKRRectangle.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface ZKRRectangle : NSObject&lt;NSCopying&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign, readonly) CGFloat width;</span><br><span class="line">@property (nonatomic, assign, readonly) CGFloat height;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  ZKRRectangle.m</span><br><span class="line"></span><br><span class="line">#import &quot;ZKRRectangle.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZKRRectangle</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _width = [[aDecoder decodeObjectForKey:@&quot;width&quot;] floatValue];</span><br><span class="line">        _height = [[aDecoder decodeObjectForKey:@&quot;height&quot;] floatValue];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithWidth:height: instad.&quot; userInfo:nil];</span><br><span class="line">    </span><br><span class="line">    return [self initWithWidth:0 height:0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _width = width;</span><br><span class="line">        _height = height;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  ZKRSquare.h</span><br><span class="line"></span><br><span class="line">#import &quot;ZKRRectangle.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ZKRSquare : ZKRRectangle</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithDimension:(CGFloat)dimension;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//  ZKRSquare.m</span><br><span class="line"></span><br><span class="line">#import &quot;ZKRSquare.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZKRSquare</span><br><span class="line"></span><br><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithDimension: instad.&quot; userInfo:nil];</span><br><span class="line">    </span><br><span class="line">    return [self initWithDimension:0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithDimension:(CGFloat)dimension</span><br><span class="line">&#123;</span><br><span class="line">    return [super initWithWidth:dimension height:dimension];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height</span><br><span class="line">&#123;</span><br><span class="line">    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithDimension: instad.&quot; userInfo:nil];</span><br><span class="line">    CGFloat dimension = MIN(width, height);</span><br><span class="line">    return [self initWithDimension:dimension];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均调用此方法。</li>
<li>若全能方法于超类不同，则需要覆写超类中的对应方法。</li>
<li>如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。</li>
</ul>
<h2 id="NSCopying协议"><a href="#NSCopying协议" class="headerlink" title="NSCopying协议"></a>NSCopying协议</h2><p>使用对象时经常需要拷贝它。在Objective-C中，此操作通过copy方法完成。如果想令自己的类支持拷贝操作，那就要实现NSCopying协议，该协议只有一个方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (id)copyWithZone:(nullable NSZone *)zone;</span><br></pre></td></tr></table></figure>

<p>为什么会出现NSZone呢？因为以前开发程序时，会据此把内容分成不同的“区”(zone)，而对象会创建在某个区里面。现在不用了，每个程序只有一个区：“默认区”(default zone)。所以说，尽管必须实现这个方法，但是你不必担心其中的zone参数。</p>
<p>copy方法由NSObject实现，该方法只是以“默认区”为参数来调用<code>copyWithZone:</code>。我们总是想覆写copy方法，其实真正需要实现的是<code>copyWithZone:</code>方法。若想使某个类支持拷贝功能，只需声明该类遵从NSCopying协议，并实现其中的那个方法即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (id)copyWithZone:(NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    ZKRRectangle *copy = [[[self class] allocWithZone:zone] initWithWidth:_width height:_height];</span><br><span class="line">    return copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说到copy方法，除了NSString这样的不可变类型的copy，与之类似的还有NSMutableString类的<code>mutableCopy</code>方法。与<code>copyWithZone:</code>方法相对应的可变内容的copy方法<code>mutableCopyWithZone:</code>方法来自于<code>NSMutableCopying</code>协议。如果你的类分为可变版本(mutable)与不可变版本(immutable)，那么就应该实现NSMutableCopying协议。若采用此模式，则在可变类中覆写<code>copyWithZone:</code>方法时，不要返回可变的拷贝，而应该返回一份不可变的版本。无论当前实例是否可变，需要获取其可变版本的拷贝，均应调用mutableCopy方法；获取不可变版本的拷贝，则总应该通过copy方法。</p>
<p><img src="/assets/images/tech/ios-design-api-guide-2.png" alt="mutableCopy和copy类"></p>
<p>深拷贝就是在拷贝对象自身时，将其底层数据也一并复制过去。<br>浅拷贝就是在拷贝对象时，只拷贝容器对象本身，而不复制其中数据。</p>
<p><img src="/assets/images/tech/ios-design-api-guide-3.png" alt="深拷贝和浅拷贝比较"></p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>objc</tag>
        <tag>ios</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS App 启动性能优化</title>
    <url>/2017-09-22-ios-app-launch-time-optimize/</url>
    <content><![CDATA[<p>应用启动时间，直接影响用户对一款应用的判断和使用体验。<code>ZAKER新闻</code>本身就包含非常多并且复杂度高的业务模块（如新闻、视频等），也接入了很多第三方的插件，这势必会拖慢应用的启动时间，本着精益求精的态度和对用户体验的追求，我们希望在业务扩张的同时最大程度的优化启动时间。</p>
<span id="more"></span>

<h2 id="启动时间"><a href="#启动时间" class="headerlink" title="启动时间"></a>启动时间</h2><p>总时间 &#x3D; T1 + T2</p>
<h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>加载<code>系统dylib</code>和<code>可执行文件</code>的时间。</p>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>从<code>main</code>到<code>applicationWillFinishLaunching</code>结束的时间。</p>
<h2 id="App启动过程"><a href="#App启动过程" class="headerlink" title="App启动过程"></a>App启动过程</h2><p><img src="/assets/images/tech/ios-app-launch-time-optimize-1.png" alt="App启动过程"></p>
<p>1）解析<code>Info.plist</code></p>
<ul>
<li>加载相关信息，例如如闪屏</li>
<li>沙箱建立、权限检查</li>
</ul>
<p>2）<code>Mach-O</code>加载</p>
<ul>
<li>如果是胖二进制文件，寻找合适当前CPU类别的部分</li>
<li>加载所有依赖的<code>Mach-O</code>文件（递归调用<code>Mach-O</code>加载的方法）</li>
<li>定位内部、外部指针引用，例如字符串、函数等</li>
<li>执行声明为<code>__attribute__((constructor))</code>的C函数</li>
<li>加载类扩展（Category）中的方法</li>
<li>C++静态对象加载、调用ObjC的<code>+load</code>函数</li>
</ul>
<p>3）程序执行</p>
<ul>
<li>调用<code>main()</code></li>
<li>调用<code>UIApplicationMain()</code></li>
<li>调用<code>applicationWillFinishLaunching</code></li>
</ul>
<h3 id="Mach-O"><a href="#Mach-O" class="headerlink" title="Mach-O"></a>Mach-O</h3><p>Mach-O 是针对不同运行时可执行文件的文件类型。</p>
<p><img src="/assets/images/tech/ios-app-launch-time-optimize-4.png" alt="Mach-O"></p>
<h4 id="文件类型："><a href="#文件类型：" class="headerlink" title="文件类型："></a>文件类型：</h4><p>Executable： 应用的主要二进制</p>
<p>Dylib： 动态链接库（又称 DSO 或 DLL）</p>
<p>Bundle： 不能被链接的 Dylib，只能在运行时使用 dlopen() 加载，可当做 macOS 的插件。</p>
<p>Image： executable，dylib 或 bundle</p>
<p>Framework： 包含 Dylib 以及资源文件和头文件的文件夹</p>
<h3 id="Mach-O-镜像文件"><a href="#Mach-O-镜像文件" class="headerlink" title="Mach-O 镜像文件"></a>Mach-O 镜像文件</h3><p>Mach-O 被划分成一些 segement，每个 segement 又被划分成一些 section。</p>
<p>segment 的名字都是大写的，且空间大小为页的整数。页的大小跟硬件有关，在 arm64 架构一页是 16KB，其余为 4KB。</p>
<p>section 虽然没有整数倍页大小的限制，但是 section 之间不会有重叠。</p>
<p>几乎所有 Mach-O 都包含这三个段（segment）： <code>__TEXT</code>,<code>__DATA</code> 和 <code>__LINKEDIT</code>：</p>
<ul>
<li><p><code>__TEXT</code> 包含 Mach header，被执行的代码和只读常量（如C 字符串）。只读可执行（r-x）。</p>
</li>
<li><p><code>__DATA</code> 包含全局变量，静态变量等。可读写（rw-）。</p>
</li>
<li><p><code>__LINKEDIT</code> 包含了加载程序的『元数据』，比如函数的名称和地址。只读（r–）。</p>
</li>
</ul>
<h3 id="Mach-O-Universal-文件"><a href="#Mach-O-Universal-文件" class="headerlink" title="Mach-O Universal 文件"></a>Mach-O Universal 文件</h3><p><a href="https://en.wikipedia.org/wiki/Fat_binary">FAT 二进制</a>文件，将多种架构的 Mach-O 文件合并而成。它通过 Fat Header 来记录不同架构在文件中的偏移量，Fat Header 占一页的空间。</p>
<p>按分页来存储这些 segement 和 header 会浪费空间，但这有利于虚拟内存的实现。</p>
<h3 id="什么是image"><a href="#什么是image" class="headerlink" title="什么是image"></a>什么是image</h3><p>1.executable可执行文件 比如.o文件。 </p>
<p>2.dylib 动态链接库 framework就是动态链接库和相应资源包含在一起的一个文件夹结构。 </p>
<p>3.bundle 资源文件 只能用dlopen加载，不推荐使用这种方式加载。</p>
<p>除了我们App本身的可行性文件，系统中所有的framework比如UIKit、Foundation等都是以动态链接库的方式集成进App中的。</p>
<h3 id="什么是ImageLoader"><a href="#什么是ImageLoader" class="headerlink" title="什么是ImageLoader"></a>什么是ImageLoader</h3><p>image 表示一个二进制文件(可执行文件或 so 文件)，里面是被编译过的符号、代码等，所以 ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。 </p>
<p>两步走：在程序运行时它先将动态链接的 image 递归加载 (也就是上面测试栈中一串的递归调用的时刻)。 再从可执行文件 image 递归加载所有符号。</p>
<h2 id="冷启动和热启动"><a href="#冷启动和热启动" class="headerlink" title="冷启动和热启动"></a>冷启动和热启动</h2><h3 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h3><p>应用首次启动。即后台线程中未有当前打开的应用，所有的资源都需要加载并初始化。</p>
<h3 id="热启动"><a href="#热启动" class="headerlink" title="热启动"></a>热启动</h3><p>应用非首次启动。即后台线程中保留有当前应用，应用的资源在内存中有保存。</p>
<h2 id="启动时间分析"><a href="#启动时间分析" class="headerlink" title="启动时间分析"></a>启动时间分析</h2><p>1）开启时间分析功能</p>
<p>在Xcode的菜单中选择<code>Project</code>→<code>Scheme</code>→<code>Edit Scheme...</code>，然后找到<code> Run</code> → <code>Environment Variables</code> →<code>+</code>，添加<code>name</code>为<code>DYLD_PRINT_STATISTICS</code> <code>value</code>为<code>1</code>的环境变量。</p>
<p><img src="/assets/images/tech/ios-app-launch-time-optimize-2.png" alt="开启时间分析功能"></p>
<p><img src="/assets/images/tech/ios-app-launch-time-optimize-3.png" alt="启动时间"></p>
<h3 id="load-dylibs-image"><a href="#load-dylibs-image" class="headerlink" title="load dylibs image"></a>load dylibs image</h3><p>在每个动态库的加载过程中， dyld需要：</p>
<p>1.分析所依赖的动态库</p>
<p>2.找到动态库的mach-o文件</p>
<p>3.打开文件</p>
<p>4.验证文件</p>
<p>5.在系统核心注册文件签名</p>
<p>6.对动态库的每一个segment调用mmap()</p>
<p>通常的，一个App需要加载100到400个dylibs， 但是其中的系统库被优化，可以很快的加载。 针对这一步骤的优化有：</p>
<p>1.减少非系统库的依赖</p>
<p>2.合并非系统库</p>
<p>3.使用静态资源，比如把代码加入主程序</p>
<h3 id="rebase-x2F-bind"><a href="#rebase-x2F-bind" class="headerlink" title="rebase&#x2F;bind"></a>rebase&#x2F;bind</h3><p>由于ASLR(address space layout randomization)的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这2步来修复镜像中的资源指针，来指向正确的地址。 rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。 </p>
<p>rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。</p>
<p>优化该阶段的关键在于减少__DATA segment中的指针数量。我们可以优化的点有：</p>
<p>1.减少Objc类数量， 减少selector数量</p>
<p>2.减少C++虚函数数量</p>
<p>3.转而使用swift stuct（其实本质上就是为了减少符号的数量）</p>
<h3 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h3><ul>
<li><code>main()</code>函数之前总共使用了506.48ms</li>
<li>在506.48ms中，加载动态库用了46.35ms，指针重定位使用了137.72ms，ObjC类初始化使用了95.39ms，各种初始化使用了226.92ms。</li>
<li>在初始化耗费的226.92ms中，用时最多的几个初始化是<code>libSystem.B.dylib</code>、<code>libBacktraceRecording.dylib</code>、<code>libglInterpose.dylib</code>以及<code>libMTLInterpose.dylib</code>。</li>
</ul>
<p>2）使用instruments工作分析具体时间消耗点</p>
<h2 id="耗时的影响因素"><a href="#耗时的影响因素" class="headerlink" title="耗时的影响因素"></a>耗时的影响因素</h2><p>1） <code>main()</code>函数之前耗时的影响因素</p>
<ul>
<li>动态库加载越多，启动越慢。</li>
<li>ObjC类越多，启动越慢</li>
<li>C的<code>constructor</code>函数越多，启动越慢</li>
<li>C++静态对象越多，启动越慢</li>
<li>ObjC的<code>+load</code>越多，启动越慢</li>
</ul>
<p>实验证明，在ObjC类的数目一样多的情况下，需要加载的动态库越多，App启动就越慢。同样的，在动态库一样多的情况下，ObjC的类越多，App的启动也越慢。需要加载的动态库从1个上升到10个的时候，用户几乎感知不到任何分别，但从10个上升到100个的时候就会变得十分明显。同理，100个类和1000个类，可能也很难查察觉得出，但1000个类和10000个类的分别就开始明显起来。</p>
<p>同样的，尽量不要写<code>__attribute__((constructor))</code>的C函数，也尽量不要用到C++的静态对象；至于ObjC的<code>+load</code>方法，似乎大家已经习惯不用它了。任何情况下，能用<code>dispatch_once()</code>来完成的，就尽量不要用到以上的方法。</p>
<p>2） <code>main()</code>函数之后耗时的影响因素</p>
<p>从<code>main()</code>函数开始至<code>applicationWillFinishLaunching</code>结束，我们统一称为<code>main()</code>函数之后的部分。</p>
<ul>
<li>执行<code>main()</code>函数的耗时</li>
<li>执行<code>applicationWillFinishLaunching</code>的耗时</li>
<li><code>rootViewController</code>及其<code>childViewController</code>的加载、<code>view</code>及其<code>subviews</code>的加载</li>
</ul>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="移除不需要用到的类"><a href="#移除不需要用到的类" class="headerlink" title="移除不需要用到的类"></a>移除不需要用到的类</h3><p>为了解决这个历史问题，我使用了一个叫做<a href="https://github.com/dblock/fui">fui（Find Unused Imports）</a>的开源项目，它能很好的分析出不再使用的类，准确率非常高，唯一的问题是它处理不了动态库和静态库里提供的类，也处理不了C++的类模板。</p>
<p>使用方法是在<code>Terminal</code>中<code>cd</code>到项目所在的目录，然后执行<code>fui find</code>，然后等上那么几分钟（是的你没有看错，真的需要好几分钟甚至需要更长的时间），就可以得到一个列表了。由于这个工具还不是100%靠谱，可根据这个列表，在Xcode中手动检查并删除不再用到的类。</p>
<h3 id="移除不再使用的图片资源"><a href="#移除不再使用的图片资源" class="headerlink" title="移除不再使用的图片资源"></a>移除不再使用的图片资源</h3><p>通过 <a href="https://github.com/tinymind/LSUnusedResources">LSUnusedResources</a> 工具，扫描出项目中不再使用的图片资源。</p>
<h3 id="合并功能类似的类和扩展（Category）"><a href="#合并功能类似的类和扩展（Category）" class="headerlink" title="合并功能类似的类和扩展（Category）"></a>合并功能类似的类和扩展（Category）</h3><h3 id="优化application-didFinishLaunchingWithOptions-方法"><a href="#优化application-didFinishLaunchingWithOptions-方法" class="headerlink" title="优化application:didFinishLaunchingWithOptions:方法"></a>优化<code>application:didFinishLaunchingWithOptions:</code>方法</h3><h3 id="优化rootViewController加载"><a href="#优化rootViewController加载" class="headerlink" title="优化rootViewController加载"></a>优化<code>rootViewController</code>加载</h3><h3 id="瘦身-APP"><a href="#瘦身-APP" class="headerlink" title="瘦身 APP"></a>瘦身 APP</h3><h4 id="静态库瘦身"><a href="#静态库瘦身" class="headerlink" title="静态库瘦身"></a>静态库瘦身</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">example 1: </span><br><span class="line">lipo -info libWeChatSDK.a </span><br><span class="line"><span class="comment"># 瘦身静态库支持 arm64 指令集</span></span><br><span class="line">lipo libWeChatSDK.a -thin arm64 -output libWeChatSDK-arm64.a</span><br><span class="line">lipo libWeChatSDK.a -thin armv7s -output libWeChatSDK-armv7s.a</span><br><span class="line"><span class="comment"># 合并</span></span><br><span class="line">lipo -create libWeChatSDK-armv7s.a libWeChatSDK-arm64.a -output libWeChatSDK-device.a</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">example 2:</span><br><span class="line">lipo -info libBaiduMobStat.a</span><br><span class="line"><span class="comment"># 移除特定指令集</span></span><br><span class="line">lipo libBaiduMobStat.a -remove armv7s -output libBaiduMobStat-thin.a </span><br></pre></td></tr></table></figure>

<h4 id="设定-Xcode-配置"><a href="#设定-Xcode-配置" class="headerlink" title="设定 Xcode 配置"></a>设定 Xcode 配置</h4><ul>
<li><p>Build Settings-&gt;Optimization Leve Release 版应该选择Fastest, Smalllest</p>
</li>
<li><p>开启 BitCode</p>
</li>
<li><p>Build Settings-&gt;Valid Architectures中<br>删除 armv7(iphone 4s,3gs),armv7s(iphone 5)</p>
</li>
<li><p>Build Settings-&gt;Strip Linked Product &#x2F; Deployment Postprocessing &#x2F; Symbols Hidden by Default<br>在 Release 版本设为 YES</p>
</li>
<li><p>Build Settings（Levels选项内）-&gt;Genetate Debug Symbols<br>在 Release 版本设为 NO</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARMv6：ARM11内核用于iPhone2G和iPhone3G中的架构</span><br><span class="line">ARMv7：modern ARM内核用于iPhone3GS和iPhone4/S中的架构</span><br><span class="line">ARMv7s：A6内核用于iPhone5中的架构</span><br><span class="line">ARM64：A7内核用于iPhone5S/C中的架构</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1）<code>NSUserDefaults</code>是否是瓶颈</p>
<p>2）还有其他哪些点可以做优化</p>
<p>参考文档：<a href="http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/">《优化 App 的启动时间》</a></p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>优化</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS 搭建 Tensorflow PyCharm 环境</title>
    <url>/2017-09-26-tensorflow-pycharm-mac/</url>
    <content><![CDATA[<p>TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。目前来说，<a href="https://github.com/tensorflow/tensorflow">Github</a>上star最多的项目就是它了。</p>
<p>在这之前，笔者写过一篇简单的入门文章<a href="/blog/tensorflow-primer-guide/">《初探 TensorFlow》</a>。当时没能成功搭建环境，加上后期的工作原因，至此搁置了一段时间。今天，终于各种折腾，在自己的Mac上经过多种尝试之后，完美搭建成功。这里就把它分享出来，希望对大家有所帮助。</p>
<span id="more"></span>

<h2 id="基于-Anaconda-的安装"><a href="#基于-Anaconda-的安装" class="headerlink" title="基于 Anaconda 的安装"></a>基于 Anaconda 的安装</h2><p><a href="https://www.anaconda.com/">Anaconda</a> 是一个集成许多第三方科学计算库的 <code>Python</code> 科学计算环境,<code>Anaconda</code> 使用 <code>conda</code> 作为自己的包管理工具,同时具有自己的计算环境,类似 <code>Virtualenv</code>.</p>
<p>和 <code>Virtualenv</code> 一样,不同 <code>Python</code> 工程需要的依赖包,<code>conda</code> 将他们存储在不同的地方。 <code>TensorFlow</code> 上安装的 <code>Anaconda</code> 不会对之前安装的 <code>Python</code> 包进行覆盖.</p>
<ul>
<li>安装 <a href="https://www.anaconda.com/download/">Anaconda</a></li>
<li>建立一个 <code>conda</code> 计算环境</li>
<li>激活环境,使用 <code>conda</code> 安装 <code>TensorFlow</code></li>
<li>安装成功后,每次使用 <code>TensorFlow</code> 的时候需要激活 <code>conda</code> 环境</li>
</ul>
<h3 id="安装-Anaconda"><a href="#安装-Anaconda" class="headerlink" title="安装 Anaconda :"></a>安装 Anaconda :</h3><p>参考 Anaconda 的下载页面的<a href="https://www.anaconda.com/download/">指导</a></p>
<h3 id="建立环境"><a href="#建立环境" class="headerlink" title="建立环境"></a>建立环境</h3><p>建立一个 conda 计算环境名字叫<code>tensorflow</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Python 2.7</span><br><span class="line">$ conda create -n tensorflow python=2.7</span><br><span class="line"></span><br><span class="line"># Python 3.4</span><br><span class="line">$ conda create -n tensorflow python=3.4</span><br></pre></td></tr></table></figure>

<h3 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h3><p>激活<code>tensorflow</code>环境,然后使用其中的 <code>pip</code> 安装 <code>TensorFlow</code>. 当使用<code>easy_install</code>使用<code>--ignore-installed</code>标记防止错误的产生。</p>
<p><a href="https://www.tensorflow.org/install/install_mac#the_url_of_the_tensorflow_python_package">URL of the TensorFlow Python package</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ source activate tensorflow</span><br><span class="line">(tensorflow)$  # Your prompt should change</span><br><span class="line"></span><br><span class="line"># Ubuntu/Linux 64-bit, CPU only, Python 2.7:</span><br><span class="line">(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl</span><br><span class="line"></span><br><span class="line"># Ubuntu/Linux 64-bit, GPU enabled, Python 2.7. Requires CUDA toolkit 7.5 and CuDNN v4.</span><br><span class="line"># For other versions, see &quot;Install from sources&quot; below.</span><br><span class="line">(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl</span><br><span class="line"></span><br><span class="line"># Mac OS X, CPU only:</span><br><span class="line">(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-0.11.0rc0-py2-none-any.whl</span><br></pre></td></tr></table></figure>

<p>对于 Python 3.x :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ source activate tensorflow</span><br><span class="line">(tensorflow)$  # Your prompt should change</span><br><span class="line"></span><br><span class="line"># Ubuntu/Linux 64-bit, CPU only, Python 3.4:</span><br><span class="line">(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl</span><br><span class="line"></span><br><span class="line"># Ubuntu/Linux 64-bit, GPU enabled, Python 3.4. Requires CUDA toolkit 7.5 and CuDNN v4.</span><br><span class="line"># For other versions, see &quot;Install from sources&quot; below.</span><br><span class="line">(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl</span><br><span class="line"></span><br><span class="line"># Mac OS X, CPU only:</span><br><span class="line">(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0rc0-py3-none-any.whl</span><br></pre></td></tr></table></figure>

<p>conda 环境激活后,你可以测试:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt; import tensorflow as tf</span><br><span class="line">&gt;&gt;&gt; print(tf.__version__)</span><br><span class="line"># 0.11.0rc0</span><br></pre></td></tr></table></figure>

<h3 id="开启或关闭环境"><a href="#开启或关闭环境" class="headerlink" title="开启或关闭环境"></a>开启或关闭环境</h3><p>当你不用 TensorFlow 的时候,关闭环境:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(tensorflow)$ source deactivate</span><br><span class="line"></span><br><span class="line">$  # Your prompt should change back</span><br></pre></td></tr></table></figure>

<p>再次使用的时候再激活 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ source activate tensorflow</span><br><span class="line">(tensorflow)$  # Your prompt should change.</span><br><span class="line"># Run Python programs that use TensorFlow.</span><br><span class="line">...</span><br><span class="line"># When you are done using TensorFlow, deactivate the environment.</span><br><span class="line">(tensorflow)$ source deactivate</span><br></pre></td></tr></table></figure>

<h2 id="PyCharm-配置"><a href="#PyCharm-配置" class="headerlink" title="PyCharm 配置"></a>PyCharm 配置</h2><p><strong>重点：</strong>正确配置<code>Project</code>的<code>Interpreter</code>即可</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>Preferences</li>
<li>Project Interpreter</li>
<li>Click More</li>
</ul>
<h3 id="附图"><a href="#附图" class="headerlink" title="附图"></a>附图</h3><ul>
<li>打开Preferences</li>
</ul>
<p><img src="/assets/images/tech/tensorflow_pycharm_config_mac_1.png" alt="打开Preferences"></p>
<p><img src="/assets/images/tech/tensorflow_pycharm_config_mac_2.png" alt="选择more"></p>
<ul>
<li>打开Project Interpreters</li>
</ul>
<p><img src="/assets/images/tech/tensorflow_pycharm_config_mac_3.png" alt="选择正确的tensorflow路径"></p>
<ul>
<li>Demo运行结果</li>
</ul>
<p><img src="/assets/images/tech/tensorflow_pycharm_config_mac_4.png" alt="demo运行结果"></p>
]]></content>
      <categories>
        <category>ml</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tensorflow</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊 iOS 数据保护</title>
    <url>/2017-10-17-ios-data-protection/</url>
    <content><![CDATA[<p>文件系统中的文件、keychain中的项，都是加密存储的。当用户解锁设备后，系统通过UDID密钥和用户设定的密码生成一个用于解密的密码密钥，存放在内存中，直到设备再次被锁，开发者可以通过Data Protection API 来设定文件系统中的文件、keychain中的项应该何时被解密。这个就是数据保护的内容。</p>
<span id="more"></span>

<h2 id="钥匙串（keychain）"><a href="#钥匙串（keychain）" class="headerlink" title="钥匙串（keychain）"></a>钥匙串（keychain）</h2><p>keychain服务提供了一种安全的保存私密信息（密码，序列号，私钥，证书等）的方式，每个iOS程序都有一个独立的keychain存储。相对于NSUserDefaults、文件保存等一般方式，keychain保存更为安全，而且keychain里保存的信息不会因APP被删除而丢失。</p>
<p>基于钥匙串的特点，我们在使用时对于新增的数据项目，要注意数据删除的时机。还有一点需要注意的就是，保护属性的指定。如果没有指定保护属性，这将被视为严重的安全漏洞。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><p>当我们备份设备数据时，系统会将用户数据保存在相应的钥匙串中，并依照相应的安全策略保存。主要分成两类：<strong>加密</strong>和<strong>不加密</strong>。</p>
<p>两者的主要区别在于恢复数据时的范围不同。加密备份的数据可以恢复到任何设备上（ThisDeviceOnly指定的项目除外），而不加密的备份则只能恢复至同一台设备。</p>
<h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p>keychain支持在多个应用之间共享数据。但现实开发中<code>UIPasteboardNameFind</code>的使用代替了keychain。不过好在Apple在iOS11中已经废弃它。看来Apple想规范开发者对于用户敏感数据的共享使用，同时提醒大家使用更加安全的方式存储用户敏感数据。</p>
<h3 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h3><h4 id="SecItemAdd"><a href="#SecItemAdd" class="headerlink" title="SecItemAdd"></a>SecItemAdd</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSMutableDictionary *dict = [NSMutableDictionary dictionary];</span><br><span class="line">NSData *passwordData = [@&quot;myPassword&quot; dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];</span><br><span class="line">[dict setObject:@&quot;Conglomco&quot; forKey:(__bridge id)kSecAttrLabel];</span><br><span class="line">[dict setObject:@&quot;This is your password for the Conglomco service.&quot; forKey:(__bridge id)kSecAttrDescription];</span><br><span class="line">[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];</span><br><span class="line">[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];</span><br><span class="line">[dict setObject:passwordData forKey:(__bridge id)kSecValueData];</span><br><span class="line">[dict setObject:(__bridge id)kSecAttrAccessibleWhenUnlocked forKey:(__bridge id)kSecAttrAccessible];</span><br><span class="line"></span><br><span class="line">OSStatus error = SecItemAdd((__bridge CFDictionaryRef)dict, NULL);</span><br><span class="line">if (error == errSecSuccess) &#123;</span><br><span class="line">    NSLog(@&quot;Yay&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SecItemDelete"><a href="#SecItemDelete" class="headerlink" title="SecItemDelete"></a>SecItemDelete</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSMutableDictionary *dict = [NSMutableDictionary dictionary];</span><br><span class="line"></span><br><span class="line">[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];</span><br><span class="line">[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];</span><br><span class="line">[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];</span><br><span class="line"></span><br><span class="line">OSStatus error = SecItemDelete((__bridge CFDictionaryRef)dict);</span><br><span class="line">if (error == errSecSuccess) &#123;</span><br><span class="line">	NSLog(@&quot;Yay&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SecItemUpdate"><a href="#SecItemUpdate" class="headerlink" title="SecItemUpdate"></a>SecItemUpdate</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSMutableDictionary *dict = [NSMutableDictionary dictionary];</span><br><span class="line">NSData *newPasswordData = [@&quot;newMyPassword&quot; dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];</span><br><span class="line">[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];</span><br><span class="line">[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];</span><br><span class="line"></span><br><span class="line">NSDictionary *updatedAttribute = [NSDictionary dictionaryWithObject:newPasswordData forKey:(__bridge id)kSecValueData];</span><br><span class="line"></span><br><span class="line">OSStatus error = SecItemUpdate((__bridge CFDictionaryRef)dict, (__bridge CFDictionaryRef)updatedAttribute);</span><br><span class="line">if (error == errSecSuccess) &#123;</span><br><span class="line">	NSLog(@&quot;Yay&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SecItemCopyMatching"><a href="#SecItemCopyMatching" class="headerlink" title="SecItemCopyMatching"></a>SecItemCopyMatching</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSMutableDictionary *dict = [NSMutableDictionary dictionary];</span><br><span class="line"></span><br><span class="line">[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];</span><br><span class="line">[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];</span><br><span class="line">[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];</span><br><span class="line">[dict setObject:(id)kCFBooleanTrue forKey:(__bridge id)kSecReturnAttributes];</span><br><span class="line"></span><br><span class="line">NSDictionary *result = nil;</span><br><span class="line">OSStatus error = SecItemCopyMatching((__bridge CFDictionaryRef)dict, (void *)&amp;result);</span><br><span class="line">if (error == errSecSuccess) &#123;</span><br><span class="line">	NSLog(@&quot;Yay %@&quot;, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SecItemAdd</td>
<td>添加数据</td>
</tr>
<tr>
<td>SecItemDelete</td>
<td>删除数据</td>
</tr>
<tr>
<td>SecItemUpdate</td>
<td>修改数据</td>
</tr>
<tr>
<td>SecItemCopyMatching</td>
<td>查找数据</td>
</tr>
</tbody></table>
<h3 id="保护属性"><a href="#保护属性" class="headerlink" title="保护属性"></a>保护属性</h3><table>
<thead>
<tr>
<th>钥匙串保护属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>kSecAttrAccessibleAfterFirstUnlock</td>
<td>开机之后密钥不可用，直到用户首次输入密码</td>
</tr>
<tr>
<td>kSecAttrAccessibleAlways</td>
<td>密钥在设备开机后依旧可用。在iOS9中已经废弃</td>
</tr>
<tr>
<td>kSecAttrAccessibleAlwaysThisDeviceOnly</td>
<td>密钥始终可用，但无法迁移到其他设备</td>
</tr>
<tr>
<td>kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly</td>
<td>作用同上</td>
</tr>
<tr>
<td>kSecAttrAccessibleWhenUnlocked</td>
<td>只要解锁过设备，则密钥保持可用状态</td>
</tr>
<tr>
<td>kSecAttrAccessibleWhenUnlockedThisDeviceOnly</td>
<td>作用同上</td>
</tr>
<tr>
<td>kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly</td>
<td>作用同上，只有用户设置密码密钥才可用</td>
</tr>
</tbody></table>
<p><code>kSecAttrAccessibleAlways</code> 将会引入一个很明显的安全问题，因为此种保护属性，只要有人窃取了你的设备，他们就能读取钥匙串的内容。</p>
<p><code>kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly</code> 这个属性可以完美的解决上述的安全问题。因为越狱时通常需要重启设备。</p>
<p><code>kSecAttrAccessibleWhenUnlocked</code> 这个属性要求攻击者必须知道用户密码才能提取隐私数据。它很适合做默认属性值。</p>
<p><code>kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly</code> 是iOS8新增的保护属性。这个属性要求在使用时用户设定了密码，否则使用就失败。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><table>
<thead>
<tr>
<th>项目类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>kSecClassGenericPassword</td>
<td>普通密码</td>
</tr>
<tr>
<td>kSecClassInternetPassword</td>
<td>专门用于互联网服务的密码</td>
</tr>
<tr>
<td>kSecClassCertificate</td>
<td>加密证书</td>
</tr>
<tr>
<td>kSecClassKey</td>
<td>加密密钥</td>
</tr>
<tr>
<td>kSecClassIdentity</td>
<td>一个密钥对（包括公共证书和私钥）</td>
</tr>
</tbody></table>
<h3 id="iCloud同步"><a href="#iCloud同步" class="headerlink" title="iCloud同步"></a>iCloud同步</h3><p>这是iOS7引入的一种新机制，可以把钥匙串项目同步到iCloud，允许用户在多个设备之间共享钥匙串项目。</p>
<p>默认情况下，应用程序创建的钥匙串项目会禁用这个机制，但可以把<code>kSecAttrSynchronizable</code>设置为<code>true</code>来启用。</p>
<p>另外请注意，使用此选项时无法指定不兼容的kSecAttrAccessible属性。例如，指定kSecAttrAccessibleWhenUnlockedThisDeviceOnly不起作用，因为ThisDeviceOnly指定的项目不会备份，也不能同步到iCloud、笔记本电脑、台式机或其他同步位置。</p>
<h2 id="数据保护"><a href="#数据保护" class="headerlink" title="数据保护"></a>数据保护</h2><p>Apple 推出了数据保护API作为额外的保护层，它允许开发者指定文件解密密钥的生命周期。可以使用这个API控制文件的访问权限，与钥匙串项目中的kSecAttrAccessible 属性类似。</p>
<p>数据保护API使用用户密码和层级密钥来加密保护文件的密钥，而当这些文件不能被访问时，会从内存中删除这个层级密钥。</p>
<h3 id="文件保护过程"><a href="#文件保护过程" class="headerlink" title="文件保护过程"></a>文件保护过程</h3><p><img src="/assets/images/tech/ios_data_protection_2.png" alt="文件保护过程"></p>
<p>1.文件生成一个<code>文件密钥</code>来加密文件的内容。</p>
<p>2.生成一个额外的密钥对，用于生成<code>文件公钥</code>和<code>文件私钥</code>。</p>
<p>3.用<code>文件私钥</code>和<code>Protected Unless Open等级公钥</code>计算出一个<code>共享密码</code>。</p>
<p>4.用<code>共享密码</code> SHA-1散列值加密文件密钥。</p>
<p>5.加密过的<code>文件密钥</code>会存储在文件的元数据中，元数据中还有文件的公钥。</p>
<p>6.系统丢弃<code>文件私钥</code>。</p>
<p>7.关闭文件时从内存中删除未加密的文件密钥。</p>
<p>8.需要再次打开文件时，用<code>Protected Unless Open等级私钥</code>和<code>文件公钥</code>计算<code>共享密码</code>。</p>
<p>9.计算<code>共享密码</code>的SHA-1散列值，把它当作解密文件的密钥。</p>
<h3 id="DataProtectionClass-权限"><a href="#DataProtectionClass-权限" class="headerlink" title="DataProtectionClass 权限"></a>DataProtectionClass 权限</h3><p>如果你的应用在设备进入后台或锁定时不需要写入或读取文件，那你就可以在工程中配置一个<code>NSFileProtectionComplete</code>值来添加权限。这将确保所有受保护的文件数据只能在设备解锁时访问，相当于为所有的应用文件都设置<code>kSecAttrAccessibleWhenUnlocked</code>选项。</p>
<p>从Xcode5开始，新工程会默认启用数据保护权限，但是一些旧工程并不会自动开启。</p>
<p>开启方式如下图：</p>
<p><img src="/assets/images/tech/ios_data_protection_1.png" alt="开启DataProtectionClass权限"></p>
<h3 id="使用范例-1"><a href="#使用范例-1" class="headerlink" title="使用范例"></a>使用范例</h3><h4 id="NSDataWritingFileProtectionComplete"><a href="#NSDataWritingFileProtectionComplete" class="headerlink" title="NSDataWritingFileProtectionComplete"></a>NSDataWritingFileProtectionComplete</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSData *data = [self generateData];</span><br><span class="line">NSError *error = nil;</span><br><span class="line">NSString *path = [NSString stringWithFormat:@&quot;%@_demo.pdf&quot;, NSTemporaryDirectory()];</span><br><span class="line">[data writeToFile:path options:NSDataWritingFileProtectionComplete error:&amp;error];</span><br><span class="line">if (error) &#123;</span><br><span class="line">	NSLog(@&quot;%@&quot;, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="NSFileProtectionComplete"><a href="#NSFileProtectionComplete" class="headerlink" title="NSFileProtectionComplete"></a>NSFileProtectionComplete</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@&quot;demo.txt&quot;];</span><br><span class="line">NSError *error = nil;</span><br><span class="line">NSDictionary *attr = [NSDictionary dictionaryWithObject:NSFileProtectionComplete forKey:NSFileProtectionKey];</span><br><span class="line">[[NSFileManager defaultManager] setAttributes:attr ofItemAtPath:path error:&amp;error];</span><br><span class="line">if (error) &#123;</span><br><span class="line">	NSLog(@&quot;%@&quot;, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SQLITE-OPEN-FILEPROTECTION-COMPLETEUNLESSOPEN"><a href="#SQLITE-OPEN-FILEPROTECTION-COMPLETEUNLESSOPEN" class="headerlink" title="SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN"></a>SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@&quot;demo.sqlite&quot;];</span><br><span class="line">sqlite3 *handle = NULL;</span><br><span class="line">sqlite3_open_v2([path UTF8String],</span><br><span class="line">                &amp;handle,</span><br><span class="line">                SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE | SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN,</span><br><span class="line">                NULL);</span><br></pre></td></tr></table></figure>

<h3 id="保护等级"><a href="#保护等级" class="headerlink" title="保护等级"></a>保护等级</h3><h4 id="CompleteUntilFirstUserAuthentication"><a href="#CompleteUntilFirstUserAuthentication" class="headerlink" title="CompleteUntilFirstUserAuthentication"></a>CompleteUntilFirstUserAuthentication</h4><p>这个保护等级是iOS5开始使用的默认值。主要用来防御一些需要重启的攻击。</p>
<h4 id="Complete"><a href="#Complete" class="headerlink" title="Complete"></a>Complete</h4><p>官方称这是目前最安全的文件保护等级。在这种情况下，锁屏之后系统就会删除内存中的层级密钥，并把文件改为不可读。</p>
<p>具体使用的范例前文可见。</p>
<p>使用Complete保护之前，考虑是否合适。如果你的应用进程需要持续写&#x2F;读一个文件，那这种保护模式就不合适了。</p>
<h4 id="CompleteUnlessOpen"><a href="#CompleteUnlessOpen" class="headerlink" title="CompleteUnlessOpen"></a>CompleteUnlessOpen</h4><p>如果一个文件当前被一个应用打开，那会暂时禁用该文件的保护。它会确保打开的文件在设备被锁定时依然能够写入，并且允许新建文件到磁盘。不过这个等级保护的文件在锁屏时无法打开，除非锁屏时就已经提前打开。</p>
<h2 id="CommonCrypto加密"><a href="#CommonCrypto加密" class="headerlink" title="CommonCrypto加密"></a>CommonCrypto加密</h2><p>CommonCrypto是Apple官方提供的一套加密框架。在使用这套方案时，主要注意以下几个问题即可。</p>
<h3 id="避免弱算法"><a href="#避免弱算法" class="headerlink" title="避免弱算法"></a>避免弱算法</h3><p>众所周知，DES就是一种很典型的弱算法。如果你使用弱算法，那应用就很容易遭受密码攻击和暴力破解。</p>
<p>我们在实际使用时，可以考虑使用AES算法、MD5算法或MD5加盐算法等。</p>
<h3 id="破碎的熵"><a href="#破碎的熵" class="headerlink" title="破碎的熵"></a>破碎的熵</h3><p>我们通常会使用<code>rand</code>方法来产生随机数，但是系统的这个随机函数并不是真正的随机。它产生的随机数符合正态分布，我们可以使用官方提供的方法<code>SecRandomCopyBytes</code>获得。也可以自己使用算法产生随机数。</p>
<p>这里分享一个笔者以前自己实现的随机数案例。<a href="/blog/uniform-random/">《均匀分布随机函数的实现》</a></p>
<h3 id="弱密钥"><a href="#弱密钥" class="headerlink" title="弱密钥"></a>弱密钥</h3><p>开发者经常将用户的密码当作加密密钥，尤其在移动设备上，这将导致一个非常脆弱、低熵加密的密钥。</p>
<p>那么正确的姿势是使用<code>CCKeyDerivationPBKDF</code>方法来生成。</p>
<h2 id="Touch-ID"><a href="#Touch-ID" class="headerlink" title="Touch ID"></a>Touch ID</h2><h3 id="使用范例-2"><a href="#使用范例-2" class="headerlink" title="使用范例"></a>使用范例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;LocalAuthentication/LocalAuthentication.h&gt;</span><br><span class="line"></span><br><span class="line">LAContext *context = [[LAContext alloc] init];</span><br><span class="line">NSError *error = nil;</span><br><span class="line">NSString *reason = @&quot;We use this to verify your identify&quot;;</span><br><span class="line">if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;error]) &#123;</span><br><span class="line">	[context evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:reason reply:^(BOOL success, NSError * _Nullable error) &#123;</span><br><span class="line">		if (success) &#123;</span><br><span class="line">			NSLog(@&quot;Hello, that&#x27;s your finger!&quot;);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			NSLog(@&quot;Couldn&#x27;t read your fingerprint. Falling back to PIN or somthing.&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	NSLog(@&quot;Error : %@ %@&quot;, error, [error userInfo]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Touch-ID-与普通密码相比的安全性"><a href="#Touch-ID-与普通密码相比的安全性" class="headerlink" title="Touch ID 与普通密码相比的安全性"></a>Touch ID 与普通密码相比的安全性</h3><p>一个人的指纹是世界上最好的密码之一。它独一无二，高度特异，并且无需记忆。它会伴随人终生，所以你可以一直使用同一个指纹密码。</p>
<p>比起简单的4位数字锁屏密码一万分之一的破解可能性，能找到同样单个指纹的人的概率为五万分之一，这是非常安全的，比起前者我可以不断尝试，Touch ID 指纹的硬性破解几率几乎没有，因为不可能有五万多个人排队来一一解锁你的设备，况且 Touch ID 会拒绝第五次以后的尝试而要求输入密码。所以我们可以添加更加复杂的密码而不是简单的数字密码来进一步提高安全性。</p>
<h3 id="Touch-ID-指纹识别的原理"><a href="#Touch-ID-指纹识别的原理" class="headerlink" title="Touch ID 指纹识别的原理"></a>Touch ID 指纹识别的原理</h3><p>在如此快速的识别过程中，Home 按钮上的一圈金属环起到了感应手指的功能，通知 Touch ID 来读取指纹。Touch ID 置于该按钮中，传感器的厚度只有 170 微米，拥有 500 ppi 高分辨率，可读取极小的指纹细节。传感器可从皮肤皮下层指纹的一些小部分拍摄高分辨率图像，然后会分析该信息，根据三种基本指纹类型（弧形纹、箕形纹或斗形纹）将指纹分类，它会绘制比人眼不可见的纹路细节，确保指纹读取准确无误。</p>
<p><img src="/assets/images/tech/ios_data_protection_3.png" alt="touch id sensor"></p>
<p>Touch ID 可从 360 度方向读取指纹，随后创建指纹的某种数学表达式，并将其与已注册的数据进行比较，以确定是否匹配。如果匹配，便可替代密码来解锁设备或通过某个令牌。</p>
<p>此外，根据苹果官方的描述，Touch ID 会向以注册的指纹数据里持续的添加新的特征数据，随着时间的推移，这能不断提高匹配准确度，也能进一步的提高安全性。</p>
<p><img src="/assets/images/tech/ios_data_protection_4.png" alt="touch id ontouch"></p>
<p>除了上述的内容，苹果还加入可以一些有效的手段来进一步确保安全，例如设备再重新启动或者保持锁定 48 小时后，就只能通过密码而不是指纹来解锁设备。</p>
<h3 id="Secure-Enclave"><a href="#Secure-Enclave" class="headerlink" title="Secure Enclave"></a>Secure Enclave</h3><p>Apple声明指纹的图案不会被保存，存储于设备中的是指纹特征的数学表达式，而且从这些表达式不可能直接反推出指纹图像。</p>
<p><img src="/assets/images/tech/ios_data_protection_5.png" alt="touch-id-structure"></p>
<p>指纹的验证运算独立于主要处理器芯片（例如 A7、A8），芯片内有称为 “Secure Enclave” 的高级安全架构，专用于密码指纹数据，并使用 Secure Enclave 的专用密钥加密，以及每次启动以随机的 UID 进行管理。指纹数据仅能被 Secure Enclave 处理和使用，正因为此架构独立于其它设备部件，仅有 Touch ID 使用它，且不能将它用于匹配其他指纹数据库，所以存储的指纹数据不会由 iOS 或其他应用访问，也不会被存储到 Apple 服务器或备份到 iCloud 等地方。</p>
<p><img src="/assets/images/tech/ios_data_protection_6.png" alt="A7-Secure-Enclave"></p>
<p>从硬件上来看指纹特征数据尚不能被 “Secure Enclave” 和 Touch ID 以外的部件访问到，并且两者芯片互相隔离开来，所有软件都没有权利获得指纹数据，仅能得到指纹是否错误的回馈。因为架构的核心秘密仅仅只有苹果公司知道，所以目前几乎没有第三方软件可以访问到这部分敏感信息。</p>
<p>到此，关于 iOS 数据保护的问题暂时告一段落。欢迎大家评论指正。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>存储</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow 广度和深度学习的教程</title>
    <url>/2017-11-30-tensorflow-wide-and-deep/</url>
    <content><![CDATA[<p>在前文 <a href="https://www.tensorflow.org/tutorials/wide">《TensorFlow Liner Model Tutorial》</a> 中，我们使用 <a href="https://archive.ics.uci.edu/ml/datasets/Census+Income">人口收入普查数据集</a> 训练了一个 logistic 线性回归模型去预测个人年收入超过 5 万美元的概率。TensorFlow 在训练深度神经网络方面效果也很好，那么你可能会考虑该如何取舍它的功能了 – 可是，为什么不选择两者兼得呢？那么，是否可以将两者的优势结合在一个模型中呢？</p>
<p>在这篇文章中，我们将会介绍如何使用 TF.Learn API 同时训练一个广度线性模型和一个深度前馈神经网络。这种方法结合了记忆和泛化的优势。它在一般的大规模回归和具有稀疏输入特性的分类问题（例如，分类特征存在一个很大的可能值域）上很有效。如果你有兴趣学习更多关于广度和深度学习如何工作的问题，请参考 <a href="http://arxiv.org/abs/1606.07792">研究论文</a></p>
<p><img src="https://www.tensorflow.org/images/wide_n_deep.svg" alt="Wide &amp; Deep Spectrum of Models" title="Wide &amp; Deep"></p>
<span id="more"></span>

<p>现在，我们来看一个简单的例子。</p>
<p>上图展示了广度模型（具有稀疏特征和转换性质的 logistic 回归模型），深度模型（具有一个嵌入层和多个隐藏层的前馈神经网络），广度和深度模型（两者的联合训练）的区别比较。在高层级里，只需要通过以下三个步骤就能使用 TF.Learn API 配置广度，深度或广度和深度模型。</p>
<p>1.选择广度部分的特征：选择要使用的稀疏基本列和交叉列。</p>
<p>2.选择深度部分的特征：选择连续列，每个分类列的嵌入维度和隐藏层大小。</p>
<p>3.将它们一起放入广度和深度模型（<code>DNNLinearCombinedClassifier</code>）。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>如果想要尝试本教程中的代码：</p>
<p>1.安装 TensorFlow ，<a href="/blog/tensorflow-pycharm-mac">请前往此处</a>。</p>
<p>2.下载 <a href="https://www.tensorflow.org/code/tensorflow/examples/learn/wide_n_deep_tutorial.py">教程代码</a>。</p>
<p>3.安装 pandas 数据分析库。因为本教程中需要使用 pandas 数据。虽然 tf.learn 不要求 pandas，但是它支持 pandas。安装 pandas：</p>
<p>a. 获取 pip：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Ubuntu/Linux 64-bit</span><br><span class="line">$ sudo apt-get install python-pip python-dev</span><br><span class="line"></span><br><span class="line"># Mac OS X</span><br><span class="line">$ sudo easy_install pip</span><br><span class="line">$ sudo easy_install --upgrade six</span><br></pre></td></tr></table></figure>

<p>b. 使用 pip 安装 pandas</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo pip install pandas</span><br></pre></td></tr></table></figure>

<p>如果你在安装过程中遇到问题，请前往 pandas 网站上的 <a href="http://pandas.pydata.org/pandas-docs/stable/install.html">说明</a> 。</p>
<p>4.执行以下命令来训练教程中描述的线性模型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python wide_n_deep_tutorial.py --model_type=wide_n_deep</span><br></pre></td></tr></table></figure>

<p>请继续阅读，了解此代码如何构建其线性模型。</p>
<h2 id="定义基本特征列"><a href="#定义基本特征列" class="headerlink" title="定义基本特征列"></a>定义基本特征列</h2><p>首先，定义我们使用的基本分类和连续特征的列。这些列将被作为模型的广度部分和深度部分的构件块。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">gender = tf.feature_column.categorical_column_with_vocabulary_list(</span><br><span class="line">    <span class="string">&quot;gender&quot;</span>, [<span class="string">&quot;Female&quot;</span>, <span class="string">&quot;Male&quot;</span>])</span><br><span class="line">education = tf.feature_column.categorical_column_with_vocabulary_list(</span><br><span class="line">    <span class="string">&quot;education&quot;</span>, [</span><br><span class="line">        <span class="string">&quot;Bachelors&quot;</span>, <span class="string">&quot;HS-grad&quot;</span>, <span class="string">&quot;11th&quot;</span>, <span class="string">&quot;Masters&quot;</span>, <span class="string">&quot;9th&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Some-college&quot;</span>, <span class="string">&quot;Assoc-acdm&quot;</span>, <span class="string">&quot;Assoc-voc&quot;</span>, <span class="string">&quot;7th-8th&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Doctorate&quot;</span>, <span class="string">&quot;Prof-school&quot;</span>, <span class="string">&quot;5th-6th&quot;</span>, <span class="string">&quot;10th&quot;</span>, <span class="string">&quot;1st-4th&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Preschool&quot;</span>, <span class="string">&quot;12th&quot;</span></span><br><span class="line">    ])</span><br><span class="line">marital_status = tf.feature_column.categorical_column_with_vocabulary_list(</span><br><span class="line">    <span class="string">&quot;marital_status&quot;</span>, [</span><br><span class="line">        <span class="string">&quot;Married-civ-spouse&quot;</span>, <span class="string">&quot;Divorced&quot;</span>, <span class="string">&quot;Married-spouse-absent&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Never-married&quot;</span>, <span class="string">&quot;Separated&quot;</span>, <span class="string">&quot;Married-AF-spouse&quot;</span>, <span class="string">&quot;Widowed&quot;</span></span><br><span class="line">    ])</span><br><span class="line">relationship = tf.feature_column.categorical_column_with_vocabulary_list(</span><br><span class="line">    <span class="string">&quot;relationship&quot;</span>, [</span><br><span class="line">        <span class="string">&quot;Husband&quot;</span>, <span class="string">&quot;Not-in-family&quot;</span>, <span class="string">&quot;Wife&quot;</span>, <span class="string">&quot;Own-child&quot;</span>, <span class="string">&quot;Unmarried&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Other-relative&quot;</span></span><br><span class="line">    ])</span><br><span class="line">workclass = tf.feature_column.categorical_column_with_vocabulary_list(</span><br><span class="line">    <span class="string">&quot;workclass&quot;</span>, [</span><br><span class="line">        <span class="string">&quot;Self-emp-not-inc&quot;</span>, <span class="string">&quot;Private&quot;</span>, <span class="string">&quot;State-gov&quot;</span>, <span class="string">&quot;Federal-gov&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Local-gov&quot;</span>, <span class="string">&quot;?&quot;</span>, <span class="string">&quot;Self-emp-inc&quot;</span>, <span class="string">&quot;Without-pay&quot;</span>, <span class="string">&quot;Never-worked&quot;</span></span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示一个哈希的例子：</span></span><br><span class="line">occupation = tf.feature_column.categorical_column_with_hash_bucket(</span><br><span class="line">    <span class="string">&quot;occupation&quot;</span>, hash_bucket_size=<span class="number">1000</span>)</span><br><span class="line">native_country = tf.feature_column.categorical_column_with_hash_bucket(</span><br><span class="line">    <span class="string">&quot;native_country&quot;</span>, hash_bucket_size=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续基列</span></span><br><span class="line">age = tf.feature_column.numeric_column(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">education_num = tf.feature_column.numeric_column(<span class="string">&quot;education_num&quot;</span>)</span><br><span class="line">capital_gain = tf.feature_column.numeric_column(<span class="string">&quot;capital_gain&quot;</span>)</span><br><span class="line">capital_loss = tf.feature_column.numeric_column(<span class="string">&quot;capital_loss&quot;</span>)</span><br><span class="line">hours_per_week = tf.feature_column.numeric_column(<span class="string">&quot;hours_per_week&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换</span></span><br><span class="line">age_buckets = tf.feature_column.bucketized_column(</span><br><span class="line">    age, boundaries=[<span class="number">18</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">50</span>, <span class="number">55</span>, <span class="number">60</span>, <span class="number">65</span>])</span><br></pre></td></tr></table></figure>

<h2 id="广度模型：具有交叉特征列的线性模型"><a href="#广度模型：具有交叉特征列的线性模型" class="headerlink" title="广度模型：具有交叉特征列的线性模型"></a>广度模型：具有交叉特征列的线性模型</h2><p>广度模型是一个具有稀疏和交叉特征列的线性模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base_columns = [</span><br><span class="line">    gender, native_country, education, occupation, workclass, relationship,</span><br><span class="line">    age_buckets,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">crossed_columns = [</span><br><span class="line">    tf.feature_column.crossed_column(</span><br><span class="line">        [<span class="string">&quot;education&quot;</span>, <span class="string">&quot;occupation&quot;</span>], hash_bucket_size=<span class="number">1000</span>),</span><br><span class="line">    tf.feature_column.crossed_column(</span><br><span class="line">        [age_buckets, <span class="string">&quot;education&quot;</span>, <span class="string">&quot;occupation&quot;</span>], hash_bucket_size=<span class="number">1000</span>),</span><br><span class="line">    tf.feature_column.crossed_column(</span><br><span class="line">        [<span class="string">&quot;native_country&quot;</span>, <span class="string">&quot;occupation&quot;</span>], hash_bucket_size=<span class="number">1000</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>具有交叉特征列的广度模型可以有效地记忆特征之间的稀疏交互。也就是说，交叉特征列不能概括没有在训练数据中出现的特征组合。让我们采用嵌入方式来添加一个深度模型来修复这个问题。</p>
<h2 id="深度模型：嵌入式神经网络"><a href="#深度模型：嵌入式神经网络" class="headerlink" title="深度模型：嵌入式神经网络"></a>深度模型：嵌入式神经网络</h2><p>深度模型是一个前馈神经网络，如前图所示。每一个稀疏，高维度分类特征首先都会被转换成一个低维度密集的实值矢量，通常被称为嵌入式矢量。这些低维度密集的嵌入式矢量与连续特征相连，然后在正向传递中馈入神经网络的隐藏层。嵌入值随机初始化，并与其他模型参数一起训练，以最大化减少训练损失。如果你有兴趣了解更多关于嵌入的知识，请在查阅教程 <a href="https://www.tensorflow.org/versions/r0.9/tutorials/word2vec/index.html">Vector Representations of Words</a> 或在 Wikipedia 上查阅 <a href="https://en.wikipedia.org/wiki/Word_embedding">Word Embedding</a>。</p>
<p>我们将使用 <code>embedding_column</code> 配置分类嵌入列，并将它们与连续列连接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">deep_columns = [</span><br><span class="line">    tf.feature_column.indicator_column(workclass),</span><br><span class="line">    tf.feature_column.indicator_column(education),</span><br><span class="line">    tf.feature_column.indicator_column(gender),</span><br><span class="line">    tf.feature_column.indicator_column(relationship),</span><br><span class="line">    <span class="comment"># 展示一个嵌入例子</span></span><br><span class="line">    tf.feature_column.embedding_column(native_country, dimension=<span class="number">8</span>),</span><br><span class="line">    tf.feature_column.embedding_column(occupation, dimension=<span class="number">8</span>),</span><br><span class="line">    age,</span><br><span class="line">    education_num,</span><br><span class="line">    capital_gain,</span><br><span class="line">    capital_loss,</span><br><span class="line">    hours_per_week,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>嵌入的 <code>dimension</code> 越高，自由度就越高，模型将不得不学习这些特性的表示。为了简单起见，我们设置所有特征列的维度为 8。从经验上看，关于维度的设定最好是从 \log_{2}(n) 或 k\sqrt[4]{n} 值开始，这里的 n 代表特征列中唯一特征的数量，k 是一个很小的常量（通常小于10）。</p>
<p>通过密集嵌入，深度模型可以更好的概括，并更好对之前没有在训练数据中遇见的特征进行预测。然而，当两个特征列之间的底层交互矩阵是稀疏和高等级时，很难学习特征列的有效低维度表示。在这种情况下，大多数特征对之间的交互应该为零，除了少数几个，但密集的嵌入将导致所有特征对的非零预测，从而可能过度泛化。另一方面，具有交叉特征的线性模型可以用更少的模型参数有效地记住这些“异常规则”。</p>
<p>现在，我们来看看如何联合训练广度和深度模型，让它们优势和劣势互补。</p>
<h2 id="将广度和深度模型结合为一体"><a href="#将广度和深度模型结合为一体" class="headerlink" title="将广度和深度模型结合为一体"></a>将广度和深度模型结合为一体</h2><p>通过将其最终输出的对数几率作为预测结合起来，然后将预测提供给 logistic 损失函数，将广度模型和深度模型相结合。所有的图形定义和变量分配都已经被处理，所以你只需要创建一个 <code>DNNLinearCombinedClassifier</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line">model_dir = tempfile.mkdtemp()</span><br><span class="line">m = tf.contrib.learn.DNNLinearCombinedClassifier(</span><br><span class="line">    model_dir=model_dir,</span><br><span class="line">    linear_feature_columns=wide_columns,</span><br><span class="line">    dnn_feature_columns=deep_columns,</span><br><span class="line">    dnn_hidden_units=[<span class="number">100</span>, <span class="number">50</span>])</span><br></pre></td></tr></table></figure>

<h2 id="训练和评估模型"><a href="#训练和评估模型" class="headerlink" title="训练和评估模型"></a>训练和评估模型</h2><p>在训练模型之前，请先阅读人口普查数据集，就像在 <a href="https://www.tensorflow.org/tutorials/wide">《TensorFlow Liner Model Tutorial》</a> 中所做的一样。 输入数据处理的代码再次为你提供方便：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为数据集定义列名</span></span><br><span class="line">CSV_COLUMNS = [</span><br><span class="line">    <span class="string">&quot;age&quot;</span>, <span class="string">&quot;workclass&quot;</span>, <span class="string">&quot;fnlwgt&quot;</span>, <span class="string">&quot;education&quot;</span>, <span class="string">&quot;education_num&quot;</span>,</span><br><span class="line">    <span class="string">&quot;marital_status&quot;</span>, <span class="string">&quot;occupation&quot;</span>, <span class="string">&quot;relationship&quot;</span>, <span class="string">&quot;race&quot;</span>, <span class="string">&quot;gender&quot;</span>,</span><br><span class="line">    <span class="string">&quot;capital_gain&quot;</span>, <span class="string">&quot;capital_loss&quot;</span>, <span class="string">&quot;hours_per_week&quot;</span>, <span class="string">&quot;native_country&quot;</span>,</span><br><span class="line">    <span class="string">&quot;income_bracket&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">maybe_download</span>(<span class="params">train_data, test_data</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Maybe downloads training data and returns train and test file names.&quot;&quot;&quot;</span></span><br><span class="line">  <span class="keyword">if</span> train_data:</span><br><span class="line">    train_file_name = train_data</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    train_file = tempfile.NamedTemporaryFile(delete=<span class="literal">False</span>)</span><br><span class="line">    urllib.request.urlretrieve(</span><br><span class="line">        <span class="string">&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data&quot;</span>,</span><br><span class="line">        train_file.name)  <span class="comment"># pylint: disable=line-too-long</span></span><br><span class="line">    train_file_name = train_file.name</span><br><span class="line">    train_file.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Training data is downloaded to %s&quot;</span> % train_file_name)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> test_data:</span><br><span class="line">    test_file_name = test_data</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    test_file = tempfile.NamedTemporaryFile(delete=<span class="literal">False</span>)</span><br><span class="line">    urllib.request.urlretrieve(</span><br><span class="line">        <span class="string">&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.test&quot;</span>,</span><br><span class="line">        test_file.name)  <span class="comment"># pylint: disable=line-too-long</span></span><br><span class="line">    test_file_name = test_file.name</span><br><span class="line">    test_file.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Test data is downloaded to %s&quot;</span>% test_file_name)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> train_file_name, test_file_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">input_fn</span>(<span class="params">data_file, num_epochs, shuffle</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;Input builder function.&quot;&quot;&quot;</span></span><br><span class="line">  df_data = pd.read_csv(</span><br><span class="line">      tf.gfile.Open(data_file),</span><br><span class="line">      names=CSV_COLUMNS,</span><br><span class="line">      skipinitialspace=<span class="literal">True</span>,</span><br><span class="line">      engine=<span class="string">&quot;python&quot;</span>,</span><br><span class="line">      skiprows=<span class="number">1</span>)</span><br><span class="line">  <span class="comment"># 移除 NaN 元素</span></span><br><span class="line">  df_data = df_data.dropna(how=<span class="string">&quot;any&quot;</span>, axis=<span class="number">0</span>)</span><br><span class="line">  labels = df_data[<span class="string">&quot;income_bracket&quot;</span>].apply(<span class="keyword">lambda</span> x: <span class="string">&quot;&gt;50K&quot;</span> <span class="keyword">in</span> x).astype(<span class="built_in">int</span>)</span><br><span class="line">  <span class="keyword">return</span> tf.estimator.inputs.pandas_input_fn(</span><br><span class="line">      x=df_data,</span><br><span class="line">      y=labels,</span><br><span class="line">      batch_size=<span class="number">100</span>,</span><br><span class="line">      num_epochs=num_epochs,</span><br><span class="line">      shuffle=shuffle,</span><br><span class="line">      num_threads=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>阅读数据之后，你可以训练并评估模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 num_epochs 设置为 None，以获得无限的数据流</span></span><br><span class="line">m.train(</span><br><span class="line">    input_fn=input_fn(train_file_name, num_epochs=<span class="literal">None</span>, shuffle=<span class="literal">True</span>),</span><br><span class="line">    steps=train_steps)</span><br><span class="line"><span class="comment"># 在所有数据被消耗之前，为了运行评估，设置 steps 为 None</span></span><br><span class="line">results = m.evaluate(</span><br><span class="line">    input_fn=input_fn(test_file_name, num_epochs=<span class="number">1</span>, shuffle=<span class="literal">False</span>),</span><br><span class="line">    steps=<span class="literal">None</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;model directory = %s&quot;</span> % model_dir)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">sorted</span>(results):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;%s: %s&quot;</span> % (key, results[key]))</span><br></pre></td></tr></table></figure>

<p>输出的第一行应该类似 <code>accuracy: 0.84429705</code>。我们可以看到使用广度和深度模型将广度线性模型精度约 83.6% 提高到了约 84.4%。如果你想看端对端的工作示例，你可以下载我们的 <a href="https://www.tensorflow.org/code/tensorflow/examples/learn/wide_n_deep_tutorial.py">示例代码</a>。</p>
<p>请注意，本教程只是一个小型数据基的简单示例，为了让你快速熟悉 API。如果你有大量具有稀疏特征列和大量可能特征值的数据集，广度和深度学习将会更加强大。此外，请随时关注我们的 <a href="http://arxiv.org/abs/1606.07792">研究论文</a>，以了解更多关于在实际中广度和深度学习在大型机器学习方面如何应用的思考。</p>
<blockquote>
<ul>
<li>原文地址：<a href="https://www.tensorflow.org/tutorials/wide_and_deep">https://www.tensorflow.org/tutorials/wide_and_deep</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li>
<li>译者：<a href="https://github.com/charsdavy">charsdavy</a></li>
<li>校对者：<a href="https://github.com/MRNIU">MRNIU</a></li>
</ul>
</blockquote>
<blockquote>
<p><a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im/">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android">Android</a>、<a href="https://github.com/xitu/gold-miner#ios">iOS</a>、<a href="https://github.com/xitu/gold-miner#%E5%89%8D%E7%AB%AF">前端</a>、<a href="https://github.com/xitu/gold-miner#%E5%90%8E%E7%AB%AF">后端</a>、<a href="https://github.com/xitu/gold-miner#%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%A7%E5%93%81">产品</a>、<a href="https://github.com/xitu/gold-miner#%E8%AE%BE%E8%AE%A1">设计</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi">知乎专栏</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>ml</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tensorflow</tag>
        <tag>机器学习</tag>
        <tag>掘金翻译计划</tag>
      </tags>
  </entry>
  <entry>
    <title>数据链路层之 LLDP</title>
    <url>/2018-01-29-data-link-layer-lldp/</url>
    <content><![CDATA[<p>随着网络技术的发展，接入网络的设备的种类越来越多，配置越来越复杂，来自不同设备厂商的设备也往往会增加自己特有的功能，这就导致在一个网络中往往会有很多具有不同特性的、来自不同厂商的设备，为了方便对这样的网络进行管理，就需要使得不同厂商的设备能够在网络中相互发现并交互各自的系统及配置信息。 </p>
<p>LLDP（Link Layer Discovery Protocol，链路层发现协议）就是用于这个目的的协议。LLDP 定义在 802.1ab 中，它是一个二层协议，它提供了一种标准的链路层发现方式。LLDP 协议使得接入网络的一台设备可以将其主要的<strong>能力，管理地址，设备标识，接口标识</strong>等信息发送给接入同一个局域网络的其它设备。当一个设备从网络中接收到其它设备的这些信息时，它就将这些信息以MIB的形式存储起来。</p>
<p>这些 MIB 信息可用于发现设备的物理拓扑结构以及管理配置信息。需要注意的是 LLDP 仅仅被设计用于进行信息通告，它被用于通告一个设备的信息并可以获得其它设备的信息，进而得到相关的 MIB 信息。它不是一个配置、控制协议，无法通过该协议对远端设备进行配置，<strong>它只是提供了关于网络拓扑以及管理配置的信息，这些信息可以被用于管理、配置的目的，如何用取决于信息的使用者。</strong></p>
<span id="more"></span>

<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>LLDP 的框架结构如图所示</p>
<p><img src="/assets/images/tech/data-link-layer-lldp-struct.png" alt="LLDP 结构图"></p>
<p>此图也表明 LLDP 就是一个信息发现与通告协议，LLDP 的实体主要维护了两个 MIB 库，一个 local system MIB，一个 remote system MIB。从其名字也可以看出，一个用于维护本地相关的设备 MIB 信息，一个用于维护远端设备 MIB 信息。</p>
<p>LLDP 通过与上图中右侧的几个 MIB 库交互来初始化并维护 local system MIB，并将本地的相关信息通告出去；同时当接收到来自其它设备的信息时就将其更新到remote system MIB 中。通过这种工作方式，一个设备就可以将自己的信息通告出去并获得网络中其它设备的相关信息，最终获得反应网络拓扑以及其它配置信息的两个 MIB 库。这两个库可以被其用户用来完成各种功能。需要说明的是<strong>LLDP 信息的通告以及接收处理不受端口的STP状态的影响。</strong></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><p>封装有 LLDPDU 的报文称为 LLDP 帧，其封装格式有两种：Ethernet II 和 SNAP（Subnetwork Access Protocol，子网访问协议）。</p>
<h4 id="Ethernet-II-格式封装的-LLDP-帧"><a href="#Ethernet-II-格式封装的-LLDP-帧" class="headerlink" title="Ethernet II 格式封装的 LLDP 帧"></a>Ethernet II 格式封装的 LLDP 帧</h4><p><img src="/assets/images/tech/data-link-layer-lldp-ethernet-ii-frame.png" alt="Ethernet II 格式封装的 LLDP 帧"></p>
<p>上图是以 Ethernet II 格式封装的 LLDP 帧，其中各字段的含义如下： </p>
<ul>
<li>DA：目的 MAC 地址，为固定的组播 MAC 地址 0x0180-C200-000E。 </li>
<li>SA：源 MAC 地址，为端口 MAC 地址或设备 MAC 地址（如有端口地址则用端口 MAC 地址，否则用设备 MAC 地址）。 指与设备相邻连接设备的桥 MAC。</li>
<li>LLDP Ethertype：帧类型，为 0x88CC。 </li>
<li>LLDPDU：LLDP Data Unit，LLDP 数据单元，它是 LLDP 信息交换的主体。</li>
<li>FCS：帧检验序列。</li>
</ul>
<h4 id="SNAP-格式封装的-LLDP-帧"><a href="#SNAP-格式封装的-LLDP-帧" class="headerlink" title="SNAP 格式封装的 LLDP 帧"></a>SNAP 格式封装的 LLDP 帧</h4><p><img src="/assets/images/tech/data-link-layer-lldp-snap-frame.png" alt="SNAP 格式封装的 LLDP 帧"></p>
<p>上图是以 SNAP 格式封装的 LLDP 帧，其中各字段的含义如下：</p>
<ul>
<li>DA：目的 MAC 地址，为固定的组播 MAC 地址 01-80-C2-00-00-0E。 </li>
<li>SA：源 MAC 地址，为端口 MAC 地址或设备 MAC 地址（如有端口地址则用端口 MAC 地址，否则用设备 MAC 地址）。 </li>
<li>Type：帧类型，为 0xAAAA-0300-0000-88CC。 </li>
<li>Data：数据，为 LLDPDU。 </li>
<li>FCS：帧检验序列。</li>
</ul>
<h4 id="目的地址"><a href="#目的地址" class="headerlink" title="目的地址"></a>目的地址</h4><p>目的地址实际上包括三个，分别为 01-80-C2-00-00-0E，01-80-C2-00-00-03，01-80-C2-00-00-00。这三个地址分别用于不同的目的，它们可以跨越不同的网络。</p>
<ul>
<li>01-80-C2-00-00-0E，也被称为 Nearest Bridge 组地址：无论是 Two-Port MAC Relay (TPMR)组件、S-VLAN 组件、C-VLAN 组件，还是 802.1D 网桥都不能转发目的为该地址的帧。简单的说任何类型的网桥都不能转发目的为该地址的帧，目的为该地址的帧被限制在连接两个网桥接口的连接上传输。</li>
<li>01-80-C2-00-00-03，也被称为 Nearest non-TPMR Bridge 组地址：对于目的地址为该地址的帧，Two-Port MAC Relay (TPMR)组件将成为一个中继器，即不接收它。而 S-VLAN（Service Provider VLAN）组件，C-VLAN（Customer VLAN）组件，以及 802.1D 网桥都不能转发它，而是需要进行接收并处理。因此目的地址为该地址的帧将跨越 TPMR。</li>
<li>01-80-C2-00-00-00，也被称为 Nearest Customer Bridge 组地址：对于目的地址为该地址的帧，Two-Port MAC Relay (TPMR)组件以及 S-VLAN 组件将成为中继器，即不接收它。而 C-VLAN 组件，以及 802.1D 网桥都不能转发它，而是需要进行接收并处理。因此目的地址为该地址的帧将跨越 TPMR 以及 S-VLAN。</li>
</ul>
<h3 id="TPMR-介绍"><a href="#TPMR-介绍" class="headerlink" title="TPMR 介绍"></a>TPMR 介绍</h3><p>TPMR 以及 S-VLAN，C-VLAN 都是 802.1Q 中的概念，包括这三者的网络以及各个地址的作用范围如下图所示</p>
<p><img src="/assets/images/tech/data-link-layer-lldp-mac-addr.png" alt="MAC Addr"></p>
<p><img src="/assets/images/tech/data-link-layer-lldp-group-mac-addr.png" alt="Group MAC Addr"></p>
<p><img src="/assets/images/tech/data-link-layer-lldp-diff-os-mac-addr.png" alt="OS MAC Addr"></p>
<ul>
<li>C-VLAN：Customer VLAN，是用户网络内部使用的 VLAN；</li>
<li>S-VLAN：Service VLAN，服务提供商网络中使用的 VLAN，该 VLAN 标识 VPN 用户或者是用户的业务；</li>
<li>Customer Bridge: Customer 网络中的 Bridge，只能识别 C-VLAN；</li>
<li>Provider Bridge：服务提供商网络中的 Bridge，根据处理内容的不同又分为S-VLAN Bridge 和 Provider Edge Bridge。其中 S-VLAN Bridge 只能识别 S-VLAN； Provider Edge Bridge 可以同时识别 C-VLAN 和 S-VLAN；</li>
<li>C-VLAN Component：在 Bridge 内可识别、插入、删除 C-VLAN 的实体，每个端口一个，对 C-VLAN 的操作互相独立（两个端口上接收到相同的 C-VLAN，但由于属于不同的客户最后的处理结果会不同）；</li>
<li>S-VLAN Component：在 Bridge 内可识别、插入、删除 S-VLAN 的实体，由于在一个 Bridge 内不存在相同的 S-VLAN 属于不同服务提供商的情况，因此在一个桥内只有一个 S-VLAN 的实体。</li>
</ul>
<h3 id="QinQ-介绍"><a href="#QinQ-介绍" class="headerlink" title="QinQ 介绍"></a>QinQ 介绍</h3><p>QinQ 的理论基础，是 IEEE 定义的 802.1ad。在这个规范里面，IEEE 提出了一个概念，它认为汇聚和接入层那里有这么两种设备：S-VLAN Bridge 和 Provider Edge Bridge，再往下就是 Customer System 了（注意，这里说 System 而不是 Bridge，是因为 Customer 接进来的未必是二层设备，可能也是三层设备）。VLAN 空间也被分成两个 VLAN 空间，即 S-VLAN 和 C-VLAN，S 即 Service Provider，C 即 Customer。在 S-VLAN Bridge 上，只有 S-VLAN 空间，而在 Provider Edge Bridge 上，则既有 S-VLAN 空间，又有 C-VLAN 空间。相应的，这个 Bridge 就被从逻辑上划分为两部分，支持 S-VLAN 功能的部分称之为 S-VLAN Component，支持 C-VLAN 功能的部分称之为 C-VLAN Component。S-VLAN Bridge 只包含 S-VLAN Component。</p>
<p>除了两种 Bridge 的概念，802.1ad 还提出了三种 Service 类型和四种 Port 类型，其中一种 Port 是内部 Port，对用户不可见，其它三种 Port 分别对应了三种不同的 Service，即运营商可以通过在交换机上配置三种不同的 Port 类型，来相应的为用户提供三种不同类型的 Service。三种 Service 分别是 Port Based Service，C-Tag Based Service 和 S-Tag Based Service。四种Port 分别是 Customer Network Port （CN）， Customer Edge Port（CE），Provider Network Port（PN），Provider Edge Port（内部 Port）。</p>
<p>所谓 Port Based Service，就是说某个 Service 是基于 Port 的，从该 Port 进来的所有报文，都被认为是属于某一个特定的 Customer 的，不管它是否带 C-Tag，带了什么样的 C-Tag，这些信息统统被忽视。所有从这个 Port 进来的报文被赋予一个 S-VLAN，该 S-VLAN 被用来标识该 Customer，或说该 Service。提供这种 Service 的 Port 就是CN Port。CN Port 的实质就是运营商为一个 Customer 提供一个专门的 Port，不跟别的 Customer 共享。注意，从这个 Port 上进来的报文不能带 S-Tag，否则会被丢弃。也就是说，对于 S-Tag 而言，这个 Port 是 Access Port，而不是 Trunk Port。这是跟后面的 S-Tag Based service 本质的不同。</p>
<p><img src="/assets/images/tech/data-link-layer-lldp-port-based-pbn.png" alt="Port Base PBN"></p>
<p>所谓的 S-Tag Based Service，就是说从一个 Port 上进来的报文，根据 S-VLAN 来把它们划分到不同的 Customer，换句话说，是用 S-VLAN 来标记 Customer。提供这种 Service 的 Port 也是 CN Port，只不过这个时候的 CN Port，必须配置成 Trunk Port，只识别 S-VLAN，根据 S-VLAN 来标识 Customer，转发报文。</p>
<p><img src="/assets/images/tech/data-link-layer-lldp-port-based-pbn-struct.png" alt="PBN Struct"></p>
<p>所谓的 C-Tag Based Service，就是指报文携带 C-Tag 进入 Port，在该 Port 上基于 C-VLAN 来标识 Customer，一个 Port 上可以支持多个 Customer。用来支持 C-Tag Based Service 的 Port 就是 CE Port，CE Port 是 C-VLAN Component 的一部分，对于 C-VLAN 而言，CE Port 是 Trunk Port。它不识别 S-Tag。</p>
<p>PN Port 是 S-VLAN Component 的一部分，它跟 CN Port 唯一的不同是 CN Port 面向 Customer Network，而它面向 Provider Network，在实际的交换机中通常被配置成 Uplink Port，而且通常都是 VLAN Trunk Mode（相对于 Access Mode）。</p>
<p>对于一个拥有 S-VLAN Component 和 C-VLAN Component 的 Provider Edge Bridge 而言，在做 Mac Forwarding&#x2F;Learning 的时候，有两种模式，一种是用 <code>S-VLAN+MAC</code>，另外一种则是 <code>S-VLAN+C-VLAN+MAC</code>，前者即所谓的 C-VLAN Unaware Mode，而后者则是 C-VLAN Aware Mode。</p>
<p>C-VLAN Aware Mode 带来的好处是显而易见的，因为它将 VLAN 空间从 4K 扩展到了 16M，但是它的问题在于，当前绝大多数芯片都不支持，就算支持了，也不太可能支持到理论上的 16M。</p>
<h4 id="一种独创的-QinQ-模式"><a href="#一种独创的-QinQ-模式" class="headerlink" title="一种独创的 QinQ 模式"></a>一种独创的 QinQ 模式</h4><p>现实世界中用户的需求是千奇百怪，有一种需求，是市场上现存的交换机所解决不了的。在讨论这种需求之前，先看一下当前交换机的做法。无论各个厂家的实现差别有多大，但是有一点大家都是一样的，就是在接入交换机上，通过 Port 或者 C-VLAN 来识别用户，然后为每个用户分配一个 S-VLAN，然后用 S-VLAN 来做后续处理，如 ACL&#x2F;QoS&#x2F;Mac Learning&#x2F;Mac Forwarding 等。</p>
<p>但是运营商，特别是欧美的一些运营商可能有这样的需求，为了描述的方便，我们假设有个运营商 A，它在为它的客户提供服务的时候，有的时候需要租用别的运营商，假设是运营商 B 的网络，在租用网络的时候，A 这些 B 的客户，运营商 B 需要给 A 分配 S-VLAN，而且往往是一个 S-VLAN 多少钱，因为 VLAN 是稀缺资源，特别是网络比较大的时候。这个时候，如果运营商 A 为它自己的客户每个都分配一个 S-VLAN，那么相应的它就需要向 B 也申请很多个 S-VLAN，不划算，这个时候它就想在自己的接入设备上，不用 S-VLAN 来标识 Customer，给所有的 Customer 分配同一个 S-VLAN，用该 S-VLAN 来穿越 B 的网络，这个时候，S-VLAN 的意义不是代表 Customer，而是代表一个 Tunnel。</p>
<p>问题关键在于，如果不用 S-VLAN 来代表 Customer，在 A 的接入设备上，如何来对不同的 Customer 来做区分处理呢？用 C-VLAN 肯定是不行的，因为不同 Port 上的 C-VLAN 代表的 Customer 可能是不同的。Centec 的交换机，在芯片内部用一个不同于 C-VLAN 和 S-VLAN 的 CustomerID 来标识 Customer，用这个值来做后续的一系列 Customer 的处理，非常强大。</p>
<h4 id="QinQ-的不足"><a href="#QinQ-的不足" class="headerlink" title="QinQ 的不足"></a>QinQ 的不足</h4><p>尽管 QinQ 貌似很好很强大，并且受到热烈追捧，但是这不能掩盖它的先天不足。</p>
<p>QinQ 的最大不足就是它无法对运营商网络完全隐藏 Customer 信息，因为它可以让运营商 Core Network 的设备看不到 Customer VLAN，但是无法让它们看不到 Customer MAC。而这一点有两个不利的影响，一个是 Scalability 非常差，如果中间的设备都是二层设备，会导致 MAC 表非常大；第二个不利的影响则是，一旦 Customer 网络出现了环路，会导致 Provider Network 里面的设备不断进行 MAC Learning，万一有 ARP 之类报文，还可能冲击 CPU。</p>
<p>如果 Customer VLAN 对运营商网络不可见，那么就起不到扩展 VLAN 空间的作用，运营商的 VLAN 空间就仍然只有 4K。</p>
<p>而 PBB，即所谓的 MAC-in-MAC 则能很好的解决 QinQ 的这个不足，因为 PBB 不仅在原来的报文上新增一个 VLAN，还新增 MACSa&#x2F;MACDa 以及 24 个 bit 的 Isid（用来标识 Service），它可以完全对运营商的 Core Network 设备隐藏 Customer 信息，且能利用 Isid 来支持 16M Customer&#x2F;Service。</p>
<p>当然PBB也有PBB的问题，目前看不到它有成为主流技术的趋势。</p>
<h2 id="LLDPDU"><a href="#LLDPDU" class="headerlink" title="LLDPDU"></a>LLDPDU</h2><p>LLDPDU 是 LLDP 的有效负载，用于承载要发送的消息。LLDPDU 的格式如下图所示</p>
<p><img src="/assets/images/tech/data-link-layer-lldp-du.png" alt="LLDPDU"></p>
<p>LLDPDU 采用了 TLV 的格式，即 <code>type+length+value</code> 的格式，type 表示 TLV 的类型，length 是以字节为单位的 TLV 的长度，value 是该 TLV 的值。其中 Chassis ID TLV，Port ID TLV Time To Live TLV 以及 End Of LLDPDU TLV 是强制的，必须包含的部分，除此之外在 TLV Time To Live TLV 和 End Of LLDPDU TLV 之间可以包含 0 个到多个可选的其它 TLV。</p>
<h2 id="TLV"><a href="#TLV" class="headerlink" title="TLV"></a>TLV</h2><p>TLV 是组成 LLDPDU 的单元，每个 TLV 都代表一个信息。LLDPDU 的 TLV 可以分为两大类</p>
<ul>
<li>被认为是网络管理的基础的 TLV 集合，所有的 LLDP 实现都需要支持。</li>
<li>组织定义的 TLV 扩展集合，包括 <code>802.1</code> 组织定义 TLV、<code>802.3</code> 组织定义 TLV 以及其他组织定义的 TLV。这些 TLV 用于增强对网络设备的管理，可根据实际需要选择是否在 LLDPDU 中发送。</li>
</ul>
<p> </p>
<p>TLV 的基本格式如图所示</p>
<p><img src="/assets/images/tech/data-link-layer-lldp-tlv-format.png" alt="TLV基本格式图"></p>
<p>TLV的类型域的定义及分配如下图所示</p>
<p><img src="/assets/images/tech/data-link-layer-lldp-tlv-list.png" alt="TLV类型域"></p>
<p>其中 <code>type0-8</code> 属于基本的 TLV 集合。对于其中的 Mandatory 的 TLV，它是必须包含在 LLDP 中的。 组织定义 TLV 集合的格式如下图所示</p>
<p><img src="/assets/images/tech/data-link-layer-lldp-tlv-frame.png" alt="TLV集合格式"></p>
<p>其中</p>
<ul>
<li>OUI：组织机构的 ID。</li>
<li>organizationally defined subtype：组织自定义的类型。</li>
<li>organizationally defined information string：传输的信息。</li>
</ul>
<h2 id="基础-TLV-集合"><a href="#基础-TLV-集合" class="headerlink" title="基础 TLV 集合"></a>基础 TLV 集合</h2><p>几个强制的必须包含的 TLV 的定义如下。非强制的可以参考 IEEE802.1AB。</p>
<h3 id="End-Of-LLDPDU-TLV"><a href="#End-Of-LLDPDU-TLV" class="headerlink" title="End Of LLDPDU TLV"></a>End Of LLDPDU TLV</h3><p>该 TLV 用于标识 LLDPDU 的结束。其格式如下</p>
<p><img src="/assets/images/tech/data-link-layer-lldp-tlv-end.png" alt="TLV End"></p>
<p>由于 length&#x3D;0，因此它不包含 value 域。</p>
<h3 id="Chassis-ID-TLV"><a href="#Chassis-ID-TLV" class="headerlink" title="Chassis ID TLV"></a>Chassis ID TLV</h3><p>该 TLV 用于通告该 LLDPDU 发送者的 Chassis ID。由于有很多方式可用来标识一个 Chassis，因此在该类 TLV 中包含一个子类型域用于告诉接收者，发送者的 Chassis ID 采用的是哪一种标识方式。其格式如图所示</p>
<p><img src="/assets/images/tech/data-link-layer-lldp-tlv-chassis.png" alt="TLV Chassis"></p>
<p>每个 LLDPDU 必须包含且仅包含一个该类型的 TLV。由于 Chassis ID 实际上是用于标识设备的，因此在连接可用时它应该保持不变。 Chassis 子类型所可能的取值如图所示</p>
<p><img src="/assets/images/tech/data-link-layer-lldp-tlv-chassis-list.png" alt="TLV Chassis List"></p>
<h3 id="Port-ID-TLV"><a href="#Port-ID-TLV" class="headerlink" title="Port ID TLV"></a>Port ID TLV</h3><p>它用于标识发送该 LLDPDU 的设备的端口。类似于 Chassis ID，有很多方式可以标识一个 Port，因此该 TLV 也包含一个子类型域。其格式如下图所示</p>
<p><img src="/assets/images/tech/data-link-layer-lldp-tlv-port.png" alt="TLV Port"></p>
<p>每个 LLDPDU 必须包含一个且只能包含一个该类型的 TLV。同时，当端口可用时，从该端口发送出去的 LLDPDU 的该 TLV 应该保持不变。 其子类型的可能取值如下图所示</p>
<p><img src="/assets/images/tech/data-link-layer-lldp-tlv-port-list.png" alt="TLV Port List"></p>
<h3 id="Time-To-Live-TLV"><a href="#Time-To-Live-TLV" class="headerlink" title="Time To Live TLV"></a>Time To Live TLV</h3><p>该 TLV 用于告诉接收端，它接收到的这些信息的有效期有多长。其格式如图所示</p>
<p><img src="/assets/images/tech/data-link-layer-lldp-tlv-ttl.png" alt="TLV TTL"></p>
<p>TTL 的时间单位是秒，由于只有 2 个字节长，因而最大有效时间是 65536 秒。如果在这个时间到期了还没有新的 LLDPDU 被收到，则该 TLV 所属的那个 LLDPDU 携带的信息会被从 MIB 中删除。如果收到了新的 LLDPDU，则</p>
<ul>
<li>如果 TTL 不为 0，则会用新收到的 LLDPDU 的信息替换 MIB 库中的相应的信息（即与该 LLDPDU 的发送者相关的 MIB 信息，LLDP 使用 <code>Chassis ID+Port ID</code> 来判断是否来自于同一个源，这也是要求这两者保持不变的原因）。</li>
<li>如果 TTL 为 0，则删除相应的 MIB 库中的信息（即与该 LLDPDU 的发送者相关的 MIB 信息）。因此 TTL 为 0 的 LLDPDU 又被称为SHUTDOWN LLDPDU。</li>
</ul>
<p>每一个 LLDPDU 必须包含且只能包含一个该类型的 TLV。</p>
<h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><p>LLDP 是一个用于信息通告和获取的协议，但是需要注意的一点是，LLDP 发送的信息通告不需要确认，不能发送一个请求来请求获取某些信息，也就是说 LLDP 是一个单向的协议，只有主动通告一种工作方式，无需确认，不能查询、请求（比如像 ARP 协议那样请求某个 IP 的 MAC 地址）。</p>
<p>LLDP 主要完成如下工作：</p>
<ol>
<li>初始化并维护本地 MIB 库中的信息。<ol start="2">
<li><pre><code>从本地 MIB 库中提取信息，并将信息封装到 LLDP 帧中。LLDP 帧的发送有两种触发方式，一是定时器到期触发，一是设备状态发生了变化触发。
</code></pre>
<ol start="3">
<li><pre><code>识别并处理接收到的 LLDPDU 帧。
</code></pre>
<ol start="4">
<li><pre><code>维护远端设备 LLDP MIB 信息库。
</code></pre>
<ol start="5">
<li><pre><code>当本地或远端设备 MIB 信息库中有信息发生变化时，发出通告事件。
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="LLDPDU-发送"><a href="#LLDPDU-发送" class="headerlink" title="LLDPDU 发送"></a>LLDPDU 发送</h3><h4 id="发送机制"><a href="#发送机制" class="headerlink" title="发送机制"></a>发送机制</h4><p>LLDPDU 的发送可以被如下事件触发：</p>
<ul>
<li>与本地 MIB 信息库相关联的定时器 txTTR 到期时，这将确保远端接收系统中的相关信息不会因为 TTL 到期而过期。</li>
<li>本地 MIB 信息库中的信息发生了改变时，会立即发送 LLDPDU，这将保证改变能及时被更新。</li>
<li>如果一个“新邻居”被识别，将会启用快速发送机制，在很短的时间内连续发送指定数量（txFastInit，默认值为 4）的 LLDPDU，以确保“新邻居”能被快速更新。如果远端系统 MIB 信息库因为过载（tooManyNeighbors）而不能容纳新的邻居信息，则会为了避免过多的LLDPDU 传输而抑制快速发送行为。</li>
</ul>
<p>LLDP 的常规发送时间是建立在系统的 Tick 之上的，间隔为 1 秒一个，为了防止在共享介质的 LAN（shared media LAN）中同时出现大量的 LLDPDU（因为接入同一个LAN的多个系统的时间是同步的，因而多个系统上的基于 Tick 的1秒定时器可能同时到期），发送定时器引入了一个随机的抖动，这就使得常规的 LLDP 帧的发送间隔时间的平均值仍是 1 秒，但是具体到某一次到期时间可能并不是准确的 1 秒。</p>
<p>同时为了防止在有多个端口需要发送 LLDPDU 的系统中，所有的端口的定时器都在同一时间到期，因而标准建议将采用某种机制将多个发送实例的定时器到期时间给错开，以避免一个系统在同一时刻发送大量的 LLDPDU。</p>
<h4 id="发送状态机"><a href="#发送状态机" class="headerlink" title="发送状态机"></a>发送状态机</h4><p>LLDPDU 的发送状态机如图所示</p>
<p><img src="/assets/images/tech/data-link-layer-lldp-send-state-machine.png" alt="Send SM"></p>
<p>对于该状态机：</p>
<ul>
<li>为了防止过于频繁的重新初始化发送状态机，在 LLDP 的发送状态机中引入了一个延时，该延时限制了在关闭发送状态机后，必须至少等待多长时间才能重新初始化发送状态机。</li>
<li>是否发送 SHUTDOWN LLDPDU 由本地的 LLDP 工作状态决定。</li>
<li>是否发送正常的 LLDPDU 由 txNow 和 txCredit 决定。这两个变量都由发送定时器状态机更新。txNow 决定是否发送，而 txCredit 则是一个信用量，决定了可以发送的量，如果是 0 则不允许发送，只有大于 0 的值才允许发送，每发送一个该值就减 1。更重要的是在本地信息快速改变时，txCredit 既允许连续发送多个 LLDPDU，但是又对可以连续发送的 LLDPDU 帧数做了限制，这使得本地状态的快速改变可以及时被通告出去，但是又不能无限发送导致网络出现大量 LLDPDU 帧。</li>
</ul>
<h4 id="发送定时器状态机"><a href="#发送定时器状态机" class="headerlink" title="发送定时器状态机"></a>发送定时器状态机</h4><p>LLDP 发送定时器状态机如图所示</p>
<p><img src="/assets/images/tech/data-link-layer-lldp-send-timer-state-machine.png" alt="Send Timer SM"></p>
<p>localChange 表示本地信息是否发生改变；txTTR 表示下一次定时器到期的时间；newNeighbor 表示是否发现了新的邻居，并由接收状态设置，由该状态机清除；txTick 表示基于系统时间的1秒定时器是否到期。</p>
<p>对于该状态机：</p>
<ul>
<li>SIGNAL_TX 用于触发发送，它会将 txNow 设置为允许发送，并设置本地信息发生改变为 FALSE，如果当前不是在快速发送状态（txFast &#x3D; 0）就设置发送定时器下次到期时间为 msgTxInterval（msgTxInterval默认为30秒，取值范围1-3600秒），否则设置发送定时器下次到期时间为 msgFastTx（msgFastTx默认值为1秒，取值范围1-3600秒）。</li>
<li>如果本地信息发生了改变，就立即进入 SIGNAL_TX。</li>
<li>如果定时器到期，则如果 txFast 大于 0，则将其减 1 并进入 SIGNAL_TX，否则直接进入 SIGNAL_TX。</li>
<li>如果发现了新邻居，则首先将发现新邻居的标识更新为没有发现新邻居，然后如果当前已经处于快速发送状态就直接进入发送定时器到期状态（以触发一次立即发送），否则设置 txFast 的值为 txFastInit 的值（txFastInit 默认值为 4，取值范围 1-8）。</li>
<li>如果基于系统时间的 1 秒定时器到期，则给 txCredit 增加信用量，其最大值为 txCreditMax，txCreditMax 是一个取值在 1 到 10 之间的值，默认值为 5。</li>
</ul>
<p>这里有取值范围的几个变量都是可配置的变量。</p>
<p>从上述两个状态机的工作状态可以看出，发送定时器状态机用于维护信用量以及是否允许发送 LLDPDU 帧，而发送状态机根据这两个信息来决定是否发送。另外需要注意的是 LLDP 所使用的所有定时器操作都是“基于系统时间的 1 秒定时器的”，每当这个定时器到期时它除了会将 txTick 设置为 TRUE 外，还会处理其它的定时功能。</p>
<h3 id="LLDPDU-接收"><a href="#LLDPDU-接收" class="headerlink" title="LLDPDU 接收"></a>LLDPDU 接收</h3><h4 id="接收机制"><a href="#接收机制" class="headerlink" title="接收机制"></a>接收机制</h4><p>LLDP 帧的接收由 3 个阶段组成：帧的识别、帧的校验、LLDP 远端 MIB 信息库更新。</p>
<h5 id="帧的识别"><a href="#帧的识别" class="headerlink" title="帧的识别"></a>帧的识别</h5><p>由在 LLDP&#x2F;LSAP（链路服务访问点）进行，检查的内容是帧的目的地是否是 LLDP 的组播 MAC 地址，帧的类型是否是 LLDP。</p>
<h5 id="帧的验证"><a href="#帧的验证" class="headerlink" title="帧的验证"></a>帧的验证</h5><p>该过程会首先根据 TLV 的格式定义依次校验 Chassis ID TLV，Port ID TLV， Time To Live TLV，如果这三个 TLV 都存在且有效，才会进一步的解码可选的 TLV 直到遇到 End Of LLDPDU TLV，然后根据获得的信息更新远端 MIB 信息库。</p>
<h5 id="远端-MIB-信息库更新"><a href="#远端-MIB-信息库更新" class="headerlink" title="远端 MIB 信息库更新"></a>远端 MIB 信息库更新</h5><p>在前两步都通过之后，LLDPDU 的接收者就需要根据解析出来的信息更新远端 MIB 信息库。在 MIB 信息库中，LLDP 使用 <code>Chassis ID+Port ID</code> 来标识、存储来自不同源的信息。</p>
<ul>
<li>如果远端MIB库中已经有对应于该 <code>Chassis ID+Port ID</code> 的信息，则使用收到的帧中的新的 TTL 来更新 TTL。并用对于收到的新的 LLDPPDU 中的每一种 type，如果有变化就进行更新，如果某种 type 原来不存在，则需要将其添加到 MIB 库中。</li>
<li>如果实现不支持某种类型的 type，则</li>
</ul>
<ol>
<li>如果 type 不是 127，则按照基本 TLV 的格式将其存储到远端 MIB 库，存储格式为 type，length，value。</li>
<li>如果 type 是 127，则按照组织定义 TLV 的格式将其存储到远端 MIB 库，存储格式为 type，length，value，OUI，组织自定义子类型，以及信息域。</li>
</ol>
<p>更新时，如果需要添加新的 <code>Chassis ID+Port ID</code> 的表项，或者为某个 <code>Chassis ID+Port ID</code> 添加新的 TLV，则可能遇到没有内存的问题，标准没有规定必须如何处理，只是给出了一些建议：</p>
<ul>
<li>忽略新的 LLDPDU 的信息</li>
<li>删除最旧的信息以释放空间给新的信息</li>
<li>随机删除一些旧的信息以释放空间给新的信息</li>
</ul>
<p>LLDPDU 携带的 TTL（Time To Live）值会影响接收端的处理方式，如果它不为 0，则更新相应信息的老化时间，如果接收到的 LLDPDU 中的 TTL 等于 0，则将立刻老化掉相应的信息（即与该 LLDPDU 的发送者相关的MIB信息）。</p>
<p>如果一个 <code>Chassis ID+Port ID</code> 标识的信息的 TTL 超时，则相应的 MIB 信息会被删除。</p>
<h4 id="接收状态机"><a href="#接收状态机" class="headerlink" title="接收状态机"></a>接收状态机</h4><p>LLDPDU 的接收状态机如图所示</p>
<p><img src="/assets/images/tech/data-link-layer-lldp-receive-state-machine.png" alt="Receive SM"></p>
<h3 id="LLDP-工作模式"><a href="#LLDP-工作模式" class="headerlink" title="LLDP 工作模式"></a>LLDP 工作模式</h3><p>LLDP 可以工作在多种模式下：</p>
<ul>
<li>TxRx：既发送也接收 LLDP 帧。</li>
<li>Tx：只发送不接收 LLDP 帧。</li>
<li>Rx：只接收不发送 LLDP 帧。</li>
<li>Disable：既不发送也不接收 LLDP 帧（准确的说，这并不是一个 LLDP 的状态，这可能是 LLDP 功能被关闭了，也可能是设备就不支持）。</li>
</ul>
<p>由于 LLDP 可以单独工作在发送或接收模式下，因此 LLDP 协议的实现需要支持单独初始化发送或者接收功能。当工作模式发生变化时，需要根据老的&#x2F;新的工作模式来关闭&#x2F;打开发送或者接收的功能。</p>
<p><img src="/assets/images/tech/data-link-layer-lldp-mib-block.png" alt="MIB Block"></p>
<p><img src="/assets/images/tech/data-link-layer-lldp-state-machine-symbol.png" alt="SM Symbol"></p>
<p>至此，LLDP 相关知识点已经介绍完，希望对大家有所帮助。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>LLDP</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow -- 基准</title>
    <url>/2018-02-05-tensorflow-performance-benchmarks/</url>
    <content><![CDATA[<p>TensorFlow 社区创建了一系列用于多平台测试的图像分类模型参考点。在 <a href="#methodology">方法</a> 章节中会详细说明如何执行测试，并给出使用的脚本链接。</p>
<span id="more"></span>

<h2 id="图像分类模型的结果"><a href="#图像分类模型的结果" class="headerlink" title="图像分类模型的结果"></a>图像分类模型的结果</h2><p>InceptionV3 (<a href="https://arxiv.org/abs/1512.00567">arXiv:1512.00567</a>), ResNet-50<br>(<a href="https://arxiv.org/abs/1512.03385">arXiv:1512.03385</a>), ResNet-152<br>(<a href="https://arxiv.org/abs/1512.03385">arXiv:1512.03385</a>), VGG16<br>(<a href="https://arxiv.org/abs/1409.1556">arXiv:1409.1556</a>), 和<br><a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf">AlexNet</a> 使用 <a href="http://www.image-net.org/">ImageNet</a> 数据集测试。这些测试运行在 Google 计算云引擎，亚马逊计算云 (Amazon EC2) 和 NVIDIA® DGX-1™ 。大部分测试使用合成和真实的数据。</p>
<p>对合成数据的测试是通过使用一个 <code>tf.Variable</code> 设置相同的 shape，除了每个 ImageNet 模型。我们认为，当评估一个平台的基准时包含真实数据是很重要的。底层硬件和框架的加载测试是为了训练实际数据。我们开始合成数据用来移除磁盘 I&#x2F;O 作为一个变量，并设置一个基准。然后使用真实的数据来验证 TensorFlow 的输入和底层磁盘 I&#x2F;O 的计算单元。</p>
<h3 id="使用-NVIDIA®-DGX-1™-NVIDIA®-Tesla®-P100-训练"><a href="#使用-NVIDIA®-DGX-1™-NVIDIA®-Tesla®-P100-训练" class="headerlink" title="使用 NVIDIA® DGX-1™ (NVIDIA® Tesla® P100) 训练"></a>使用 NVIDIA® DGX-1™ (NVIDIA® Tesla® P100) 训练</h3><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">
  <img style="width:80%" src="https://www.tensorflow.org/images/perf_summary_p100_single_server.png">
</div>

<p>细节和附加结果在 <a href="#details_for_nvidia_dgx-1tm_nvidia_tesla_p100">NVIDIA® DGX-1™ (NVIDIA®<br>Tesla® P100) 的细节</a> 章节中。</p>
<h3 id="使用-NVIDIA®-Tesla®-K80-训练"><a href="#使用-NVIDIA®-Tesla®-K80-训练" class="headerlink" title="使用 NVIDIA® Tesla® K80 训练"></a>使用 NVIDIA® Tesla® K80 训练</h3><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">
  <img style="width:80%" src="https://www.tensorflow.org/images/perf_summary_k80_single_server.png">
</div>

<p>细节和附加结果在 <a href="#details_for_google_compute_engine_nvidia_tesla_k80">Google 计算引擎<br>(NVIDIA® Tesla® K80) 的细节</a> 和<br><a href="#details_for_amazon_ec2_nvidia_tesla_k80">Amazon EC2 (NVIDIA® Tesla®<br>K80) 的细节</a> 章节中。</p>
<h3 id="使用-NVIDIA®-Tesla®-K80-分布式训练"><a href="#使用-NVIDIA®-Tesla®-K80-分布式训练" class="headerlink" title="使用 NVIDIA® Tesla® K80 分布式训练"></a>使用 NVIDIA® Tesla® K80 分布式训练</h3><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">
  <img style="width:80%" src="https://www.tensorflow.org/images/perf_summary_k80_aws_distributed.png">
</div>

<p>细节和附加结果在 <a href="#details_for_amazon_ec2_distributed_nvidia_tesla_k80">分布式 Amazon EC2<br>(NVIDIA® Tesla® K80) 的细节</a><br>章节中。</p>
<h3 id="比较合成和真实训练数据"><a href="#比较合成和真实训练数据" class="headerlink" title="比较合成和真实训练数据"></a>比较合成和真实训练数据</h3><p><strong>NVIDIA® Tesla® P100</strong></p>
<div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">
  <img style="width:35%" src="https://www.tensorflow.org/images/perf_summary_p100_data_compare_inceptionv3.png">
  <img style="width:35%" src="https://www.tensorflow.org/images/perf_summary_p100_data_compare_resnet50.png">
</div>

<p><strong>NVIDIA® Tesla® K80</strong></p>
<div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">
  <img style="width:35%" src="https://www.tensorflow.org/images/perf_summary_k80_data_compare_inceptionv3.png">
  <img style="width:35%" src="https://www.tensorflow.org/images/perf_summary_k80_data_compare_resnet50.png">
</div>

<h2 id="NVIDIA®-DGX-1™-NVIDIA®-Tesla®-P100-的细节"><a href="#NVIDIA®-DGX-1™-NVIDIA®-Tesla®-P100-的细节" class="headerlink" title="NVIDIA® DGX-1™ (NVIDIA® Tesla® P100) 的细节"></a>NVIDIA® DGX-1™ (NVIDIA® Tesla® P100) 的细节</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><ul>
<li><strong>Instance type</strong>: NVIDIA® DGX-1™</li>
<li><strong>GPU:</strong> 8x NVIDIA® Tesla® P100</li>
<li><strong>OS:</strong> Ubuntu 16.04 LTS with tests run via Docker</li>
<li><strong>CUDA &#x2F; cuDNN:</strong> 8.0 &#x2F; 5.1</li>
<li><strong>TensorFlow GitHub hash:</strong> b1e174e</li>
<li><strong>Benchmark GitHub hash:</strong> 9165a70</li>
<li><strong>Build Command:</strong> <code>bazel build -c opt --copt=-march=&quot;haswell&quot; --config=cuda //tensorflow/tools/pip_package:build_pip_package</code></li>
<li><strong>Disk:</strong> Local SSD</li>
<li><strong>DataSet:</strong> ImageNet</li>
<li><strong>Test Date:</strong> May 2017</li>
</ul>
<p>每个模型的批处理大小和优化器如下表所示。除了下表所示的批处理大小，InceptionV3、ResNet-50、ResNet-152 和 VGG16 也用批处理大小为 32 进行测试。这些结果在 <em>其他结果</em> 章节。</p>
<table>
<thead>
<tr>
<th>Options</th>
<th>InceptionV3</th>
<th>ResNet-50</th>
<th>ResNet-152</th>
<th>AlexNet</th>
<th>VGG16</th>
</tr>
</thead>
<tbody><tr>
<td>Batch size per GPU</td>
<td>64</td>
<td>64</td>
<td>64</td>
<td>512</td>
<td>64</td>
</tr>
<tr>
<td>Optimizer</td>
<td>sgd</td>
<td>sgd</td>
<td>sgd</td>
<td>sgd</td>
<td>sgd</td>
</tr>
</tbody></table>
<p>用于每个模型的配置。</p>
<table>
<thead>
<tr>
<th>Model</th>
<th>variable_update</th>
<th>local_parameter_device</th>
</tr>
</thead>
<tbody><tr>
<td>InceptionV3</td>
<td>parameter_server</td>
<td>cpu</td>
</tr>
<tr>
<td>ResNet50</td>
<td>parameter_server</td>
<td>cpu</td>
</tr>
<tr>
<td>ResNet152</td>
<td>parameter_server</td>
<td>cpu</td>
</tr>
<tr>
<td>AlexNet</td>
<td>replicated (with NCCL)</td>
<td>n&#x2F;a</td>
</tr>
<tr>
<td>VGG16</td>
<td>replicated (with NCCL)</td>
<td>n&#x2F;a</td>
</tr>
</tbody></table>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">
  <img style="width:80%" src="https://www.tensorflow.org/images/perf_summary_p100_single_server.png">
</div>

<div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">
  <img style="width:35%" src="https://www.tensorflow.org/images/perf_dgx1_synth_p100_single_server_scaling.png">
  <img style="width:35%" src="https://www.tensorflow.org/images/perf_dgx1_real_p100_single_server_scaling.png">
</div>

<p><strong>训练合成数据</strong></p>
<table>
<thead>
<tr>
<th>GPUs</th>
<th>InceptionV3</th>
<th>ResNet-50</th>
<th>ResNet-152</th>
<th>AlexNet</th>
<th>VGG16</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>142</td>
<td>219</td>
<td>91.8</td>
<td>2987</td>
<td>154</td>
</tr>
<tr>
<td>2</td>
<td>284</td>
<td>422</td>
<td>181</td>
<td>5658</td>
<td>295</td>
</tr>
<tr>
<td>4</td>
<td>569</td>
<td>852</td>
<td>356</td>
<td>10509</td>
<td>584</td>
</tr>
<tr>
<td>8</td>
<td>1131</td>
<td>1734</td>
<td>716</td>
<td>17822</td>
<td>1081</td>
</tr>
</tbody></table>
<p><strong>训练真实数据</strong></p>
<table>
<thead>
<tr>
<th>GPUs</th>
<th>InceptionV3</th>
<th>ResNet-50</th>
<th>ResNet-152</th>
<th>AlexNet</th>
<th>VGG16</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>142</td>
<td>218</td>
<td>91.4</td>
<td>2890</td>
<td>154</td>
</tr>
<tr>
<td>2</td>
<td>278</td>
<td>425</td>
<td>179</td>
<td>4448</td>
<td>284</td>
</tr>
<tr>
<td>4</td>
<td>551</td>
<td>853</td>
<td>359</td>
<td>7105</td>
<td>534</td>
</tr>
<tr>
<td>8</td>
<td>1079</td>
<td>1630</td>
<td>708</td>
<td>N&#x2F;A</td>
<td>898</td>
</tr>
</tbody></table>
<p>从上图表可以看出，由于最大输入的限制，AlexNet 模型没有使用 8 个 GPU 来训练数据。</p>
<h3 id="其他结果"><a href="#其他结果" class="headerlink" title="其他结果"></a>其他结果</h3><p>以下是批处理大小为 32 的结果。</p>
<p><strong>训练合成数据</strong></p>
<table>
<thead>
<tr>
<th>GPUs</th>
<th>InceptionV3</th>
<th>ResNet-50</th>
<th>ResNet-152</th>
<th>VGG16</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>128</td>
<td>195</td>
<td>82.7</td>
<td>144</td>
</tr>
<tr>
<td>2</td>
<td>259</td>
<td>368</td>
<td>160</td>
<td>281</td>
</tr>
<tr>
<td>4</td>
<td>520</td>
<td>768</td>
<td>317</td>
<td>549</td>
</tr>
<tr>
<td>8</td>
<td>995</td>
<td>1485</td>
<td>632</td>
<td>820</td>
</tr>
</tbody></table>
<p><strong>训练真实数据</strong></p>
<table>
<thead>
<tr>
<th>GPUs</th>
<th>InceptionV3</th>
<th>ResNet-50</th>
<th>ResNet-152</th>
<th>VGG16</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>130</td>
<td>193</td>
<td>82.4</td>
<td>144</td>
</tr>
<tr>
<td>2</td>
<td>257</td>
<td>369</td>
<td>159</td>
<td>253</td>
</tr>
<tr>
<td>4</td>
<td>507</td>
<td>760</td>
<td>317</td>
<td>457</td>
</tr>
<tr>
<td>8</td>
<td>966</td>
<td>1410</td>
<td>609</td>
<td>690</td>
</tr>
</tbody></table>
<h2 id="Google-Compute-Engine-NVIDIA®-Tesla®-K80-的细节"><a href="#Google-Compute-Engine-NVIDIA®-Tesla®-K80-的细节" class="headerlink" title="Google Compute Engine (NVIDIA® Tesla® K80) 的细节"></a>Google Compute Engine (NVIDIA® Tesla® K80) 的细节</h2><h3 id="环境配置-1"><a href="#环境配置-1" class="headerlink" title="环境配置"></a>环境配置</h3><ul>
<li><strong>Instance type</strong>: n1-standard-32-k80x8</li>
<li><strong>GPU:</strong> 8x NVIDIA® Tesla® K80</li>
<li><strong>OS:</strong> Ubuntu 16.04 LTS</li>
<li><strong>CUDA &#x2F; cuDNN:</strong> 8.0 &#x2F; 5.1</li>
<li><strong>TensorFlow GitHub hash:</strong> b1e174e</li>
<li><strong>Benchmark GitHub hash:</strong> 9165a70</li>
<li><strong>Build Command:</strong> <code>bazel build -c opt --copt=-march=&quot;haswell&quot; --config=cuda //tensorflow/tools/pip_package:build_pip_package</code></li>
<li><strong>Disk:</strong> 1.7 TB Shared SSD persistent disk (800 MB&#x2F;s)</li>
<li><strong>DataSet:</strong> ImageNet</li>
<li><strong>Test Date:</strong> May 2017</li>
</ul>
<p>每个模型的批处理大小和优化器如下表所示。除了下表所示的批处理大小，InceptionV3 和 ResNet-50 也用批处理大小为 32 进行测试。这些结果在 <em>其他结果</em> 章节。</p>
<table>
<thead>
<tr>
<th>Options</th>
<th>InceptionV3</th>
<th>ResNet-50</th>
<th>ResNet-152</th>
<th>AlexNet</th>
<th>VGG16</th>
</tr>
</thead>
<tbody><tr>
<td>Batch size per GPU</td>
<td>64</td>
<td>64</td>
<td>32</td>
<td>512</td>
<td>32</td>
</tr>
<tr>
<td>Optimizer</td>
<td>sgd</td>
<td>sgd</td>
<td>sgd</td>
<td>sgd</td>
<td>sgd</td>
</tr>
</tbody></table>
<p>每个模型所用的配置中， variable_update 和 parameter_server 配置相同，local_parameter_device 和 cpu 配置相同。</p>
<h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">
  <img style="width:35%" src="https://www.tensorflow.org/images/perf_gce_synth_k80_single_server_scaling.png">
  <img style="width:35%" src="https://www.tensorflow.org/images/perf_gce_real_k80_single_server_scaling.png">
</div>

<p><strong>训练合成数据</strong></p>
<table>
<thead>
<tr>
<th>GPUs</th>
<th>InceptionV3</th>
<th>ResNet-50</th>
<th>ResNet-152</th>
<th>AlexNet</th>
<th>VGG16</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>30.5</td>
<td>51.9</td>
<td>20.0</td>
<td>656</td>
<td>35.4</td>
</tr>
<tr>
<td>2</td>
<td>57.8</td>
<td>99.0</td>
<td>38.2</td>
<td>1209</td>
<td>64.8</td>
</tr>
<tr>
<td>4</td>
<td>116</td>
<td>195</td>
<td>75.8</td>
<td>2328</td>
<td>120</td>
</tr>
<tr>
<td>8</td>
<td>227</td>
<td>387</td>
<td>148</td>
<td>4640</td>
<td>234</td>
</tr>
</tbody></table>
<p><strong>训练真实数据</strong></p>
<table>
<thead>
<tr>
<th>GPUs</th>
<th>InceptionV3</th>
<th>ResNet-50</th>
<th>ResNet-152</th>
<th>AlexNet</th>
<th>VGG16</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>30.6</td>
<td>51.2</td>
<td>20.0</td>
<td>639</td>
<td>34.2</td>
</tr>
<tr>
<td>2</td>
<td>58.4</td>
<td>98.8</td>
<td>38.3</td>
<td>1136</td>
<td>62.9</td>
</tr>
<tr>
<td>4</td>
<td>115</td>
<td>194</td>
<td>75.4</td>
<td>2067</td>
<td>118</td>
</tr>
<tr>
<td>8</td>
<td>225</td>
<td>381</td>
<td>148</td>
<td>4056</td>
<td>230</td>
</tr>
</tbody></table>
<h3 id="其他结果-1"><a href="#其他结果-1" class="headerlink" title="其他结果"></a>其他结果</h3><p><strong>训练合成数据</strong></p>
<table>
<thead>
<tr>
<th>GPUs</th>
<th>InceptionV3 (batch size 32)</th>
<th>ResNet-50 (batch size 32)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>29.3</td>
<td>49.5</td>
</tr>
<tr>
<td>2</td>
<td>55.0</td>
<td>95.4</td>
</tr>
<tr>
<td>4</td>
<td>109</td>
<td>183</td>
</tr>
<tr>
<td>8</td>
<td>216</td>
<td>362</td>
</tr>
</tbody></table>
<p><strong>训练真实数据</strong></p>
<table>
<thead>
<tr>
<th>GPUs</th>
<th>InceptionV3 (batch size 32)</th>
<th>ResNet-50 (batch size 32)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>29.5</td>
<td>49.3</td>
</tr>
<tr>
<td>2</td>
<td>55.4</td>
<td>95.3</td>
</tr>
<tr>
<td>4</td>
<td>110</td>
<td>186</td>
</tr>
<tr>
<td>8</td>
<td>216</td>
<td>359</td>
</tr>
</tbody></table>
<h2 id="Amazon-EC2-NVIDIA®-Tesla®-K80-的细节"><a href="#Amazon-EC2-NVIDIA®-Tesla®-K80-的细节" class="headerlink" title="Amazon EC2 (NVIDIA® Tesla® K80) 的细节"></a>Amazon EC2 (NVIDIA® Tesla® K80) 的细节</h2><h3 id="环境配置-2"><a href="#环境配置-2" class="headerlink" title="环境配置"></a>环境配置</h3><ul>
<li><strong>Instance type</strong>: p2.8xlarge</li>
<li><strong>GPU:</strong> 8x NVIDIA® Tesla® K80</li>
<li><strong>OS:</strong> Ubuntu 16.04 LTS</li>
<li><strong>CUDA &#x2F; cuDNN:</strong> 8.0 &#x2F; 5.1</li>
<li><strong>TensorFlow GitHub hash:</strong> b1e174e</li>
<li><strong>Benchmark GitHub hash:</strong> 9165a70</li>
<li><strong>Build Command:</strong> <code>bazel build -c opt --copt=-march=&quot;haswell&quot; --config=cuda //tensorflow/tools/pip_package:build_pip_package</code></li>
<li><strong>Disk:</strong> 1TB Amazon EFS (burst 100 MiB&#x2F;sec for 12 hours, continuous 50<br>MiB&#x2F;sec)</li>
<li><strong>DataSet:</strong> ImageNet</li>
<li><strong>Test Date:</strong> May 2017</li>
</ul>
<p>每个模型的批处理大小和优化器如下表所示。除了下表所示的批处理大小，InceptionV3 和 ResNet-50 也用批处理大小为 32 进行测试。这些结果在 <em>其他结果</em> 章节。</p>
<table>
<thead>
<tr>
<th>Options</th>
<th>InceptionV3</th>
<th>ResNet-50</th>
<th>ResNet-152</th>
<th>AlexNet</th>
<th>VGG16</th>
</tr>
</thead>
<tbody><tr>
<td>Batch size per GPU</td>
<td>64</td>
<td>64</td>
<td>32</td>
<td>512</td>
<td>32</td>
</tr>
<tr>
<td>Optimizer</td>
<td>sgd</td>
<td>sgd</td>
<td>sgd</td>
<td>sgd</td>
<td>sgd</td>
</tr>
</tbody></table>
<p>用于每个模型的配置。</p>
<table>
<thead>
<tr>
<th>Model</th>
<th>variable_update</th>
<th>local_parameter_device</th>
</tr>
</thead>
<tbody><tr>
<td>InceptionV3</td>
<td>parameter_server</td>
<td>cpu</td>
</tr>
<tr>
<td>ResNet-50</td>
<td>replicated (without NCCL)</td>
<td>gpu</td>
</tr>
<tr>
<td>ResNet-152</td>
<td>replicated (without NCCL)</td>
<td>gpu</td>
</tr>
<tr>
<td>AlexNet</td>
<td>parameter_server</td>
<td>gpu</td>
</tr>
<tr>
<td>VGG16</td>
<td>parameter_server</td>
<td>gpu</td>
</tr>
</tbody></table>
<h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">
  <img style="width:35%" src="https://www.tensorflow.org/images/perf_aws_synth_k80_single_server_scaling.png">
  <img style="width:35%" src="https://www.tensorflow.org/images/perf_aws_real_k80_single_server_scaling.png">
</div>

<p><strong>训练合成数据</strong></p>
<table>
<thead>
<tr>
<th>GPUs</th>
<th>InceptionV3</th>
<th>ResNet-50</th>
<th>ResNet-152</th>
<th>AlexNet</th>
<th>VGG16</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>30.8</td>
<td>51.5</td>
<td>19.7</td>
<td>684</td>
<td>36.3</td>
</tr>
<tr>
<td>2</td>
<td>58.7</td>
<td>98.0</td>
<td>37.6</td>
<td>1244</td>
<td>69.4</td>
</tr>
<tr>
<td>4</td>
<td>117</td>
<td>195</td>
<td>74.9</td>
<td>2479</td>
<td>141</td>
</tr>
<tr>
<td>8</td>
<td>230</td>
<td>384</td>
<td>149</td>
<td>4853</td>
<td>260</td>
</tr>
</tbody></table>
<p><strong>训练真实数据</strong></p>
<table>
<thead>
<tr>
<th>GPUs</th>
<th>InceptionV3</th>
<th>ResNet-50</th>
<th>ResNet-152</th>
<th>AlexNet</th>
<th>VGG16</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>30.5</td>
<td>51.3</td>
<td>19.7</td>
<td>674</td>
<td>36.3</td>
</tr>
<tr>
<td>2</td>
<td>59.0</td>
<td>94.9</td>
<td>38.2</td>
<td>1227</td>
<td>67.5</td>
</tr>
<tr>
<td>4</td>
<td>118</td>
<td>188</td>
<td>75.2</td>
<td>2201</td>
<td>136</td>
</tr>
<tr>
<td>8</td>
<td>228</td>
<td>373</td>
<td>149</td>
<td>N&#x2F;A</td>
<td>242</td>
</tr>
</tbody></table>
<p>由于我们的 EFS 没有提供足够的吞吐量，上面的图表中我们排出了使用 8 个 GPU 来训练 AlexNet 模型的统计。</p>
<h3 id="其他结果-2"><a href="#其他结果-2" class="headerlink" title="其他结果"></a>其他结果</h3><p><strong>训练合成数据</strong></p>
<table>
<thead>
<tr>
<th>GPUs</th>
<th>InceptionV3 (batch size 32)</th>
<th>ResNet-50 (batch size 32)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>29.9</td>
<td>49.0</td>
</tr>
<tr>
<td>2</td>
<td>57.5</td>
<td>94.1</td>
</tr>
<tr>
<td>4</td>
<td>114</td>
<td>184</td>
</tr>
<tr>
<td>8</td>
<td>216</td>
<td>355</td>
</tr>
</tbody></table>
<p><strong>训练真实数据</strong></p>
<table>
<thead>
<tr>
<th>GPUs</th>
<th>InceptionV3 (batch size 32)</th>
<th>ResNet-50 (batch size 32)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>30.0</td>
<td>49.1</td>
</tr>
<tr>
<td>2</td>
<td>57.5</td>
<td>95.1</td>
</tr>
<tr>
<td>4</td>
<td>113</td>
<td>185</td>
</tr>
<tr>
<td>8</td>
<td>212</td>
<td>353</td>
</tr>
</tbody></table>
<h2 id="Amazon-EC2-Distributed-NVIDIA®-Tesla®-K80-的细节"><a href="#Amazon-EC2-Distributed-NVIDIA®-Tesla®-K80-的细节" class="headerlink" title="Amazon EC2 Distributed (NVIDIA® Tesla® K80) 的细节"></a>Amazon EC2 Distributed (NVIDIA® Tesla® K80) 的细节</h2><h3 id="环境配置-3"><a href="#环境配置-3" class="headerlink" title="环境配置"></a>环境配置</h3><ul>
<li><strong>Instance type</strong>: p2.8xlarge</li>
<li><strong>GPU:</strong> 8x NVIDIA® Tesla® K80</li>
<li><strong>OS:</strong> Ubuntu 16.04 LTS</li>
<li><strong>CUDA &#x2F; cuDNN:</strong> 8.0 &#x2F; 5.1</li>
<li><strong>TensorFlow GitHub hash:</strong> b1e174e</li>
<li><strong>Benchmark GitHub hash:</strong> 9165a70</li>
<li><strong>Build Command:</strong> <code>bazel build -c opt --copt=-march=&quot;haswell&quot; --config=cuda //tensorflow/tools/pip_package:build_pip_package</code></li>
<li><strong>Disk:</strong> 1.0 TB EFS (burst 100 MB&#x2F;sec for 12 hours, continuous 50 MB&#x2F;sec)</li>
<li><strong>DataSet:</strong> ImageNet</li>
<li><strong>Test Date:</strong> May 2017</li>
</ul>
<p>每个模型的批处理大小和优化器如下表所示。除了下表所示的批处理大小，InceptionV3 和 ResNet-50 也用批处理大小为 32 进行测试。这些结果在 <em>其他结果</em> 章节。</p>
<table>
<thead>
<tr>
<th>Options</th>
<th>InceptionV3</th>
<th>ResNet-50</th>
<th>ResNet-152</th>
</tr>
</thead>
<tbody><tr>
<td>Batch size per GPU</td>
<td>64</td>
<td>64</td>
<td>32</td>
</tr>
<tr>
<td>Optimizer</td>
<td>sgd</td>
<td>sgd</td>
<td>sgd</td>
</tr>
</tbody></table>
<p>用于每个模型的配置。</p>
<table>
<thead>
<tr>
<th>Model</th>
<th>variable_update</th>
<th>local_parameter_device</th>
<th>cross_replica_sync</th>
</tr>
</thead>
<tbody><tr>
<td>InceptionV3</td>
<td>distributed_replicated</td>
<td>n&#x2F;a</td>
<td>True</td>
</tr>
<tr>
<td>ResNet-50</td>
<td>distributed_replicated</td>
<td>n&#x2F;a</td>
<td>True</td>
</tr>
<tr>
<td>ResNet-152</td>
<td>distributed_replicated</td>
<td>n&#x2F;a</td>
<td>True</td>
</tr>
</tbody></table>
<p>为了简化服务器设置，EC2 实例（p2.8xlarge）运行了 worker 服务器和 parameter 服务器。相同数量的 worker 服务器和 parameter 服务器使用了下述的配置：</p>
<ul>
<li>InceptionV3: 8 instances &#x2F; 6 parameter servers</li>
<li>ResNet-50: (batch size 32) 8 instances &#x2F; 4 parameter servers</li>
<li>ResNet-152: 8 instances &#x2F; 4 parameter servers</li>
</ul>
<h3 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h3><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">
  <img style="width:80%" src="https://www.tensorflow.org/images/perf_summary_k80_aws_distributed.png">
</div>

<div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">
  <img style="width:70%" src="https://www.tensorflow.org/images/perf_aws_synth_k80_distributed_scaling.png">
</div>

<p><strong>训练合成数据</strong></p>
<table>
<thead>
<tr>
<th>GPUs</th>
<th>InceptionV3</th>
<th>ResNet-50</th>
<th>ResNet-152</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>29.7</td>
<td>52.4</td>
<td>19.4</td>
</tr>
<tr>
<td>8</td>
<td>229</td>
<td>378</td>
<td>146</td>
</tr>
<tr>
<td>16</td>
<td>459</td>
<td>751</td>
<td>291</td>
</tr>
<tr>
<td>32</td>
<td>902</td>
<td>1388</td>
<td>565</td>
</tr>
<tr>
<td>64</td>
<td>1783</td>
<td>2744</td>
<td>981</td>
</tr>
</tbody></table>
<h3 id="其他结果-3"><a href="#其他结果-3" class="headerlink" title="其他结果"></a>其他结果</h3><div style="width:95%; margin:auto; margin-bottom:10px; margin-top:20px;">
  <img style="width:50%" src="https://www.tensorflow.org/images/perf_aws_synth_k80_multi_server_batch32.png">
</div>

<p><strong>训练合成数据</strong></p>
<table>
<thead>
<tr>
<th>GPUs</th>
<th>InceptionV3 (batch size 32)</th>
<th>ResNet-50 (batch size 32)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>29.2</td>
<td>48.4</td>
</tr>
<tr>
<td>8</td>
<td>219</td>
<td>333</td>
</tr>
<tr>
<td>16</td>
<td>427</td>
<td>667</td>
</tr>
<tr>
<td>32</td>
<td>820</td>
<td>1180</td>
</tr>
<tr>
<td>64</td>
<td>1608</td>
<td>2315</td>
</tr>
</tbody></table>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>上述结果是使用该 <a href="https://github.com/tensorflow/benchmarks/tree/master/scripts/tf_cnn_benchmarks">脚本</a> 运行在各种平台上而生成。<a href="https://www.tensorflow.org/performance/performance_models">《High-Performance Models》</a> 文章详细描述了脚本中的技术，以及如何执行脚本的示例。</p>
<p>为了创建尽可能重复的结果，每个测试运行 5 次，然后取平均值。在给定的平台上，GPU 是在默认状态下运行的。对于 NVIDIA® Tesla® K80 来说这意味着不使用 <a href="https://devblogs.nvidia.com/parallelforall/increase-performance-gpu-boost-k80-autoboost/">GPU<br>Boost</a>。</p>
<p>对于每个测试，需要完成 10 次预热，然后再平均完成 100 次测试。</p>
<blockquote>
<ul>
<li>原文地址：<a href="https://www.tensorflow.org/performance/benchmarks">https://www.tensorflow.org/performance/benchmarks</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner">掘金翻译计划</a></li>
<li>译者：<a href="https://github.com/charsdavy">charsdavy</a></li>
<li>校对者：<a href="https://github.com/joyking7">joyking7</a></li>
</ul>
</blockquote>
<blockquote>
<p><a href="https://github.com/xitu/gold-miner">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im/">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android">Android</a>、<a href="https://github.com/xitu/gold-miner#ios">iOS</a>、<a href="https://github.com/xitu/gold-miner#%E5%89%8D%E7%AB%AF">前端</a>、<a href="https://github.com/xitu/gold-miner#%E5%90%8E%E7%AB%AF">后端</a>、<a href="https://github.com/xitu/gold-miner#%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%A7%E5%93%81">产品</a>、<a href="https://github.com/xitu/gold-miner#%E8%AE%BE%E8%AE%A1">设计</a>、<a href="https://github.com/xitu/gold-miner#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi">知乎专栏</a>。</p>
</blockquote>
]]></content>
      <categories>
        <category>ml</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
        <tag>机器学习</tag>
        <tag>性能</tag>
        <tag>掘金翻译计划</tag>
      </tags>
  </entry>
  <entry>
    <title>CocoaPods 提交代码踩坑</title>
    <url>/2018-07-16-cocoapods-source-commit/</url>
    <content><![CDATA[<p>如何提交代码至 CocoaPods？这个问题在 Google 一搜索可以有很多文章出来，不过，其中遇到的坑却无人提及。笔者现在将实际操作工程记录如下，并总结踩坑注意事项：操作顺序、文件配置、命令使用。</p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h3><p>将需要提交至 CocoaPods 的代码提交至代码托管服务器，例如：GitHub。</p>
<p>这里需要注意的是，提交的代码需要包含 <code>tag</code> 标签。其实就是 git 里面的 <code>git tag</code>。</p>
<h3 id="安装或更新-CocoaPods"><a href="#安装或更新-CocoaPods" class="headerlink" title="安装或更新 CocoaPods"></a>安装或更新 CocoaPods</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gem install cocoapods</span><br></pre></td></tr></table></figure>

<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod update</span><br></pre></td></tr></table></figure>

<h3 id="注册-Trunk"><a href="#注册-Trunk" class="headerlink" title="注册 Trunk"></a>注册 Trunk</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod trunk register e_mail_address <span class="string">&#x27;your_name&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>记得去注册邮箱激活</p>
<h4 id="查看注册信息"><a href="#查看注册信息" class="headerlink" title="查看注册信息"></a>查看注册信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod trunk me</span><br><span class="line"></span><br><span class="line">  - Name:     charsdavy</span><br><span class="line">  - Email:    chars.davy@gmail.com</span><br><span class="line">  - Since:    July 15th, 21:38</span><br><span class="line">  - Pods:</span><br><span class="line">    - JCCNavigationController</span><br><span class="line">  - Sessions:</span><br><span class="line">    - July 15th, 21:38 - November 21st, 01:45. IP: xx.xx.xx.xx</span><br></pre></td></tr></table></figure>

<h2 id="创建-podspec-文件"><a href="#创建-podspec-文件" class="headerlink" title="创建 .podspec 文件"></a>创建 .podspec 文件</h2><p><code>.podspec</code> 文件的作用是为了让 CocoaPods 搜索引擎知道该代码的作者、版本号、概要、描述、源代码地址、部署版本、依赖的框架等描述信息。 </p>
<p><code>.podspec</code>文件可以自动生成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod spec create JCCNavigationController // 生成 JCCNavigationController.podspec 文件</span><br></pre></td></tr></table></figure>

<p><code>JCCNavigationController.podspec</code> 文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">#  Be sure to run `pod spec lint JCCNavigationController.podspec&#x27; to ensure this is a</span><br><span class="line">#  valid spec and to remove all comments including this before submitting the spec.</span><br><span class="line">#</span><br><span class="line">#  To learn more about Podspec attributes see http://docs.cocoapods.org/specification.html</span><br><span class="line">#  To see working Podspecs in the CocoaPods repo see https://github.com/CocoaPods/Specs/</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">Pod::Spec.new do |s|</span><br><span class="line"></span><br><span class="line">  # ―――  Spec Metadata  ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  These will help people to find your library, and whilst it</span><br><span class="line">  #  can feel like a chore to fill in it&#x27;s definitely to your advantage. The</span><br><span class="line">  #  summary should be tweet-length, and the description more in depth.</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  s.name         = &quot;JCCNavigationController&quot;</span><br><span class="line">  s.version      = &quot;1.0&quot;</span><br><span class="line">  s.summary      = &quot;A navigation bar integrated transition animation effect.&quot;</span><br><span class="line"></span><br><span class="line">  # This description is used to generate tags and improve search results.</span><br><span class="line">  #   * Think: What does it do? Why did you write it? What is the focus?</span><br><span class="line">  #   * Try to keep it short, snappy and to the point.</span><br><span class="line">  #   * Write the description between the DESC delimiters below.</span><br><span class="line">  #   * Finally, don&#x27;t worry about the indent, CocoaPods strips it!</span><br><span class="line">  s.description  = &lt;&lt;-DESC</span><br><span class="line">                  With zoom interactive animation, A navigation bar integrated transition animation effect.</span><br><span class="line">                  DESC</span><br><span class="line"></span><br><span class="line">  s.homepage     = &quot;https://github.com/charsdavy/JCCNavigationController&quot;</span><br><span class="line">  s.screenshots  = &quot;https://raw.githubusercontent.com/charsdavy/JCCNavigationController/master/Screenshot.gif&quot;</span><br><span class="line">  # s.screenshots  = &quot;www.example.com/screenshots_1.gif&quot;, &quot;www.example.com/screenshots_2.gif&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # ―――  Spec License  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  Licensing your code is important. See http://choosealicense.com for more info.</span><br><span class="line">  #  CocoaPods will detect a license file if there is a named LICENSE*</span><br><span class="line">  #  Popular ones are &#x27;MIT&#x27;, &#x27;BSD&#x27; and &#x27;Apache License, Version 2.0&#x27;.</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; &#125;</span><br><span class="line">  # s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # ――― Author Metadata  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  Specify the authors of the library, with email addresses. Email addresses</span><br><span class="line">  #  of the authors are extracted from the SCM log. E.g. $ git log. CocoaPods also</span><br><span class="line">  #  accepts just a name if you&#x27;d rather not provide an email address.</span><br><span class="line">  #</span><br><span class="line">  #  Specify a social_media_url where others can refer to, for example a twitter</span><br><span class="line">  #  profile URL.</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  s.author             = &#123; &quot;charsdavy&quot; =&gt; &quot;charsdavy@gamil.com&quot; &#125;</span><br><span class="line">  s.social_media_url   = &quot;https://twitter.com/charsdavy&quot;</span><br><span class="line"></span><br><span class="line">  s.swift_version = &quot;4.0&quot;</span><br><span class="line">  # ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  If this Pod runs only on iOS or OS X, then specify the platform and</span><br><span class="line">  #  the deployment target. You can optionally include the target after the platform.</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  s.platform     = :ios</span><br><span class="line">  s.platform     = :ios, &quot;8.0&quot;</span><br><span class="line"></span><br><span class="line">  #  When using multiple platforms</span><br><span class="line">  s.ios.deployment_target = &quot;8.0&quot;</span><br><span class="line">  # s.osx.deployment_target = &quot;10.7&quot;</span><br><span class="line">  # s.watchos.deployment_target = &quot;2.0&quot;</span><br><span class="line">  # s.tvos.deployment_target = &quot;9.0&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  Specify the location from where the source should be retrieved.</span><br><span class="line">  #  Supports git, hg, bzr, svn and HTTP.</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  s.source       = &#123; :git =&gt; &quot;https://github.com/charsdavy/JCCNavigationController.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  CocoaPods is smart about how it includes source code. For source files</span><br><span class="line">  #  giving a folder will include any swift, h, m, mm, c &amp; cpp files.</span><br><span class="line">  #  For header files it will include any header in the folder.</span><br><span class="line">  #  Not including the public_header_files will make all headers public.</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  s.source_files  = &quot;JCCNavigationController/*.swift&quot;</span><br><span class="line">  # s.exclude_files = &quot;Classes/Exclude&quot;</span><br><span class="line"></span><br><span class="line">  # s.public_header_files = &quot;Classes/**/*.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # ――― Resources ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  A list of resources included with the Pod. These are copied into the</span><br><span class="line">  #  target bundle with a build phase script. Anything else will be cleaned.</span><br><span class="line">  #  You can preserve files from being cleaned, please don&#x27;t preserve</span><br><span class="line">  #  non-essential files like tests, examples and documentation.</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  # s.resource  = &quot;icon.png&quot;</span><br><span class="line">  # s.resources = &quot;Resources/*.png&quot;</span><br><span class="line"></span><br><span class="line">  # s.preserve_paths = &quot;FilesToSave&quot;, &quot;MoreFilesToSave&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # ――― Project Linking ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  Link your library with frameworks, or libraries. Libraries do not include</span><br><span class="line">  #  the lib prefix of their name.</span><br><span class="line">  #</span><br><span class="line"></span><br><span class="line">  # s.framework  = &quot;SomeFramework&quot;</span><br><span class="line">  # s.frameworks = &quot;SomeFramework&quot;, &quot;AnotherFramework&quot;</span><br><span class="line"></span><br><span class="line">  # s.library   = &quot;iconv&quot;</span><br><span class="line">  # s.libraries = &quot;iconv&quot;, &quot;xml2&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #</span><br><span class="line">  #</span><br><span class="line">  #  If your library depends on compiler flags you can set them in the xcconfig hash</span><br><span class="line">  #  where they will only apply to your library. If you depend on other Podspecs</span><br><span class="line">  #  you can include multiple dependencies to ensure it works.</span><br><span class="line"></span><br><span class="line">  # s.requires_arc = true</span><br><span class="line"></span><br><span class="line">  # s.xcconfig = &#123; &quot;HEADER_SEARCH_PATHS&quot; =&gt; &quot;$(SDKROOT)/usr/include/libxml2&quot; &#125;</span><br><span class="line">  # s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>以上文件，需要注意 <code>s.platform</code> 这个字段，文本中的注释说的很明白，默认是全平台都支持的，如果只支持某一个平台，则需要细心配置完善。</p>
<h2 id="验证-podspec-文件是否合法"><a href="#验证-podspec-文件是否合法" class="headerlink" title="验证 .podspec 文件是否合法"></a>验证 <code>.podspec</code> 文件是否合法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod spec lint JCCNavigationController.podspec</span><br></pre></td></tr></table></figure>

<p>如果配置文件仍存在错误，则根据错误提示修复错误。</p>
<p>如果只有以下一个错误，则只需提交代码即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ERROR | unknown: Encountered an unknown error (uninitialized constant REST::DisconnectedError) during validation.</span><br></pre></td></tr></table></figure>

<h2 id="提交-podspec-文件"><a href="#提交-podspec-文件" class="headerlink" title="提交 .podspec 文件"></a>提交 <code>.podspec</code> 文件</h2><p>将 <code>.podspec</code> 文件提交至代码托管服务器，例如，将 <code>JCCNavigationController.podspec</code> 文件提交至 <code>JCCNavigationController</code> 项目。</p>
<h2 id="提交代码至-CocoaPods"><a href="#提交代码至-CocoaPods" class="headerlink" title="提交代码至 CocoaPods"></a>提交代码至 CocoaPods</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pod trunk push JCCNavigationController.podspec --allow-warnings</span><br></pre></td></tr></table></figure>

<p>返回以下信息则为成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"> 🎉  Congrats</span><br><span class="line"></span><br><span class="line"> 🚀  JCCNavigationController (1.0) successfully published</span><br><span class="line"> 📅  July 16th, 00:58</span><br><span class="line"> 🌎  https://cocoapods.org/pods/JCCNavigationController</span><br><span class="line"> 👍  Tell your friends!</span><br><span class="line">--------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="JCCNavigationController"><a href="#JCCNavigationController" class="headerlink" title="JCCNavigationController"></a><a href="https://github.com/charsdavy/JCCNavigationController">JCCNavigationController</a></h3><p><a href="https://github.com/charsdavy/JCCNavigationController">JCCNavigationController</a>，一种导航栏一体化转场动画效果。</p>
<p><img src="https://raw.githubusercontent.com/charsdavy/JCCNavigationController/master/Screenshot.gif" alt="JCCNavigationController"></p>
<h3 id="DDCornerRadius"><a href="#DDCornerRadius" class="headerlink" title="DDCornerRadius"></a><a href="https://github.com/charsdavy/JCCNavigationController">DDCornerRadius</a></h3><p><a href="https://github.com/charsdavy/DDCornerRadius">DDCornerRadius</a>，优化圆角实现方案，避免离屏渲染。</p>
<p><img src="https://raw.githubusercontent.com/charsdavy/DDCornerRadius/master/Screenshot.gif" alt="DDCornerRadius"></p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>cocoapods</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个 RESTful API 服务器</title>
    <url>/2018-07-31-restful-api-go/</url>
    <content><![CDATA[<p>RESTful 是目前最为流行的一种互联网软件结构。因为它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p>
<span id="more"></span>

<h2 id="什么是-REST"><a href="#什么是-REST" class="headerlink" title="什么是 REST"></a>什么是 REST</h2><p>REST（REpresentational State Transfer），首次出现在 2000 年 Roy Thomas Fielding 的博士论文中，它指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful 的。</p>
<ul>
<li>资源（Resources），REST 是“表现层状态转化”，其实它省略了主语。“表现层”其实指的是“资源”的“表现层”。那么什么是资源呢？我们平时网上访问到图片、文字、文档、多媒体等就是资源，一般通过 URI 来定位。也就是说，一个 URI 就表示一个资源。</li>
<li>表现层（Representation），资源是作为一个具体的实体信息，它可以有多种的展现方式。而把实体展现出来就是表现层。例如一个 txt 文本信息，它可以输出成 html、json 等。</li>
<li>状态转化（State Transfer），访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，就涉及到数据和状态的变化。而 HTTP 协议是无状态的，那么这些状态肯定保存在服务器端，所以如果客户端想要通知服务器端改变数据和状态的变化，就要通过某种方式来通知它。客户端能通知服务器端的手段，只能是 HTTP 协议。具体来说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源。</li>
</ul>
<p>综上所述，我们总结一下什么是 RESTful 架构：</p>
<p>1、每一个 URI 代表一种资源</p>
<p>2、客户端和服务端之间，传递这种资源的某种表现层</p>
<p>3、客户端通过四个 HTTP 动词，对服务端资源进行操作，实现“表现层状态转化”</p>
<p>将它们概述为图片形式，则 REST 架构图为：</p>
<p><img src="/assets/images/tech/restful-api-go-REST-struct.png" alt="REST架构图"></p>
<p>REST 的扩展性：</p>
<p><img src="/assets/images/tech/restful-api-go-REST-extern.png" alt="REST 的扩展性"></p>
<h2 id="什么是-RPC"><a href="#什么是-RPC" class="headerlink" title="什么是 RPC"></a>什么是 RPC</h2><p>RPC（Remote Procedure Call Protocol）远程过程调用协议，是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。它假定某些传输协议的存在，如 TCP 或 UDP，以便为通信程序之间携带信息数据。通过它可以使函数调用模式网络化。在 OSI 网络通信模型中，RPC 跨越了传输层和应用层。RPC 使得开发包括网络分布式多程序在内的应用程序更加容易。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="/assets/images/tech/restful-api-go-RPC-flow.png" alt="RPC工作流程图"></p>
<p>运行时，一次客户端对服务器的 RPC 调用，其内部操作大致有如下步骤：</p>
<p>1、调用客户端句柄；执行传送参数</p>
<p>2、调用本地系统内核发送网络消息</p>
<p>3、消息传送到服务端</p>
<p>4、服务器句柄得到消息并取得参数</p>
<p>5、执行远程过程</p>
<p>6、执行的过程将结果返回服务器句柄</p>
<p>7、服务器句柄返回结果，调用远程系统内核</p>
<p>8、消息传回本地主机</p>
<p>9、客户端句柄由内核接收消息</p>
<p>10、客户端接收句柄返回的数据</p>
<h2 id="REST-vs-RPC"><a href="#REST-vs-RPC" class="headerlink" title="REST vs RPC"></a>REST vs RPC</h2><p>在做 API 服务器开发时，很多人都会遇到这个问题 —— 选择 REST 还是 RPC。RPC 相比 REST 的优点主要有 3 点：</p>
<p>1、RPC+Protobuf 采用的是 TCP 做传输协议，REST 直接使用 HTTP 做应用层协议，这种区别导致 REST 在调用性能上会比 RPC+Protobuf 低</p>
<p>2、RPC 不像 REST 那样，每一个操作都要抽象成对资源的增删改查，在实际开发中，有很多操作很难抽象成资源，比如登录操作。所以在实际开发中并不能严格按照 REST 规范来写 API，RPC 就不存在这个问题</p>
<p>3、RPC 屏蔽网络细节、易用，和本地调用类似</p>
<p>但是 REST 相较 RPC 也有很多优势：</p>
<p>1、轻量级，简单易用，维护性和扩展性都比较好</p>
<p>2、REST 相对更规范，更标准，更通用，无论哪种语言都支持 HTTP 协议，可以对接外部很多系统，只要满足 HTTP 调用即可，更适合对外，RPC 会有语言限制，不同语言的 RPC 调用起来很麻烦</p>
<p>3、JSON 格式可读性更强，开发调试都很方便</p>
<p>4、在开发过程中，如果严格按照 REST 规范来写 API，API 看起来更清晰，更容易被大家理解</p>
<p>其实业界普遍采用的做法是，内部系统之间调用用 RPC，对外用 REST，因为内部系统之间可能调用很频繁，需要 RPC 的高性能支撑。对外用 REST 更易理解，更通用些。</p>
<h2 id="一个基本的-Web-Server"><a href="#一个基本的-Web-Server" class="headerlink" title="一个基本的 Web Server"></a>一个基本的 Web Server</h2><p>一个 RESTful 服务本质上首先是一个 Web service。下面是一个最简单的 Web server，对于任何请求都简单的直接返回请求链接：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">        <span class="string">&quot;html&quot;</span></span><br><span class="line">        <span class="string">&quot;log&quot;</span></span><br><span class="line">        <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">            fmt.Fprintf(w, <span class="string">&quot;Hello, %q&quot;</span>, html.EscapeString(r.URL.Path))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行之后，使用 curl 测试，结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -v -XGET -H <span class="string">&quot;Content-Type: application/json&quot;</span> http://127.0.0.1:8080/user</span><br><span class="line"></span><br><span class="line">Hello, <span class="string">&quot;/user&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="路由功能"><a href="#路由功能" class="headerlink" title="路由功能"></a>路由功能</h2><p>很显然，我们的线上项目不可能使用这么简单的 API 服务器。当用户增加，请求也会不断上涨，该如何处理好这些请求？作者使用了一个开源路由框架 <a href="https://github.com/gorilla/mux">mux</a>。这是一个小巧高效，且使用较广的第三方框架。接下来的篇幅里，作者会使用 mux 搭建一个 API 服务器框架。</p>
<h3 id="安装-mux"><a href="#安装-mux" class="headerlink" title="安装 mux"></a>安装 mux</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$go</span> get github.com/gorilla/mux</span><br></pre></td></tr></table></figure>

<h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Router.go</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gorilla/mux&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Route <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name        <span class="type">string</span></span><br><span class="line">	Method      <span class="type">string</span></span><br><span class="line">	Pattern     <span class="type">string</span></span><br><span class="line">	HandlerFunc http.HandlerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Routes []Route</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRouter</span><span class="params">()</span></span> *mux.Router &#123;</span><br><span class="line">	router := mux.NewRouter().StrictSlash(<span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">for</span> _, route := <span class="keyword">range</span> routes &#123;</span><br><span class="line">		<span class="keyword">var</span> handler http.Handler</span><br><span class="line"></span><br><span class="line">		handler = route.HandlerFunc</span><br><span class="line">		handler = http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">			handler.ServeHTTP(w, r)</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		router.Methods(route.Method).Path(route.Pattern).Name(route.Name).Handler(handler)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> router</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> routes = Routes&#123;</span><br><span class="line">	Route&#123;</span><br><span class="line">		<span class="string">&quot;DeleteItem&quot;</span>,</span><br><span class="line">		<span class="string">&quot;DELETE&quot;</span>,</span><br><span class="line">		<span class="string">&quot;/v1/delete&quot;</span>,</span><br><span class="line">		v1_deleteItem,</span><br><span class="line">	&#125;,</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Handler.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">v1_deleteItem</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json; charset=UTF-8&quot;</span>)</span><br><span class="line"></span><br><span class="line">	w.WriteHeader(http.StatusOK)</span><br><span class="line">	<span class="keyword">if</span> err := json.NewEncoder(w).Encode(jsonErr&#123;Code: http.StatusOK, Text: <span class="string">&quot;操作成功&quot;</span>&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.<span class="built_in">print</span>(<span class="string">&quot;%s\n%s&quot;</span>, err.Error(), debug.Stack())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体 mux 功能实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	router := NewRouter()</span><br><span class="line"></span><br><span class="line">	log.<span class="built_in">print</span>(<span class="string">&quot;service running(PID:%d)...&quot;</span>, os.Getpid())</span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, router))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>API 基本框架已经实现，接下来就是将相应功能实现模块与相应接口对接即可。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>对于想要学习作为一个客户端开发者如何独立完成一个具有 API 服务器功能的线上 APP，可以参考专栏<a href="https://zhuanlan.zhihu.com/health-go">《如何独立开发一个完整应用》</a>，专栏中使用线上 APP <a href="https://itunes.apple.com/cn/app/id1177823334">靓手艺</a> 作为案例，详细分享了笔者如何实现 APP 全部功能。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是大 O 表示法</title>
    <url>/2018-08-05-big-o-notation/</url>
    <content><![CDATA[<p>“大O表示法”是一种特殊的表示法，指出了算法的速度有多快。但是它却不是指具体的时间，那么该如何正确理解它呢？</p>
<span id="more"></span>

<h2 id="算法的运行时间以不同的速度增加"><a href="#算法的运行时间以不同的速度增加" class="headerlink" title="算法的运行时间以不同的速度增加"></a>算法的运行时间以不同的速度增加</h2><p>“算法的运行时间以不同的速度增加”这句话应该如何理解呢？下面我们通过🌰来看看这句话到底想表达什么。</p>
<p>小明现在需要编写一个查找算法，这个算法服务于学校图书馆，目的是帮助童鞋们能够快速的找到自己需要的书籍所在位置。</p>
<p>假设小明现在只会“二分查找”和“简单查找”。一方面，二分查找的速度很快，小明必须在 10 秒钟内找到书籍所在位置，否则童鞋们没有更多耐心等待。另一方面，简单查找算法编写起来更容易，因此出现 bug 的可能性更小。</p>
<p>为了检验这两种算法的耗时，小明决定计算两种算法在列表包含 100 个元素的情况下需要的时间。</p>
<p>假设检查一个元素需要 1 毫秒。使用简单查找时，小明必须检查 100 个元素，因此需要 100 毫秒才能查找完毕。而使用二分查找时，只需检查 7 个元素（log2 100大约为7），因此需要 7 毫秒就能查找完毕。然而，实际要查找的列表可能包含 10 亿个元素，在这种情况下，简单查找需要多长时间呢？二分查找又需要多长时间呢？</p>
<p>小明使用包含 10 亿个元素的列表运行二分查找，运行时间为 30 毫秒（log2 1 000 000 000大约为30）。他心里想，二分查找的速度大约为简单查找的 15 倍，因为列表包含 100 个元素时，简单查找需要 100 毫秒，而二分查找需要 7 毫秒。因此，列表包含 10 亿个元素时，简单查找需要 30 × 15 &#x3D; 450 毫秒，完全符合在 10 秒内查找完毕的要求。小明决定使用简单查找。这是正确的选择吗？</p>
<p>不是。实际上，小明错了，而且错得离谱。列表包含 10 亿个元素时，简单查找需要 10 亿毫秒，相当于 11 天！为什么会这样呢？因为二分查找和简单查找的运行时间的增速不同。</p>
<table>
<thead>
<tr>
<th>简单查找</th>
<th>二分查找</th>
<th>元素个数</th>
</tr>
</thead>
<tbody><tr>
<td>100 毫秒</td>
<td>7 毫秒</td>
<td>100</td>
</tr>
<tr>
<td>10 秒</td>
<td>14 毫秒</td>
<td>10 000</td>
</tr>
<tr>
<td>11 天</td>
<td>30 毫秒</td>
<td>1 000 000 000</td>
</tr>
</tbody></table>
<p>随着元素数量的增加，二分查找需要的额外时间并不多，而简单查找需要的额外时间却很多。因此，随着列表的增长，二分查找的速度比简单查找快得多。小明以为二分查找速度为简单查找的 15 倍，这不对：列表包含 10 亿个元素时，为 3300 万倍。有鉴于此，仅知道算法需要多长时间才能运行完毕还不够，还需知道运行时间如何随列表增长而增加。这正是大O表示法的用武之地。</p>
<p>大O表示法指出了算法有多快。例如，假设列表包含 n 个元素。简单查找需要检查每个元素，因此需要执行 n 次操作。使用大O表示法，这个运行时间为 O(n)。单位秒呢？没有！大O表示法指的并非以秒为单位的速度。大O表示法让你能够比较操作数，它指出了算法运行时间的增速。</p>
<h2 id="最糟糕情况下的运行时间"><a href="#最糟糕情况下的运行时间" class="headerlink" title="最糟糕情况下的运行时间"></a>最糟糕情况下的运行时间</h2><p>假设你使用简单查找在电话簿中找人。你知道，简单查找的运行时间为 O(n)，这意味着在最糟情况下，必须查看电话簿中的每个条目。如果要查找的是 Chars ——电话簿中的第一个人，一次就能找到，无需查看每个条目。考虑到一次就找到了 Chars，请问这种算法的运行时间是 O(n)还是 O(1) 呢？</p>
<p>简单查找的运行时间总是为 O(n)。查找 Chars 时，一次就找到了，这是最佳的情形，但大O表示法说的是最糟的情形。因此，你可以说，在最糟情况下，必须查看电话簿中的每个条目，对应的运行时间为 O(n)。这是一个保证——你知道简单查找的运行时间不可能超过 O(n)。</p>
<blockquote>
<p>说明</p>
<p>除最糟情况下的运行时间外，还应考虑平均情况的运行时间，这很重要。最糟情况和平均情况将在第4章讨论。</p>
</blockquote>
<h2 id="一些常见的大O运行时间"><a href="#一些常见的大O运行时间" class="headerlink" title="一些常见的大O运行时间"></a>一些常见的大O运行时间</h2><p>下面按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。</p>
<ul>
<li>O (log n )，也叫对数时间 ，这样的算法包括二分查找。</li>
<li>O (n )，也叫线性时间 ，这样的算法包括简单查找。</li>
<li>O (n * log n )，这样的算法包括快速排序——一种速度较快的排序算法。</li>
<li>O (n 2 )，这样的算法包括选择排序——一种速度较慢的排序算法。</li>
<li>O (n !)，这样的算法包括旅行商问题的解决方案——一种非常慢的算法。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、算法的速度指的并非时间，而是操作数的增速。</p>
<p>2、谈论算法的速度时，说的是随着输入的增加，其运行时间将以什么样的速度增加。</p>
<p>3、算法的运行时间用大O表示法表示。</p>
<p>4、O(log n) 比 O(n)快，当需要搜索的元素越多时，前者比后者快得越多。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>对算法有兴趣的童鞋可以关注专栏<a href="https://zhuanlan.zhihu.com/easy-to-understand-algorithm">《通俗易懂的算法》</a>，也欢迎大家多多投稿分享。</p>
<p>同时欢迎大家加入移动开发交流Q群交流讨论，Q群号：811237468</p>
<p><img src="/assets/images/Q811237468.jpg" alt="Q811237468"></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>云南，一片上天眷顾的土地</title>
    <url>/2018-08-09-yunnan-travel-notes/</url>
    <content><![CDATA[<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-12.jpg" alt="丽江古城"></p>
<p>距离从云南回来已经好些天了。但，脑海中还会时常回忆起那里的景色。或许对于一些人来说，那些也是很通常的环境。旅行，不就是不同环境生活的人，暂时交换体验吗？这次的旅行，发现自己变化很大，从心性上来说，应该成熟些了吧。对于这次的旅行，还是想能够记下来，毕竟对于我来说，是一份很珍贵的记忆。</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-1.jpg" alt="泸沽湖畔蒲公英"></p>
<span id="more"></span>

<p>云南（不对，应该还包括四川。因为这次出行，已经各种跨省跨境的游玩了）不仅是个景色优美的地方，而且美食也是很重要的角色。相信我辈吃货们很关注那里有什么好吃的吧。这里首先来推荐几款一定要尝尝的美食吧。</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-8.jpg" alt="四川麻辣面"></p>
<p>这是当时在扎窝洛码头住民宿时老板做的。看着很辣，一向清淡饮食的我被吓着了，试着吃了一口之后，完全停不下来，不仅不辣，还香气扑鼻。好吃！爽！</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-38.jpg" alt="黄李子"></p>
<p>这种黄李子只能在丽江买到，可能是特色水果吧。最棒的吃法是，使用当地泉水或井水，洗干净吃。不要问为什么，你自己去了尝试一下就明白了。至于是不是叫黄李子，这个就很难说了，一路上问了不少人。感觉没有一个是认真回答这个问题的，都随便叫一个名字。哈哈哈，这个“随便”的用法也是和当地人学的。</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-15.jpg" alt="相思草"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-11.jpg" alt="水性杨花"></p>
<p>以上这两种菜是在大理洱海畔的双廊一家餐馆吃的，味道嘛，和吃一般蔬菜一样，只不过名字比较有意思。</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-22.jpg" alt="炸昆虫"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-35.jpg" alt="棱角"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-36.jpg" alt="折洱根"></p>
<p>以上三样都是在大理古城逛吃发现的。</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-40.jpg" alt="云南米线"></p>
<p>到了云南，肯定不能不吃云南米线。不过，有点分不清这个和米粉有什么区别啦。</p>
<p>当然，吃的东西不仅仅如此，只不过这些都是比较有意思的。</p>
<p>除了吃，当然就是玩啦。</p>
<p>第一天早上来到丽江，因为太早。从火车站，直接坐18路公交进入市区，18路，记得郴州火车站的公交也是18路。好巧呀。</p>
<p>车子可以直接到达丽江古城的忠义市场，以前需要的古城维修费，现在也不需要啦。下车之后找个地方吃了碗当地的云南米线，物价也不是很贵。接下来，绕着古城，找到南门，然后进去逛一逛。清晨空气很棒，古城里的公园很多运动的爷爷奶奶。还看到一对夫妻，前一天晚上就在他们的SUV中度过的，居然还带着宠物狗出门。真的很惬意呀！把行李寄存在客栈之后，就直接去丽江古城逛吃咯。</p>
<p>丽江古城由束河古镇、大研古城、白沙古镇组成。最方便、最热闹的是大研古城，也就是人们常说的丽江古城。这里商业气息比较重，有很多小吃和店铺，人流量也是比较大的。虽然束河古城比较清净，但相应的是交通不怎么方便。因为客栈距离丽江古城东门，所以吃住还是很方便的。古城不是封闭的，你可以从任何你喜欢的地方进入。</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-18.jpg" alt="丽江古城"></p>
<p>这是在狮子山附近看到的古城全貌。真的很幸运，前一天这里还在下雨，到的这一天却赶上放晴。</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-21.jpg" alt="丽江古城"></p>
<p>“大水车”不仅是古城的一个景点，它旁边也是古城北门。这附近有去泸沽湖的汽车，也有去其他景点的车。</p>
<p>之前也去过乌镇，这种旧时建筑，可能风格都差不多，美不美，在于你！</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-9.jpg" alt="丽江古城"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-34.jpg" alt="丽江古城"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-10.jpg" alt="丽江古城"></p>
<p>走累了，坐在这石桥上吃黄李子，桥木有拍，当然看不见啦。</p>
<p>逛吃饱了之后，买了两件纳西族的衣服，准备期间穿起来。走出古城，办理好入住。准备出发去“拉市海”。拉市海边的花田和草地，让人眼前一亮，很久不见了。</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-23.jpg" alt="拉市海"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-19.jpg" alt="拉市海"></p>
<p>租条皮划艇，自己划着。心之所往，片刻即至。</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-28.jpg" alt="拉市海"></p>
<p>划了半天皮划艇，晚上都不想出门啦，在客栈收拾好，准备次日的行程–玉龙雪山。没错，奔着4680去的。</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-14.jpg" alt="玉龙雪山"></p>
<p>不能不说是遗憾，这个也不由想起大四时候，和室友去爬华山，想看日出。然后那天大雾！这个玉龙雪山是准备了一天的时间，所以除了登4680，还有蓝月谷可以玩。</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-33.jpg" alt="蓝月谷"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-2.jpg" alt="蓝月谷"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-39.jpg" alt="蓝月谷"></p>
<p>下午5:30准时下山返程，回到客栈。次日，就要去泸沽湖啦。</p>
<p>泸沽湖三分之一在云南 ，三分之二在四川，由湖泊和万亩草海组成。云南、 四川两省都可以进入。</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-17.jpg" alt="泸沽湖"></p>
<p>先来一个全景，不错，这个就是一个未被污染的天然水域。迎面出来凉凉的风，好久没有这样的感觉啦。</p>
<p>在泸沽湖，是住在四川境内的扎窝洛码头【老知青之家】民宿，这里是摩梭族人聚居区。在这里，体验当地人生活。</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-37.jpg" alt="草海"></p>
<p>来看看漂亮的民宿。</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-20.jpg" alt="草海"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-5.jpg" alt="草海"></p>
<p>老板有两个和我一般年纪的儿子，下午刚好跟着一起去了【摩梭博物馆】</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-32.jpg" alt="草海"></p>
<p>这个是“莫言”题字的哟！不清楚是在获奖前还是后啦。</p>
<p>晚上还去看了当地的篝火晚会！</p>
<p>次日，和两个小老板一起环湖游啦，因为景区现在已经禁止骑行啦，少了一大乐趣！</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-13.jpg" alt="泸沽湖"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-31.jpg" alt="泸沽湖"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-6.jpg" alt="泸沽湖"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-16.jpg" alt="泸沽湖"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-7.jpg" alt="泸沽湖"></p>
<p>看见水面上的水性杨花了吗？那个就是可以吃的！</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-27.jpg" alt="草海"></p>
<p>这两天在泸沽湖呆得都不想离开啦。</p>
<p>次日，来到大理古城。</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-3.jpg" alt="大理古城"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-24.jpg" alt="大理古城"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-26.jpg" alt="大理古城"></p>
<p>晚上逛吃，休息好。因为～</p>
<p>次日清晨起来，在古城里逛悠个早餐，租了个小电驴，开启洱海环行！</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-4.jpg" alt="崇圣寺三塔"></p>
<p>先来到崇圣寺三塔，不错，就是那个明信片经常出现的地方！</p>
<p>中午到双廊吃午餐，继续一路向前，出发。</p>
<p><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-29.jpg" alt="大理洱海"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-25.jpg" alt="大理洱海"><br><img src="/assets/images/life/yunnan-travel-notes/yunnan-travel-notes-30.jpg" alt="大理洱海"></p>
<p>晚上回到客栈，都不敢想象，今天环洱海有150公里。到了这个时候，旅行进度条也要撑不住啦。不久就要返程啦。</p>
<p>最后一天还是在大理，不过没有具体目标，早上多睡了一会，然后出门觅食。最后在洱海公园好好逛了逛。</p>
<p>这次旅行，真的很放松。这期间，可以不管手机上的信息，不用理会各种事物。在那里，都是使用现金，离开网络，离开忙碌的世界。</p>
<p>社会在快速发展，人到底是变得更幸福快乐了吗？</p>
<p>回来之后，又要开启自己的学习节奏，既然走了这条路，就要坚持下去。现在已经开设了知乎专栏<a href="https://zhuanlan.zhihu.com/easy-to-understand-algorithm">《通俗易懂的算法》</a>、<a href="https://zhuanlan.zhihu.com/health-go">《如何独立开发一个完整应用》</a>，有兴趣的童鞋欢迎关注和推荐给他人。</p>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>如何通过浏览器上网</title>
    <url>/2018-08-10-how-to-surfing-via-browser/</url>
    <content><![CDATA[<p><strong>当我们在网页浏览器（Web browser）的地址栏中输入 URL 时，Web 页面是如何呈现的吗？</strong></p>
<p>Web 页面当然不能凭空显示出来。根据 Web 浏览器地址栏中指定的 URL，Web 浏览器从 Web 服务器端获取文件资源（resource）等信息，从而显示出 Web 页面。像这种通过发送请求获取服务器资源的 Web 浏览器等，都可称为客户端（client）。</p>
<p>Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器端等一系列运作流程。而协议是指规则的约定，可以说，Web 是建立在 HTTP 协议上通信的。</p>
<blockquote>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol) 是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。1960 年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext），这成为了 HTTP 超文本传输协议标准架构的发展根基。Ted Nelson 组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的 RFC，其中著名的 RFC 2616 定义了 HTTP 1.1。</p>
</blockquote>
<span id="more"></span>

<h2 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h2><p>HTTP 的出生时间是 1989 年 3 月，那时候互联网还属于少数人。</p>
<p>CERN（欧洲核子研究组织）的蒂姆 • 伯纳斯 - 李（Tim BernersLee）博士提出了一种能让远隔两地的研究者们共享知识的设想。</p>
<p>最初设想的基本理念是：借助多文档之间相互关联形成的超文本（HyperText），连成可相互参阅的 WWW（World Wide Web，万维网）。</p>
<p>现在已提出了 3 项 WWW 构建技术，分别是：把 SGML（Standard Generalized Markup Language，标准通用标记语言）作为页面的文本标记语言的 HTML（HyperText Markup Language，超文本标记语言）；作为文档传递协议的 HTTP ；指定文档所在地址的 URL（Uniform Resource Locator，统一资源定位符）。</p>
<p>WWW 这一名称，是 Web 浏览器当年用来浏览超文本的客户端应用程序时的名称。现在则用来表示这一系列的集合，也可简称为 Web。 </p>
<p>1990 年 11 月，CERN 成功研发了世界上第一台 Web 服务器和 Web 浏览器。</p>
<h2 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h2><h3 id="HTTP-x2F-0-9"><a href="#HTTP-x2F-0-9" class="headerlink" title="HTTP&#x2F;0.9"></a>HTTP&#x2F;0.9</h3><p>HTTP 于 1990 年问世。那时的 HTTP 并没有作为正式的标准被建立。现在的 HTTP 其实含有 HTTP1.0 之前版本的意思，因此被称为 HTTP&#x2F;0.9。</p>
<h3 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h3><p>HTTP 正式作为标准被公布是在 1996 年的 5 月，版本被命名为 HTTP&#x2F;1.0，并记载于 <a href="http://www.ietf.org/rfc/rfc1945.txt">RFC1945</a>。虽说是初期标准，但该协议标准至今仍被广泛使用在服务器端。 </p>
<h3 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h3><p>1997 年 1 月公布的 HTTP&#x2F;1.1 是目前主流的 HTTP 协议版本。当初的标准是 RFC2068，之后发布的修订版 <a href="http://www.ietf.org/rfc/rfc2616.txt">RFC2616</a> 就是当前的最新版本。 </p>
<h2 id="TCP-x2F-IP-简介"><a href="#TCP-x2F-IP-简介" class="headerlink" title="TCP&#x2F;IP 简介"></a>TCP&#x2F;IP 简介</h2><p>为了理解 HTTP，我们有必要事先了解一下 TCP&#x2F;IP 协议族。通常使用的网络（包括互联网）是在 TCP&#x2F;IP 协议族的基础上运作的。而 HTTP 属于它内部的一个子集。</p>
<p>计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。 </p>
<p><img src="/assets/images/tech/how-to-surfing-via-browser-TCP-IP-Protocol.png" alt="TCP/IP 协议族"></p>
<h3 id="分层管理"><a href="#分层管理" class="headerlink" title="分层管理"></a>分层管理</h3><p>TCP&#x2F;IP 协议族里重要的一点就是分层。TCP&#x2F;IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。</p>
<p><strong>分层的好处：</strong>若某个地方需要改变设计时，不需要把所有部分整体替换掉，只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层决定了向用户提供应用服务时通信的活动。</p>
<p>TCP&#x2F;IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）。HTTP 协议也处于该层。</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>传输层为应用层，提供处于网络连接中的两台计算机之间的数据传输。</p>
<p>在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。</p>
<p>TCP 提供可靠的字节流服务。所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。简单来说，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。而为了准确无误地将数据传输到目标，TCP 采用了三次握手策略。</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。</p>
<p>与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。</p>
<h5 id="负责传输的-IP-协议"><a href="#负责传输的-IP-协议" class="headerlink" title="负责传输的 IP 协议"></a>负责传输的 IP 协议</h5><p>IP（Internet Protocol）网际协议位于网络层。需要注意的是可“IP”和“IP 地址”的区别，“IP”其实是一种协议的名称。 </p>
<p>IP 协议的作用是把各种数据包传送给对方。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。</p>
<p>IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。基本上各大网卡制作厂商都被预制分配了 MAC 地址区间段。</p>
<p>IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。</p>
<p>在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线。这种机制称为路由选择（routing）。 </p>
<p><img src="/assets/images/tech/how-to-surfing-via-browser-routing.png" alt="路由选择"></p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。</p>
<p>硬件上的范畴均在链路层的作用范围之内。</p>
<p>在数据链路层还有一个常见的网络协议 LLDP。了解更多可以查看<a href="/blog/data-link-layer-lldp">《数据链路层之 LLDP》</a>。</p>
<h3 id="通信传输流"><a href="#通信传输流" class="headerlink" title="通信传输流"></a>通信传输流</h3><p><img src="/assets/images/tech/how-to-surfing-via-browser-stram.png" alt="TCP/IP 通信传输流"></p>
<p>为了更好的理解上图，我们使用 HTTP 🌰 说明。</p>
<p><img src="/assets/images/tech/how-to-surfing-via-browser-HTTP-transport.png" alt="HTTP 通信"></p>
<ol>
<li><p>作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。</p>
</li>
<li><p>在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</p>
</li>
<li><p>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。</p>
</li>
<li><p>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。</p>
</li>
</ol>
<p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法称为封装（encapsulate）。</p>
<h2 id="DNS-简述"><a href="#DNS-简述" class="headerlink" title="DNS 简述"></a>DNS 简述</h2><p>DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。</p>
<p>计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。🌰 <a href="http://www.chars.tech/">www.chars.tech</a>。</p>
<p>用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。</p>
<p>但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。</p>
<p><img src="/assets/images/tech/how-to-surfing-via-browser-DNS.jpg" alt="DNS 服务"></p>
<h2 id="访问网站"><a href="#访问网站" class="headerlink" title="访问网站"></a>访问网站</h2><p>至此，大致可以回答开篇的问题了，我们在浏览器输入框中输入想浏览的网页地址之后，发生了哪些事情呢？</p>
<p><img src="/assets/images/tech/how-to-surfing-via-browser-Step.jpg" alt="HTTP 浏览网页"></p>
<ol>
<li>客户端发起页面网址请求给 DNS。</li>
<li>DNS 解析出对应 IP 地址返回给客户端。</li>
<li>客户端填充请求 IP 地址。</li>
<li>客户端根据 HTTP 交互封装请求数据包。</li>
<li>请求数据包经过路由机制到达目的地址。</li>
<li>目的地址服务器返回数据给客户端。</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>不是结束，只是开始</title>
    <url>/2018-09-14-just-begin-not-leave/</url>
    <content><![CDATA[<p>今天自己已经没有上班了，心里却是莫名的失落。没有开心与轻松，自己现在并不累。今天终于发现自己真的很恋旧。在 ZAKER 呆了 912 天，说来也不是很短了。本来以为自己可以继续呆下去，依旧可以做着一边工作一边兼顾自己的项目，在工作中迸发自己的 idea，然后付诸行动。</p>
<span id="more"></span>

<p>正如离开时对领导所说，自己是带着情怀来的，但是很可惜，要带着遗憾离开。</p>
<p>自己在很早就使用 ZAKER 来看新闻，当时来到广州，经过各种面试考验，如愿来到老东家。慢慢的想着要将它变得更好，或者是说自己能够为它的成长贡献力量。两年多下来，看着它慢慢迭代，和两年前比较，已经不是同一个产品啦，变化还是很大的。</p>
<p>最开始进来时，就被小组的团队氛围所触动。没错，我们是一个很年轻的团队，大家可以很自然的沟通，可以很放松，可以很时髦，但是我们也很努力。</p>
<p>两年多来，自己不断被影响，努力前行。从一个开发新手，到一个完全可以自己 hold 住需求的开发人员。自己的成长，也得到了肯定。期间经历团队同事的离开，经历引导人的离开，这些无不是一种心理磨练。特别是当面试自己的领导同事离开时，那种说出不的滋味。虽然明白天下无不散之宴席，但当自己真的面对时，还是需要心理建设的。苟富贵，勿相忘。江湖再见。这几句话我们会在散场的时候诉说的。或许若干年后，我们会真的体会它的深意。</p>
<p>最后，自己也不知道想要写什么，或许就是想留下一个印记吧。ZAKER 我曾经来过，ZAKER 我曾经为你激情付出。ZAKER 希望你越来越好！ </p>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>Privacy Policy</title>
    <url>/2018-10-28-privacy-policy-en/</url>
    <content><![CDATA[<h2 id="Privacy-Policy"><a href="#Privacy-Policy" class="headerlink" title="Privacy Policy"></a>Privacy Policy</h2><p>Effective date: October 28, 2018</p>
<p>Niffler (“us”, “we”, or “our”) operates the Niffler mobile application (the “Service”).</p>
<p>This page informs you of our policies regarding the collection, use, and disclosure of personal data when you use our Service and the choices you have associated with that data. Our Privacy Policy for Niffler is created with the help of the Free Privacy Policy Generator.</p>
<span id="more"></span>

<p>We use your data to provide and improve the Service. By using the Service, you agree to the collection and use of information in accordance with this policy. Unless otherwise defined in this Privacy Policy, terms used in this Privacy Policy have the same meanings as in our Terms and Conditions.</p>
<h3 id="Information-Collection-And-Use"><a href="#Information-Collection-And-Use" class="headerlink" title="Information Collection And Use"></a>Information Collection And Use</h3><p>We collect several different types of information for various purposes to provide and improve our Service to you.</p>
<h3 id="Types-of-Data-Collected"><a href="#Types-of-Data-Collected" class="headerlink" title="Types of Data Collected"></a>Types of Data Collected</h3><h4 id="Personal-Data"><a href="#Personal-Data" class="headerlink" title="Personal Data"></a>Personal Data</h4><p>While using our Service, we may ask you to provide us with certain personally identifiable information that can be used to contact or identify you (“Personal Data”). Personally identifiable information may include, but is not limited to:</p>
<ul>
<li>Cookies and Usage Data</li>
</ul>
<h4 id="Usage-Data"><a href="#Usage-Data" class="headerlink" title="Usage Data"></a>Usage Data</h4><p>When you access the Service by or through a mobile device, we may collect certain information automatically, including, but not limited to, the type of mobile device you use, your mobile device unique ID, the IP address of your mobile device, your mobile operating system, the type of mobile Internet browser you use, unique device identifiers and other diagnostic data (“Usage Data”).</p>
<h4 id="Tracking-amp-Cookies-Data"><a href="#Tracking-amp-Cookies-Data" class="headerlink" title="Tracking &amp; Cookies Data"></a>Tracking &amp; Cookies Data</h4><p>We use cookies and similar tracking technologies to track the activity on our Service and hold certain information.</p>
<p>Cookies are files with small amount of data which may include an anonymous unique identifier. Cookies are sent to your browser from a website and stored on your device. Tracking technologies also used are beacons, tags, and scripts to collect and track information and to improve and analyze our Service.</p>
<p>You can instruct your browser to refuse all cookies or to indicate when a cookie is being sent. However, if you do not accept cookies, you may not be able to use some portions of our Service.</p>
<h4 id="Examples-of-Cookies-we-use"><a href="#Examples-of-Cookies-we-use" class="headerlink" title="Examples of Cookies we use:"></a>Examples of Cookies we use:</h4><ul>
<li>Session Cookies. We use Session Cookies to operate our Service.</li>
<li>Preference Cookies. We use Preference Cookies to remember your preferences and various settings.</li>
<li>Security Cookies. We use Security Cookies for security purposes.</li>
</ul>
<h3 id="Use-of-Data"><a href="#Use-of-Data" class="headerlink" title="Use of Data"></a>Use of Data</h3><p>Niffler uses the collected data for various purposes:</p>
<ul>
<li>To provide and maintain the Service</li>
<li>To notify you about changes to our Service</li>
<li>To allow you to participate in interactive features of our Service when you choose to do so</li>
<li>To provide customer care and support</li>
<li>To provide analysis or valuable information so that we can improve the Service</li>
<li>To monitor the usage of the Service</li>
<li>To detect, prevent and address technical issues</li>
</ul>
<h3 id="Transfer-Of-Data"><a href="#Transfer-Of-Data" class="headerlink" title="Transfer Of Data"></a>Transfer Of Data</h3><p>Your information, including Personal Data, may be transferred to — and maintained on — computers located outside of your state, province, country or other governmental jurisdiction where the data protection laws may differ than those from your jurisdiction.</p>
<p>If you are located outside China and choose to provide information to us, please note that we transfer the data, including Personal Data, to China and process it there.</p>
<p>Your consent to this Privacy Policy followed by your submission of such information represents your agreement to that transfer.</p>
<p>Niffler will take all steps reasonably necessary to ensure that your data is treated securely and in accordance with this Privacy Policy and no transfer of your Personal Data will take place to an organization or a country unless there are adequate controls in place including the security of your data and other personal information.</p>
<h3 id="Disclosure-Of-Data"><a href="#Disclosure-Of-Data" class="headerlink" title="Disclosure Of Data"></a>Disclosure Of Data</h3><h4 id="Legal-Requirements"><a href="#Legal-Requirements" class="headerlink" title="Legal Requirements"></a>Legal Requirements</h4><p>Niffler may disclose your Personal Data in the good faith belief that such action is necessary to:</p>
<ul>
<li>To comply with a legal obligation</li>
<li>To protect and defend the rights or property of Niffler</li>
<li>To prevent or investigate possible wrongdoing in connection with the Service</li>
<li>To protect the personal safety of users of the Service or the public</li>
<li>To protect against legal liability</li>
</ul>
<h3 id="Security-Of-Data"><a href="#Security-Of-Data" class="headerlink" title="Security Of Data"></a>Security Of Data</h3><p>The security of your data is important to us, but remember that no method of transmission over the Internet, or method of electronic storage is 100% secure. While we strive to use commercially acceptable means to protect your Personal Data, we cannot guarantee its absolute security.</p>
<h3 id="Service-Providers"><a href="#Service-Providers" class="headerlink" title="Service Providers"></a>Service Providers</h3><p>We may employ third party companies and individuals to facilitate our Service (“Service Providers”), to provide the Service on our behalf, to perform Service-related services or to assist us in analyzing how our Service is used.</p>
<p>These third parties have access to your Personal Data only to perform these tasks on our behalf and are obligated not to disclose or use it for any other purpose.</p>
<h4 id="Analytics"><a href="#Analytics" class="headerlink" title="Analytics"></a>Analytics</h4><p>We may use third-party Service Providers to monitor and analyze the use of our Service.</p>
<ul>
<li>Firebase</li>
</ul>
<p>Firebase is analytics service provided by Google Inc.</p>
<p>You may opt-out of certain Firebase features through your mobile device settings, such as your device advertising settings or by following the instructions provided by Google in their <a href="https://policies.google.com/privacy?hl=en">Privacy Policy</a>.</p>
<p>We also encourage you to review the Google’s policy for safeguarding your data: <a href="https://support.google.com/analytics/answer/6004245">https://support.google.com/analytics/answer/6004245</a>. For more information on what type of information Firebase collects, please visit please visit the Google Privacy &amp; Terms <a href="https://policies.google.com/privacy?hl=en">web page</a>.</p>
<h3 id="Links-To-Other-Sites"><a href="#Links-To-Other-Sites" class="headerlink" title="Links To Other Sites"></a>Links To Other Sites</h3><p>Our Service may contain links to other sites that are not operated by us. If you click on a third party link, you will be directed to that third party’s site. We strongly advise you to review the Privacy Policy of every site you visit.</p>
<p>We have no control over and assume no responsibility for the content, privacy policies or practices of any third party sites or services.</p>
<h3 id="Children’s-Privacy"><a href="#Children’s-Privacy" class="headerlink" title="Children’s Privacy"></a>Children’s Privacy</h3><p>Our Service does not address anyone under the age of 18 (“Children”).</p>
<p>We do not knowingly collect personally identifiable information from anyone under the age of 18. If you are a parent or guardian and you are aware that your Children has provided us with Personal Data, please contact us. If we become aware that we have collected Personal Data from children without verification of parental consent, we take steps to remove that information from our servers.</p>
<h3 id="Changes-To-This-Privacy-Policy"><a href="#Changes-To-This-Privacy-Policy" class="headerlink" title="Changes To This Privacy Policy"></a>Changes To This Privacy Policy</h3><p>We may update our Privacy Policy from time to time. We will notify you of any changes by posting the new Privacy Policy on this page.</p>
<p>We will let you know via email and&#x2F;or a prominent notice on our Service, prior to the change becoming effective and update the “effective date” at the top of this Privacy Policy.</p>
<p>You are advised to review this Privacy Policy periodically for any changes. Changes to this Privacy Policy are effective when they are posted on this page.</p>
<h3 id="Contact-Us"><a href="#Contact-Us" class="headerlink" title="Contact Us"></a>Contact Us</h3><p>If you have any questions about this Privacy Policy, please contact us:</p>
<p>By email: <a href="mailto:&#x61;&#x70;&#112;&#95;&#115;&#x65;&#x76;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#x6d;">&#x61;&#x70;&#112;&#95;&#115;&#x65;&#x76;&#x40;&#x31;&#x36;&#51;&#x2e;&#99;&#111;&#x6d;</a></p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>Niffler</tag>
      </tags>
  </entry>
  <entry>
    <title>日本，我眼中的样子</title>
    <url>/2018-12-01-japan-life-experience/</url>
    <content><![CDATA[<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-1.JPG" alt="礁岸"></p>
<p>来到日本已经有一段时间了，为什么直到现在才开始想起来写一点感想呢。一是，时间不多。二是，之前体验不多。</p>
<p>这次来日本，抱着学习、求证的心态。身边的人问起，笔者的回答一向都是，过来“浪”了。因为不是有很具体的目的过来的。在大学毕业时，就因为一些原因，对这边有兴趣。而现在，有机会过来了。那么，就能好好验证之前自己的困惑了。</p>
<p>目前为止，最大的体会就是，日本绝对是个生活的好地方。</p>
<span id="more"></span>

<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-24.JPG" alt="居住区"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-23.JPG" alt="马路"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-22.JPG" alt="公园"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-21.JPG" alt="公园"></p>
<p>环境很不错，在大马路上走，都基本闻不到尾气。晨跑笔者是直接在马路边、公园里、居住区进行。</p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-25.JPG" alt="街道"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-4.JPG" alt="街道"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-20.JPG" alt="街道"></p>
<p>周末出去逛逛街，看看各种地方。</p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-5.JPG" alt="街道"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-10.JPG" alt="街道"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-6.JPG" alt="街道"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-15.JPG" alt="街道"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-18.JPG" alt="街道"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-16.JPG" alt="街道"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-19.JPG" alt="街道"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-3.JPG" alt="街道"></p>
<p>除了这些安静，空寂的街道。在人气比较旺的旅游区，也是大同小异。</p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-9.JPG" alt="街道"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-8.JPG" alt="街道"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-7.JPG" alt="街道"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-26.JPG" alt="街道"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-27.JPG" alt="街道"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-28.JPG" alt="街道"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-29.JPG" alt="街道"></p>
<p>这个红色的邮筒，超级有个性，很难得见到在发达国家还保持着一些比较原始的习惯，还包括看报纸。</p>
<p>久负盛名的团地。</p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-31.JPG" alt="团地"></p>
<p>至于吃的嘛，那就很随意了。</p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-30.JPG" alt="寿司"></p>
<p>当然，具有标志性的建筑，东京塔，也要来看看的。</p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-13.jpg" alt="东京塔"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-14.jpg" alt="东京塔"></p>
<p>最后，附上一些生活杂类拍照。</p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-12.JPG" alt="生活"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-11.JPG" alt="生活"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-16.JPG" alt="生活"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-17.JPG" alt="生活"></p>
<p><img src="/assets/images/life/japan-life-experience/japan-life-experience-2.JPG" alt="生活"></p>
<p>看了这么多，应该很多人都会想过来体验一把。客观来说，这边除了工作，其他都很好。为什么这么说呢？工作就涉及到了日本文化问题了，或许有很多人喜欢，但是对于我们这些受欧美影响较多的人来说，或许，当真的亲身体验时，可能又是另一番感受了吧。</p>
]]></content>
      <categories>
        <category>talk</category>
      </categories>
      <tags>
        <tag>碎碎念</tag>
      </tags>
  </entry>
  <entry>
    <title>Core Data 是什么样子的</title>
    <url>/2019-03-22-core-data-junior-learn/</url>
    <content><![CDATA[<p>Core Data 是 iOS3.0 时引入的一个数据持久化的框架。与 sqlite 对比最大的优点莫过于支持对象的存储，苹果的官方文档说其简化了数据库的操作，使用 Core Data 确实可以大量减少代码中的 SQL 语句。</p>
<p>可是现状，大家对于持久化的选择方案仍多数是 FMDB。笔者猜测，最大的原因可能就是性能。</p>
<span id="more"></span>

<p><img src="/assets/images/tech/core-data-junior-learn-queries.jpg" alt="各种持久化方案性能比较"></p>
<h2 id="Core-Data-是什么"><a href="#Core-Data-是什么" class="headerlink" title="Core Data 是什么"></a>Core Data 是什么</h2><p>Core Data 是一个模型层的技术，帮助开发者建立代表程序状态的模型层。同时也是一种持久化技术，它能将模型对象的状态持久化到磁盘。它是完全独立于 UI 层级的框架，是作为模型层框架被设计出来的。</p>
<p>Core Data 不是一个 O&#x2F;RM，但它比 O&#x2F;RM 能做的更多。它也不是一个 SQL wrapper。它默认使用 SQL，但它是一种更高级的抽象概念。</p>
<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>Core Data 有相当多可用的组件。当所有的组件都捆绑到一起的时候，我们把它称作 Core Data 堆栈，这个堆栈有两个主要部分。</p>
<p>一部分是关于对象图管理，这正是你需要很好掌握的那一部分，并且知道怎么使用。<br>另一部分是关于持久化，比如，保存你模型对象的状态，然后再恢复模型对象的状态。</p>
<p>堆栈结构如下</p>
<p><img src="/assets/images/tech/core-data-junior-learn-stack-complex.png" alt="Core Data 堆栈"></p>
<p>NSPersistentStoreCoordinator 是一个位于本地存储文件与缓存层（NSManagedObjectContext）之间的一个持久化层，它是真实操作数据库本地文件。</p>
<p>NSManagedObjectContext 是一个被管理数据的上下文，它实际上是对所有数据库操作的一个缓存层，把所有的操作都先缓存起来避免大量磁盘 IO 造成不流畅，在操作完数据库后调用其 save 方法，就可以把数据库操作提交给持久化层（NSPersistentStoreCoordinator），由持久化层一次性写入数据库文件。</p>
<p>NSManagedObject 是被管理的数据记录，对应数据库的一个表。</p>
<p>另外，Core Data 可以将多个 stores 附属于同一个持久化存储协调器，并且除了存储 SQL 格式外，还有很多存储类型可供选择。<br>最常见的方案如下</p>
<p><img src="/assets/images/tech/core-data-junior-learn-stack-simple.png" alt="多个 stores 持久化"></p>
<h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>下面是笔者定义的一个 Event 表的元素组成</p>
<p><img src="/assets/images/tech/core-data-junior-learn-event-struct.png" alt="数据表元素"></p>
<p>定义数据模型</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MXWEventModel</span>: <span class="title class_">NSObject</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">Int64</span></span><br><span class="line">    <span class="keyword">var</span> time: <span class="type">Date</span></span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> detail: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> addr: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">id</span>: <span class="type">Int64</span>, <span class="params">title</span>: <span class="type">String</span>, <span class="params">detail</span>: <span class="type">String</span>, <span class="params">addr</span>: <span class="type">String</span>, <span class="params">time</span>: <span class="type">Date</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> context <span class="operator">=</span> persistentContainer.viewContext</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">add</span>(<span class="params">model</span>: <span class="type">AnyObject</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> eventModel: <span class="type">MXWEventModel</span> <span class="operator">=</span> model <span class="keyword">as!</span> <span class="type">MXWEventModel</span></span><br><span class="line">	<span class="keyword">let</span> entity <span class="operator">=</span> <span class="type">NSEntityDescription</span>.entity(forEntityName: @<span class="string">&quot;MXWEvent&quot;</span>, in: context<span class="operator">!</span>)</span><br><span class="line">	<span class="keyword">let</span> obj <span class="operator">=</span> <span class="type">NSManagedObject</span>(entity: entity<span class="operator">!</span>, insertInto: context)</span><br><span class="line">	obj.setValue(eventModel.id, forKey: <span class="string">&quot;id&quot;</span>)</span><br><span class="line">	obj.setValue(eventModel.title, forKey: <span class="string">&quot;title&quot;</span>)</span><br><span class="line">	obj.setValue(eventModel.detail, forKey: <span class="string">&quot;detail&quot;</span>)</span><br><span class="line">	obj.setValue(eventModel.time, forKey: <span class="string">&quot;time&quot;</span>)</span><br><span class="line">	obj.setValue(eventModel.addr, forKey: <span class="string">&quot;addr&quot;</span>)</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> context<span class="operator">?</span>.save()</span><br><span class="line">	&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(error)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">delete</span>(<span class="params">id</span>: <span class="type">Int64</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> request <span class="operator">=</span> <span class="type">NSFetchRequest</span>&lt;<span class="type">NSFetchRequestResult</span>&gt;(entityName: @<span class="string">&quot;MXWEvent&quot;</span>)</span><br><span class="line">	request.predicate <span class="operator">=</span> <span class="type">NSPredicate</span>(format: <span class="string">&quot;id==<span class="subst">\(id)</span>&quot;</span>)</span><br><span class="line">	<span class="keyword">let</span> deleteRequest <span class="operator">=</span> <span class="type">NSBatchDeleteRequest</span>(fetchRequest: request)</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> context<span class="operator">?</span>.execute(deleteRequest)</span><br><span class="line">	&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(error)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">update</span>(<span class="params">id</span>: <span class="type">Int64</span>, <span class="params">model</span>: <span class="type">AnyObject</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> eventModel: <span class="type">MXWEventModel</span> <span class="operator">=</span> model <span class="keyword">as!</span> <span class="type">MXWEventModel</span></span><br><span class="line">	<span class="keyword">let</span> request <span class="operator">=</span> <span class="type">NSFetchRequest</span>&lt;<span class="type">NSFetchRequestResult</span>&gt;(entityName: @<span class="string">&quot;MXWEvent&quot;</span>)</span><br><span class="line">	request.predicate <span class="operator">=</span> <span class="type">NSPredicate</span>(format: <span class="string">&quot;id==<span class="subst">\(id)</span>&quot;</span>)</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> eventObj <span class="operator">=</span> <span class="keyword">try</span> context<span class="operator">?</span>.fetch(request)</span><br><span class="line">		<span class="keyword">let</span> updateObj <span class="operator">=</span> eventObj<span class="operator">?</span>.first <span class="keyword">as!</span> <span class="type">NSManagedObject</span></span><br><span class="line">		updateObj.setValue(eventModel.title, forKey: <span class="string">&quot;title&quot;</span>)</span><br><span class="line">		updateObj.setValue(eventModel.detail, forKey: <span class="string">&quot;detail&quot;</span>)</span><br><span class="line">		updateObj.setValue(eventModel.time, forKey: <span class="string">&quot;time&quot;</span>)</span><br><span class="line">		updateObj.setValue(eventModel.addr, forKey: <span class="string">&quot;addr&quot;</span>)</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> context<span class="operator">?</span>.save()</span><br><span class="line">		&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(error)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(error)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">fetch</span>(<span class="params">id</span>: <span class="type">Int64</span>) -&gt; <span class="type">AnyObject</span>? &#123;</span><br><span class="line">	<span class="keyword">let</span> request <span class="operator">=</span> <span class="type">NSFetchRequest</span>&lt;<span class="type">NSFetchRequestResult</span>&gt;(entityName: @<span class="string">&quot;MXWEvent&quot;</span>)</span><br><span class="line">	request.predicate <span class="operator">=</span> <span class="type">NSPredicate</span>(format: <span class="string">&quot;id==<span class="subst">\(id)</span>&quot;</span>)</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> r <span class="operator">=</span> <span class="keyword">try</span> context<span class="operator">?</span>.fetch(request)</span><br><span class="line">		<span class="keyword">for</span> data <span class="keyword">in</span> r <span class="keyword">as!</span> [<span class="type">NSManagedObject</span>] &#123;</span><br><span class="line">			<span class="keyword">let</span> m <span class="operator">=</span> <span class="type">MXWEventModel</span>(id: data.value(forKey: <span class="string">&quot;id&quot;</span>) <span class="keyword">as!</span> <span class="type">Int64</span>, title: data.value(forKey: <span class="string">&quot;title&quot;</span>) <span class="keyword">as!</span> <span class="type">String</span>, detail: data.value(forKey: <span class="string">&quot;detail&quot;</span>) <span class="keyword">as!</span> <span class="type">String</span>, addr: data.value(forKey: <span class="string">&quot;addr&quot;</span>) <span class="keyword">as!</span> <span class="type">String</span>, time: data.value(forKey: <span class="string">&quot;time&quot;</span>) <span class="keyword">as!</span> <span class="type">Date</span>)</span><br><span class="line">			<span class="keyword">return</span> m</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(error)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><p>在功能迭代过程中，难免会遇到要修改 <code>.xcdatamodeld</code> 文件。例如，新增或删除一个实体、增加或删除一个原有实体的属性等。如果开发者没有设置数据迁移，那更新后原有的数据将会被清空，所以此时需要进行数据的迁移操作。</p>
<p>Core Data 可以设置轻量级的数据迁移，系统会自动分析差异，进行映射，这种方式只适用于简单的增删实体或是增删属性等操作。除此之外还有一种相当复杂的自定义数据迁移。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK: - Core Data stack</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">var</span> persistentContainer: <span class="type">NSPersistentContainer</span> <span class="operator">=</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> container <span class="operator">=</span> <span class="type">NSPersistentContainer</span>(name: <span class="string">&quot;Demo&quot;</span>)</span><br><span class="line">    container.loadPersistentStores(completionHandler: &#123; storeDescription, error <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> error <span class="operator">=</span> error <span class="keyword">as</span> <span class="type">NSError</span>? &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">&quot;Unresolved error <span class="subst">\(error)</span>, <span class="subst">\(error.userInfo)</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置数据迁移（shouldMigrateStoreAutomatically 默认值为 true）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> sDescription: <span class="type">NSPersistentStoreDescription</span> <span class="operator">=</span> storeDescription <span class="keyword">as</span> <span class="type">NSPersistentStoreDescription</span> &#123;</span><br><span class="line">            sDescription.shouldMigrateStoreAutomatically <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">            sDescription.shouldInferMappingModelAutomatically <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> container</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>对于 Core Data，Apple 官方很久之前就已经推出，但是并不受开发者青睐。笔者在这段时间的学习过程中也在思考这个问题。</p>
<p>下面是笔者学习中遇到的注意点：</p>
<ol>
<li>Core Data 中没有自增数据类型。因为 Core Data 不能使用数据库思维去使用，所以也就很好解释了。</li>
<li>设置 context 的 merge 策略，减少数据迁移的麻烦。</li>
<li>最好使用多线程，可以进一步提升性能。</li>
</ol>
<p>最后，文章开头给出了性能比较。但是，笔者认为，在客户端并没有很大量的数据写入，只要开发者在使用过程中稍作注意，性能应该不是否决 Core Data 技术方案的理由。反倒，Core Data 对 iCloud 很好的支持，以及数据迁移备份，这些都可以很容易实现。笔者认为，完全可以考虑使用它做客户端的数据持久化方案。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/#//apple_ref/doc/uid/TP40001075-CH2-SW1">《Core Data Programming Guide》</a></p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swift</tag>
        <tag>persistence</tag>
        <tag>core data</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 单元测试</title>
    <url>/2019-06-24-ios-unit-test/</url>
    <content><![CDATA[<p>单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如 C 语言中单元指一个函数，Java 里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。</p>
<p>单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。</p>
<span id="more"></span>

<h2 id="为什么要做单元测试"><a href="#为什么要做单元测试" class="headerlink" title="为什么要做单元测试"></a>为什么要做单元测试</h2><p>1）在一个复杂的项目中添加某功能模块时，可以快捷的进行针对性测试，而不用将整个项目 Run 起来。</p>
<p>2）可以便捷的对某个具体方法进行测试。</p>
<h2 id="单元测试有哪些"><a href="#单元测试有哪些" class="headerlink" title="单元测试有哪些"></a>单元测试有哪些</h2><p>iOS 开发（或者 MacOS、tvOS、watchOS 等）中，单元测试有多种方式，主要分为 Xcode 提供的以及第三方测试框架这两类：</p>
<ul>
<li><p>Xcode自带<br>XCTest：XCTest 是 Xcode自带的单元测试工具，其前身是 OCUnit，随着 Xcode 的发展，XCTest 已经越来越完善，功能也越强大。</p>
</li>
<li><p>第三方框架<br>GHUnit：GHUnit  是 GitHub 上著名的开源测试框架，可视化、开源、扩展等功能，让其相比 XCTest 更加强大（现在的 XCTest 也很完善了，不过 GHUnit 比较老，现在已经停止维护，不建议使用）<br>OCMock：OCMock 也是 Github 上的著名开源测试框架，用于 Mock、Stub，为测试提供数据作假功能。</p>
</li>
</ul>
<p>以上三种就是比较主流的测试 Xcode 单元测试途径，还有一些 BDD 行为测试框架：</p>
<blockquote>
<p>什么是 BDD<br>BDD（Behavior Driven Development），即行为驱动开发，是敏捷开发技术之一，通过自然语言定义系统行为，以功能使用者的角度，编写需求场景，且这些行为描述可以直接形成需求文档，同时也是测试标准。</p>
</blockquote>
<ul>
<li>Specta：GitHub 上轻量级的 BDD 测试框架。</li>
<li>Expecta：与 Specta 同个作者，是一个功能强大的匹配框架。</li>
<li>Kiwi：Kiwi 是重量级的，集 OCMock、Specta、Expecta 所拥有的功能与一身的 BDD DSL 测试框架。</li>
</ul>
<p>其他的，还有一些其他测试工具、测试方式，如：</p>
<ul>
<li>Nocilla：强大的 HTTP 模拟测试工具。</li>
<li>OHHTTPStubs：也是 HTTP 模拟测试工具。</li>
<li>TUDelorean：基于 Objective-C 的时间模拟测试工具。</li>
<li>KIF：集成／界面测试工具，其它的还有 Frank、Calabash 等。</li>
<li>GitHub + Jenkins + TestFlight：自动化测试。</li>
<li>Monkey Test：随机测试。</li>
</ul>
<h2 id="XCTest-测试"><a href="#XCTest-测试" class="headerlink" title="XCTest 测试"></a>XCTest 测试</h2><p>1、创建测试类</p>
<p>注意，所有测试类都继承自 XCTestCase。</p>
<p>2、测试类的结构</p>
<p>默认创建的单元测试类为一个 <code>.m</code> 文件，里面包含了以下四个方法：</p>
<ul>
<li><code>- (void)setUp</code>：在每个测试用例开始前调用，可以做一些测试准备工作，为可选方法。</li>
<li><code>- (void)tearDown</code>：在每个测试用例结束后调用，可以做一些测试收尾工作，为可选方法。</li>
<li><code>- (void)testExample</code>：默认创建的测试用例。</li>
<li><code>- (void)testPerformanceExample</code>：性能测试方法。</li>
</ul>
<p>3、测试流程</p>
<p>当我们默认执行测试时，系统找到所有的测试类，并执行每个测试方法；我们也可以选择性地执行某些测试而已，比如，在 scheme 中 disable 某个用例，或者直接在测试导航栏中每个测试用例后面的运行按钮，单独执行某个测试。</p>
<p>默认流程如下：</p>
<p>上一个测试类 -&gt; 当前类<code>+ (void)setUp</code> -&gt; [ <code>- (void)setUp</code> -&gt; 测试方法 -&gt; <code>- (void)tearDown</code> ] (循环直至当前类测试方法全部执行完) -&gt; 当前类 <code>+ (void)tearDown</code> -&gt; 下一个测试类</p>
<p>4、测试方法</p>
<p>测试方法以 test 为前缀，没有参数，返回值为 void，方法中用断言来判断测试的正确性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)testColorIsRed &#123;</span><br><span class="line">   // Set up, call test subject API. (Code could be shared in setUp method.)</span><br><span class="line">   // Test logic and values, assertions report pass/fail to testing framework.</span><br><span class="line">   // Tear down. (Code could be shared in tearDown method.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)testThatItDoesURLEncoding &#123;</span><br><span class="line">    // given</span><br><span class="line">    NSString *searchQuery = @&quot;$content$amp;?@&quot;;</span><br><span class="line">    HTTPRequest *request = [HTTPRequest requestWithURL:@&quot;/search?q=%@&quot;, searchQuery];</span><br><span class="line"></span><br><span class="line">    // when</span><br><span class="line">    NSString *encodedURL = request.URL;</span><br><span class="line"></span><br><span class="line">    // then</span><br><span class="line">    XCTAssertEqualObjects(encodedURL, @&quot;/search?q=%24%26%3F%40&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、测试断言</p>
<p>断言一般由判断条件、字符串 format、字符串参数组成，参数可选，在 XCTest 中，断言有以下分类：</p>
<ul>
<li>Unconditional Fail：XCTFail，失败时候抛出。</li>
<li>Equality Tests：用于断言两个表达式相等或不相等，如：XCTAssertEqual、XCTAssertEqualWithAccuracy、XCTAssertNotEqual、 XCTAssertGreaterThan。</li>
<li>Boolean Tests：断言布尔表达式真假，如：XCTAssertTrue、XCTAssertFalse。</li>
<li>Nil Tests：空断言，如：XCTAssertNil、XCTAssertNotNil。</li>
<li>Exception Tests：断言表达式抛出或不抛出异常，如：XCTAssertThrows、XCTAssertThrowsSpecific、XCTAssertNoThrow。</li>
</ul>
<h2 id="Specta、Expecta-测试"><a href="#Specta、Expecta-测试" class="headerlink" title="Specta、Expecta 测试"></a>Specta、Expecta 测试</h2><p><a href="https://github.com/specta/specta">Specta</a> 和 <a href="https://github.com/specta/expecta">Expecta</a> 都是出自 Github 作者 <a href="https://github.com/orta">Orta</a> 之手，他最出名的开源框架莫过于 <a href="https://github.com/CocoaPods/CocoaPods">Cocoapods</a>。</p>
<h3 id="Specta"><a href="#Specta" class="headerlink" title="Specta"></a>Specta</h3><p>Specta 是一个轻量级 BBD 测试框架，其为 <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL (Domain-Specific Language)</a> 模式，让测试更加接近于自然语言描述，更加易懂。</p>
<p>1、主要有以下特点：</p>
<ul>
<li>容易集成到项目中。</li>
<li>基于XCTest编写，可以很好地与XCTest配合使用。</li>
</ul>
<p>2、语法介绍</p>
<ol>
<li><p>SpecBegin 声明了一个测试类，SpecEnd 结束类声明</p>
</li>
<li><p>describe (context) 块声明了一组实例</p>
</li>
<li><p>it (example&#x2F;specify) 是一个单一的样例</p>
</li>
<li><p>beforeAll 是一个执行于全部同级块之前的块，仅仅执行一次。afterAll 与beforeAll相反，是在全部同级块之后执行的块。仅仅执行一次。</p>
</li>
<li><p>beforeEach&#x2F;afterEach，在每一个同级块执行的时候，都会执行一次，而beforeAll&#x2F;afterAll仅仅会执行一次</p>
</li>
<li><p>it&#x2F;waitUntil&#x2F;done()。异步调用，注意完毕异步操作之后。必须调用done()函数。例如以下：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">it(@&quot;should do some stuff asynchronously&quot;, ^&#123;</span><br><span class="line">	waitUntil(^(DoneCallback done) &#123;</span><br><span class="line">	  // Async example blocks need to invoke done() callback.</span><br><span class="line">	  done();</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>sharedExamplesFor 和 itShouldBehaveLike结合在一起。能够实如今不同的spec之间共享同一套test case<br>sharedExamplesFor 设置多个spec之间共享的test case，第一个參数作为标识符。通过itShouldBehaveLike来执行spec中test case。第一个參数传入sharedExamplesFor设置时使用的标识符。</li>
</ol>
<p>注意：在describe局部使用sharedExamplesFor定义shared examples。能够在它作用域内覆盖全局的shared examples。</p>
<ol start="8">
<li>pending，仅仅打印一条log信息。不做测试。这个语句会给出一条警告，能够作为一开始集中书写行为描写叙述时还未实现的测试的提示。</li>
</ol>
<p>3、一般使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SpecBegin(Car)</span><br><span class="line">    describe(@&quot;Car&quot;, ^&#123;</span><br><span class="line">        __block Car *car;</span><br><span class="line"></span><br><span class="line">        // Will be run before each enclosed it</span><br><span class="line">        beforeEach(^&#123;</span><br><span class="line">            car = [Car new];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // Will be run after each enclosed it</span><br><span class="line">        afterEach(^&#123;</span><br><span class="line">            car = nil;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // An actual test</span><br><span class="line">        it(@&quot;should be red&quot;, ^&#123;</span><br><span class="line">            expect(car.color).to.equal([UIColor redColor]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        describe(@&quot;when it is started&quot;, ^&#123;</span><br><span class="line">            beforeEach(^&#123;</span><br><span class="line">                [car start];</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            it(@&quot;should have engine running&quot;, ^&#123;</span><br><span class="line">                expect(car.engine.running).to.beTruthy();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        describe(@&quot;move to&quot;, ^&#123;</span><br><span class="line">            context(@&quot;when the engine is running&quot;, ^&#123;</span><br><span class="line">                beforeEach(^&#123;</span><br><span class="line">                    car.engine.running = YES;</span><br><span class="line">                    [car moveTo:CGPointMake(42,0)];</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                it(@&quot;should move to given position&quot;, ^&#123;</span><br><span class="line">                    expect(car.position).to.equal(CGPointMake(42, 0));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            context(@&quot;when the engine is not running&quot;, ^&#123;</span><br><span class="line">                beforeEach(^&#123;</span><br><span class="line">                    car.engine.running = NO;</span><br><span class="line">                    [car moveTo:CGPointMake(42,0)];</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                it(@&quot;should not move to given position&quot;, ^&#123;</span><br><span class="line">                    expect(car.engine.running).to.beTruthy();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">SpecEnd</span><br></pre></td></tr></table></figure>

<p>上面例子对 Car 这个类做测试，通过多个上下文嵌套（describe&#x2F;context），结合不同的条件（beforeEach)，来作出不同的断言（it)；当我们某个测试失败时，我们会收到一段很明确的错误信息，比如：汽车启动后应该移动到指定位置这个用例测试失败，那么我们会收到 Car move to when the engine is running should move to given position 这么一段话。这样非常接近自然语言的描述会让我们很快知道错误出在哪里。</p>
<p>4、注意：</p>
<ul>
<li><p>如果想用 SPEC_BEGIN 和 SPEC_END 替代 SpecBegin and SpecEnd，应该在引入头文件之前写上 #define SPT_CEDAR_SYNTAX</p>
</li>
<li><p>如果要使用 XCTest Resporter，那么在 Test Scheme 中，把 SPTXCTestReporter 字段值改为 SPECTA_REPORTER_CLASS</p>
</li>
<li><p>把环境变量 SPECTA_SHUFFLE 设置为 1 启用测试拖拽（test shuffling)</p>
</li>
</ul>
<h3 id="Expecta"><a href="#Expecta" class="headerlink" title="Expecta"></a>Expecta</h3><p>Expecta 是基于 Objective-C／Cocoa 的断言框架，XCTest 自带的断言 XCAssert 有好几个基础操作，不过基础的断言不太丰富，和 Specta 也没有很适配。 Expecta 不一样，将匹配过程从断言中剥离开，可以很好地适配 Specta 的 DSL 断言块。</p>
<p>1、Expecta 有以下几个特点：</p>
<ul>
<li><p>没有类型限制，比如数值 1，并不用关心它是整形还是浮点数</p>
</li>
<li><p>链式编程，可读性高，如：expect(foo).notTo.equal(1)</p>
</li>
<li><p>反向匹配，断言不匹配只需加上 .notTo 或者 .toNot，如：expect(x).notTo.equal(y)</p>
</li>
<li><p>延时匹配，可以在链式表达式中加入 .will、.willNot、.after(interval) 等操作来延时匹配</p>
</li>
<li><p>可扩展，支持增加自定义匹配</p>
</li>
</ul>
<p>2、基础匹配 API：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expect(x).to.equal(y); // x 与 y 相等</span><br><span class="line">expect(x).to.beIdenticalTo(y); // x 与 y 相等且内存地址相同</span><br><span class="line">expect(x).to.beNil(); // x 为 nil</span><br><span class="line">expect(x).to.beTruthy(); // x 为 true（非 0）</span><br><span class="line">expect(x).to.beFalsy(); // x 为 false（0 值）</span><br></pre></td></tr></table></figure>

<p>3、异步匹配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">describe(@&quot;WebImage&quot;, ^&#123;</span><br><span class="line">	beforeAll(^&#123;</span><br><span class="line">	    // 设置默认延时匹配时间</span><br><span class="line">	    [Expecta setAsynchronousTestTimeout:2];</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	it(@&quot;will not be nil&quot;, ^&#123;</span><br><span class="line">	    //	使用默认延时匹配</span><br><span class="line">	    expect(webImage).willNot.beNil();</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	it(@&quot;should equal 42 after 3 seconds&quot;, ^&#123;</span><br><span class="line">	    // 不使用默认延时匹配，手动设置为3秒</span><br><span class="line">	    expect(webImage).after(3).to.equal(42);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>4、自定义使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;Specta/Specta.h&gt;</span><br><span class="line">#import &lt;Expecta/Expecta.h&gt;</span><br><span class="line">#import &quot;ImageModel.h&quot;</span><br><span class="line"></span><br><span class="line">SpecBegin(ImageModel);</span><br><span class="line"></span><br><span class="line">__block ImageModel *model;</span><br><span class="line"></span><br><span class="line">beforeEach(^&#123;</span><br><span class="line">    model = [[ImageModel alloc] initWithUrl:@&quot;http://pic37.nipic.com/20140113/8800276_184927469000_2.png&quot; title:@&quot;天空独角马&quot; described:@&quot;在黄色的沙漠里，特别突兀&quot;];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(@&quot;should not nil&quot;, ^&#123;</span><br><span class="line">    expect(model).toNot.beNil();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">it(@&quot;equal&quot;, ^&#123;</span><br><span class="line">    expect(model.url).to.equal(@&quot;http://pic37.nipic.com/20140113/8800276_184927469000_2.png&quot;);</span><br><span class="line">    expect(model.title).to.equal(@&quot;天空独角马&quot;);</span><br><span class="line">    expect(model.described).to.equal(@&quot;在黄色的沙漠里，特别突兀&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">SpecEnd;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Expecta 和 Specta 需要配合使用，与 XCTest 一样都是基于 XCTestCase 实现。在断言的使用上，XCTest 太过死板，Expecta 和 Specta 则很灵活，可以满足大部分场景需求。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>objc</tag>
        <tag>ios</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>X-Callback-URL 在‘今日账单’中的使用</title>
    <url>/2019-11-24-x-callback-url-cn/</url>
    <content><![CDATA[<p><strong>今日账单</strong> 实现了 <a href="http://x-callback-url.com/">x-callback-url</a> 协议，这是一种通用的 URL Scheme 协议。它能让你在不通的 App 之间通信，<a href="https://workflow.is/">Workflow</a>、<a href="https://contrast.co/launch-center-pro/">Launch Center Pro</a> 等 App 都支持了 x-callback-url，因此 <strong>今日账单</strong> 也支持与他们协作。</p>
<span id="more"></span>

<p>今日账单 的 <code>x-callback-url</code> 格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">niffler://x-callback-url/[动作]?[动作参数]&amp;[x-callback 参数]</span><br></pre></td></tr></table></figure>

<h3 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h3><p><code>/account</code></p>
<p>使用指定的名字创建账本</p>
<p><code>/bill</code></p>
<p>使用指定的名称和数字创建账单</p>
<h3 id="动作参数"><a href="#动作参数" class="headerlink" title="动作参数"></a>动作参数</h3><p><code>name</code>（必选）账本或账单项目名称</p>
<p><code>value</code>，当动作为bill时，为必选参数。账单开销数值。</p>
<p><code>type</code>，当动作为bill时，为必选参数。账单开销类型，0 支出，1 收入，2 已报销。</p>
<p><code>remark</code>（可选），备注信息</p>
<p><code>payway</code>（可选），账单支付方式</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>1.创建一个名为“装修”，备注信息为“店铺”的账本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">niffler://x-callback-url/account?name=装修&amp;remark=店铺</span><br></pre></td></tr></table></figure>

<p>2.创建一条类别为“饮食”的“午餐”通过“现金”支出 12 元的账单。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">niffler://x-callback-url/bill?name=饮食&amp;type=0&amp;remark=午餐&amp;value=12&amp;payway=现金</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本文档对应 App 版本为 3.7.6 及以上</p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>Niffler</tag>
      </tags>
  </entry>
  <entry>
    <title>Use of X-Callback-URL in &#39;Niffler&#39;</title>
    <url>/2019-11-24-x-callback-url-en/</url>
    <content><![CDATA[<p><strong>Niffler</strong> implements the <a href="http://x-callback-url.com/">x-callback-url</a> protocol, a generic URL Scheme protocol. It allows you to communicate between different apps. <a href="https://workflow.is/">Workflow</a>, <a href="https://contrast.co/launch-center-pro/">Launch Center Pro</a> and other apps support x-callback-url, so <strong>Niffler</strong> also supports working with them.</p>
<span id="more"></span>

<p>Niffler’s <code>x-callback-url</code> format is:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">niffler://x-callback-url/[action]?[action parameter]&amp;[x-callback parameter]</span><br></pre></td></tr></table></figure>

<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p><code>/account</code></p>
<p>Create account with specified name</p>
<p><code>/bill</code></p>
<p>Create a bill with the specified name and number</p>
<h3 id="Action-Parameters"><a href="#Action-Parameters" class="headerlink" title="Action Parameters"></a>Action Parameters</h3><p><code>name</code>(required), Account or bill item name</p>
<p><code>value</code>, This parameter is required when the action is bill. Billing overhead figures.</p>
<p><code>type</code>, This parameter is required when the action is bill. Billing expense type, 0 expenses, 1 income, 2 reimbursed.</p>
<p><code>remark</code>(optional), Remark Information</p>
<p><code>payway</code>(optional), Bill payment method</p>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>1.Create a account named “Decoration” with a remark of “Shop”.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">niffler://x-callback-url/account?name=Decoration&amp;remark=Shop</span><br></pre></td></tr></table></figure>

<p>2.Create a bill of “Lunch” with the category “Diet” to spend $ 12 in “Cash”.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">niffler://x-callback-url/bill?name=Diet&amp;type=0&amp;remark=Lunch&amp;value=12&amp;payway=Cash</span><br></pre></td></tr></table></figure>

<h3 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h3><p>This document corresponds to the App version 3.7.6 and above</p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>Niffler</tag>
      </tags>
  </entry>
  <entry>
    <title>一个解决WebRTC在iOS模拟器红屏问题的实践</title>
    <url>/2022-08-21-A-solution-to-the-WebRTC-in-iOS-simulator-red-screen-problem-practice/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>随着音视频、云游戏越来越火，一个开源解决方案 WebRTC 成为了众多技术者绕不过的框架。在了解 WebRTC 基础流程后，笔者也萌生了一个想法：使用 WebRTC 实现一个点对点的视频 &amp; 文本单聊程序。根据 WebRTC 的框架能力，视频聊天属于其基础功能。想到就做，笔者开始将想法落地。</p>
<p>笔者在实现点对点视频通信过程中，遇到了 iOS 模拟器红屏问题。本文主要记录如何解决这一问题。主要对 SDP 进行解读，分享在编辑 SDP 过程中遇到的问题。</p>
<span id="more"></span>

<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>WebRTC 虽然可以实现点对点通信，但是在其通道建立过程中，有一个信令交互环节，则必要无法完全脱离服务器，为此我们需要搭建一个信令服务器。</p>
<p>我们可以使用 node.js 来实现一个简单的 websocket 服务器，其只需要做一件事：广播收到的数据。我们还可以选择使用 swift 来实现这样一个简单的信令服务器。</p>
<p>总结一下，我们需要的环境：</p>
<ul>
<li>1）MacOS 设备，例如 Mac Mini</li>
<li>2）信令服务器一台</li>
</ul>
<h1 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h1><p>在环境搭建完毕，工程实现完成后，急切点开应用程序的视频通话按钮后，看到的是如下图效果</p>
<p><img src="/assets/images/webrtc/%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%BA%A2%E5%B1%8F%E6%95%88%E6%9E%9C.png" alt="模拟器红屏效果"></p>
<p>是的，笔者遇到了模拟器上运行视频通话后红屏的问题。</p>
<p>这似乎是 WebRTC 在 H264 上的一个 bug，官方也发现了，所以出了一个 <a href="https://bugs.chromium.org/p/webrtc/issues/detail?id=11012">错误报告</a>。该 bug 的具体原因不在本文讨论。而想要解决该问题，则有两种方案。</p>
<ul>
<li>1）修改源代码</li>
</ul>
<p>援引 Stack Overflow 上的方案 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fix is to not set attribute &#x27;kCVPixelBufferIOSurfacePropertiesKey&#x27; in  RTCVideoDecoderH264.mm for TARGET_IPHONE_SIMULATOR</span><br></pre></td></tr></table></figure>

<p>笔者亲测有效。此方案的麻烦点在于，我们改动完源代码后，需要自行编译，重新生成 <code>WebRTC.framework</code> 文件。</p>
<ul>
<li>2）修改 SDP 内容</li>
</ul>
<p>WebRTC 在 iOS 模拟器上会出现红屏问题，主要还是因为框架对 H264 的解码出现的 bug，我们可以通过在模拟器上不使用 H264 来规避此问题。因此，我们可以在应用层编辑 SDP 内容来达到禁用 H264 编码的目的。</p>
<h2 id="SDP-是什么"><a href="#SDP-是什么" class="headerlink" title="SDP 是什么"></a>SDP 是什么</h2><p>想要编辑 SDP，我们首先需要了解它。SDP（Session Description Protocol），会话描述的协议,它不包含传输协议。</p>
<h3 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                                +---------------------+</span><br><span class="line">                                                |        v=           |</span><br><span class="line">                                                +---------------------+</span><br><span class="line">                +---------------------+         +---------------------+</span><br><span class="line">        ====    |   Session Metadata  |  =====  |        o=           |</span><br><span class="line">        |       +---------------------+         +----------------------</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |        t=           |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |        c=           |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |       +---------------------+</span><br><span class="line">        ====    | Network Description |   =====</span><br><span class="line">        |       +---------------------+</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |    a=candidate      |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |        m=           |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |        +---------------------+        +---------------------+</span><br><span class="line">        ====     | Stream Description  |  ===== |      a=rtpmap       |</span><br><span class="line">        |        +---------------------+        +----------------------</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |      a=fmtp         |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |      a=sendrecv..   |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">+---------------+</span><br><span class="line">|    SEMANTIC   |</span><br><span class="line">| COMPONENTS OF |</span><br><span class="line">|     SDP       |</span><br><span class="line">+---------------+</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |      a=crypto       |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |         +---------------------+       +---------------------+</span><br><span class="line">        ====      |Security Descriptions|  =====|      a=ice-frag     |</span><br><span class="line">        |         +---------------------+       +----------------------</span><br><span class="line">				 |                                       +---------------------+</span><br><span class="line">        |                                       |      a=ice-pwd      |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |     a=fingerprint   |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |                                       |      a=rtcp-fb      |</span><br><span class="line">        |                                       +---------------------+</span><br><span class="line">        |         +---------------------+       +---------------------+</span><br><span class="line">        ====      |   Qos,Grouping      |       |                     |</span><br><span class="line">                  |   Descriptions      |  =====|       a=group       |</span><br><span class="line">                  +---------------------+       +----------------------</span><br><span class="line">                                                +---------------------+</span><br><span class="line">                                                |       a=rtcpmux     |</span><br><span class="line">                                                +---------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上文可以知道 SDP 有五个部分：</p>
<ul>
<li>Session Metadata</li>
<li>Network Description</li>
<li>Stream Description</li>
<li>Security Descriptions</li>
<li>Qos, Grouping Descriptions</li>
</ul>
<h3 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h3><p>下面根据 RTCPeerConnection.createOffer 产生的 SDP 进行解读（RFC4566）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SDP 类型，有 offer、answer</span><br><span class="line">offer</span><br><span class="line">// ---------------------- Session Metadata -------------------//</span><br><span class="line">// v = 0  “v =”字段给出SDP的版本,默认为0。</span><br><span class="line">v=0</span><br><span class="line">// o = &lt;username&gt; &lt;sess-id&gt; &lt;sess-version&gt; &lt;nettype&gt; &lt;addrtype&gt; &lt;unicast-address&gt; </span><br><span class="line">// &lt;username&gt; 是用户在始发主机上的登录名</span><br><span class="line">// &lt;sess-id&gt; &lt;sess-id&gt;是一个数字字符串，使得&lt;username&gt;&lt;sess-id&gt;nettype&gt;&lt;addrtype&gt;和&lt;unicast-address&gt;的元组形成会话的全局唯一标识符。</span><br><span class="line">// &lt;sess-version&gt;是此会话描述的版本号 </span><br><span class="line">// &lt;nettype&gt;是一个给出网络类型的文本字符串。 “IN”被定义为具有“Internet”的含义</span><br><span class="line">// &lt;addrtype&gt;是一个文本字符串，给出了后面的地址类型 定义了“IP4”和“IP6”</span><br><span class="line">// &lt;unicast-address&gt;是创建会话的计算机的地址。 </span><br><span class="line">o=- 4764183099742106259 2 IN IP4 127.0.0.1</span><br><span class="line">// s = &lt;会话名称&gt;  “s =”字段是文本会话名称.每个会话描述必须有一个且只有一个“s =”字段。“s =”字段不能为空</span><br><span class="line">s=-</span><br><span class="line">// t =&lt;start-time&gt; &lt;stop-time&gt;“t =”行指定会话的开始和停止时间。如果&lt;stop-time&gt;设置为零，则会话不受限制，但在&lt;start-time&gt;之后才会生效。如果&lt;start-time&gt;也为零，则会话被视为永久会话。</span><br><span class="line">t=0 0</span><br><span class="line">//********************* Session Metadata ********************//</span><br><span class="line"></span><br><span class="line">//---------------------- Security Descriptions-------------------//</span><br><span class="line">//a = &lt;attribute&gt;：&lt;value&gt; </span><br><span class="line">//a = &lt;fingerprint&gt; SRIP 所需的DTLS指纹信息</span><br><span class="line">a=fingerprint:sha-256 00:B3:00:58:25:4A:7D:C7:CB:E3:C6:63:43:03:71:63:33:73:CE:F9:CE:12:52:4C:95:2E:0E:96:FC:93:CE:11</span><br><span class="line">// Negotiating Media Multiplexing Using the Session Description Protocol</span><br><span class="line">// 表示需要共用一个传输通道传输的媒体，通过ssrc进行区分不同的流。如果没有这一行，音视频数据就会分别用单独udp端口来发送</span><br><span class="line">a=group:BUNDLE 0 1 2</span><br><span class="line">a=extmap-allow-mixed</span><br><span class="line">// WebRTC MediaStream Identification in the Session Description Protocol</span><br><span class="line">// 标识SDP中包含MediaStream的标识</span><br><span class="line">a=msid-semantic: WMS stream</span><br><span class="line">a=ice-ufrag:9gy+</span><br><span class="line">a=ice-pwd:FlgstiDMt4ffZ2NumjV7UZPP</span><br><span class="line">// Trickle ICE:Incremental Provisioning of Candidates for the Interactive Connectivity Establishment (ICE) Protocol</span><br><span class="line">// ICE建立候选时 采用增量设置的方式</span><br><span class="line">a=ice-options:trickle renomination</span><br><span class="line">// DTLS 握手方式 &quot;active&quot; / &quot;passive&quot; / &quot;actpass&quot;/ &quot;holdconn&quot;   &#x27;actpass&#x27;： 连接或启动传出连接。</span><br><span class="line">a=setup:actpass</span><br><span class="line">a=mid:0</span><br><span class="line">//********************* Security Descriptions ********************//</span><br><span class="line"></span><br><span class="line">//---------------------- Stream Description -------------------//</span><br><span class="line">// m=&lt;media&gt; &lt;port&gt; &lt;proto&gt; &lt;fmt&gt; ...</span><br><span class="line">// &lt;media&gt;是媒体类型 当前定义的媒体 &quot;audio&quot;,&quot;video&quot;, &quot;text&quot;, &quot;application&quot;, and &quot;message&quot;</span><br><span class="line">// &lt;port&gt;是传输媒体流的传输端口。在相关的“c =”字段中指定，以及在媒体字段的&lt;proto&gt;子字段中定义的传输协议。</span><br><span class="line">// &lt;proto&gt;是传输协议。传输协议的含义取决于相关“c =”字段中的地址类型字段。</span><br><span class="line">// &lt;fmt&gt;是媒体格式描述(编码类型)。第四个和任何后续 如果&lt;proto&gt;子字段是“RTP / AVP”或“RTP / SAVP”，则&lt;fmt&gt; 子字段包含RTP有效载荷类型号。</span><br><span class="line">m=audio 9 UDP/TLS/RTP/SAVPF 111 63 103 104 9 102 0 8 106 105 13 110 112 113 126</span><br><span class="line">// c=&lt;nettype&gt; &lt;addrtype&gt; &lt;connection-address&gt;</span><br><span class="line">// 会话描述必须包含 每个媒体描述中的至少一个“c =”字段或会话级别的单个“c =”字段</span><br><span class="line">// &lt;nettype&gt;   “IN”被定义为具有“Internet”的含义</span><br><span class="line">// &lt;addrtype&gt; 为IP4和IP6时</span><br><span class="line">c=IN IP4 0.0.0.0</span><br><span class="line">// The URI for declaring this header extension in an extmap attribute is &quot;urn:ietf:params:rtp-hdrext:ssrc-audio-level&quot;.</span><br><span class="line">a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level</span><br><span class="line">a=extmap:2 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time</span><br><span class="line">a=extmap:3 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01</span><br><span class="line">a=extmap:4 urn:ietf:params:rtp-hdrext:sdes:mid</span><br><span class="line">//a = sendrecv 这指定应以发送和接收模式启动工具。对于具有默认为仅接收模式的工具的交互式会议，这是必需的。</span><br><span class="line">a=sendrecv</span><br><span class="line">a=msid:stream audio0</span><br><span class="line">// &quot;a = rtcp-mux&quot;属性以指示需要RTP和RTCP多路复用</span><br><span class="line">a=rtcp-mux</span><br><span class="line">a=rtpmap:111 opus/48000/2</span><br><span class="line">a=rtcp-fb:111 transport-cc</span><br><span class="line">a=fmtp:111 minptime=10;useinbandfec=1</span><br><span class="line">a=rtpmap:63 red/48000/2</span><br><span class="line">a=fmtp:63 111/111</span><br><span class="line">a=ssrc:3316495333 cname:FlAaGq79STLBNArX</span><br><span class="line">a=ssrc:3316495333 msid:stream audio0</span><br><span class="line">m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 127 124 35 36 123 122 125</span><br><span class="line">c=IN IP4 0.0.0.0</span><br><span class="line">a=rtcp:9 IN IP4 0.0.0.0</span><br><span class="line">a=ice-ufrag:9gy+</span><br><span class="line">a=ice-pwd:FlgstiDMt4ffZ2NumjV7UZPP</span><br><span class="line">a=ice-options:trickle renomination</span><br><span class="line">a=fingerprint:sha-256 00:B3:00:58:25:4A:7D:C7:CB:E3:C6:63:43:03:71:63:33:73:CE:F9:CE:12:52:4C:95:2E:0E:96:FC:93:CE:11</span><br><span class="line">a=setup:actpass</span><br><span class="line">a=mid:1</span><br><span class="line">a=extmap:14 urn:ietf:params:rtp-hdrext:toffset</span><br><span class="line">a=extmap:2 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time</span><br><span class="line">a=extmap:13 urn:3gpp:video-orientation</span><br><span class="line">a=extmap:3 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01</span><br><span class="line">a=extmap:5 http://www.webrtc.org/experiments/rtp-hdrext/playout-delay</span><br><span class="line">a=extmap:6 http://www.webrtc.org/experiments/rtp-hdrext/video-content-type</span><br><span class="line">a=extmap:7 http://www.webrtc.org/experiments/rtp-hdrext/video-timing</span><br><span class="line">a=extmap:8 http://www.webrtc.org/experiments/rtp-hdrext/color-space</span><br><span class="line">a=extmap:4 urn:ietf:params:rtp-hdrext:sdes:mid</span><br><span class="line">a=extmap:10 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id</span><br><span class="line">a=extmap:11 urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id</span><br><span class="line">a=sendrecv</span><br><span class="line">a=msid:stream video0</span><br><span class="line">a=rtcp-mux</span><br><span class="line">a=rtcp-rsize</span><br><span class="line">// rtpmap：&lt;payload type&gt; &lt;encoding name&gt; / &lt;clock rate&gt; [/ &lt;encoding parameters&gt;]</span><br><span class="line">// &lt;payload type&gt; 此属性从RTP有效内容类型编号（在 “m =”行中使用）映射到表示要使用的有效载荷格式,编码类型 采样率 编码参数</span><br><span class="line">// 而以下格式的编码的格式要去相应编码格式标准文档中查看 比如H264 就是RFC3984 https://tools.ietf.org/html/rfc3984</span><br><span class="line">a=rtpmap:96 H264/90000</span><br><span class="line">a=rtcp-fb:96 goog-remb</span><br><span class="line">a=rtcp-fb:96 transport-cc</span><br><span class="line">a=rtcp-fb:96 ccm fir</span><br><span class="line">// a = rtcp-fb： RTCP-FB-PT SP RTCP-FB-VAL CRLF</span><br><span class="line">// rtcp-fb-pt是有效负载类型</span><br><span class="line">// rtcp-fb-val定义反馈消息的类型 ack，nack，trr-int和rtcp-fb-id</span><br><span class="line">a=rtcp-fb:96 nack</span><br><span class="line">a=rtcp-fb:96 nack pli</span><br><span class="line">a=fmtp:96 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=640c1f</span><br><span class="line">a=rtpmap:97 rtx/90000</span><br><span class="line">a=fmtp:97 apt=96</span><br><span class="line">a=rtpmap:98 H264/90000</span><br><span class="line">a=rtcp-fb:98 goog-remb</span><br><span class="line">a=rtcp-fb:98 transport-cc</span><br><span class="line">a=rtcp-fb:98 ccm fir</span><br><span class="line">a=rtcp-fb:98 nack</span><br><span class="line">a=rtcp-fb:98 nack pli</span><br><span class="line">a=fmtp:98 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f</span><br><span class="line">a=rtpmap:99 rtx/90000</span><br><span class="line">a=fmtp:99 apt=98</span><br><span class="line">a=rtpmap:100 VP8/90000</span><br><span class="line">a=rtcp-fb:100 goog-remb</span><br><span class="line">a=rtcp-fb:100 transport-cc</span><br><span class="line">a=rtcp-fb:100 ccm fir</span><br><span class="line">a=rtcp-fb:100 nack</span><br><span class="line">a=rtcp-fb:100 nack pli</span><br><span class="line">a=rtpmap:101 rtx/90000</span><br><span class="line">a=fmtp:101 apt=100</span><br><span class="line">a=rtpmap:125 ulpfec/90000</span><br><span class="line">a=ssrc-group:FID 2531124184 1348659893</span><br><span class="line">a=ssrc:2531124184 cname:FlAaGq79STLBNArX</span><br><span class="line">a=ssrc:2531124184 msid:stream video0</span><br><span class="line">a=ssrc:1348659893 cname:FlAaGq79STLBNArX</span><br><span class="line">a=ssrc:1348659893 msid:stream video0</span><br><span class="line">m=application 9 UDP/DTLS/SCTP webrtc-datachannel</span><br><span class="line">c=IN IP4 0.0.0.0</span><br><span class="line">a=ice-ufrag:9gy+</span><br><span class="line">a=ice-pwd:FlgstiDMt4ffZ2NumjV7UZPP</span><br><span class="line">a=ice-options:trickle renomination</span><br><span class="line">a=fingerprint:sha-256 00:B3:00:58:25:4A:7D:C7:CB:E3:C6:63:43:03:71:63:33:73:CE:F9:CE:12:52:4C:95:2E:0E:96:FC:93:CE:11</span><br><span class="line">a=setup:actpass</span><br><span class="line">a=mid:2</span><br><span class="line">a=sctp-port:5000</span><br><span class="line">a=max-message-size:262144</span><br></pre></td></tr></table></figure>

<h3 id="媒体流信息"><a href="#媒体流信息" class="headerlink" title="媒体流信息"></a>媒体流信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// m=&lt;media&gt; &lt;port&gt; &lt;proto&gt; &lt;fmt&gt; ...</span><br><span class="line">// &lt;media&gt;是媒体类型 当前定义的媒体 &quot;audio&quot;,&quot;video&quot;, &quot;text&quot;, &quot;application&quot;, and &quot;message&quot;</span><br><span class="line">// &lt;port&gt;是传输媒体流的传输端口。在相关的“c =”字段中指定，以及在媒体字段的&lt;proto&gt;子字段中定义的传输协议。</span><br><span class="line">// &lt;proto&gt;是传输协议。传输协议的含义取决于相关“c =”字段中的地址类型字段。</span><br><span class="line">// &lt;fmt&gt;是媒体格式描述(编码类型)。第四个和任何后续 如果&lt;proto&gt;子字段是“RTP / AVP”或“RTP / SAVP”，则&lt;fmt&gt; 子字段包含RTP有效载荷类型号。</span><br><span class="line">m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 127 124 35 36 123 122 125</span><br><span class="line">c=IN IP4 0.0.0.0</span><br><span class="line">a=rtcp:9 IN IP4 0.0.0.0</span><br><span class="line">a=ice-ufrag:9gy+</span><br><span class="line">a=ice-pwd:FlgstiDMt4ffZ2NumjV7UZPP</span><br><span class="line">a=ice-options:trickle renomination</span><br><span class="line">a=fingerprint:sha-256 00:B3:00:58:25:4A:7D:C7:CB:E3:C6:63:43:03:71:63:33:73:CE:F9:CE:12:52:4C:95:2E:0E:96:FC:93:CE:11</span><br><span class="line">a=setup:actpass</span><br><span class="line">a=mid:1</span><br><span class="line">a=extmap:14 urn:ietf:params:rtp-hdrext:toffset</span><br><span class="line">a=extmap:2 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time</span><br><span class="line">a=extmap:13 urn:3gpp:video-orientation</span><br><span class="line">a=extmap:3 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01</span><br><span class="line">a=extmap:5 http://www.webrtc.org/experiments/rtp-hdrext/playout-delay</span><br><span class="line">a=extmap:6 http://www.webrtc.org/experiments/rtp-hdrext/video-content-type</span><br><span class="line">a=extmap:7 http://www.webrtc.org/experiments/rtp-hdrext/video-timing</span><br><span class="line">a=extmap:8 http://www.webrtc.org/experiments/rtp-hdrext/color-space</span><br><span class="line">a=extmap:4 urn:ietf:params:rtp-hdrext:sdes:mid</span><br><span class="line">a=extmap:10 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id</span><br><span class="line">a=extmap:11 urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id</span><br><span class="line">a=sendrecv</span><br><span class="line">a=msid:stream video0</span><br><span class="line">a=rtcp-mux</span><br><span class="line">a=rtcp-rsize</span><br><span class="line">a=rtpmap:96 H264/90000</span><br><span class="line">a=rtcp-fb:96 goog-remb</span><br><span class="line">a=rtcp-fb:96 transport-cc</span><br><span class="line">a=rtcp-fb:96 ccm fir</span><br><span class="line">a=rtcp-fb:96 nack</span><br><span class="line">a=rtcp-fb:96 nack pli</span><br><span class="line">a=fmtp:96 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=640c1f</span><br><span class="line">a=rtpmap:97 rtx/90000</span><br><span class="line">a=fmtp:97 apt=96</span><br><span class="line">a=rtpmap:98 H264/90000</span><br><span class="line">a=rtcp-fb:98 goog-remb</span><br><span class="line">a=rtcp-fb:98 transport-cc</span><br><span class="line">a=rtcp-fb:98 ccm fir</span><br><span class="line">a=rtcp-fb:98 nack</span><br><span class="line">a=rtcp-fb:98 nack pli</span><br><span class="line">a=fmtp:98 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f</span><br><span class="line">a=rtpmap:99 rtx/90000</span><br><span class="line">a=fmtp:99 apt=98</span><br><span class="line">a=rtpmap:100 VP8/90000</span><br><span class="line">a=rtcp-fb:100 goog-remb</span><br><span class="line">a=rtcp-fb:100 transport-cc</span><br><span class="line">a=rtcp-fb:100 ccm fir</span><br><span class="line">a=rtcp-fb:100 nack</span><br><span class="line">a=rtcp-fb:100 nack pli</span><br><span class="line">a=rtpmap:101 rtx/90000</span><br><span class="line">a=fmtp:101 apt=100</span><br><span class="line">a=rtpmap:127 VP9/90000</span><br><span class="line">a=rtcp-fb:127 goog-remb</span><br><span class="line">a=rtcp-fb:127 transport-cc</span><br><span class="line">a=rtcp-fb:127 ccm fir</span><br><span class="line">a=rtcp-fb:127 nack</span><br><span class="line">a=rtcp-fb:127 nack pli</span><br><span class="line">a=rtpmap:124 rtx/90000</span><br><span class="line">a=fmtp:124 apt=127</span><br><span class="line">a=rtpmap:35 AV1/90000</span><br><span class="line">a=rtcp-fb:35 goog-remb</span><br><span class="line">a=rtcp-fb:35 transport-cc</span><br><span class="line">a=rtcp-fb:35 ccm fir</span><br><span class="line">a=rtcp-fb:35 nack</span><br><span class="line">a=rtcp-fb:35 nack pli</span><br><span class="line">a=rtpmap:36 rtx/90000</span><br><span class="line">a=fmtp:36 apt=35</span><br><span class="line">a=rtpmap:123 red/90000</span><br><span class="line">a=rtpmap:122 rtx/90000</span><br><span class="line">a=fmtp:122 apt=123</span><br><span class="line">a=rtpmap:125 ulpfec/90000</span><br><span class="line">a=ssrc-group:FID 2531124184 1348659893</span><br><span class="line">a=ssrc:2531124184 cname:FlAaGq79STLBNArX</span><br><span class="line">a=ssrc:2531124184 msid:stream video0</span><br><span class="line">a=ssrc:1348659893 cname:FlAaGq79STLBNArX</span><br><span class="line">a=ssrc:1348659893 msid:stream video0</span><br></pre></td></tr></table></figure>

<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>上文中提到修改源代码来解决红屏问题。另外一种方式就是修改 SDP 内容，而 SDP 的内容修改，也有两个方法。其一是修改底层源代码生成 offer 的实现，将 H264 在模拟器环境下排除。另一种则是在应用层修改 SDP 内容。</p>
<p>在实际修改过程中，很可能会遇到 <code>Session Description is NULL.</code> 报错。相信笔者，我们的实现思路是没有错的，只要再注意一些小细节即可。</p>
<ul>
<li>1）在  <code>RTCPeerConnection.setRemoteDescription</code> 前修改 SDP 内容。</li>
<li>2）注意 <code>\r\n</code> 符号。</li>
</ul>
<p>我们需要确保将上文示例 SDP 内容修改如下即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m=video 9 UDP/TLS/RTP/SAVPF 100 101 127 124 35 36 123 122 125</span><br><span class="line">c=IN IP4 0.0.0.0</span><br><span class="line">a=rtcp:9 IN IP4 0.0.0.0</span><br><span class="line">a=ice-ufrag:9gy+</span><br><span class="line">a=ice-pwd:FlgstiDMt4ffZ2NumjV7UZPP</span><br><span class="line">a=ice-options:trickle renomination</span><br><span class="line">a=fingerprint:sha-256 00:B3:00:58:25:4A:7D:C7:CB:E3:C6:63:43:03:71:63:33:73:CE:F9:CE:12:52:4C:95:2E:0E:96:FC:93:CE:11</span><br><span class="line">a=setup:actpass</span><br><span class="line">a=mid:1</span><br><span class="line">a=extmap:14 urn:ietf:params:rtp-hdrext:toffset</span><br><span class="line">a=extmap:2 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time</span><br><span class="line">a=extmap:13 urn:3gpp:video-orientation</span><br><span class="line">a=extmap:3 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01</span><br><span class="line">a=extmap:5 http://www.webrtc.org/experiments/rtp-hdrext/playout-delay</span><br><span class="line">a=extmap:6 http://www.webrtc.org/experiments/rtp-hdrext/video-content-type</span><br><span class="line">a=extmap:7 http://www.webrtc.org/experiments/rtp-hdrext/video-timing</span><br><span class="line">a=extmap:8 http://www.webrtc.org/experiments/rtp-hdrext/color-space</span><br><span class="line">a=extmap:4 urn:ietf:params:rtp-hdrext:sdes:mid</span><br><span class="line">a=extmap:10 urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id</span><br><span class="line">a=extmap:11 urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id</span><br><span class="line">a=sendrecv</span><br><span class="line">a=msid:stream video0</span><br><span class="line">a=rtcp-mux</span><br><span class="line">a=rtcp-rsize</span><br><span class="line">a=rtpmap:100 VP8/90000</span><br><span class="line">a=rtcp-fb:100 goog-remb</span><br><span class="line">a=rtcp-fb:100 transport-cc</span><br><span class="line">a=rtcp-fb:100 ccm fir</span><br><span class="line">a=rtcp-fb:100 nack</span><br><span class="line">a=rtcp-fb:100 nack pli</span><br><span class="line">a=rtpmap:101 rtx/90000</span><br><span class="line">a=fmtp:101 apt=100</span><br><span class="line">a=rtpmap:127 VP9/90000</span><br><span class="line">a=rtcp-fb:127 goog-remb</span><br><span class="line">a=rtcp-fb:127 transport-cc</span><br><span class="line">a=rtcp-fb:127 ccm fir</span><br><span class="line">a=rtcp-fb:127 nack</span><br><span class="line">a=rtcp-fb:127 nack pli</span><br><span class="line">a=rtpmap:124 rtx/90000</span><br><span class="line">a=fmtp:124 apt=127</span><br><span class="line">a=rtpmap:35 AV1/90000</span><br><span class="line">a=rtcp-fb:35 goog-remb</span><br><span class="line">a=rtcp-fb:35 transport-cc</span><br><span class="line">a=rtcp-fb:35 ccm fir</span><br><span class="line">a=rtcp-fb:35 nack</span><br><span class="line">a=rtcp-fb:35 nack pli</span><br><span class="line">a=rtpmap:36 rtx/90000</span><br><span class="line">a=fmtp:36 apt=35</span><br><span class="line">a=rtpmap:123 red/90000</span><br><span class="line">a=rtpmap:122 rtx/90000</span><br><span class="line">a=fmtp:122 apt=123</span><br><span class="line">a=rtpmap:125 ulpfec/90000</span><br><span class="line">a=ssrc-group:FID 2531124184 1348659893</span><br><span class="line">a=ssrc:2531124184 cname:FlAaGq79STLBNArX</span><br><span class="line">a=ssrc:2531124184 msid:stream video0</span><br><span class="line">a=ssrc:1348659893 cname:FlAaGq79STLBNArX</span><br><span class="line">a=ssrc:1348659893 msid:stream video0</span><br></pre></td></tr></table></figure>

<h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p><img src="/assets/images/webrtc/%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%BA%A2%E5%B1%8F%E6%95%88%E6%9E%9C%E4%BF%AE%E5%A4%8D.png" alt="模拟器红屏效果修复"></p>
<p><strong>文中图片若有侵权，请联系笔者及时删除</strong></p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>objc</tag>
        <tag>ios</tag>
        <tag>webrtc</tag>
      </tags>
  </entry>
  <entry>
    <title>砸壳提取 ipa 包</title>
    <url>/2022-12-06-crack-export-ipa/</url>
    <content><![CDATA[<p>因为工作原因，需要对一个产品进行分析和了解，基于 <code>ipa</code> 包做一些解析。但是，因为 Apple 的安全机制，我们很难再获取 <code>ipa</code> 文件。</p>
<p>为了解决这个问题，作者想到了逆向工程，文章记录了如何操作，并成功实现 <code>ipa</code> 文件提取。</p>
<span id="more"></span>

<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul>
<li>越狱设备</li>
</ul>
<p>作者使用的是 iPhone 5s，iOS 12.5.5</p>
<ul>
<li>设备已经安装了 AF2（Apple File Conduit 2） 插件</li>
</ul>
<p>越狱操作可以使用<a href="https://www.i4.cn/">爱思助手</a>提供的<code>一键越狱</code>功能完成</p>
<ul>
<li>Clutch 工具</li>
</ul>
<p><a href="https://github.com/KJCracks/Clutch">https://github.com/KJCracks/Clutch</a></p>
<h1 id="拷贝-Clutch"><a href="#拷贝-Clutch" class="headerlink" title="拷贝 Clutch"></a>拷贝 Clutch</h1><p>有两种方法可以实现将 Clutch 拷贝至已越狱设备</p>
<p>1、可以通过爱思助手将 Clutch 可执行文件拷贝到 <code>/usr/bin</code> 路径下</p>
<p><img src="/assets/images/crack/%E7%88%B1%E6%80%9D%E5%8A%A9%E6%89%8B%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D.png" alt="爱思助手文件拷贝"></p>
<p>2、通过终端拷贝</p>
<p><code>$ scp Clutch root@设备ip:/usr/bin/</code></p>
<p>密码默认：<code>alpine</code>，设备ip可用通过查看网络信息获取，需要注意的是，设备与电脑需要连接在同一网络下。</p>
<h1 id="配置-Clutch"><a href="#配置-Clutch" class="headerlink" title="配置 Clutch"></a>配置 Clutch</h1><p>1、连接设备</p>
<p><code>$ ssh root@设备ip</code></p>
<p>通过 ssh 连接设备，密码默认：<code>alpine</code>。</p>
<p>连接成功后可以在设备 <code>/usr/bin/</code> 目录下查看 <code>Clutch</code> 是否存在。</p>
<p>2、给 Clutch 添加可执行权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cd /usr/bin</span><br><span class="line">$ chmod +x Clutch</span><br></pre></td></tr></table></figure>

<p>3、确定 Clutch 是否可执行</p>
<p>可以在命令行输入 Clutch，显示下图则说明操作成功</p>
<p><img src="/assets/images/crack/Clutch%E5%8F%AF%E7%94%A8%E5%8F%82%E6%95%B0.png" alt="Clutch可用参数"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ Clutch -b // 砸壳，砸壳后文件是二进制文件</span><br><span class="line">$ Clutch -d // 砸壳，砸壳后的文件是ipa文件</span><br><span class="line">$ Clutch -i // 查看越狱设备当前安装的应用列表</span><br></pre></td></tr></table></figure>

<h1 id="砸壳-amp-提取"><a href="#砸壳-amp-提取" class="headerlink" title="砸壳&amp;提取"></a>砸壳&amp;提取</h1><p>1、获取设备上的安装应用</p>
<p><code>$ Clutch -i</code></p>
<p><img src="/assets/images/crack/%E8%AE%BE%E5%A4%87%E4%B8%8A%E5%AE%89%E8%A3%85%E7%9A%84%E5%BA%94%E7%94%A8.png" alt="设备上安装的应用"></p>
<p>2、砸壳</p>
<p><code>$ Clutch -d 6</code></p>
<p>表示要砸 <code>云哈利波特：魔法觉醒</code> 这款应用的壳。</p>
<p><img src="/assets/images/crack/%E7%A0%B8%E5%A3%B3%E5%93%88%E5%88%A9%E6%B3%A2%E7%89%B9.png" alt="砸壳哈利波特"></p>
<p>3、DONE</p>
<p>上图中 <code>DONE</code> 即表示砸壳成功，后面则是<code>ipa</code>文件路径，可以通过爱思助手或终端将 <code>ipa</code> 文件导出。</p>
<p><code>scp -r root@设备ip:/private/var/mobile/Documents/Dumped/xxx.ipa ~/Desktop/</code></p>
<p>密码默认：<code>alpine</code>。</p>
<p>到此，整个砸壳和提取 <code>ipa</code> 文件操作结束。</p>
]]></content>
      <categories>
        <category>pieces</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>逆向</tag>
        <tag>安全</tag>
      </tags>
  </entry>
</search>
