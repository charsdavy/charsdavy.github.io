<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[sublime text 实用技巧]]></title>
      <url>%2F2017%2F03%2F30%2Fsublime-text-tool%2F</url>
      <content type="text"><![CDATA[Sublime Text 是一个代码编辑器（Sublime Text 2是收费软件，但可以无限期试用），也是HTML和散文先进的文本编辑器。Sublime Text是由程序员Jon Skinner于2008年1月份所开发出来，它最初被设计为一个具有丰富扩展功能的Vim。 笔者整理了一些使用快捷方式，以及一些常用插件，分享一下。 安装包控制（Package Control）打开Sublime Text 2，按快捷键 ctrl+` 或者点击 Tools → Command Palette 调出控制台Console；将以下代码复制粘贴进命令行后回车： 1import urllib2,os;pf=&apos;Package Control.sublime-package&apos;;ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp)elseNone;open(os.path.join(ipp,pf),&apos;wb&apos;).write(urllib2.urlopen(&apos;http://sublime.wbond.net/&apos;+pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) 重新启动Sublime Text 2，如果在Preferences → Package Settings 中看到 Package Control 这一项，就说明安装成功。 安装Alignment插件对于喜欢整齐的码农来说，这不失为一个省事的插件。该插件可以通过上面安装好的 Package Control 来安装： 按ctrl + shift + P调出命令面板； 输入 install 调出 Package Control：Install Package 选项，并回车； 输入Alignment，选中并按回车安装； 重启Sublime Text 2，选中文本并按ctrl + alt + a 就可以进行对齐操作了。 安装 Soda 主题这里的主题不同于针对代码的 color scheme，而是针对Sublime Text 2该软件本身的主题，该主题也可以通过万能的 Package Control 来安装。 按ctrl + shift + P调出命令面板； 输入 install 调出 Package Control：Install Package 选项，并回车； 输入 theme soda 选中后回车即可安装； 安装完之后要激活主题，打开 Preferences → Global Settings – User，加上以下代码保存即可生效： 1&quot;theme&quot;: &quot;Soda Light.sublime-theme&quot; 或者 &quot;theme&quot; : &quot;Soda Dark.sublime-theme&quot; 安装cTags插件首先，从Ctags官网下载压缩包下来，解压到电脑的某个地方，比如“C:\Program Files\ctags”，然后把cTags添加到系统变量里去：在“我的电脑”右键属性 → 高级 → 环境变量 → 在“系统变量”里找到“Path”，点击“编辑” → 把“;C:\Program Files\ctags”（不包括双引号）复制到最后 → 最后一路“确定”保存。 然后通过 Package Control 来安装 cTags 插件： 按ctrl + shift + P调出命令面板； 输入 install 调出 Package Control：Install Package 选项，并回车； 输入 ctags 选中后回车即可安装。 安装完之后，在项目的当前目录下按ctrl + t, ctrl + r，会生成.tags的文件。当光标停留在某个函数上时，按快捷键 ctrl+t, ctrl+t就可以打开函数所在的文件，并跳转到相应的位置了。 PS 安装这个插件折腾了我蛮久，主要是不知道还要从ctags官网下载压缩包，以及修改系统的变量，后来还是一博友给我发的国外的参考资料才知道要这样配置 的。刚开始知道这软件之所以没用是因为没有像eclipse可以追踪函数的功能，后来才知道可以通过安装cTags插件来实现。装上此功能后，就更喜欢用 Sublime Text 2了。 jsFormat插件格式化js：选中一段文本，control+alt+f。 DocBlockr 在JS函数上方输入/**，然后回车，doc就生成好了非常好用。 sublime-jslint 打开一个js文件，control+j，即可输出jsLint检查的结果。打开Packages目录，找到插件目录sublime-jslint，打开 sublime-jslint.sublime-settings文件，可以修改jsLint配置，还可以配置文件保存时自动检查等，如： 1&#123; // Path to the jslint jar. // Leave blank to use bundled jar. &quot;jslint_jar&quot;: &quot;&quot;, // Options pass to jslint. // Jerry Qu注：全部可用配置参考这里，https://github.com/fbzhong/sublime-jslint/wiki/Available- jslint4java-options &quot;jslint_options&quot;: &quot;--encoding utf-8 --bitwise --browser --cap --css --devel --debug --evil --forin --fragment --on --sub --white --windows --sloppy&quot;, // Ignore errors, regex. &quot;ignore_errors&quot;: [ // &quot;Expected an identifier and instead saw &apos;undefined&apos; \(a reserved word\)&quot; ], // run jslint on save. &quot;run_on_save&quot;: false, // debug flag. &quot;debug&quot;:false &#125; SideBarEnhancements推荐通过 Package Control 安装 SideBarEnhancements 这个插件，可以大大加强在侧栏目录树中右键的选项 推荐插件：1）Zen Coding 2）jQuery Package for sublime Text 3）Clipboard History 4）Bracket Highlighter 5）GBK to UTF8 6）Git 常用快捷键 按键组合 作用 Command+Shift+L 选中多行即可可以同时编辑这些行 control + Command +G 可以一次性选择全部相同的文件进行同时编辑 Ctrl+D 选词（反复按快捷键，即可继续向下同时选中下一个相同的文本进行同时编辑） Ctrl+G 跳转到相应的行 Ctrl+J 合并行（已选择需要合并的多行时） Ctrl+L 选择整行（按住-继续选择下行） Ctrl+M 光标移动至括号内开始或结束的位置 Ctrl+T 词互换 Ctrl+U 软撤销 Ctrl+P 查找当前项目中的文件和快速搜索；输入@查找文件主标题/函数；或者输入:跳转到文件某行； Ctrl+R 快速列出/跳转到某个函数 Ctrl+KBackspace 从光标处删除至行首 Ctrl+KB 开启/关闭侧边栏 Ctrl+KK 从光标处删除至行尾 Ctrl+KT 折叠属性 Ctrl+KU 改为大写 Ctrl+KL 改为小写 Ctrl+K0 展开所有 Ctrl+Enter 插入行后（快速换行） Ctrl+Tab 当前窗口中的标签页切换 Ctrl+Shift+A 选择光标位置父标签对儿 Ctrl+Shift+D 复制光标所在整行，插入在该行之前 ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找 Ctrl+Shift+K 删除整行 Ctrl+Shift+L 鼠标选中多行（按下快捷键），即可同时编辑这些行 Ctrl+Shift+M 选择括号内的内容（按住-继续选择父括号） Ctrl+Shift+P 打开命令面板 Ctrl+Shift+/ 注释已选择内容 Ctrl+Shift+↑ 可以移动此行代码，与上行互换 Ctrl+Shift+↓ 可以移动此行代码，与下行互换 Ctrl+Shift+[ 折叠代码 Ctrl+Shift+] 展开代码 Ctrl+Shift+Enter 光标前插入行 Ctrl+PageDown、Ctrl+PageUp 文件按开启的前后顺序切换 Ctrl+Z 撤销 Ctrl+Y 恢复撤销 Ctrl+F2 设置书签 Ctrl+/ 注释整行（如已选择内容，同“Ctrl+Shift+/”效果） Ctrl+鼠标左键 可以同时选择要编辑的多处文本 Shift+鼠标右键（或使用鼠标中键） 可以用鼠标进行竖向多行选择 Shift+F2 上一个书签 Shift+Tab 去除缩进 Alt+Shift+1~9（非小键盘） 屏幕显示相等数字的小窗口 Alt+. 闭合当前标签 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑 Tab 缩进,自动完成 F2 下一个书签 F6 检测语法错误 F9 行排序(按a-z) F11 全屏模式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[想说说文章版权]]></title>
      <url>%2F2017%2F03%2F29%2Farticle-copyright%2F</url>
      <content type="text"><![CDATA[文章版权，这个词汇以前笔者以前是不怎么有体会的，认为在当今互联网的时代，随便网上Google一下很多地方的文章如出一辙，而作者也是千奇百怪，甚至都不清楚谁才是作者。这篇文章，笔者是遇见了真实的事件，现在很想说一说，看看大家是否也是一样，认为一个版权意识高的视界里，资源与时间都是高效的。不用在看一条，两条都是一样的，浪费时间和资源。 不知道是否有人明白什么叫“版权”。说实在的，笔者并不是很清楚它的定义。这里引入百科的解释： 版权（copyright）是用来表述创作者因其文学和艺术作品而享有的权利的一个法律用语。 版权是对计算机程序、文学著作、音乐作品、照片、电影等的复制权利的合法所有权。除非转让给另一方，版权通常被认为是属于作者的。大多数计算机程序不仅受到版权的保护，还受软件许可证的保护。版权只保护思想的表达形式，而不保护思想本身。算法、数学方法、技术或机器的设计均不在版权的保护之列。 这个是属于法律领域了，只不过在天朝，大家都不认为这是事儿。不过现在好了，慢慢的付费阅读，付费视频等等开始流行，这样大家虽然花了米米，不过质量却是有了保证。 说回这篇文章的初衷，就是在这两天，笔者遇到了自己博客网站的文章别他人拿去分享，并攫取了利益。更巧的是，被笔者知道了。曾经在知乎一个问答里看见，关于招聘，面试官会直接pass掉那些抄袭他们文章的应聘者。看到之后笔者将自己转载，并备注了“转载”二字的文章删除干净。不错，或许笔者没有从中获利，不过确实有些文章是没有联系到作者的，虽然给了原链接，可是确实吸引了眼球。 现在，保证文章都是原创，无论深浅文雅如何，总归是自己的作品。相反，在不断撰写过程中，会发现很多自身的漏洞。网络已经很发达了，大家都能在网上找到自己需要的文章，干嘛还要做搬运工呢，笔者认为，高手应该转载于无形，即看懂原文加上自己的思考，想必比简单的复制拷贝要有价值得多。 笔者之前在一个“同行说”的平台分享自己的文章，后来转行了，渐渐时间少了，也就远离了一段时间的撰文。现在，又要安利大家了，这款开发者头条，内容不错，文章也很是有质量，笔者使用pocket已经收藏了不少好文。不过，这篇文章的始因也是源于此平台。平台有激励作者自荐的机制，积分商城应该算得上为数不多的几家良心公司。为此，笔者有空会创作原创，因为这样才能登上文章精选的列表。 可是，不得不说的一点是，平台没有很好的原创保护机制。笔者作为一个技术人员。看到几点问题： 1.平台有精选文章缓存。这样的后果就是，即使作者发现了自己文章的错误，修改之后还是不能同步到精选文章列表。 2.对于原创和非原创没有好的保护与甄别，除非巧合遇到像笔者这样的情况，且还是个较真的人。 3.软件聊天体验有待提高。emoji发送太麻烦，iOS平台必须依赖系统键盘的发送。Android端没有用过不清楚。 第一个问题，笔者建议可以使用定时机制，一段时间检测分享链接的内容，这样也能很好的保护原创。当原创作者发现自己的文章被他人肆意分享，只需改变文章地址即可令其失效。这样也就不存在原创甄别问题了。还保证了文章内容的同步。 第二个问题，技术不是问题，关键是否会为这个的细节付出时间。 不过，笔者自己也想过使用什么方式能够避免这样的问题，URL混淆？反爬虫？不知道是否可行。不过迫于无奈，现在笔者的文章顶部都加了一条申明。其实就是小偷和锁的问题，是否有效只取决于剽窃者。 最后，很感谢平台的及时沟通和处理，为笔者补回了损失。不过，却便宜了剽窃者。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS的那些面试]]></title>
      <url>%2F2017%2F03%2F28%2Fios-interview%2F</url>
      <content type="text"><![CDATA[笔试面试是程序员应聘绕不过的坎，想进大厂就一定要有知识储备量，而这个却是最佳的考察方式。笔者分享一些收集的iOS面试题，答案仅供参考，如有错误，还请指正。 第一部分1.Objective-C语言的基本特点？ Objective-C语言是C语言的一个超集，只是在C的基础之上添加了面向对象（OO）的特性；Objective-C与Java语言相同都是单继承，这一点与C++语言不同（多重继承），这一点可以参看之前有关讲解继承的文章；Objective-C不支持命名空间，取而代之的是在类名之前添加前缀，以此来区分。 2.#include与#import的区别，#import与@class的区别？ 1）#include和#import效果相同，只是后者不会引起交叉编译，确保头文件只会被导入一次。 2）#import会包含这个类的所有信息，包括实体变量和方法，而@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂时不用考虑，后面会再告诉你。使用#import编译效率高，防止相互包含的编译错误。 3.简述类目优缺点，如果覆盖本类或者父类的方法会出现什么问题？ 优点：不需要通过增加子类而增加现有类的行为（方法），且类目中的方法与原始类方法基本没有区别。 缺点：无法向类目添加实例变量。覆盖原始类方法后，原始类的方法没办法调用。 4.简述内存管理基本原则？ 如果使用alloc、copy（mutableCopy）或者retain一个对象时，你就有义务向它发送一条release或autorelease消息。其他方法创建的对象，不需要由你来管理内存。 5.什么是ARC技术？与GC是否相同？ ARC是Automatic Reference Counting的简称，我们称之为自动引用计数，是iOS5.0之后推出的内存管理的新特性。本质上还是使用引用计数来管理对象，只是我们在编写代码时，不需要向对象发送release或autorelease方法，也不可以调用dealloc方法，编译器会在合适的位置自动给用户生成release（autorelease）消息。GC是Garbage Collection，内存垃圾回收机制，ARC比GC性能好。 6.iOS中是否支持垃圾回收机制？ iOS开发只支持MRC与ARC，Mac开发支持GC垃圾回收机制，10.8之后弃用了GC，推荐使用ARC。 7.深、浅复制的基本概念以及区别？ 浅复制：只复制对象本身，不对里面的属性复制。 深复制：不仅复制对象本身，对象持有的属性对象也做复制。 8.内存中的堆区和栈区的差别？ 栈区（stack）由编译器自动分配释放，存放方法（函数）的参数值，局部变量的值等。 堆区（heap）一般由程序员分配与释放，若程序员不释放，则会内存溢出。 9.用户自定义了一个对象，如何实现拷贝（可变和不可变拷贝）？ 必须实现copying和mutableCopying协议，表示返回一个不可变和可变的对象。否则，程序将会出现异常。 1234567-(id)copyWithZone:(NSZone *)zone &#123; Person *person = [[self Class] allocWithZone:zone]; person-&gt;age = self.age; person-&gt;name = self.name; return person;&#125;-(id)mutableCopyWithZone:(NSZone *)zone; 10.定义属性时，什么时候用assign、retain、copy和nonatomic？ assign：普通赋值，一般常用于基本数据类型，常见委托设计模式，以此来防止循环引用。 retain：保留计数，获得了对象的所有权。引用计数在原有基础上加1。 copy：用来复制对象，一般字符串使用，Foundation中的不可变对象使用，效果相当于retain，只是引用计数加1。 nonatomic：非原子性访问，不加同步，多线程并发访问会提高性能。 11.strong和weak，_unsafe_unretained与weak的区别？ strong：强引用，在ARC中告诉编译器帮助我们自动插入retain。 weak：弱引用，是普通赋值，相当于手动管理内存的assign。 _unsafe_unretained：与weak功能一致，区别在于当指向的对象销毁后，weak会将变量置为nil，防止调用野指针。 12.ARC存在内存泄露吗？ ARC中如果内存管理不当的话，同样会存在内存泄露。例如，ARC中也会循环引用导致内存泄露；Objective-C对象与CoreFoundation类之间桥接时，管理不当也会产生内存泄露。 13.当我们释放对象时，为什么需要调用[super dealloc]方法？ 子类是继承自父类，那么子类中有一些实例变量（对象），是继承自父类的，因此，我们需要调用父类方法，将父类所拥有的实例进行释放。 14.自动释放池是什么，如何工作？ 自动释放池是NSAutorelease类的一个实例，当向一个对象发送autorelease消息时，该对象会自动入池，待池销毁时，将会向池中所有对象发送一条release消息，释放对象。 15.为什么delegate（代理）属性都是assign而不是retain的？ 防止循环引用，以至对象无法得到正确的释放。 第二部分1.iOS开发中数据持久性有哪几种？ plist文件写入，对象归档，sqlite3数据库，CoreData。 2.什么是KVC和KVO？它们之间的关系是什么？ KVC：键值编码，是一种间接访问对象实例变量的机制，该机制可以不通过存取方法就可以访问对象的实例变量。 KVO：键值观察，是一种能使得对象获取到其他对象属性变化的通知机制。实现KVO键值观察模式，被观察的对象必须使用KVC键值编码来修改它的实例变量，这样才能被观察者观察到。因此，KVC是KVO的基础或者说KVO的实现是建立在KVC的基础之上的。 3.简述常见的设计模式？ 单例模式、代理设计、观察者（通知）、工厂方法、模板方法。 4.内存管理在dealloc方法中用release方法与self.xx=nil哪个好？ 使用self.xx=nil更好，因为先调用了release方法，而且还将变量设置为nil，这样就更安全的释放对象，防止野指针调用。 5.线程与进程的区别和联系？ 一般的应用程序是单个进程，也有多进程（Chrome），进程是个静态的容器，里面容纳了很多个线程，线程是一系列方法的线性执行路径。 6.Objective-C语言的优缺点？ 优点：类目、动态识别、支持C语言、Objective-C与C++可以混编。 缺点：不支持命名空间、不支持运算符重载、不支持多重继承。 7.代理delegate、通知Notification与block的使用区别？ delegate和block一般是用于两个对象一对一之间的通信交互，delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信。block更加简洁，不需要定义繁琐的协议方法，但是如果通信事件比较多的话，建议使用delegate。Notification主要用于一对多情况下通信，而且，通信对象之间不需要建立关系，但是使用通知，代码可读性差。 8.控制器ViewController的loadView、viewDidLoad、viewWillApear和viewDidUnload分别是在什么时候调用？ loadView：当控制器的根视图view为空，且此view被访问时调用。 viewDidLoad：loadView调用之后被调用。 viewWillApear：当控制器根视图view被添加到父视图上时调用。 viewDidUnload：iOS6.0之前，当内存警告时，先卸载视图，再调用viewDidUnload来释放内存。 9.@synthesize和@dynamic的区别？ @synthesize：系统自动生成getter和setter属性声明。 @dynamic：告诉编译器，属性的获取与赋值方法由用户自己实现，不自动生成。 10.事件响应者链的概念？ 响应者链表示一系列的响应者对象。事件被交由第一响应者对象处理，如果第一响应者不处理，事件被沿着响应者链向上传递，交给下一个响应者。一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件交由它处理，如果它不处理，事件会被传递给它的视图控制器对象（如果存在），然后是它的父视图对象（如果存在），以此类推，直到顶层视图。接下来会沿着顶层视图到窗口（UIWindow对象），再到程序（UIApplication对象）。如果整个过程都没有响应这个事件，该事件被丢弃。一般情况下，在响应者链中只要有对象处理事件，事件就停止传递。但有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。 11.C语言中的static变量和static函数有什么作用？ 1）表示变量是静态存储变量，表示变量存放在静态存储区。 2）加在函数前面的时候表示该函数是内部连接，只在本文件中有效，别的文件中不能使用该函数。 12.指针题 123456781）int a; //一个数值。2）int *a; //一个指向数值的指针。3）int **a; //一个指向指针的指针。4）int a[10]; //一个有10个指针的数组，该指针是指向一个整型数的。5）int *a[10]; //一个有10个指针的数组，该指针是指向一个整型数的。6）int (*a)[10]; //一个指向有10个整型数数组的指针。7）int (*a)(int); //一个指向函数的指针，该函数有一个整型参数并返回一个整型数。8）int (*a[10])(int); //一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数。 13.写一个NSString类的实现？ 123456+(id)initWithCString:(const char *)nullTerminatedCString encoding:(NSStringEncoding)encoding &#123; NSString *obj; obj = [self allocWithZone:NSDefaultMallocZone()]; obj = [obj initWithCString:nullTerminatedCString encoding:encoding]; return autorelease(obj);&#125; 14.Objective-C与C如何混用？Objective-C与C++如何混用？ 实现文件的扩展名.m改成.mm即可，但cpp文件必须只能使用C/C++代码，而且cpp文件include的头文件中，也不能出现Objective-C的代码，因为cpp只能写C++的代码。 15.Objective-C中有私有方法和私有变量吗？ 使用private修饰的全局变量是私有的变量。 Objective-C在语法上没有设计私有的方法，不过可以通过延展在实现文件里定义方法作为私有的方法。但不是真正意义上的私有方法，也是可以调用的，只是外部不可见而已。 第三部分1.下面关键字const有什么含义？ 1234const int a;int const a;const int *a;int * const a; 前两个的作用是一样的，a是一个常整型数。 第三个意味着a是一个指向常整型数的指针（即整型数是不可修改的，但指针可以）。 第四个意味着a是一个指向整型数的常指针（即指针指向的整型数是可以修改的，但指针是不可修改的）。 2.C语言中extern的作用，extern “C”的作用？ 1）extern可以置于变量或者函数前，以标示变量或函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。 2）C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。 3.Objective-C是如何管理内存的？ Objective-C语言是使用引用计数来管理一个对象的生命周期，当对象被其他“人”使用的时候引用计数加1，不使用时减1，当此对象的引用计数为0时，则对象被系统回收。 4.什么是动态绑定（多态）？ 动态绑定是面向对象特性之一多态的体现，声明一个变量，在运行的时候可以绑定不同的对象，比如在方法的参数中声明这样一个变量UIView *view，运行的时候，我们可以根据不同的应用场景给view变量传入不同的对象，可以传递一个UIButton对象，也可以传入UIImageView对象。 5.如何理解delegate？ delegate，又称为委托或代理，它是一种设计模式。delegate主要用于两个对象之间的通信交互，并且解除两个通信对象的耦合性，iOS中大量使用了delegate设计，主要用于视图与使用对象之间的通信交互。 6.block与函数有何异同？block有何优点？ 1）block类似于C里面的函数指针，都可以作为参数进行传递，用于回调。但是block的实现可以定义在方法中，函数则不可以。 2）block语法简洁，可以在方法中定义实现，这样可以访问方法中的局部变量，使代码更加的紧凑，结构化。 7.为什么标准头文件都有类似以下的结构？ 12345678910#ifndef __INCvxWorksh#define __INCvxWorksh#ifdef __cplusplusextern &quot;C&quot; &#123;#endif/*...*/#ifdef __cplusplus&#125;#endif#endif /*__INCvxWorksh*/ 显然，头文件中的编译宏“#ifndef INCvxWorksh、#define INCvxWorksh、#endif”的作用是防止该头文件被重复引用。 8.CocoaTouch框架？ UIKit、Foundation、CoreGraphic、CoreAnimation 1）音频和视频：Core Audio、OpenAL、Media Library、AV Foundation 2）数据管理：Core Data、SQLite 3）图形和动画：Core Animation、OpenGL ES、Quartz 2D、Core Graphic 4）用户应用：Address Book、Core Location、Map Kit、Store Kit 9.栈结构与队列的区别？ 栈（stack）：限定只能在表的一端进行插入和删除操作的线性表。 队列（queue）：限定只能在表的一端插入和在另一端进行删除操作的线性表。 1）队列先进先出，栈先进后出。 2）对插入和删除操作的“限定”不同。 3）遍历数据速度不同。队列遍历数据的速度要快得多。 10.Objective-C中有无多重继承？如何实现多重继承？ Objective-C是没有多重继承的。 Cocoa中所有的类都是NSObject的子类，多继承在这里是用protocol委托代理来实现的。 面向对象语言大部分都是单继承，例如：Java、C#。 C++支持多继承。 11.static全局变量与普通的全局变量的区别？局部变量呢？函数呢？ 1）static全局变量与普通全局变量的区别：static全局变量只初始化一次，防止在其他文件单元中被引用。 2）static局部变量与普通局部变量的区别：static局部变量只被初始化一次，下一次依据上一次结果值。 3）static函数与普通函数的区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。 12.什么是类目与延展？ 类目：为已知的类增加新的方法。 延展：通知在本类的定义里使用类目来声明私有方法。 13.Objective-C中的协议和Java中的接口区别？ 协议定义的方法，可以设置可选实现和必须实现。 接口则是必须全部实现。 14.在一个对象的方法里self.name=”object”和name=”object”有什么不同？ 前者调用的是设置器方法，后者是普通赋值。 15.单例设计模式的实现？为什么使用单例设计？ 123456789101112static File *instance = nil;@implementation File//获取单例的方法+(id)shareInstance &#123; @synthesize (self) &#123; if(instance == nil) &#123; instance = [[File alloc] init]; &#125; &#125; return instance;&#125;//覆写allocWithZone、copyWithZone、retain、release和autorelease方法，目的是限制这个类只创建一个对象 为什么使用单例设计？ 1）单例设计是用来限制一个类只能创建一个对象，那么此对象中的属性可以存储全局共享的数据，所有的类都可以访问、设置此单例对象中的属性数据。 2）如果一个类创建的时候非常的耗费性能，那么此类如果能满足要求，可以设置为单例节约性能。 第四部分1.层CALayer和UIView的区别是什么？ 两者最大的区别是，图层不会直接渲染到屏幕上。UIView是iOS系统中界面元素的基础，所有的界面元素都是继承自它，它本身是由CoreAnimation来实现的，它真正绘图的部分是由一个CALayer类来管理的。UIView本身更像是一个CALayer的管理器。一个UIView上可以有多个CALayer，每个CALayer显示一种东西，增强UIView的展现能力。 2.什么是GCD？ GCD是Apple开发的一个多核编程的较新的解决方法。在Mac OS X 10.6雪豹中首次推出，并引入到iOS4.0。GCD是一个替代诸如NSThread等技术的很高效和强大的技术。GCD完全可以处理诸如数据锁定和资源泄漏等复杂的异步编程问题。 3.TCP/UDP的区别和联系？ 1）TCP的全称为传输控制协议，这种协议可以提供面向连接的、可靠的、点到点的通信。 2）UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。 3）用TCP还是UDP，需要看程序注重哪一个方面，需要可靠还是快速。 4.Socket连接和Http连接的区别？ Http连接：Http连接就是所谓的短链接，即客户端向服务器发送一次请求，服务器响应后连接即会断掉。 Socket连接：Socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉。 5.什么是TCP连接的三次握手？ 第一次握手：客户端发送SYN包（SYN=j）到服务器，并进入SYN_SEND状态，等待服务器确认。 第二次握手：服务器收到SYN包，必须确认客户的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。 第三次握手：客户端接收到服务器的SYN+ACK包，向服务器发送确认包ACK（ACK=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 6.frame和bounds的区别？ frame指的是：该view在父view坐标系统中的位置大小（参照点是父视图的坐标系统）。 bounds指的是：该view在本身坐标系统中的位置和大小（参照点是本身的坐标系统）。 7.如何理解MVC设计模式？ MVC是一种架构设计，M表示数据模型，V表示视图，C表示控制器。 数据模型：负责存储、定义、操作数据。 视图：用来展示数据给用户，和用户进行操作交互。 控制器：它是M与V的协调者，控制器获取数据，将数据交给视图去展示。 8.控制器的xib是怎么加载的？ 当UIViewController的loadView被调用时，在此方法中，通过NSBundle加载xib，先通过控制器的类名作为xib的文件名加载此xib文件。如果找到此xib文件，则加载为view对象作为控制器的根视图，如果没有xib文件，则通过alloc创建一个view对象作为根视图。 9.控制器如何处理系统内存不足警告？ 内存不足时，系统会调用控制器didReceiveMemoryWaring方法通知控制器内存不足。iOS6.0与6.0之前的处理方式不一样。 1）iOS6.0之前：调用didReceiveMemoryWaring后，将self.view设置为nil，并且再调用viewDidUnload方法，在此方法中我们应该释放子视图。 2）iOS6.0之后：调用didReceiveMemoryWaring后，不再调用viewDidUnload方法，则应该在didReceiveMemoryWaring方法中手动将self.view=nil，并且释放子视图。 10.iOS中对象间有哪些通信方式？ 代理delegate、block、通知和KVO。 11.block在内存管理上的特点？需要注意循环引用，如何解决循环引用？ 1）block中使用了局部对象，则会将此对象retain，引用了当前对象的属性或者方法，则会将当前对象retain。 2）解决循环引用：将当前对象赋值给一个局部变量，并且使用__block关键字修饰该局部变量，使用该变量访问当前对象的属性和方法。 12.Objective-C中有线程池（线程队列）吗？NSOperationQueue是如何管理线程的？ NSOperationQueue是Objective-C的线程池，线程池中可以存放多个线程。 NSOperationQueue可以管理线程的并发数，还可以管理线程间的优先级。 13.timer的间隔周期准吗？为什么？怎样实现一个精准的timer？ 定时器timer一般都是准确的，但是当主线程有些时候难免会出现堵塞情况，这样就有可能导致定时器timer会延迟从而不准确。我们可以开发一个多线程，在此多线程上运行定时器，这样多线程只运行定时器，不会因堵塞而导致误差。 14.Http协议的特点？GET与POST的区别？什么是Https协议？ 1）Http协议是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，连接则断开。 2）GET请求没有请求体，POST含有请求体，请求参数可以放入请求体中，所以，POST可以提交大量的数据给服务器，更加安全。 3）HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议，它是一个安全通信通道，它基于HTTP开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层（SSL）进行信息交换，简单来说它是HTTP的安全版。 15.XML数据的解析方式各有什么不同？JSON解析有哪些框架？ XML数据解析有两种方式：DOM解析和SAX解析。 DOM解析：必须完成DOM树的构造，在处理规模较大的XML文档时就很耗费内存，占用资源较多。 SAX解析：与DOM不同的是，SAX是用事件驱动模型，解析XML文档时每遇到一个开始或者结束标签、属性或一条指令时，程序就产生一个事件来进行相应的处理。因此，SAX相对于DOM来说更适合操作大的XML文档。 JSON解析：现在性能比较好的主要是第三方的JSONKit和iOS自带的JSON解析类，自带的JSON解析性能是最高的，但是只能是iOS5之后才可以使用。 第五部分1.tableView是如何复用的？ 如果屏幕上能显示10个单元格，则tableView只会创建11个单元格，也就是n+1，当滑到第12个单元格时就会复用第1个单元格对象。tableView中有个单元格池的概念，tableView调用协议方法获取单元格时，先从池子中查找是否有可复用的单元格，如果有则复用，如果没有则创建一个单元格对象。 2.如何优化tableView的滑动速度？ 1）复用单元格。 2）使用不透明的视图，单元格中尽量少使用动画。 3）图片加载使用异步加载，并且设置图片加载的并发数。 4）滑动时不加载图片，停止滑动开始加载。 5）文字、图片可直接drawInRect绘制。 6）如非必要，减少reloadData全部cell，只reloadRowsAtIndexPaths。 7）如果cell是动态行高度，计算出高度后缓存。 8）cell高度固定的话直接用cell.rowHeight设置高度。 3.谈谈对Runloop的理解？ Run loops是线程相关的基础框架的一部分。一个run loop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。使用run loop的目的是让你的线程在有工作的时候忙于工作，而没有工作的时候处于休眠状态。 4.如何调用drawRect方法与layoutSubView方法？这两个方法的作用？ 通过setNeedsLayout方法异步调用layoutSubView方法。 通过setNeedsDisplay方法异步调用drawRect方法。drawRect方法用于绘图，layoutSubView方法用于布局子视图。 5.UIView与UIViewController的关系？ 每个控制器都有一个根视图，控制器UIViewController用来管理此视图的加载和显示。 6.iOS中有哪些手势？ 轻击、捏合、平移、轻扫、旋转和长按。 7.Http和Socket的区别？ Http是客户端用Http协议进行请求，发送请求时需要封装http请求头，并绑定请求的数据，服务器一般有Web服务器配合（当然也非绝对）。Http请求方式为客户端主动发起请求，服务器才能给响应，一次请求完毕后则断开连接，以节省资源。服务器不能主动给客户端响应（除非采用http长连接技术）。iPhone主要使用的类是NSURLConnection。 Socket是客户端跟服务器直接使用Socket套接字进行连接，并没有规定连接后断开，所以客户端和服务器可以保持连接通道，双方都可以主动发送数据。一般在游戏开发或股票开发，这种要求即时性很强并且保持发送数据量比较大的场合使用。主要使用的类是CFSocketRef。 8.storyboard有什么特点？ storyboard是iOS5新增的特性，是对xib的升级版本，引入了一个容器用于管理多个xib文件，和它们之间的跳转交互。 优点：不用再为每个控制器创建xib文件；可以使用静态cell，当cell固定且不多时，使用起来比较方便。 缺点：storyboard单个文件，不利于团队协作开发。 9.如何打包静态库？ 新建一个Framework&amp;Library的项目，编译的时候会将项目中的代码文件打包成一个.a静态库文件。 10.APP发布的上架流程？ 1）在苹果官网的开发者中心，新建一个APP，填写此APP相关的一些描述信息。 2）下载安装发布证书。 3）选择发布证书，使用Archive编译发布包。 4）使用Xcode提交发布包。 11.iOS5有哪些新特性？ iCloud、定制UI、storyboard、ARC、CoreImage滤镜、新增JSON解析类。 12.iOS6有哪些新特性？ UIRefreshControl水滴效果下拉刷新、UICollectionView控件的使用、SLComposeViewController新浪微博控件、PassKit中Passbook、AutoLayout自动布局。 13、iOS7有哪些新特性？ 系统：全新的UI设计与交互；Control Center控制中心；全新的多任务Multitasking；AirDrop共享文件；全新的Safari浏览器交互式体验。 SDK：动态UIKit，新增了UIDynamicItem委托，用来为UIView制定动态行为；新增游戏引擎Sprite Kit Framework框架，类似于Cocos2D。 14.ARC有什么特点？ ARC是编译器特性，iOS5.0新添加的特性，使用ARC开发者不需要再retain、release、autorelease，因为编译器会在合适的地方自动插入retain、release。 ARC不会因少release而导致内存泄漏，过度使用release导致程序崩溃， ARC可以产生更简洁的代码和更健壮的应用。 15.SVN、Git协作开发，怎么防止代码文件冲突？ 防止代码冲突：不要多人同时修改同一个文件。例如，A、B都修改同一个文件，先让A修改，然后提交到服务器，然后B更新下来，再进行修改。服务器上的项目文件xcodeproj，仅让一个人管理提交，其他人只更新。防止此文件产生冲突。 第六部分1.什么是ARC？ ARC是automatic reference counting自动引用计数，在程序编译时自动加入retain/release。在对象被创建时retain count+1，在对象被release时count-1，当count=0时，销毁对象。程序中加入autoreleasepool对象会由系统自动加上autorelease方法，如果该对象引用计数为0，则销毁。那么ARC是为了解决MRC手动管理内存存在的一些而诞生的。 MRC下内存管理的缺点： 1）释放一个堆内存时，首先要确定指向这个堆空间的指针都被release了。(避免提前释放) 2）释放指针指向的堆空间，首先要确定哪些指向同一个堆，这些指针只能释放一次。(避免释放多次，造成内存泄露) 3）模块化操作时，对象可能被多个模块创建和使用，不能确定最后由谁释放。 4）多线程操作时，不确定哪个线程最后使用完毕。虽然ARC给我们编程带来的很多好多，但也可能出现内存泄露。如下面两种情况： 1）循环参照：A有个属性参照B，B有个属性参照A，如果都是strong参照的话，两个对象都无法释放。 2）死循环：如果有个ViewController中有无限循环，也会导致即使ViewController对应的view消失了，ViewController也不能释放。 2.block一般用哪个关键字修饰，为什么？ block一般使用copy关键之进行修饰，block使用copy是从MRC遗留下来的“传统”，在MRC中，方法内容的block是在栈区的，使用copy可以把它放到堆区。但在ARC中写不写都行：编译器自动对block进行了copy操作。 3.用@property声明的NSString（或NSArray，NSDictionary）经常 使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？用@property声明 NSString、NSArray、NSDictionary 经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。 如果我们使用是strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。 copy此特质所表达的所属关系与strong类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。 当属性类型为NSString时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个NSMutableString类的实例。这个类是NSString的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。 4.runloop、autorelease pool以及线程之间的关系？ 每个线程(包含主线程)都有一个Runloop。对于每一个Runloop，系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个像callstack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。 5.@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的？ “属性”(property)有两大概念：ivar(实例变量)、存取方法(access method=getter)，即@property = ivar + getter + setter。例如下面的这个类： 1234@interface WBTextView :UITextView @property (nonatomic,copy)NSString *placehold; @property (nonatomic,copy)UIColor *placeholdColor; @end 类完成属性的定以后，编译器会自动编写访问这些属性的方法(自动合成autosynthesis)，上述代码写出来的类等效与下面的代码： 123456@interface WBTextView :UITextView - (NSString *)placehold; -(void)setPlacehold:(NSString *)placehold; -(UIColor *)placeholdColor; -(void)setPlaceholdColor:(UIColor *)placeholdColor; @end 详细介绍见：http://blog.csdn.net/jasonjwl/article/details/49427377 6.分别写一个setter方法用于完成@property (nonatomic,retain)NSString *name和@property (nonatomic,copy) NSString *name？ retain属性的setter方法是保留新值并释放旧值，然后更新实例变量，令其指向新值。顺序很重要。假如还未保留新值就先把旧值释放了，而且两个值又指向同一个对象，先执行的release操作就可能导致系统将此对象永久回收。 123456789-(void)setName:(NSString *)name&#123; [name retain]; [_name release]; _name = name;&#125;-(void)setName:(NSString *)name&#123; [_name release]; _name = [name copy];&#125; 7.说说assign和weak，_block和 _weak的区别？ assign适用于基本数据类型，weak是适用于NSObject对象，并且是一个弱引用。 assign其实也可以用来修饰对象，那么为什么不用它呢？因为被assign修饰的对象在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil。如果在后续内存分配中，刚巧分到了这块地址，程序就会崩溃掉。而weak修饰的对象在释放之后，指针地址会被置为nil。 _block是用来修饰一个变量，这个变量就可以在block中被修改。 _block:使用_block修饰的变量在block代码块中会被retain(ARC下，MRC下不会retain)。 _weak:使用_weak修饰的变量不会在block代码块中被retain。 8.请说出下面代码是否有问题，如果有问题请修改？ 123456@autoreleasepool &#123; for (int i=0; i&lt;largeNumber; i++) &#123; Person *per = [[Person alloc] init]; [per autorelease]; &#125; &#125; 内存管理的原则：如果对一个对象使用了alloc、copy、retain，那么你必须使用相应的release或者autorelease。咋一看，这道题目有alloc，也有autorelease，两者对应起来，应该没问题。但autorelease虽然会使引用计数减一，但是它并不是立即减一，它的本质功能只是把对象放到离他最近的自动释放池里。当自动释放池销毁了，才会向自动释放池中的每一个对象发送release消息。这道题的问题就在autorelease。因为largeNumber是一个很大的数，autorelease又不能使引用计数立即减一，所以在循环结束前会造成内存溢出的问题。 解决方案如下： 12345678@autoreleasepool &#123; for (int i=0; i&lt;100000; i++) &#123; @autoreleasepool &#123; Person *per = [[Person alloc] init]; [per autorelease]; &#125; &#125; &#125; 在循环内部再加一个自动释放池，这样就能保证每创建一个对象就能及时释放。 9.请问下面代码是否有问题，如有问题请修改？ 123456789@autoreleasepool &#123; NSString *str = [[NSString alloc] init]; [str retain]; [str retain]; str = @&quot;jxl&quot;; [str release]; [str release]; [str release];&#125; 这道题跟第8题一样存在内存泄露问题， 1）内存泄露 ； 2）指向常量区的对象不能release。 指针变量str原本指向一块开辟的堆区空间，但是经过重新给str赋值，str的指向发生了变化，由原来指向堆区空间，到指向常量区。常量区的变量根本不需要释放，这就导致了原来开辟的堆区空间没有释放，造成内存泄露。 10.什么情况下使用weak关键字，相比assign有什么不同？什么情况使用weak关键字？ 1）在ARC中，在有可能出现循环引用的时候，往往要通过让其中一端使用weak来解决。比如delegate代理。 2）自身已经对它进行一次强引用，没有必要再强引用一次，此时也会使用weak，自定义控件属性一般也使用weak。 不同点： 1）weak此特性表明该属性定义了一种“非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特性与assign一样，然而在属性所指的对象遭到销毁时，属性值也会清空。而assign的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。 2）assign可以用非OC对象，而weak必须用于OC对象。 11.内存管理语义(assign、strong、weak等的区别)? 1）assign “设置方法” 只会执行针对“纯量”的简单赋值操作。 2）strong 此特性表明该属性定义了一种“拥有关系”。为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。 3）weak 此特性表明该属性定义了一种“非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特性同assign类似，然而在属性所指的对象遭到销毁时，属性值也会清空。 4）unsafe_unretained 此特性的语义和assign相同，但是它适用于“对象类型”，该特性表达一种“非拥有关系”，当目标对象遭到销毁时，属性值不会自动清空，这一点与weak有区别。 5）copy 此特性所表达的所属关系与strong类似。然而设置方法并不保留新值，而是将其“拷贝”。当属性类型为NSString*时，经常用此特性来保护其封装性，因为传递给设置方法的新值有可能指向一个NSMutableString类的实例。这个类是NSString的子类，表示一种可以修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变”的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的”，就应该在设置新属性值时拷贝一份。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objective-C中的NSPredicate]]></title>
      <url>%2F2017%2F03%2F28%2Fobjective-c-NSPredicate%2F</url>
      <content type="text"><![CDATA[编写软件时，经常需要获取一个对象集合，并通过某些已经条件计算该集合的值。你需要保留符合某个条件的对象，删除那些不满足条件的对象，从而提供一些有意义的对象。 在使用软件iPhoto的过程中，经常会看到这种现象，如果通知iPhoto仅显示等级为三星级或三星级以上的图片，则指定的条件为“照片的等级必须为三星级或三星级以上”。这样，所有照片都需要经过该过滤器过滤。满足条件的对象通过了过滤器，而其他对象被筛除了。最后，iPhoto将显示出所有高质量的图片。 Cocoa提供了一个名为NSPredicate的类，它用于指定过滤器的条件。可以创建NSPredicate对象，通过该对象准确地描述所需的条件，对每个对象通过谓词进行筛选，判断它们是否与条件相匹配。这里的“谓词”通常用在数学和计算机科学概念中，表示计算真值或假值的函数。 Cocoa用NSPredicate描述查询的方式，原理类似于在数据库中进行查询。可以在数据库风格的API中使用NSPredicate类，例如Core Data和Spotlight。可以将NSPredicate看成另一种间接操作方式。例如，如果需要查询满足条件的机器人，可以使用谓词对象进行检查，而不必使用代码进行显示查询。通过交换谓词对象，可以使用通用代码对数据进行过滤，而不必对相关条件进行硬编码。 创建1）方式一 创建许多对象，并将它们组合起来。如果正在构建通用用户接口来指定查询，采用这种方式比较简单。 2）方式二 查询代码中的字符串。 1234567Car *car;Car = makeCar(@&quot;Herbie&quot;, @&quot;Honda&quot;, @&quot;CRX&quot;, 1984, 2, 110000, 58);[garage addCar:car];/*构建的汽车：品牌为Herbie，型号为双门1984Honda CRX，马力引擎为58，已经行驶距离为110000英里*//*创建谓词*/NSPredicate *predicate;predicate = [NSPredicate predicateWithFormat:@&quot;name == &apos;Herbie&apos;&quot;]; 计算谓词 12BOOL match = [predicate evaluateWithObject:car];NSLog(@&quot;%s&quot;,(match) ? &quot;YES&quot;:&quot;NO&quot;); 另外一个谓词： 12345678NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;engine.horsepower &gt;150&quot;];/*查看车库中哪些车的功率最大，可以循环测试每个汽车的谓词*/NSArray *cars = [garage cars];for(Car *car in cars)&#123; if([predicate evaluateWithObject:car])&#123; NSLog(@&quot;%@&quot;, car.name); &#125;&#125; 过滤器如果我们不必像上文那样编写for循环和if语句，这有什么不好？实际上，某些类别将谓词过滤方法添加到了Cocoa集合类中。-filteredArrayUsingPredicate:是NSArray数组中的一种类别方法，它将循环过滤数组内容，根据谓词计算每个对象的值，并将值为YES的对象累积到将被返回的新数组中： 123NSArray *results;results = [cars filteredArrayUsingPredicate:predicate];NSLog(@&quot;%@&quot;,results); 假如有一个可变数组，你需要剔除不属于该数组的所有项目： 12NSMutableArray *carsCopy = [cars mutableCopy];[carsCopyfilterUsingPredicate:predicate]; 格式说明符资深编程人员都知道，硬编码并非好方法，因此，我们可以通过格式符构建谓词： 1NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;engine.horsepower &gt; %d&quot;, 50]; 运算符NSPredicate的格式字符串包含大量不同的运算符。 1）比较和逻辑运算符 谓词字符串语法支持C语言中一些常用的运算符，例如等号运算符==和=。不等号运算符具有各种形式： 12345&gt;：大于&gt;=和=&gt;：大于或等于&lt;：小于&lt;=和=&lt;：小于或等于!=和&lt;&gt;：不等于 此外，谓词字符串语法还支持括号表达式和AND、OR、NOT逻辑运算符或者C样式的等效表达式&amp;&amp;、||和!。 2）数组运算符 谓词字符串“(engine.horsepower&gt; 50) OR (engine.horsepower &lt; 200)”是一种十分常见的模式。等效于： 1predicate= [NSPredicate predicateWithFormat:@&quot;engine.horespower BETWEEN &#123;50,200&#125;&quot;]; 花括号表示数组，BETWEEN将数组中第一个元素看成是数组的下界，第二个元素看成是数组的上界。 12NSArray *betweens = [NSArray arrayWithObjects:[NSNumber numberWithInt:50],[NSNumber numberWithInt:200], nil];predicate = [NSPredicate predicateWithFormat:@&quot;engine.horsepower BETWEEN %@&quot;,betweens]; 数组不仅仅用来指定某个区间的端点值。你可以使用IN运算符查找数组中是否含有某个特定值。 1predicate = [NSPredicate predicateWithFormat:@&quot;name IN &#123;&apos;Herbie&apos;, &apos;Snugs&apos;, &apos;Badger&apos;,&apos;Flap&apos;&#125;&quot;];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[日语-助词]]></title>
      <url>%2F2017%2F03%2F26%2Fjapanese-auxiliary-word%2F</url>
      <content type="text"><![CDATA[助词，又称为语助词。文法术语，指的是一种词类，属于虚词，附着在其他词汇、词组，或是句子上，作为辅助之用。通常用于句子前、中、后，表示各种语气；或是用于语句中间，表示结构上的关系。 日语中的助词极为丰富，而每一个助词的使用场景也非常多，不得不承认这是一大难点，也是重点。 に用法 表地点，场所名词+に+名词，具体位置 部屋に机があります。 表时间点（包含数字的时间） 学校は８時半に始まります。 表附着点 温泉に入ります。 船に乗ります。 表目的 日本へ花見に行きます。 土曜日か日曜日に買い物に行きます。（第一个に表示时间点，第二个に表示目的） 表对象，人物对象，抽象事物 友達に会います。 表频率 李さんは１週間に２回プールへ行きます。 李さんは週に２回プールへ行きます。 表目的地 日本に行きます。 家に帰ります。 で用法 表交通手段 上海まで飛行機で行きます。 表地点范围，名词+で+动词 図書館で勉強します。 お昼は食堂（しよくどう）で食べます。 妹は部屋で音樂を聞きます。 表方式，手段 速達で送ります。 メールで両親と連絡します。 表原材料（で表示能看出原材料，から表示不能看出原材料） こむぎこでパンを作ります。 表花费（时间，金钱） このケーキは３個で１５０円です。 で和に的区别１）で强调后接动态动词。に强调后接静态动词。 が用法 表情感词前 ネズミがこれい。 表能力词前 日本語が分かる。 日本語ができる。 自动词前 足が疲れる。 足が痛い。 形容词前 箱根はホテルや旅館が多いですね。 存在句（が表听话方不知道的，は表双方都知道的） ホテルで友達の写真展があります。 疑问词作主语 この中でどの料理がいちばんおいしいですか。 を用法 表对象，动宾结构，名词+を+动词 パンヤミルクなどを食べます。 表范围，路线 駅前を通る（とおる）。 表出发点 家をでます。 から用法 表时间起点 來週、金曜日の夜７時から、ホテルでパーテイーがあります。 表空间起点 大阪（おおさか）から上海（シャンハイ）まで飛行機（ひこうき）で行きますか。 表因为 私はドリアンを全然食べません。嫌いですから。 へ用法 表去向 吉田さんは中国へ行きます。 か用法 表选择，二选一，名词+か+名词 毎月（まいつき）１回か２回映画（えいが）を見ます。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MySQL 密码修改]]></title>
      <url>%2F2017%2F03%2F22%2Fmysql-modify-password%2F</url>
      <content type="text"><![CDATA[MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。 Mac 安装完 MySQL 之后，软件会生成一个默认密码给我们。但是，当我使用Navicat来建立连接是却提示密码失效，无奈，只能修改数据库默认密码。 接下来，记录整个root密码修改过程。 在开始下面的步骤之前必须先停止mysql服务！ 1234561, cd /usr/local/mysql/bin/2, sudo su3, ./mysqld_safe --skip-grant-tables &amp; //这一步的作用是跨过权限验证4, ./mysql -uroot //以root身份登录，因为第三步的原因不需要密码了。这之后的命令就不需要在前面加./mysql了5, use mysql;6, update user set authentication_string=&apos;123456&apos; where User=&apos;root&apos;; 网上流传的版本全部是set password ＝‘’ ，这样写一直报错说 ‘password’列不存在！最终用sql命令查出来只有authentication_string字段，并没有password字段。 上一步执行之后本来以为已经可以登录了，可是navicat连接测试时出现了： 12ERROR 1862 (HY000): Your password has expired. To log in you mustchange it using a client that supports expired passwords. 所以还需要下面步骤 12341, cd /usr/local/mysql/bin/2, sudo su3, ./mysql -uroot -p1234564, set password = password(&apos;123456&apos;) 用户名：root，密码：123456修改成功]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FMDB 代码阅读]]></title>
      <url>%2F2017%2F03%2F21%2Ffmdb-reading%2F</url>
      <content type="text"><![CDATA[FMDB 是iOS平台的SQLite数据库框架，以ObjC的方式封装了SQLite的C语言的API。FMDB使用起來更加的面向对象，省去了很多麻烦、冗余的C语言代码。相比Apple自带的Core Data框架，更加的轻量和灵活。提供了多线程安全的数据库操作的方法，有效的防止数据混乱。 项目文件 FMDatabase : 一个SQLite数据库操作单例，通过它可以对数据库进行增删改查等操作。 FMResultSet : FMDatabase执行查询之后的结果集。 FMDatabaseAdditions : 拓展FMDatabase类，新增对查询结果只返回单个值的方法进行简化，对表、列是否存在，版本号，校验SQL等功能。 FMDatabaseQueue : 使用串行对列 ，操作多线程。 FMDatabasePool : 使用任务池的形式，操作多线程。 FMDatabase打开数据库连接 -(BOOL)open; 其实是对sqlite3_open()函数的封装。 - (void)setMaxBusyRetryTimeInterval:(NSTimeInterval)timeout; 设置重试时间。其实调用的是 int sqlite3_busy_handler(sqlite3 *,int(*)(void *,int),void *); 该函数的第一个参数：需要告知哪一个数据库需要设置busy handler。 第二个参数：需要回调的busy handler，当你调用该回调函数的时候，需要传给它一个void*的参数，也就是sqlite3_busy_handler的第三个参数。 第三个参数：需要传给回调函数的int参数表示这次锁事件，该回调函数被调用的次数。如果回调函数返回0时，将不再尝试再次访问数据库，而返回SQLITE_BUSY或者SQLITE_IOERR_BLOCKED。如果回调函数返回非0，将会不断尝试操作数据库。程序运行过程中，如果有其他进程或者线程在读写数据库，那么sqlite3_busy_handler会不断用用该回调函数，直到其他线程或者进程释放锁。获得锁之后，不会再调用该回调函数，从而继续向下执行下去，进行数据库操作。该函数是在获取不到锁的时候，以执行回调函数的次数來进行延时，等待其他进程或者线程操作数据库结束，从而获得锁进行操作数据库。 查询数据库executeQuery 系列函数从根本上看，其实调用的都是 - (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args 参数sql: 需要查詢的sql语句。 参数arrayArgs: 数组类型的参数。 1FMResultSet *resultSet = [_db executeQuery:@&quot;SELECT * FROM t_student WHERE age &gt; ?&quot; withArgumentsInArray:@[@20]]; 参数dictionaryArgs: 字典类型的参数。 1FMResultSet *resultSet = [_db executeQuery:@&quot;SELECT * FROM t_student WHERE age &gt; :age&quot; withParameterDictionary:@&#123;@&quot;age&quot;:@20&#125;]; 参数args: 可变参数类型。 1FMResultSet *resultSet = [_db executeQuery:@&quot;SELECT * FROM t_student WHERE age &gt; ?&quot;,@(20)]; 更新数据库操作这并不只是单单更新数据，而是对数据库有更改的操作，增删改都算。FMDB调用的都是executeupdate系列函数。这个函数基本上跟executeQuery系列函数的实现基本相同。只是它生成statement对象后，直接调用rc = sqlite3_step(pStmt);更新执行，而没有像executeQuery延迟到FMResultSet中的next函数中执行。 一次性执行多条sql语句。使用executeStatements函数可以一次性执行多条sql语句。其实现方式就是对sqlite3_exec函数的封装。 FMDB的加解密FMDataase中使用- (BOOL)setKey:(NSString*)key;和- (BOOL)setKeyWithData:(NSData *)keyData;输入数据库密码以求验证用户身份，使用- (BOOL)rekey:(NSString*)key;和- (BOOL)rekeyWithData:(NSData *)keyData;来给数据库设置密码或者清除密码。这两类函数分別对sqlite3_key和sqlite3_rekey函数进行了封装。 FMDatabaseAdditionsXXXForQuery系列函数对查询结果只有一个值的情况进行优化，有多个值也只取第一个值。 123456/** * 使用FMDatabaseAdditions中的intForQuery函数查找数据,如果返回结果有多个数据只取第一条数据 */- (void)queryForIntForQuery&#123; int idx = [_db intForQuery:@&quot;SELECT id FROM t_student WHERE age = ?&quot;,@(26)];&#125; 数据库的一些概要信息-(BOOL)tableExists:(NSString*)tableName;数据库表是否存在。 -(BOOL)columnExists:(NSString*)columnName inTableWithName:(NSString*)tableName;在tableName表中columnName是否存在。 -(FMResultSet*)getSchema;数据库的一些概要信息。 校验sql语句是否合法1-(BOOL)validateSQL:(NSString *)sql error:(NSError **)error; FMResultSet初始化对象 参数1：(FMStatement *)statement 该对象主要是对sqlite3_stmt的封装，sqlite3_stmt * 所表示的内容可以看成是预处理过的sql语句，已经不是我们熟知的sql语句。它是一个已经把sql语句解析了，用sqlite自己表示记录的内部数据结构。 参数2：(FMDatabase *)aDB该结果集所属于的FMDatabase数据库操作对象。 1+ (instancetype)resultSetWithStatement:(FMStatement *)statement usingParentDatabase:(FMDatabase*)aDB; 遍历取得所有的结果集合-(BOOL)next; 其实是对 -(BOOL)nextWithError:(NSError **)outErr; 函数的封装。主要作用是通过sqlite3_step函数对FMStatement中的sqlite3_stmt对象进行逐行取值。 列名与该列的列数的一一对应关系 @property (readonly) NSMutableDictionary *columnNameToIndexMap; 对象中保存了列名与索引一一对应的关系的对照表。 -(int)columnIndexForName:(NSString *)columnName; 根据列名获取该列所在第几列（列的索引） -(NSString *)columnNameForIndex:(int)columnIdx; 根据列的索引获取该列的名称。 获得每一行中每一个列字段的值。 -XXXForColumnIndex:(int)columnIdx; 根据列的索引获取该列的值。 -XXXForColumn:(NSString*)columnName; 根据列的名称获取该列的值。 -XXXForColumnIndex:(int)columnIdx; 其实是对sqlite3column*函数的封装。 123- (int)intForColumnIndex:(int)columnIdx &#123; return sqlite3_column_int([_statement statement], columnIdx);&#125; 获取每一行中所有的结果集合- (NSDictionary*)resultDictionary; FMDatabaseQueue使用实例: 12345678910111213141516171819202122232425FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];[queue inDatabase:^(FMDatabase *db) &#123; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:1]]; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:2]]; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:3]]; FMResultSet *rs = [db executeQuery:@&quot;select * from foo&quot;]; while ([rs next]) &#123; … &#125;&#125;];[queue inTransaction:^(FMDatabase *db, BOOL *rollback) &#123; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:1]]; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:2]]; [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:3]]; if (whoopsSomethingWrongHappened) &#123; *rollback = YES; return; &#125; // etc… [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, [NSNumber numberWithInt:4]];&#125;]; 事务的实现数据库中的事务也是保证数据库安全的一种手段。一段sql语句，要么全部成功，要么全部不成功。 关于延时性事务和独占性事务的区别 在SQLite 3.0.8或更高版本中，事务可以是延迟的，即时的或者独占的。“延迟的”即是说在数据库第一次被访问之前不获得锁。这样就会延迟事务，BEGIN语句本身不做任何事情。直到初次读取或访问数据库时才获取锁。对数据库的初次读取创建一个SHARED锁，初次写入创建一个RESERVED锁。由于锁的获取被延迟到第一次需要时，别的线程或进程可以在当前线程执行BEGIN语句之后创建另外的事务写入数据库。若事务是即时的，则执行BEGIN命令后立即获取RESERVED锁，而不等数据库被使用。在执行BEGIN IMMEDIATE之后， 你可以确保其它的线程或进程不能写入数据库或执行BEGIN IMMEDIATE或BEGIN EXCLUSIVE. 但其它进程可以获取数据库。 独占事务在所有的数据库获取EXCLUSIVE锁，在执行BEGIN EXCLUSIVE之后，你可以确保在当前事务结束前没有任何其它线程或进程能够读写数据库。 FMDatabasePoolFMDatabasePool : 使用任务池的形式，对多线程的操作提供支持。 不过官方对这种方式并不推荐使用（ONLY_USE_THE_POOL_IF_YOU_ARE_DOING_READS_OTHERWISE_YOULL_DEADLOCK_USE_FMDATABASEQUEUE_INSTEAD），优先选择FMDatabaseQueue的方式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[日语-动词]]></title>
      <url>%2F2017%2F02%2F26%2Fjapanese-verb%2F</url>
      <content type="text"><![CDATA[动词（Verb），简称v 。 一般就是用来表示动作或状态的词汇。基本上每个完整的句子都有一个动词，要表示第二个动作时可使用不定词、动名词、对等连接词、从属连接词或增加子句等方法连结。&lt;比如&gt; 突跃,突击,突袭等描述动作过程均属动词。中文语法中表示人或事物的动作或一种动态变化。一般出现在名词主语或主句后面。 日语中动词主要分为3大类，称为一类动词，二类动词和三类动词（简称，动1，动2和动3），而三类动词中又可以分为2类，即カ变和サ变动词。 另外，还有一种经常用到的动词，即授受动词。 授受动词 あげます：我或我方给别人，常用于上对下 私は小野さんにパンカチをあげます。 彼氏は李さんにバラをあげます。 注意：若分不清我方和别人时，一律用这种句型。 父は母に本をあげます。 私は先生に本をあげます。 注意：变疑问句 [我方]は誰（だれ）に何をあげますか。 もらいます：我或我方从别人那里得到，礼貌用法 私は先生からに辞書をもらいます。 私は会社からパソコンをもらいます。 注意：别人为个人时，后面用に；别人为团体时，后面用から。 くれます：别人给我或我方，平级间使用 先生は私に辞書をくれます。 社長は弟におもちゃをくれます。 注意 还有一些动词也属于授受类，例如，借东西，还东西。 教えます、貸します：我或我方教别人学习东西或借东西给别人。 習います、借ります：我或我方跟别人学习东西或从别人那里借东西。 动词分类 类型 规则 示例 一类动词（动1） 以う段假名结尾的词 行く、読む、帰る（かえる）、滑る（すべる） 二类动词（动2） 以る结尾，且る前为い段假名或え段假名的词 寝る、見る、食べる （注意一个汉字一个音） 三类动词（サ变） する（万能动词） 勉強する、電話する 三类动词（カ变） 来（く）る 动词变形原形变ます形 类型 规则 示例 一类动词 う段-&gt;い段＋ます 行く-&gt;行きます 二类动词 去る-&gt;＋ます 見る-&gt;見ます 三类动词（サ变） する-&gt;します 勉強する-&gt;勉強します 三类动词（カ变） くる-&gt;きます 来る-&gt;来ます ます形变原形 类型 规则 示例 一类动词 去掉ます，将ます前一个假名按行后移一个 あります-&gt;ある 二类动词 将ます去掉，直接换成る 見ます-&gt;見る 三类动词（サ变） します-&gt;する 勉強します-&gt;勉強する 三类动词（カ变） きます-&gt;くる 来ます-&gt;来る 原形变て形て形作用：两个动词间使用，表中顿，表相继；语法接续。 一类动词变て形 1）う、つ、る结尾，促音变。即去掉结尾假名变成って 示例：買う-&gt;買って、待つ-&gt;待って、売る（うる）-&gt;売って 2）ぬ、ぶ、む结尾，拨音变。即去掉结尾假名变成んで 示例：死ぬ-&gt;死んで、飛ぶ-&gt;飛んで、飲む-&gt;飲んで 3）く、ぐ结尾，い音变。即去掉结尾假名分别变成いて、いで 示例：歩く-&gt;歩いて、急ぐ-&gt;急いで 4）す变成して 示例：話す-&gt;話して 特例 行く-&gt;行って 二类动词变て形 去る+て 示例：見る-&gt;見て、食べる-&gt;食べて 三类动词变て形 1）する-&gt;して 示例：勉強する-&gt;勉強して 2）来る（くる）-&gt;来て（きて）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac 安装和配置 Tomcat]]></title>
      <url>%2F2017%2F01%2F02%2Fmac-install-apache-tomcat%2F</url>
      <content type="text"><![CDATA[Tomcat是由Apache软件基金会下属的Jakarta项目开发的一个Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。由于Tomcat本身也内含了一个HTTP服务器，它也可以被视作一个单独的Web服务器。但是，不能将Tomcat和Apache Web服务器混淆，Apache Web Server是一个用C语言实现的HTTP web server；这两个HTTP web server不是捆绑在一起的。Apache Tomcat包含了一个配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。 这篇文章主要介绍Mac环境下，使用Eclipse + Tomcat搭建Java EE开发环境。 下载资源前去官网下载安装包，zip和tar.gz均可。 安装解压下载的压缩包文件，将文件放置/Library/Tomcat路径。 设置权限： 1sudo chmod 755 /Library/Tomcat/bin/*.sh 启动Tomacat1sudo sh /Library/Tomcat/bin/startup.sh 成功的话会出现： 1Tomcat started. 打开浏览器输入：localhost:8080 。就可以看见Tomcat: 关闭Tomcat1sudo sh /Library/Tomcat/bin/shutdown.sh 创建快捷命令每次按照上述的开启，关闭命令来操作，太麻烦，我们可以使用下列方法创建简洁快捷的命令。 创建shell文件12cd /usr/local/bin sudo touch tomcat 设置权限1chmod 777 /usr/local/bin/tomcat 添加shell代码123456789101112131415161718#!/bin/bashcase $1 instart)sudo sh /Library/Tomcat/bin/startup.sh;;stop)sudo sh /Library/Tomcat/bin/shutdown.sh;;restart)sudo sh /Library/Tomcat/bin/shutdown.shsudo sh /Library/Tomcat/bin/startup.sh;;*)echo &quot;Usage: start|stop|restart&quot;esacexit 0 使用123tomcat starttomcat stoptomcat restart 配置为了便于配置Tomcat，我们需要安装Eclipse Tomcat插件 。 打开Eclipse，选择菜单中的Preferences，选择Tomcat的版本，安装路径等。 第一个Web程序创建 File-&gt;New-&gt;Dynamic Web Project File-&gt;New-&gt;JSP File 新建JSP文件index.jsp，保存在WebContent根目录下。 添加代码至index.jsp文件 123456789101112131415&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% java.util.Date d = new java.util.Date(); %&gt;&lt;h1&gt;Today&apos;s date is &lt;%= d.toString() %&gt; and this jsp page worked!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 运行选中项目，Run As-&gt;Run on Server 运行效果：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[日语-形容词]]></title>
      <url>%2F2016%2F12%2F26%2Fjapanese-adjective%2F</url>
      <content type="text"><![CDATA[形容词（Adjective），很多语言中均有的主要词类中的一种。形容词主要用来描写或修饰名词或代词，表示人或事物的性质、 状态、特征或属性，常用作定语，也可作表语、补语或状语。 日语中的形容词分为两大类，称为一类形容词和二类形容词（简称，形1和形2）。形容词所表示的事物的属性，一般具有静止的、固定的、永恒的特点。 形容词分类 类型 规则 示例 一类形容词（形1） 以い结尾的词 美味しい（おいしい）、暑い（あっい） 二类形容词（形2） 不以い结尾的词 元気（げんき）、暇（ひま） 注意特例 綺麗い（きれい）、嫌い（きらい）、いっぱい 是形2。 形容词变形形容词变否定 类型 规则 示例 一类形容词（形1） 去い变成くない或者くありません １）この料理は美味しくないです。２）この料理は美味しくありません。 二类形容词（形2） 形2＋ではありません この通りはにぎやかではありません。 注意特例 いいです的否定形式是よくないです或よくありません。 形容词变过去时 类型 规则 示例 一类形容词（形1） 去い变成かった よい-&gt;よかった 二类形容词（形2） 有名です-&gt;有名でした 形容词变过去否定时 类型 规则 示例 一类形容词（形1） 去い变成くなかった よい-&gt;よくなかった 二类形容词（形2） 有名です-&gt;有名ではありませんでした 示例 时态 一类形容词 变形 二类形容词 变形 否定 よい よくない 有名です 有名ではありません 过去时 よい よかった 有名です 有名でした 过去否定时 よい よくなかった 有名です 有名ではありませんでした 形容词变副词 类型 规则 示例 一类形容词（形1） 去い变成く 多い（おおい）-&gt;多く 形容词变て形 类型 规则 示例 一类形容词（形1） 去い变成くて 広い（ひろい）-&gt;広くて 二类形容词（形2） 直接加で 簡単（かんたん）-&gt;簡単で 注意いい不能用来变形，要用其对应的よい进行变形]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS App 上架（Analysis 工具使用）]]></title>
      <url>%2F2016%2F11%2F15%2Fapple-app-release-analysis%2F</url>
      <content type="text"><![CDATA[随着iOS开发的流行，针对iOS开发涉及的方方面面，早有一些公司提供了专门的解决方案或工具。这些解决方案或工具包括：用户行为统计工具（友盟，Flurry，Google Analytics等), App Store销售分析工具（例如App annie)， App crash收集工具（例如Crashlytics)，App测试发布工具（Test Flight）, App Push服务等。 这些解决方案或工具节省了iOS开发者大量的开发时间，但是由于相关介绍文章的缺乏，许多开发者都在重复着自己一次又一次重新造轮子。所以将自己使用的相关的第三方服务使用经验，整理成一系列文章，以便广大开发者能够省去大量的重复性工作。 用户习惯数据收集了解用户的使用习惯以及相关数据信息，可以更好的帮助开发者调整产品的方向和重点。首先是数据的收集，受工作的影响，选择 百度移动统计 。不得不说，这是一款很符合国人使用习惯的工具。 使用方法很简单，接入过程直接根据官方文档。自定义统计事件需要自己在web端逐个添加。而页面访问统计则不需要，只需要在App上将名字传入调用接口即可。 百度移动统计不仅仅是做应用统计，也可以做crash分析，游戏统计分析，DSP统计，还有广告营销分析。 页面数据的分析，可以帮助开发者很明了的知道用户群体的习惯与流失，有助于产品成长。 Crash 数据收集作为上线App，最担心的就是crash数据的收集。Crashlytics 是专门为移动应用开者发提供的保存和分析应用崩溃信息的工具。 使用Crashlytics的好处 Crashlytics不会漏掉任何应用崩溃信息。在iTunes Connect的后台查看不到任何崩溃信息。但是用户通过微博或者客服电话反馈应用崩溃的情况，在Crashlytics中都可以统计到。 Crashlytics可以像Bug管理工具那样，管理这些崩溃日志。例如：Crashlytics会根据每种类型的Crash的出现频率以及影响的用户量来自动设置优先级。对于每种类型的Crash，Crashlytics除了会像一般的工具提供Call Stack外，还会显示更多相关的有助于诊断的信息，例如：设备是否越狱，当时的内存量，当时的iOS版本等。对于修复掉的Crash日志，可以在Crashlytics的后台将其关掉。 Crashlytics可以每天和每周将崩溃信息汇总发到你的邮箱，所有信息一目了然。 使用 注册 使用邮箱在Crashlytic官网注册。稍后会收到官方验证邮件，根据邮件内容及稍后提示一步步操作。 接入工程 根据官方接入引导教程，分为使用pod方式和手动下载sdk接入方式。具体的可以根据官方文档来操作。这里主要分享一下自己遇到的问题。 1) 忘记添加 Run Script ，这个步骤会导致App无法build成功。 2) 重新配置 Crashlytics 之后，需要删除 ~/Library/Caches/com.crashlytics.data/ 和 ~/Library/Caches/com.crashlytics.mac/ 文件夹下的所有文件，重新build。 3) 注意配置 Build Settings 中 Debug Information Format 选项将debug和release全部设置成DWARF with dSYM File。 4) 如果提示 missing dSYMs ，就需要自行上载文件，具体方法教程 。 希望对大家有所帮助。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Effective Objective-C 2.0 读书笔记 -- 熟悉Objective-C语言]]></title>
      <url>%2F2016%2F09%2F05%2Feffective-objc-2-introduction-objc%2F</url>
      <content type="text"><![CDATA[看到Effective这个词，大家一定会想到《Effective C++》、《Effective Java》等业界名著，那些书里汇聚了多项实用技巧，又系统而深入的讲解了各种编程知识。那么，《Effective Objective-C 2.0》也是如此。 作为Mac OS X与iOS应用程序的开发语言，Objective-C作为首选。那么，它有哪些需要注意的呢？ 起源Objective-C与C++、Java一样，是面向对象的语言，是由Smalltalk演化而来。Smalltalk是消息型语言的鼻祖。消息与函数调用之间的区别看上去就像这样： 1234567//Messaging (Objective-C)Object *obj = [Object new];[obj performWith:parameter1 and:parameter2];//Function calling (C++)Object *obj = new Object;obj-&gt;perform(parameter1, parameter2); 关键区别在于：使用消息结构的语言，其运行时所应执行的代码由运行环境来决定；而使用函数调用的语言，则由编译器决定。 Objective-C是C的“超集”(superset)，所以C语言中的所有功能在编写Objective-C代码时依然适用。理解C语言的内存模型(memory model)，有助于理解Objective-C的内存模型及其“引用计数”(reference counting)机制的工作原理。Objective-C语言中的指针是用来指示对象的。 关于使用头文件主要使用 import 关键字。然而，我们在 .h 文件中一般首选使用 @class 关键字，它能“向前声明”一个类。对于不需要知道类细节的情况下我们使用它。否则不会轻易使用 import 来引入整个头文件。 过多的引入头文件，会增加编译时间。这就是我们多使用 @class 关键字的直接原因。 除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用“向前声明”来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合(coupling)。 有时无法使用“向前声明”，比如要声明某个类遵循一项协议。这种情况下，尽量把“该类遵循某协议”的这条声明移至“class-continuation分类”中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。 字面量语法在编写Objective-C程序时，总会用到某几个类，它们属于Foundation框架。虽然从技术上来说，不用Foundation框架也能写出Objective-C代码，但是实际上却经常要用到此框架。这几个类是NSString、NUNumber、NSArray、NSDictionary。从类名上即可看出各自所表示的数据结构。 Objective-C以语法繁杂而著称。不过从Objective-C 1.0起，有一种简单的方式能创建NSString 对象。这就是“字符串字面量”(string literal)，其语法如下： 1NSString *string = @"Effective Objective-C 2.0"; 字面数值123NSNumber *number = [NSNumber numberWithInt:10];//等价于NSNumber *number = @10; 更多表示： 12345NSNumber *intNumber = @11;NSNumber *floatNumber = @2.5f;NSNumber *doubleNumber = @3.1415926;NSNumber *boolNumber = @YES;NSNumber *charNumber = @'ABC'; 字面量语法也适用于下述表达式 123int x =5;float y = 6.5fNSNumber *expressionNumber = @(x * y); 字面量数组123NSarray *animals = [NSArray arrayWithObjects:@"cat", @"dog", @"mouse", @"badger", nil];// 等价于NSarray *animals = @[@"cat", @"dog", @"mouse", @"badger"]; 使用数组 123NSString *dog = [animals objectAtIndex:1];// 等价于NSString *dog = animals[1]; 字面量字典123NSDictionary *personData = [NSDictionary dictionaryWithObjectsAnsKeys:@"Matt", @"firstName", @"Galloway", @"lastName", [NSNumber numberWithInt:28], @"age", nil];// 等价于NSDictionary *personData = @&#123;@"firstName":@"Matt", @"lastName":@"Galloway", @"age":[NSNumber numberWithInt:28]&#125;; 使用字典 123NSString *lastName = [personData objectForKey:@"lastName"];// 等价于NSString *lastName = personData[@"lastName"]; 可变数组和字典12345[mutableArray replaceObjectAtIndex:1 withObject:@"dog"];[mutableDictionary setObject:@"Galloway" forKey:@"lastName"];// 等价于mutableArray[1] = @"dog";mutableDictionary[@"lastName"] = @"Galloway"; 局限性字面量语法有个小小的限制，就是除了字符串以外，所创建出来的对象必须属于Foundation框架才行。如果自定义了这些类的子类，则无法用字面量语法创建其对象。要想创建自定义子类的实例，必须采用“非字面量语法”(nonliteral syntax)。 使用字面量语法创建出来的字符串、数组、字典对象都是不可变的(immutable)。若想要可变版本的对象，则需要复制一份： 1NSMutableArray *mutable = [@[@1, @2, @3, @4] mutableCopy]; 这么做会多调用一个方法，而且还要再创建一个对象，不过使用字面量语法所带来的好处还是多于上述缺点的。 用字面量语法创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值里不含nil。 多用类型常量 少用#define预处理指令编写代码时经常要定义常量。掌握了Objective-C与其C语言的基础的人，也许会用这种方法来做： 1#define ANIMATION_DURATION 0.3 上述预处理指令会把源代码中的ANIMATION_DURATION字符串替换为0.3.预处理过程会把碰到的所有ANIMATION_DURATION一律替换成0.3，这样的话，假设此指令声明在某个头文件中，那么所有引入了这个头文件的代码，其ANIMATION_DURATION都会被替换。 要解决此问题，应该设法利用编译器的某些特性才对。 1static const NSTimeInterval kAnimationDuration = 0.3; 用此方式定义的常量包含类型信息，其好处的清楚地描述了常量的含义。 常用的命名法是： 若常量局限于某”编译单元”(translation unit，也就是“实现文件”，implementation file)之内，则在前面加字母k； 若常量在类之外可见，则通常以类名为前缀。 定义常量的位置很重要。在头文件里声明预处理指令，这样会增加常量名称互相冲突的可能性。 在头文件中使用extern来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区隔，通常用与之相关的类名做前缀。 枚举使用枚举只是一种常量命名方式。某个对象所经历的各种状态就可以定义为一个简单的枚举集(enumeration set)。 12345enum IHConnectionState &#123; IHConnectionStateDisconnected, IHConnectionStateConnecting, IHConnectionStateConnected&#125;; 默认情况下，枚举起始值为0，以后依次递增，1,2,3… 其实还可以我们自己指定枚举值： 12345enum IHConnectionState &#123; IHConnectionStateDisconnected = 1, IHConnectionStateConnecting, IHConnectionStateConnected&#125;; 也可以定义为位移值： 123456789enum UIViewAutoresizing &#123; UIViewAutoresizing = 0, UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0, UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1, UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2, UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3, UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4, UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5&#125;; 关于枚举，Foundation框架中定义了一些辅助的宏，用这些来定义枚举类型时，也可以指定用于保存枚举值的底层数据类型。 123456789101112typedef NS_ENUM(NSUInteger, IHConnectionState) &#123; IHConnectionStateDisconnected = 1, IHConnectionStateConnecting, IHConnectionStateConnected&#125;;typedef NS_OPTIONS(NSUInteger, IHPermittedDirection) &#123; IHPermittedDirectionUp = 1 &lt;&lt; 0, IHPermittedDirectionDown = 1 &lt;&lt; 1, IHPermittedDirectionLeft = 1 &lt;&lt; 2, IHPermittedDirectionRight = 1 &lt;&lt; 3&#125;; 这些宏的定义如下： 123456789101112131415#if(__cplusplus &amp;&amp; __cplusplus &gt;= 201103L &amp;&amp; (__has_extension(cxx_strong_enums) || __has_feature(objc_fixed_enum))) || (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum)) #define NS_ENUM(_type, _name) enum _name:_type _name; enum _name:_type #if (__cplusplus) #define NS_OPTIONS(_type, _name) type _name; enum:_type #else #define NS_OPTIONS(_type, _name) enum _name:_type _name; enum _name:_type #endif#else #define NS_ENUM(_type, _name) _type _name; enum #define NS_OPTIONS(_type, _name) _type _name; enum#endif 第一个#if用于判断编译器是否支持新式枚举。如果不支持，那么就用老式语法来定义枚举。 在处理枚举类型的switch语句中不要实现default分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch语句并未处理所有枚举。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac 如何升级 Ruby 版本]]></title>
      <url>%2F2016%2F09%2F03%2Fmac-ruby-update%2F</url>
      <content type="text"><![CDATA[Ruby 是一种面向对象、命令式、函数式、动态的通用编程语言。 在20世纪90年代中期由日本人松本行弘（Matz）设计并开发。 遵守BSD许可证和Ruby License。 它的灵感与特性来自于Perl、Smalltalk、Eiffel、Ada以及Lisp语言。 Ruby 可运行于多种平台，如 Windows、MAC OS 和 UNIX 的各种版本。 Ruby用于最明显，且和Apple系列的程序员最直接关联的就是Mac的开发环境，直接关联于Cocoapods工具。但是，cocoapods工具与Ruby的版本有一定的关联性，难免不涉及到升级。 那么，如何升级最方便快捷呢？ 这就是rvm大展身手的时候啦。rvm是什么？rvm是ruby版本管理器。为什么要安装rvm呢？因为rvm可以让你拥有多个版本的Ruby，并且可以在多个版本之间自由切换。 第一步：安装rvm12$ curl -L get.rvm.io | bash -s stable$ source ~/.profile 等待终端加载完毕，后输入： 1$ rvm -v 如果能显示版本号,则安装成功。 第二步：安装ruby列出ruby可安装的版本信息 1$ rvm list known 安装一个ruby版本 1$ rvm install 2.3 如果想设置为默认版本，可以用这条命令来完成 1$ rvm use 2.1.4 --default 查看已安装的ruby 1$ rvm list 卸载一个已安装ruby版本 1$ rvm remove 2.3 第三步：更换源查看已有的源 1$ gem source -l 显示如下： 12CURRENT SOURCEShttp://rubygems.org/ 然后我们需要修改更换源（由于国内被墙），所以要把源切换至淘宝镜像服务器，在终端执行以下命令 1234$ gem update --system$ gem uninstall rubygems-update$ gem sources -r http://rubygems.org/$ gem sources -a https://ruby.taobao.org]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac OS 开发 － 聊聊如何打包dmg文件]]></title>
      <url>%2F2016%2F09%2F03%2Fmac-os-archive-app%2F</url>
      <content type="text"><![CDATA[最近因为博主自己的需求，而App Store上的App不能满足需求，或者是说，想借此机会涉猎一下Mac OS的开发。之前一直臆想iOS开发和Mac OS差不多，实则不然。 BTW 推荐一款非Apple官方的App Store，HackStore是一款来自俄罗斯的Mac应用商店，我们可以将自己开发完的App免费发布上去，也是具有审核机制的，博主目前推广自己的ImageHosting，一款图床软件，目前支持七牛云存储。有需求欢迎大家使用，吐槽。 ImageHosting for Mac 现在，分享一下，当我们完成Mac开发，release一个.app文件之后，我们应该如何打包成一个dmg文件的方法。 言归正传，说到dmg，这个我们熟悉的格式，那么它是怎么生成的呢，跟着接下来的步骤吧。博主将它们分为系统默认和自定义，不过，两者都离不开一个工具 －－ 磁盘工具（Disk Utility）。 系统默认打开 磁盘工具 －&gt; 文件 －&gt; 新建映像 －&gt; 来自文件夹的映像 资源文件夹内容 配置 选择包括 .app 和 Applications 替身 文件夹的路径，也就是上图说的 资源文件夹 路径 点击 打开 ，配置相关信息 点击 存储 即可。 自定义1 准备资源，包括：背景图片，.app 和 Applications 替身 文件。 2 创建一个空的映像文件 配置信息 3 配置资源 －－ 配置背景图 1）打开显示选项 2）配置背景图 3）隐藏背景图片文件 使用mv命令进行重命名 1$ mv background.tif .background.tif 4 配置资源 －－ 拖拽.app 和 Applications 替身 5 转换 配置转换信息 6 效果 附言每次自定义类型打包dmg，都需要从零开始，不能使用上一次的未转换时的文件直接替换.app文件。否则，呈现的样式将不是CD样式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ImageHosting 开源软件的使用说明]]></title>
      <url>%2F2016%2F08%2F22%2FImageHosting-use-introduction%2F</url>
      <content type="text"><![CDATA[博主在转战iOS开发以来，一直坚持撰写自己的技术博客。使用Github Pages + Hexo 搭建了属于自己的空间。具体搭建方法可以参考《手把手教 GitHub + Hexo 搭建博客》 。 然而，博客中有很多时候需要使用图片说明，俗话说“一图胜千言”，博主使用 七牛云 做图床，然每次编写博客时需要打开Web版上传图片，甚是繁琐。故此，博主自己编写了一个自己的图片上传软件。 软件下载地址：ImageHosting for Mac 源代码地址 安装遇到提示“不能安装未知来源程序”时，处理方法为，将权限改为“任何来源”即可。 软件菜单栏 打开软件配置，添加账户信息 打开文件选择页，选择文件上传文件 上传进度提示 上传完成 操作提示未添加账户信息提示 未选择上传文件提示 上传文件成功提示]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单聊聊大小端问题]]></title>
      <url>%2F2016%2F08%2F13%2Fmemory-big-little-endian%2F</url>
      <content type="text"><![CDATA[在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器）。另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。 先来看一段代码： 1234567891011121314151617181920212223#include&lt;stdio.h&gt;union&#123; unsigned long bits32; unsigned char bytes[4];&#125;value;int isLittleEndian()&#123; value.bytes[0] = 0; value.bytes[1] = 1; value.bytes[2] = 0; value.bytes[3] = 0; return value.bits32 == 256;&#125;int main()&#123; if( isLittleEndian()) printf("is little endian! "); else printf("is big endian! "); return 0;&#125; 所谓的大端模式，是指数据的低位（就是权值较小的后面那几位）保存在内存的高地址中，而数据的高位，保存在内存的低地址中。这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放； 所谓的小端模式，是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。 为什么会有大小端模式之分呢？ 这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器）。另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。 例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。下面这段代码可以用来测试一下你的编译器是大端模式还是小端模式： 12345short int x; char x0, x1; x = 0x1122; x0 = ((char*)&amp;x)[0]; //低地址单元 x1 = ((char*)&amp;x)[1]; //高地址单元 若x0=0x11,则是大端; 若x0=0x22,则是小端。 上面的程序还可以看出，数据寻址时，用的是低位字节的地址。 什么是字节对齐，为什么要对齐? 现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。 对齐的作用和原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。 字节对齐对程序的影响？ 先让我们看几个例子(32bit，x86环境，gcc编译器)：设结构体如下定义： 123456789101112struct A&#123; int a; char b; short c;&#125;;struct B&#123; char b; int a; short c;&#125;; 现在已知32位机器上各种数据类型的长度如下： 12345char:1(有符号无符号同) short:2(有符号无符号同) int:4(有符号无符号同) long:4(有符号无符号同) float:4 double:8 那么上面两个结构大小如何呢? 结果是： 12sizeof(strcut A)值为8sizeof(struct B)的值却是12 结构体A中包含了4字节长度的int一个，1字节长度的char一个和2字节长度的short型数据一个,B也一样；按理说A，B大小应该都是7字节。之所以出现上面的结果是因为编译器要对数据成员在空间上进行对齐。上面是按照编译器的默认设置进行对齐的结果，那么我们是不是可以改变编译器的这种默认对齐设置呢，当然可以。例如： 1234567891011121314151617181920#pragma pack (2) /*指定按2字节对齐*/struct C&#123; char b; int a; short c;&#125;;#pragma pack () /*取消指定对齐，恢复缺省对齐*/sizeof(struct C)值是8。修改对齐值为1：#pragma pack (1) /*指定按1字节对齐*/struct D&#123; char b; int a; short c;&#125;;#pragma pack () /*取消指定对齐，恢复缺省对齐*/sizeof(struct D)值为7。 编译器是按照什么样的原则进行对齐的? 先让我们看四个重要的基本概念： 1.数据类型自身的对齐值： 对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，单位字节。 2.结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。 3.指定对齐值：#pragma pack (value)时的指定对齐值value。 4.数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。 有了这些值，我们就可以很方便的来讨论具体数据结构的成员和其自身的对齐方式。有效对齐值N是最终用来决定数据存放地址方式的值，最重要。有效对齐N，就是表示“对齐在N上”，也就是说该数据的“存放起始地址%N=0”。而数据结构中的数据变量都是按定义的先后顺序来排放的。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐排放，结构体本身也要根据自身的有效对齐值圆整(就是结构体成员变量占用总长度需要是对结构体有效对齐值的整数倍，结合下面例子理解)。这样就不难理解上面的几个例子的值了。 例子分析： 123456struct B&#123; char b; int a; short c;&#125;; 假设B从地址空间0x0000开始排放。该例子中没有定义指定对齐值，在笔者环境下，该值默认为4。第一个成员变量b的自身对齐值是1，比指定或者默认指定对齐值4小，所以其有效对齐值为1，所以其存放地址0x0000符合0x0000%1=0。第二个成员变量a，其自身对齐值为4，所以有效对齐值也为4，所以只能存放在起始地址为0x0004到0x0007这四个连续的字节空间中，复核0x0004%4=0,且紧靠第一个变量。第三个变量c，自身对齐值为2，所以有效对齐值也是2，可以存放在0x0008到0x0009这两个字节空间中，符合0x0008%2=0。所以从0x0000到0x0009存放的都是B内容。再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b）所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求，0x0009到0x0000=10字节，（10＋2）％4＝0。所以0x000A到0x000B也为结构体B所占用。故B从0x0000到0x000B共有12个字节，sizeof(struct B)=12;其实如果就这一个就来说它已经满足字节对齐了，因为它的起始地址是0，因此肯定是对齐的。之所以在后面补充2个字节，是因为编译器为了实现结构数组的存取效率，试想如果我们定义了一个结构B的数组，那么第一个结构起始地址是0没有问题，但是第二个结构呢?按照数组的定义，数组中所有元素都是紧挨着的，如果我们不把结构的大小补充为4的整数倍，那么下一个结构的起始地址将是0x000A，这显然不能满足结构的地址对齐了，因此我们要把结构补充成有效对齐大小的整数倍。其实诸如：对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，这些已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知了，所以他们的自身对齐值也就已知了。 同理，分析下面例子： 12345678#pragma pack (2) /*指定按2字节对齐*/struct C&#123; char b; int a; short c;&#125;;#pragma pack () /*取消指定对齐，恢复缺省对齐*/ 第一个变量b的自身对齐值为1，指定对齐值为2，所以，其有效对齐值为1，假设C从0x0000开始，那么b存放在0x0000，符合0x0000%1=0；第二个变量，自身对齐值为4，指定对齐值为2，所以有效对齐值为2，所以顺序存放在0x0002、0x0003、0x0004、0x0005四个连续字节中，符合0x0002%2=0。第三个变量c的自身对齐值为2，所以有效对齐值为2，顺序存放在0x0006、0x0007中，符合0x0006%2=0。所以从0x0000到0x00007共八字节存放的是C的变量。又C的自身对齐值为4，所以C的有效对齐值为2。又8%2=0，C只占用0x0000到0x0007的八个字节。所以sizeof(struct C)=8。 如何修改编译器的默认对齐值? 1.在VC IDE中，可以这样修改：[Project]|[Settings],c/c++选项卡Category的Code Generation选项的Struct Member Alignment中修改，默认是8字节。 2.在编码时，可以这样动态修改：#pragma pack。注意：是pragma而不是progma。 针对字节对齐，我们在编程中如何考虑? 如果在编程的时候要考虑节约空间的话,那么我们只需要假定结构的首地址是0，然后各个变量按照上面的原则进行排列即可，基本的原则就是把结构中的变量按照类型大小从小到大声明，尽量减少中间的填补空间。还有一种就是为了以空间换取时间的效率，我们显示的进行填补空间进行对齐，比如：有一种使用空间换时间做法是显式的插入reserved成员： 12345struct A&#123; char a; char reserved[3];//使用空间换时间 int b;&#125; reserved成员对我们的程序没有什么意义，它只是起到填补空间以达到字节对齐的目的。当然即使不加这个成员，通常编译器也会给我们自动填补对齐，我们自己加上它只是起到显式的提醒作用。 字节对齐可能带来的隐患？ 代码中关于对齐的隐患，很多是隐式的。比如在强制类型转换的时候。例如： 1234567unsigned int i = 0x12345678;unsigned char *p=NULL;unsigned short *p1=NULL;p=&amp;i;*p=0x00;p1=(unsigned short *)(p+1);*p1=0x0000; 最后两句代码，从奇数边界去访问unsigned short型变量，显然不符合对齐的规定。在x86上，类似的操作只会影响效率，但是在MIPS或者sparc上，可能就是一个error，因为它们要求必须字节对齐。 如何查找与字节对齐方面的问题？ 如果出现对齐或者赋值问题首先查看: 编译器的big little端设置； 看这种体系本身是否支持非对齐访问； 如果支持，看设置了对齐与否；如果没有，则看访问时需要加某些特殊的修饰来标志其特殊访问操作。 ARM下的对齐处理？ 对齐的使用： 1.__align(num) 这个用于修改最高级别对象的字节边界。在汇编中使用LDRD或者STRD时，就要用到此命令align(8)进行修饰限制来保证数据对象是相应对齐。这个修饰对象的命令最大是8个字节限制，可以让2字节的对象进行4字节对齐，但是不能让4字节的对象2字节对齐。align是存储类修改，它只修饰最高级类型对象，不能用于结构或者函数对象。 2.__packed __packed是进行一字节对齐 1）不能对packed的对象进行对齐； 2）所有对象的读写访问都进行非对齐访问； 3）float及包含float的结构联合及未用__packed的对象将不能字节对齐； 4）__packed对局部整型变量无影响； 5）强制由unpacked对象向packed对象转化是未定义，整型指针可以合法定义为packed。 1__packed int* p; //__packed int 则没有意义 6）对齐或非对齐读写访问带来问题 1234567891011121314151617181920212223242526272829303132333435363738394041__packed struct STRUCT_TEST&#123; char a; int b; char c;&#125;; //定义如下结构此时b的起始地址一定是不对齐的 //在栈中访问b可能有问题,因为栈上数据肯定是对齐访问[from CL]//将下面变量定义成全局静态不在栈上 static char* p;static struct STRUCT_TEST a;void Main()&#123;__packed int* q; //此时定义成__packed来修饰当前q指向为非对齐的数据地址下面的访问则可以p = (char*)&amp;a; q = (int*)(p+1); *q = 0x87654321; /* 得到赋值的汇编指令很清楚ldr r5,0x20001590 ; = #0x12345678[0xe1a00005] mov r0,r5[0xeb0000b0] bl __rt_uwrite4 //在此处调用一个写4byte的操作函数 [0xe5c10000] strb r0,[r1,#0] //函数进行4次strb操作然后返回保证了数据正确的访问[0xe1a02420] mov r2,r0,lsr #8[0xe5c12001] strb r2,[r1,#1][0xe1a02820] mov r2,r0,lsr #16[0xe5c12002] strb r2,[r1,#2][0xe1a02c20] mov r2,r0,lsr #24[0xe5c12003] strb r2,[r1,#3][0xe1a0f00e] mov pc,r14*//*如果q没有加__packed修饰则汇编出来指令是这样直接会导致奇地址处访问失败[0xe59f2018] ldr r2,0x20001594 ; = #0x87654321[0xe5812000] str r2,[r1,#0]*///这样可以很清楚的看到非对齐访问是如何产生错误的//以及如何消除非对齐访问带来问题//也可以看到非对齐访问和对齐访问的指令差异导致效率问题&#125; 有关于内存对齐的问题，可以看看《内存对齐详解》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac OS 开发 (一) 准备工作]]></title>
      <url>%2F2016%2F08%2F12%2Fmac-os-develop-prepare%2F</url>
      <content type="text"><![CDATA[程序猿，一个另类的物种。 其实很多时候，懒懒的程序猿因为自己的需要，或者是因为使用别人的工具并不满意，而催发出自己解决问题的想法。这个 Mac OS 开发系列，就是因为博主自己写博客是需要上传图片，而目前的 App 并不满意的情况下，决心自己学习，自己开发出喜欢的 App 而诞生的。 本文章为该系列开篇，循序渐进，从基础开始。 Mac这是开发的基础，至于是 Mac Book Pro，还是iMac，或者Mac mini 就随个人喜欢和实际状况。总之，不建议使用黑苹果。 Xcode这是毫无置疑的开发工具，具体如何使用，Google 一大把，这里就不再详说，以后若是博主自己写了相关内容，会后续放上链接跳转。 创建启动Xcode，选择Create a new Xcode project，(非首次运行Xcode，从菜单File-New-&gt;Project) 进入工程模版选择界面，选择OSX-&gt;Application-&gt;Cocoa Application 配置info.plist Application is agent(UIElement) 字段可以控制App的MainMenu是否显示，Logo在Dock是否显示。 Capabilities 这里我们重点关注下App Sandbox，Apple现在要求上架Mac AppStore的应用必须使用沙盒，所以发布到Mac商店的应用你必须选择打开。 如果你的应用要访问服务器的API接口，必须打开Outgoing Connections。 Hardware里面必须选择打开Printing，否则审核不通过。 File Accedd:如果你需要让用户选择访问本地的文件，User Selected File 中选择读/写权限。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[配色和排版（基础篇）]]></title>
      <url>%2F2016%2F08%2F05%2Fdesign-harmonize-colours%2F</url>
      <content type="text"><![CDATA[在什么样的团队就能成为什么样的人 来到公司已经有一段时间了，在这段时间里，自我感觉是快速成长的。今天，终于决定扯来公司这张虎皮来给自己镀镀金，这里主要分享一下公司设计团队的设计技巧，希望对大家有帮助。 基本颜色 暖色 冷色 中性色 以上色块示例只是日常使用中的基础颜色，各种颜色可以延伸出较多的相近色。这个需要根据内容主题来搭配颜色。所有的颜色搭配都是为了突出和强调主题。 颜色搭配基础 暖色 暖色系的搭配包括深色+浅色，也可以使用少量冷色衬托。 冷色 冷色系的搭配包括深色+浅色，也可以使用少量暖色衬托。 对比色 对比色是深色和浅色，暖色和冷色的搭配。 中性色 中性色可以搭配冷色、暖色。 图文排版基础 左对齐 左对齐分两种： 1）文字位于整张图片左侧，图片内容居右。 2）文字位于整张图片中间，但文字还是左对齐。 居中对齐 居中对齐是文字位于整张图片中间，背景加入素材作为衬托。 右对齐 文字位于整张图片右侧，图片内容居左。 总结配色是否协调需要长期观摩。排版需要注意适当的留白。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode 常用插件]]></title>
      <url>%2F2016%2F08%2F02%2Fxcode-plugin-list%2F</url>
      <content type="text"><![CDATA[工欲善其事，必先利其器 这里主要罗列一些常用的 Xcode 插件。 BBUncrustify 代码格式化 https://github.com/benoitsan/BBUncrustifyPlugin-Xcode Backlight 光标选中行高亮 https://github.com/limejelly/Backlight-for-XCode HighlightSelectedString 代码变量选中高亮 https://github.com/keepyounger/HighlightSelectedString VVDocumenter 快捷注释 https://github.com/onevcat/VVDocumenter-Xcode KSImageNamed 根据图片名，输入代码时图片预览 https://github.com/ksuther/KSImageNamed-Xcode]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈谈iOS App打包发布]]></title>
      <url>%2F2016%2F07%2F21%2Fios-app-distribution%2F</url>
      <content type="text"><![CDATA[来到 ZAKER 工作已经有一段时间了，博主也开始了自己的 iOS 开发之旅，因为博主是自学的，难免有些知识点的遗漏，很巧的是，关于App打包发布就是其中之一。而在最近，机缘巧合之下，需要自己打包上传到公司自己服务器用来做demo演示。在此，博主分享一下有关iOS App打包的过程。 1.安装发布证书 自己去Apple开发者中心配置 找其他已经有证书的小伙伴导出p12文件 2.设置Scheme Xcode-&gt;Product-&gt;Scheme-&gt;Edit Scheme 3.设置软件版本号 版本号格式：数字.数字-字符(驼峰式).数字 示例：1.1-beta.1 , 1.1.1-beta 说明：版本号从0开始，不过一般版本号为0的数字省略。 4.Archive 注意：选择真机或者Generic iOS Device Product-&gt;Archive 5.Export 6.安装企业应用证书 7.上传到ZAKER服务器]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[打造自己的 Mac 环境]]></title>
      <url>%2F2016%2F07%2F17%2Fcustom-myself-develop-tool%2F</url>
      <content type="text"><![CDATA[作为一个程序猿，每天接触最多的就是自己的“女朋友”，那么猿们肯定都有自己的一套撸具，我们都会根据自己的喜好配置自己的万能功能。无非是对于terminal的使用与配置。 文章主要分享记录博主自己搭建环境的过程。 清单罗列一下博主 Mac 上的盆友们，顺便来个简要介绍。 1）开发类 Xcode：苹果官方开发工具 PaintCode：可视化设计转代码神器 GitX：git可视化工具，开源 SimPholders：直接打开模拟器App文件神器 2）工具类 奇妙清单：云记事本 Beyond Compare：文件比较神器，付费 Charles：网络抓包神器，付费 Go2Shell：命令行打开工具，可以实现Finder下打开terminal Navicat Premium：数据库可视化工具，付费 Chrome：谷歌浏览器 The Unarchiver：文件解压缩工具 DaisyDisk：磁盘清理工具，付费 MindNode Pro：思维导图，付费 3）文本编辑类 Sublime Text：文本编辑神器 Pages：苹果官方办公工具 Mou：markdown语法文本编辑器 4）阅读类 Reeder：博客订阅 Pocket：文章收藏 Dash：离线开发文档阅读 Skim：PDF阅读，开源 CHM View：chm文件阅读 5）图像类 Acorn：轻量级PhotoShop ScreenFlow：录屏，生成视频文件，付费 licecap：录屏，生成.gif文件 Snip：截图 Sublime Text配置命令打开 Sublime Text 1ln -s &quot;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&quot; /usr/local/bin/subl 之后使用时，使用如下命令即可打开： 1$ subl 实际上这就是一个软链接的应用。 JSON代码格式化网上有很多工具可用，博主自己现在使用一个 Tidy 的插件，效果还是蛮不错的。 1.打开链接https://gist.github.com/charsdavy/cd2324f9483ff83425bbacf85a6ea9be，下载文件。 2.将解压后的文件夹中的 prettify_json.py 和 tidy_xml.py 问价拷贝到 ~/Library/Application Support/Sublime Text 2/Packages/User 路径 3.打开 Sublime Text，从菜单中打开“Key-Bindings Default”文件 4.添加快捷键 12&#123; &quot;keys&quot;: [&quot;ctrl+shift+x&quot;], &quot;command&quot;: &quot;tidy_xml&quot; &#125;,&#123; &quot;keys&quot;: [&quot;ctrl+shift+j&quot;], &quot;command&quot;: &quot;prettify_json&quot; &#125;, 5.使用 全选，然后按下 Control + shift + j 键即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac 中 Git 命令自动补全]]></title>
      <url>%2F2016%2F07%2F17%2Fgit-auto-completion-mac%2F</url>
      <content type="text"><![CDATA[转战iOS开发已经有一段时间了，现在使用Mac，对于命令行的使用，真的是越来越喜欢，但是，在使用Git命令的时候，不能使用【Tab】来自动补全，为此，博主找寻方法，来完善Git命令补全功能。本文分享此功能实现。 安装Homebrew使用Homebrew安装的git，如何安装Honebrew及其使用在此就跳过，烦请自行查看(http://brew.sh/index_zh-cn.html)。 安装bash-completion1$ brew list 查看是否已经安装了”bash-completion”，如果没有，继续往下看： 123456789$ brew install bash-completion#####安装完成之后######$ brew info bash-completion #####下边这句话很重要#######==&gt; CaveatsAdd the following lines to your ~/.bash_profile:if [ -f $(brew --prefix)/etc/bash_completion ]; then. $(brew --prefix)/etc/bash_completionfi 将if…then…那一句添加到~/.bash_profile（如果没有该文件，新建一个） 获取git-completion.bash将git源码clone到本地 1$ git clone https://github.com/git/git.git 找到”contrib/completion/“目录下的git-completion.bash，将该文件拷贝到~/下并重命名为.git-completion.bash 1$ cp git-completion.bash ~/.git-completion.bash 配置git-completion.bash在~/.bash_profile文件（该目录下如果没有，新建一个）中添加下边的内容 1source ~/.git-completion.bash 重启终端即可 12$ git --h[tab][tab]--help --html-path]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在Finder中打开终端]]></title>
      <url>%2F2016%2F07%2F13%2Ffinder-open-terminal%2F</url>
      <content type="text"><![CDATA[在Mac中，如果要在终端中进入在Finder中打开的目录，常用的方法是在终端中先敲入一个”cd “，然后在Finer中选中文件夹拖入到终端中，再回车即可实现。不过这样做终究还是麻烦了点，下面介绍如何直接在Finder中直接操作。 在终端里打开Finder很简单，使用open .即可 系统设置在Finder打开terminal这个功能其实是有的，但是系统默认没有打开，我们可以通过如下方法将其打开 进入系统偏好设置-&gt;键盘-&gt;快捷键-&gt;服务。 在右边新建位于文件夹位置的终端窗口上打勾。 如此设置后，在Finder中右击某文件，在出现的菜单中找到服务，然后点击新建位于文件夹位置的终端窗口即可。 Go2Shell在Mac App Store中下载 Go2Shell 软件，下载后在”应用程序“里找到Go2Shell软件，按住Cmd键，将其拖动到Finder的工具栏上。 打开Go2Shell设置的方法是：在终端中输入命令 open -a Go2Shell --args config，然后回车。 优点：可以不需要选中文件夹，直接点Go2Shell按钮就可以打开终端。 缺点：每次都是在新的终端窗口中打开，而不是在新的终端标签中打开。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git可视化比较工具P4Merge]]></title>
      <url>%2F2016%2F07%2F12%2Fgit-diff-p4merge%2F</url>
      <content type="text"><![CDATA[在转战Mac之后，BeyondCompare 不再那么容易免费使用，今天终于让我找到了一个Git的GUI比较工具P4Merge，免费的，支持中文，还不错，推荐一下 下载打开这个链接: perforce-visual-merge-and-diff-tools，点左上角的 FREE DOWNLOAD P4Merge , 找到 Perforce Clients 中的 P4Merge: Visual Merge Tool 项，在右边的第二行选择Mac OS 10.6+ (64bit） ，点下面橙色的 Accept and Download，选择跳过 Skip Registration ，就会开始下载了。 下载到P4V.dmg文件后，双击打开，拖动P4Merge到Application文件夹上就可以完成安装了。 配置123git config --global diff.tool p4mergegit config --global difftool.p4merge.cmd /Applications/p4merge.app/Contents/MacOS/p4mergegit config --global difftool.p4merge.cmd &quot;/Applications/p4merge.app/Contents/Resources/launchp4merge \$LOCAL \$REMOTE&quot; 如果直接复制原文的代码，运行上面的代码时会提示：error: key does not contain a section: -global跟别人的命令比较一下，就会发现应该是—global（要两个短横连在一起的），原文的短横线有问题 现在敲git difftool命令执行时，会提示： /usr/libexec/git-core/mergetools/p4merge: line 2: p4merge: command not found 原因是路径还需要再配置一下，如下 git config --global difftool.p4merge.path &quot;/Applications/p4merge.app/Contents/Resources/launchp4merge&quot;以后想要比较Git中的代码时，敲git difftool filepath 即可 Linux、Windows下也都可以使用这个工具进行比较代码，只是需要另行配置了。P4Merge除了有比较功能，还有合并功能，怎么配置可以借鉴下面给出的参考链接。另外还有一个可视化比较工具meld，据说也不错，有时间试试. 参考《Mac os x下git merge工具P4Merge的安装与配置》 《Git 用户信息》 《Setup p4merge as a visual diff and merge tool for git》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[说说升级Xcode中SDK与真机调试版本]]></title>
      <url>%2F2016%2F06%2F30%2Fxcode-update-sdk-devicesupport%2F</url>
      <content type="text"><![CDATA[相信作为一名iOS开发者，每当WWDC开始，iOS升级时，那种切肤之痛，是只有开发者才能体会而又无言的一种沉默抗议。 Apple很残暴的将MAC OS、iOS、Xcode牢固的捆绑在一起。如果需要真机调试，那么Xcode的SDK版本一定不能低于真机，Xcode版本的安装有MAC OS的版本要求，这样一来，只要升级一下iOS版本，那么恭喜你，很有可能你需要升级MAC OS和Xcode。而对于动辄数十个G的文件，在天朝的绿色网络保护下，是一件多么伤神的事情啊。更甚的是，现在的MAC OS系统越来越不好用了，我很是怀恋之前的版本，课无奈胳膊拗不过大腿。 现在，终于有了可行的办法，能够解决上述神伤，在此总结分享给大家。 下载Xcode历史版本Apple提供了官方下载地址： https://developer.apple.com/download/more 打开链接，登录账户，即可看见下图所示： 根据左侧栏，筛选自己需要的软件，下载即可。 升级Xcode真机调试版本1）在一台已经安装好的高版本中，获取需要的文件。 2）替换自己的电脑上的Xcode对应的文件。 步骤如下： 1）找到应用程序，显示包中的文件 2）进入路径 /Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport 拷贝需要的文件，如 9.3文件夹。 粘贴至自己电脑对应的位置即可。 升级Xcode的SDK延续上述步骤，只需要进入文件路径 /Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs 拷贝SDKs文件夹，粘贴至自己电脑相对应位置即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo 博客功能扩展 - 添加回滚到顶部按钮]]></title>
      <url>%2F2016%2F06%2F24%2Fhexo-extern-scroll-top%2F</url>
      <content type="text"><![CDATA[摘要：承接前文《手把手教 GitHub + Hexo 搭建博客》 ，对现有博客进行功能扩展。因为随着文章的发表，页面变得很长，长文章也较多，偶尔需要立即回到顶部，这个时候，就需要添加新的快捷方式。于是乎，诞生了这个功能扩展。文章主要分享实现滚动到顶部按钮功能。 以Yilia主题为例，不同的主题可以类比找到对应的文件地址。 添加html代码打开文件夹/themes/Yilia/layout/_partial在此文件夹下，新建文件totop.ejs，并向其中加入如下代码： 123&lt;div id=&quot;totop&quot; style=&quot;position:fixed;bottom:50px;right:30px;cursor: pointer;&quot;&gt;&lt;a title=&quot;返回顶部&quot;&gt;&lt;img src=&quot;/img/scrollup.png&quot;/&gt;&lt;/a&gt;&lt;/div&gt; 注意： 文件的编码格式为utf-8。 添加js代码打开文件夹/themes/Yilia/source/js，新建文件totop.js，将如下代码复制其中： 123456789101112131415161718192021222324252627(function($) &#123; // When to show the scroll link // higher number = scroll link appears further down the page var upperLimit = 1000; // Our scroll link element var scrollElem = $(&apos;#totop&apos;); // Scroll to top speed var scrollSpeed = 1600; // Show and hide the scroll to top link based on scroll position scrollElem.hide(); $(window).scroll(function () &#123; var scrollTop = $(document).scrollTop(); if ( scrollTop &gt; upperLimit ) &#123; $(scrollElem).stop().fadeTo(300, 1); // fade back in &#125;else&#123; $(scrollElem).stop().fadeTo(300, 0); // fade out &#125; &#125;); // Scroll to top animation on click $(scrollElem).click(function()&#123; $(&apos;html, body&apos;).animate(&#123;scrollTop:0&#125;, scrollSpeed); return false; &#125;);&#125;)(jQuery); 可以对upperLimit和scrollSpeed参数进行修改，控制显示位置和回滚速度。 添加文件引用打开文件/themes/Yilia/layout/_partial/after_footer.ejs，在文件的末尾添加以下两行代码： 12&lt;%- partial(&apos;totop&apos;) %&gt;&lt;script src=&quot;&lt;%- config.root %&gt;js/totop.js&quot;&gt;&lt;/script&gt; 资源将下面的图片复制到/themes/Yilia/source/img目录下，文件名为scrollup.png，页面足够长时，就可以看见按钮出现。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单聊聊 iOS 中的网络加密]]></title>
      <url>%2F2016%2F06%2F15%2Fios-network-encrypt%2F</url>
      <content type="text"><![CDATA[摘要：公司的接口一般会两种协议的，一种HTTP，一种HTTPS的，HTTP 只要请求，服务器就会响应，如果我们不对请求和响应做出加密处理，所有信息都是会被检测劫持到的，是很不安全的，客户端加密可以使用本文这套工具类进行处理。 导言公司的接口一般会两种协议的，一种HTTP，一种HTTPS的，HTTP 只要请求，服务器就会响应，如果我们不对请求和响应做出加密处理，所有信息都是会被检测劫持到的，是很不安全的，客户端加密可以使用本文这套工具类进行处理。 但是不论在任何时候，都应该将服务置于HTTPS上，因为它可以避免中间人攻击的问题，还自带了基于非对称密钥的加密通道。 HTTPS交互原理简答说，HTTPS 就是 HTTP协议加了一层SSL协议的加密处理，SSL 证书就是遵守 SSL协议，由受信任的数字证书颁发机构CA（如GlobalSign，wosign），在验证服务器身份后颁发，这是需要花钱滴，签发后的证书作为公钥一般放在服务器的根目录下，便于客户端请求返回给客户端，私钥在服务器的内部中心保存，用于解密公钥。 HTTPS 客户端与服务器交互过程： 1）客户端发送请求，服务器返回公钥给客户端； 2）客户端生成对称加密秘钥，用公钥对其进行加密后，返回给服务器； 3）服务器收到后，利用私钥解开得到对称加密秘钥，保存； 4）之后的交互都使用对称加密后的数据进行交互。 证书简单说，证书有两种，一种是正经的： CA颁发的证书 一种是不正经的： 自己生成签发的证书 我们需要做什么如果遇到正经的证书，我们直接用AFNetworking 直接请求就好了，AFNetworking 内部帮我们封装了HTTPS的请求方式，但是大部分公司接口都是不正经的证书，这时需要我们做以下几步： 1）将服务器的公钥证书拖到Xcode中 2）修改验证模式 1manager.securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModePublicKey]; 原理简单来说，就是你本可以修改AFN这个设置来允许客户端接收服务器的任何证书，但是这么做有个问题，就是你无法验证证书是否是你的服务器后端的证书，给中间人攻击，即通过重定向路由来分析伪造你的服务器端打开了大门。 12AFSecurityPolicy *securityPolicy = [AFSecurityPolicy defaultPolicy];securityPolicy.allowInvalidCertificates = YES; 解决方法AFNetworking是允许内嵌证书的，通过内嵌证书，AFNetworking就通过比对服务器端证书、内嵌的证书、站点域名是否一致来验证连接的服务器是否正确。由于CA证书验证是通过站点域名进行验证的，如果你的服务器后端有绑定的域名，这是最方便的。将你的服务器端证书，如果是pem格式的，用下面的命令转成cer格式 1openssl x509 -in &lt;你的服务器证书&gt;.pem -outform der -out server.cer 然后将生成的server.cer文件，如果有自建ca，再加上ca的cer格式证书，引入到app的bundle里，AFNetworking在 1AFSecurityPolicy *securityPolicy = [AFSecurityPolicy AFSSLPinningModeCertificate]; 或者 1AFSecurityPolicy *securityPolicy = [AFSecurityPolicy AFSSLPinningModePublicKey]; 情况下，会自动扫描bundle中.cer的文件，并引入，这样就可以通过自签证书来验证服务器唯一性了。 AFSecurityPolicy三种验证模式 AFSSLPinningModeNone这个模式表示不做SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书就不会通过。 AFSSLPinningModeCertificate这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。 AFSSLPinningModePublicKey这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。 参考 http://www.jianshu.com/p/75d96b72bfb1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[State 模式]]></title>
      <url>%2F2016%2F06%2F10%2Fstate-pattern%2F</url>
      <content type="text"><![CDATA[摘要：State模式在实际使用中比较多,适合”状态的切换”.因为我们经常会使用if else if else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式了.不只是根据状态,也有根据属性.如果某个对象的属性不同,对象的行为就不一样,这点在数据库系统中出现频率比较高,我们经常会在一个数据表的尾部,加上property属性含义的字段,用以标识记录中一些特殊性质的记录,这种属性的改变(切换)又是随时可能发生的,就有可能要使用State.文章主要分享State模式相关内容. 定义不同的状态,不同的行为;或者说,每个状态有着相应的行为. 何时使用State模式在实际使用中比较多,适合”状态的切换”.因为我们经常会使用 if else if else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式了. 不只是根据状态,也有根据属性.如果某个对象的属性不同,对象的行为就不一样,这点在数据库系统中出现频率比较高,我们经常会在一个数据表的尾部,加上property属性含义的字段,用以标识记录中一些特殊性质的记录,这种属性的改变(切换)又是随时可能发生的,就有可能要使用State. 参考网址：http://www.jdon.com/designpatterns/designpattern_State.htm 举例来说：一个人具有生气，高兴和抓狂等状态，在这些状态下做同一个事情可能会有不同的结果，一个人的心情可能在这三种状态中循环转变。使用一个moodState类表示一个人的心情，使用mad,Happy,Angry类代表不同的心情。使用UML图表示如下所示： 适用性：在下面的两情况下均可以使用State模式： 一个对象的行为取决于它的状态，并且必须在运行时刻根据状态改变它的行为。 一个操作中含有庞大的多分支的条件豫剧，并且这些分支依赖于该对象的状态，这个状态通常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构，State模式将每一个条件分支放入一个单独的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。 参与者： Context(环境，Person)定义客户感兴趣的类。 State(Moodstate)：定义一个接口以封装与Context的一个特定状态相关的行为 ConcreteState Subclasses(具体状态子类，如Angry)每一个子类实现一个与Context的状态相关的行为。 他们的协作关系是： Context将于状态相关的请求委托给当前的ConcreteState对象处理。 Context可将自身作为一个参数传递给处理该请求的状态对象，这使得状态对象在必要的时候可访问Context。 Context是客户使用的主要接口，客户可用状态对象来配置一个Context，一旦一个Context配置完毕，他的客户不再需要直接与状态对象打交道。 Context或者ConcreteState子类都可以决定哪个状态是另外那个状态的后继者，以及是在何种条件下进行状态转换。 相应的代码：MoodState代码： 12345package state;public interface MoodState&#123; public void doSomething(); public void changeState();&#125; Angry代码: 1234567891011121314package state;public class implements MoodState&#123; Person p; public Angry(Person p)&#123; this.p = p; &#125; public void doSomething()&#123; System.out.println(&quot;I&apos;m angry!&quot;); &#125; public void changeState()&#123; p.setState(new Happy(p)); &#125;&#125; Happy代码： 12345678910111213package state;public class Happy implements MoodState&#123; Person p; public Happy(Person p)&#123; this.p = p; &#125; public void doSomething()&#123; System.out.println(&quot;I&apos;m happy!&quot;); &#125; public void changeState()&#123; p.setState(new Mad(p)); &#125;&#125; Mad代码： 12345678910111213package state;public class Mad implements MoodState&#123; Person p; public Mad(Person p)&#123; this.p=p; &#125; public void doSomething()&#123; System.out.println(&quot;I&apos;m Mad&quot;); &#125; public void changeState()&#123; p.setState( new Angry(p)); &#125;&#125; Person代码： 1234567891011121314package state;public class Person&#123; private MoodState state; public Person()&#123; state = new Mad(this); &#125; public void setState(MoodState state)&#123; this.state = state; &#125; public void doSomething()&#123; state.doSomething(); state.changeState(); &#125;&#125; Client代码： 12345678package state;public class Client&#123; public static void main(String[] args)&#123; Person p = new Person(); for(int i=0;i&lt;10;i++) p.doSomething(); &#125;&#125; 总结状态模式将与特定状态相关的行为局部化，并且将不同状态的行为分割开来，使得状态转换显式化并且可以被共享。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git 使用 - 远程操作]]></title>
      <url>%2F2016%2F06%2F05%2Fgit-using-remote%2F</url>
      <content type="text"><![CDATA[摘要：Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git的读音为/gɪt/。 Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper，后者之前一直是Linux 内核开发人员在全球使用的主要源代码工具。开放源码社区中的有些人觉得 BitKeeper 的许可证并不适合开放源码社区的工作，因此 Torvalds 决定着手研究许可证更为灵活的版本控制系统。尽管最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是我们已经发现在很多其他自由软件项目中也使用了 Git。例如 最近就迁移到 Git 上来了，很多 Freedesktop 的项目也迁移到了 Git 上。 Git有很多优势，其中之一就是远程操作非常简单。但是，Git也是一把双刃剑，使用得当，将会尽享Git的便利与强大。本文将主要介绍几个常用的Git远程操作命令。 git clone远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。 1$ git clone &lt;版本库的网址&gt; 比如，克隆Weibo的版本库。 1$ git clone https://github.com/charsdavy/iWeibo.git 该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。 1$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt; git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。 1234567$ git clone http[s]://example.com/path/to/repo.git/$ git clone ssh://example.com/path/to/repo.git/$ git clone git://example.com/path/to/repo.git/$ git clone /opt/git/project.git $ git clone file:///opt/git/project.git$ git clone ftp[s]://example.com/path/to/repo.git/$ git clone rsync://example.com/path/to/repo.git/ SSH协议还有另一种写法： 1$ git clone [user@]example.com:path/to/repo.git/ 通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。 git remote为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。 不带选项的时候，git remote命令列出所有远程主机。 12$ git remoteorigin 使用-v选项，可以参看远程主机的网址。 123$ git remote -vorigin git@github.com:charsdavy/iWeibo.git (fetch)origin git@github.com:charsdavy/iWeibo.git (push) 上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。 克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。 123$ git clone -o Weibo https://github.com/charsdavy/iWeibo.git$ git remoteWeibo 上面命令表示，克隆的时候，指定远程主机叫做Weibo。 git remote show命令加上主机名，可以查看该主机的详细信息。 $ git remote show &lt;主机名&gt; git remote add命令用于添加远程主机。 $ git remote add &lt;主机名&gt; &lt;网址&gt; git remote rm命令用于删除远程主机。 $ git remote rm &lt;主机名&gt; git remote rename命令用于远程主机的改名。 $ git remote rename &lt;原主机名&gt; &lt;新主机名&gt; git fetch一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。 1$ git fetch &lt;远程主机名&gt; 上面命令将某个远程主机的更新，全部取回本地。 git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。 默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。 1$ git fetch &lt;远程主机名&gt; &lt;分支名&gt; 比如，取回origin主机的master分支。 1$ git fetch origin master 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。 git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。 123456$ git branch -rorigin/master$ git branch -a* master remotes/origin/master 上面命令表示，本地主机的当前分支是master，远程分支是origin/master。 取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。 1$ git checkout -b newBrach origin/master 上面命令表示，在origin/master的基础上，创建一个新分支。 此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。 123$ git merge origin/master# 或者$ git rebase origin/master 上面命令表示在当前分支上，合并origin/master。 git pullgit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。 1$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。 1$ git pull origin next:master 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。 1$ git pull origin next 上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。 12$ git fetch origin$ git merge origin/next 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。 Git也允许手动建立追踪关系。 1git branch --set-upstream master origin/next 上面命令指定master分支追踪origin/next分支。 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。 1$ git pull origin 上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。 如果当前分支只有一个追踪分支，连远程主机名都可以省略。 1$ git pull 上面命令表示，当前分支自动与唯一一个追踪分支进行合并。 如果合并需要采用rebase模式，可以使用–rebase选项。 1$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。 但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。 1234$ git pull -p# 等同于下面的命令$ git fetch --prune origin $ git fetch -p git pushgit push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。 1$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 注意：分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。 如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 1$ git push origin master 上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。 123$ git push origin :master# 等同于$ git push origin --delete master 上面命令表示删除origin主机的master分支。 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。 1$ git push origin 上面命令表示，将当前分支推送到origin主机的对应分支。 如果当前分支只有一个追踪分支，那么主机名都可以省略。 1$ git push 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。 1$ git push -u origin master 上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。 不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。 123$ git config --global push.default matching# 或者$ git config --global push.default simple 还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。 1$ git push --all origin 上面命令表示，将所有本地分支都推送到origin主机。 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。 1$ git push --force origin 上面命令使用–force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用–force选项。 最后，git push不会推送标签（tag），除非使用–tags选项。 1$ git push origin --tags git fetch最近工作上有点忙，不免回家之后还需要办公，可是工作用公司的设备。回家之后只能使用自己的MAC。不过，如何在两台设备同步代码就成了问题。需要能够在一个文件夹不断的同步新的分支，而不会产生新的文件夹。这里，分享博主的解决办法。 1）从远端获取分支 1$ git fetch origin 2）基于远端分支创建本地分支 1$ git checkout -b local_branch_name origin/remote_branch_name 这样，就会在本地创建一个基于远端分支的分支。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[七牛云存储应用]]></title>
      <url>%2F2016%2F06%2F02%2Fqiniu-using%2F</url>
      <content type="text"><![CDATA[摘要：七牛云存储，是专为移动时代开发者打造的数据管理平台，为互联网网站和移动App提供数据的在线托管、传输加速以及图片、音视频等富媒体的云处理服务。本文讲述如何使用七牛云存储来作为自己APP的数据云存储空间。 前言七牛云存储，是专为移动时代开发者打造的数据管理平台，为互联网网站和移动App提供数据的在线托管、传输加速以及图片、音视频等富媒体的云处理服务。七牛云官网http://www.qiniu.com/ ，进入开发者平台，浏览了所有的开发指南，可是却是没有具体清晰的操作步骤。今天自己试着通过网络，实现了使用七牛云存储文件。现在，将操作步骤记录如下。 准备工作1.注册七牛云账号。 2.创建空间。 3.获取Access Key。 4.获取Secret Key。 5.获取官方SDK（https://github.com/qiniu/objc-sdk ）。 导入工程1.打开Xcode创建Project。 2.从获取的官方SDK导入库，如下图 3.获取token 这一步，网上大家都说得很简单，在这一步卡壳许久。现在说说自己使用的方法： 1）获取服务器代码，编译工程，以备生成token。 服务器代码地址：https://github.com/CharsDavy/QiNiuGenertorToken2）使用Eclipse导入上述服务器代码 在Test.java文件中，修改自己的空间名称，Access Key和Secret Key。运行程序，即可获得token。 这种方式生成的token的有效期是可以自己设定的，如果你想，设定1000年过期也是可以的。 4.使用代码上传文件 1234567891011#import &lt;QiniuSDK.h&gt;... NSString token = @&quot;从服务端SDK获取&quot;; QNUploadManager *upManager = [[QNUploadManager alloc] init]; NSData *data = [@&quot;Hello, World!&quot; dataUsingEncoding : NSUTF8StringEncoding]; [upManager putData:data key:@&quot;hello&quot; token:token complete: ^(QNResponseInfo *info, NSString *key, NSDictionary *resp) &#123; NSLog(@&quot;%@&quot;, info); NSLog(@&quot;%@&quot;, resp); &#125; option:nil];... 调试工程导入之后，可能会出现以下几种可能的错误。 1.若报 Undefined symbols for architecture x86_64: &quot;_crc32&quot;, referenced from:，项目中需导入 libz.dylib。(Build Phases—Link Binary With Libraries) 2.若报&quot;_res_9_ninit&quot;, referenced from: _setup_dns_server in QNResolver.o等， 1）项目中需导入 libresolv.dylib或libresolv.9.dylib。(Build Phases— Link Binary With Libraries)； 2）或 (Build Settings— Linking— Other Linker Flags) 添加 -lresolv选项。 3.若报 Thread 1: EXC_BAD_ACCESS(code=1,address=0x180f4beb8)类似错误，将 QN打头的都设置 arc (Build Phases — Compile Sources) 4.可能需要修改部分内容，如 #import &lt;AFNetworking/AFNetworking.h&gt;改为 #import &quot;AFNetworking.h&quot; 小结以上就是本人在工程中使用七牛云进行文件云存储的过程，本文中使用的仅仅是上传文件，更多其他操作功能请参照官方文档。 最后，附上一个使用七牛云存储的软件，源码地址：https://github.com/CharsDavy/MyNotes 其实，对于获取token来完成上载操作，也可以参考官方文档，地址http://developer.qiniu.com/docs/v6/api/reference/security/put-policy.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[你和日本的距离只差5mm]]></title>
      <url>%2F2016%2F06%2F01%2Fchopsticks-using%2F</url>
      <content type="text"><![CDATA[摘要：世界上使用筷子的国家并不是很多，很多人都认为能够使用筷子是件很神奇的事情。那么，不同的国家地区使用筷子的讲究也有所不同。这里主要说说日本使用筷子的禁忌，有些也很符合天朝国情的。 日本在使用筷子的时候，也有很大的「箸（はし）」学问，有什么禁忌是千万不要犯的呢？！ ✖握り箸（にぎりばし）——握筷子，这是初级错误，一般来说只有初学使用筷子的孩子和外国人会犯。 ✖クロス箸——两根筷子交叉，很不雅观。 ✖迷い箸（まよいばし）——拿起筷子犹豫不决，前后左右晃动，似乎在挑拣食物。 ✖移り箸（うつりばし）——前面食物的味道还残留在口中，就取另外的食物。 ✖こじ箸——在碗底翻腾取食物。 ✖寄せ箸（よせばし）——用筷子拨动、移动盘子。 ✖刺し箸（さしばし）——用筷子扎取食物（对于不会用筷子的人来说，吃丸子的时候不这样会很难~）。 ✖涙箸——“泪筷子”，这个名称很形象，筷子夹起食物滴滴答答的流汤。 ✖かき箸——把碗放在嘴边，用筷子把食品拨拉到嘴里。 ✖込み箸（こみばし）——筷子进嘴塞食。 ✖持ち箸（もちばし）——把筷子拿在手里，端起碗吸食，日本农民 。 ✖ねぶり箸——把筷子放在嘴里吸允。 ✖渡し箸（わたしばし）——把筷子架在碗上。 ✖叩き箸（はたきばし）——用筷子敲碗催促他人（这样真的很招人烦）。 ✖指さし箸（ゆびさしばし）——用筷子指人（用手指人也是很不好的）。 ✖直箸（じかばし）——有公筷不用，直接使用自己的筷子在盘内取食。 ✖立箸——把筷子插在米饭碗里。 ✖そろえ箸——用舌头、嘴唇或者其他平面整理、理顺两根筷子（为什么不用手，这样多累啊）。 ✖探り箸（さぐりばし）——用筷子在盘子里搅拌、寻找食物（瞄准一个直接吃得了，在那ba la啥）。 ✖せせり箸——把筷子当牙签使（小花儿表示：她的牙缝没这么大）。 ✖かみ箸——用牙齿咬筷子。 ✖振り箸（ふりばし）——甩手抖落筷子上的汤汁（轻微洁癖真的有点接受不了）。 ✖洗い箸（あらい）——在碗盘汤中涮洗筷子。 ✖箸渡し（はしわたし）——用筷子向他人的筷子递送食品。✖そら箸——筷子靠近了盘子，却又不取食品。 以上是25条使用筷子的禁忌。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手把手教 GitHub + Hexo 搭建博客]]></title>
      <url>%2F2016%2F05%2F31%2Fbuild-blog-by-hexo%2F</url>
      <content type="text"><![CDATA[摘要：本文章主要介绍使用hexo框架搭建博客，使用GitHub免费托管自己的博客代码，并使用GitHub Pages提供的免费服务。换句话说，就是使用免费资源搭建属于自己的博客网站。 前言在很久以前，博主就想着要有自主的博客专栏或者网站。经历了博客园这个需要所谓的编辑审核，一直比较困惑，这些编辑是什么出身，怎么知道技术博客的价值性。 接下来找到了开源中国，这个可以自由发言的地方。不过，不知道是不是受众面不广，访问量都不是很理想。 再然后就来自己动手开始搭建博客。从手写html发布文章，到使用jekyll，最后到了hexo阵营。 终于，有种找到家的赶脚。hexo不仅搭建方便，而且在后续的功能扩展以及文章发布都是非常方便的。不仅如此，还可以本地调试，预览效果。最方便的是支持markdown编写文档。 本文就是介绍如何安装使用hexo搭建属于自己的博客。从此不再担心投稿被莫名拒绝。可以在自己的一亩三分地讲述着自己的故事。 环境准备安装GitMAC OS X 是自带Git命令行工具。 Windows 可以安装Git Bash。 安装Node.js前往官网地址，根据教程安装即可。 安装hexo1$ sudo npm install hexo-cli -g 使用hexo12345678910111213141516171819# 创建hexo文件夹$ mkdir hexo# 进入hexo文件夹$ cd hexo# 初始化hexo$ hexo init# 安装依赖包$ npm install# 本地查看# 先运行下面的命令，再在浏览器输入localhost:4000即可$ hexo server# 问题：执行hexo server提示找不到该指令# 解决办法：在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：$ npm install hexo -server --save 生成静态网站1$ hexo generate 目录结构1234567891011.├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json 全局配置 _config.yml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site #站点信息title: #标题subtitle: #副标题description: #站点描述，给搜索引擎看的author: #作者email: #电子邮箱language: zh-CN #语言# URL #链接格式url: #网址root: / #根目录permalink: :year/:month/:day/:title/ #文章的链接格式tag_dir: tags #标签目录archive_dir: archives #存档目录category_dir: categories #分类目录code_dir: downloads/codepermalink_defaults:# Directory #目录source_dir: source #源文件目录public_dir: public #生成的网页文件目录# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）titlecase: false #标题转换成大写external_link: true #在新选项卡中打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsehighlight: #语法高亮 enable: true #是否启用 line_number: true #显示行号 tab_replace:# Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Archives2: 开启分页1: 禁用分页0: 全部禁用archive: 2category: 2tag: 2# Server #本地服务器port: 4000 #端口号server_ip: localhost #IP 地址logger: falselogger_format: dev# Date / Time format #日期时间格式date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/time_format: H:mm:ss# Pagination #分页per_page: 10 #每页文章数，设置成 0 禁用分页pagination_dir: page# Disqus #Disqus评论，替换为多说disqus_shortname:# Extensions #拓展插件theme: landscape-plus #主题exclude_generator:plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap# Deployment #部署，将 lmintlcx 改成用户名deploy: type: git repo: github创库地址.git branch: master 注意 配置文件的冒号“:”后面有一个空格 repo: github创库地址.git hexo命令行使用123456789101112131415常用命令：hexo help #查看帮助hexo init #初始化一个目录hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成网页，可以在 public 目录查看整个网站的文件hexo server #本地预览，&apos;Ctrl+C&apos;关闭hexo deploy #部署.deploy目录hexo clean #清除缓存，强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹简写：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 使用GitHub注册账号前往GitHub官网注册账号，按照网站提示注册。 创建代码仓库这个仓库的名字需要和你的账号对应。格式: yourname.github.io 具体使用GitHub可以参考：《GitHub 使用》 编辑文章12# 新建文章$ hexo new &quot;标题&quot; 在 _posts 目录下会生成文件标题.md 1234567---title: Hello Worlddate: 2015-07-30 07:56:29 #发表日期，一般不改动categories: hexo #文章文类tags: [hexo,github] #文章标签，多于一项时用这种格式---正文，使用Markdown语法书写 编辑完后保存, 预览 1$ hexo server hexo部署执行下列指令完成部署 12hexo generatehexo deploy 以下提示说明部署成功 1[info] Deploy done: git hexo插件使用添加rss订阅功能安装hexo-generator-feed插件 1$ npm install hexo-generator-feed --save 安装完后，会在node_modules目录下生成hexo-generator-feed目录。然后将其配置到根目录的_config.yml 12345678910# Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed: #可选项，可以不填type: atompath: atom.xmllimit: 20 最后，在你当前主题下的_config.yml下，添加RSS订阅链接即可，这里博主用的是Yilia主题，subnav下添加rss： 123# SubNavsubnav:rss: &quot;/atom.xml&quot; 至此，博客搭建完成，基本使用介绍完毕。希望对大家有所帮助。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[YYModel源代码阅读 - 基础知识]]></title>
      <url>%2F2016%2F05%2F27%2FYYModel-reading%2F</url>
      <content type="text"><![CDATA[摘要：YYModel堪称神级大作，虽然不免一些小bug，但是完全不影响膝盖碎一地。文章主要分享在阅读YYModel源代码时，所引发的知识点的补充与思考。 前言这段时间因为工作需要，阅读了YYModel这个开源框架，至于它能做什么，最直白的讲述就是JSON与Model之间的相互转化。 源代码在Github，大家可以自行git clone或者download。 接下来，笔者主要分析阅读源代码而引出的各种问题与知识点，不足之处请大家指正。 NS_ASSUME_NONNULL_BEGIN &amp; NS_ASSUME_NONNULL_END这组宏是成对使用的，不得不说我们自己写代码的时候使用的很少，以至于遗漏这个知识点，现在我们就来看看这两个宏会引出什么问题。 这组宏会引出几个关于Objective-C新特性的知识点： Nullability Annotations Lightweight Generics __kindof Nullability Annotations我们都知道在swift中，可以使用!和?来表示一个对象是optional的还是non-optional，如view?和view!。而在 Objective-C中则没有这一区分，view既可表示这个对象是optional，也可表示是non-optioanl。这样就会造成一个问题：在 Swift与Objective-C混编时，Swift编译器并不知道一个Objective-C对象到底是optional还是non-optional，因此这种情况下编译器会隐式地将Objective-C的对象当成是non-optional。 为了解决这个问题，苹果在Xcode 6.3引入了一个Objective-C的新特性：nullability annotations。这一新特性的核心是两个新的类型注释： __nullable 和 __nonnull 。从字面上我们可以猜到，__nullable表示对象可以是NULL或nil，而__nonnull表示对象不应该为空。当我们不遵循这一规则时，编译器就会给出警告。 我们来看看以下的实例， 12345678910111213@interface TestNullabilityClass ()@property (nonatomic, copy) NSArray * items;- (id)itemWithName:(NSString * __nonnull)name;@end@implementation TestNullabilityClass...- (void)testNullability &#123; [self itemWithName:nil]; // 编译器警告：Null passed to a callee that requires a non-null argument&#125;- (id)itemWithName:(NSString * __nonnull)name &#123; return nil;&#125;@end 不过这只是一个警告，程序还是能编译通过并运行。 事实上，在任何可以使用const关键字的地方都可以使用__nullable和__nonnull，不过这两个关键字仅限于使用在指针类型上。而在方法的声明中，我们还可以使用不带下划线的nullable和nonnull，如下所示： 12345678- (nullable id)itemWithName:(NSString * nonnull)name在属性声明中，也增加了两个相应的特性，因此上例中的items属性可以如下声明：@property (nonatomic, copy, nonnull) NSArray * items;当然也可以用以下这种方式：@property (nonatomic, copy) NSArray * __nonnull items;推荐使用nonnull这种方式，这样可以让属性声明看起来更清晰。 Nonnull区域设置(Audited Regions)如果需要每个属性或每个方法都去指定nonnull和nullable，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END。在这两个宏之间的代码，所有简单指针对象都被假定为 nonnull，因此我们只需要去指定那些nullable的指针。如下代码所示： 123456NS_ASSUME_NONNULL_BEGIN@interface TestNullabilityClass ()@property (nonatomic, copy) NSArray * items;- (id)itemWithName:(nullable NSString *)name;@endNS_ASSUME_NONNULL_END 在上面的代码中，items属性默认是nonnull的，itemWithName:方法的返回值也是nonnull，而参数是指定为nullable的。 不过，为了安全起见，苹果还制定了几条规则： typedef定义的类型的nullability特性通常依赖于上下文，即使是在Audited Regions中，也不能假定它为nonnull。 复杂的指针类型(如id )必须显示去指定是nonnull还是nullable。例如，指定一个指向nullable对象的nonnull指针，可以使用”__nullable id __nonnull”。 我们经常使用的NSError **通常是被假定为一个指向nullable NSError对象的nullable指针。 兼容性因为Nullability Annotations是Xcode 6.3新加入的，所以我们需要考虑之前的老代码。实际上，苹果已以帮我们处理好了这种兼容问题，我们可以安全地使用它们： 老代码仍然能正常工作，即使对nonnull对象使用了nil也没有问题。 老代码在需要和swift混编时，在新的swift编译器下会给出一个警告。 nonnull不会影响性能。事实上，我们仍然可以在运行时去判断我们的对象是否为nil。 事实上，我们可以将nonnull/nullable与我们的断言和异常一起看待，其需要处理的问题都是同一个：违反约定是一个程序员的错误。特别是，返回值是我们可控的东西，如果返回值是nonnull的，则我们不应该返回nil，除非是为了向后兼容。 Lightweight GenericsLightweight Generics 轻量级泛型，轻量是因为这是个纯编译器的语法支持（LLVM 7.0），和 Nullability 一样，没有借助任何 objc runtime 的升级，也就是说，这个新语法在 Xcode 7 上可以使用且完全向下兼容（更低的 iOS 版本） 带泛型的容器这无疑是本次最重大的改进，有了泛型后终于可以指定容器类中对象的类型了： 12NSArray&lt;NSString *&gt; *strings = @[@&quot;sun&quot;, @&quot;yuan&quot;];NSDictionary&lt;NSString *, NSNumber *&gt; *mapping = @&#123;@&quot;a&quot;: @1, @&quot;b&quot;: @2&#125;; 返回值的 id 被替换成具体的类型后，令人感动的代码提示也出来了。 假如向泛型容器中加入错误的对象，编译器会不开心的。 系统中常用的一系列容器类型都增加了泛型支持，甚至连 NSEnumerator 都支持了，这是非常 Nice 的改进。和 Nullability 一样，我认为最大的意义还是丰富了接口描述信息，对比下面两种写法： 12@property (readonly) NSArray *imageURLs;@property (readonly) NSArray&lt;NSURL *&gt; *imageURLs; 不用多想就清楚下面的数组中存的是什么，避免了 NSString 和 NSURL 的混乱。 自定义泛型类比起使用系统的泛型容器，更好玩的是自定义一个泛型类，目前这里还没什么文档，但拦不住我们写测试代码，假设我们要自定义一个 Stack 容器类： 12345@interface Stack&lt;ObjectType&gt; : NSObject- (void)pushObject:(ObjectType)object;- (ObjectType)popObject;@property (nonatomic, readonly) NSArray&lt;ObjectType&gt; *allObjects;@end 这个 ObjectType 是传入类型的 placeholder，它只能在 @interface 上定义（类声明、类扩展、Category），如果你喜欢用 T 表示也 OK，这个类型在 @interface 和 @end 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型，应该说一切都是符合预期的。我们还可以给 ObjectType 增加类型限制，比如： 1234// 只接受 NSNumber * 的泛型@interface Stack&lt;ObjectType: NSNumber *&gt; : NSObject// 只接受满足 NSCopying 协议的泛型@interface Stack&lt;ObjectType: id&lt;NSCopying&gt;&gt; : NSObject 若什么都不加，表示接受任意类型 ( id )；当类型不满足时编译器将产生 error。实例化一个 Stack，一切工作正常： 对于多参数的泛型，用逗号隔开，其他都一样，可以参考 NSDictionary 的头文件。 协变性和逆变性当类支持泛型后，它们的 Type 发生了变化，比如下面三个对象看上去都是 Stack，但实际上属于三个 Type： 123Stack *stack; // Stack *Stack&lt;NSString *&gt; *stringStack; // Stack&lt;NSString *&gt;Stack&lt;NSMutableString *&gt; *mutableStringStack; // Stack&lt;NSMutableString *&gt; 当其中两种类型做类型转化时，编译器需要知道哪些转化是允许的，哪些是禁止的，比如，默认情况下： 12345678910Stack *stack;Stack&lt;NSString *&gt; *stringStack;Stack&lt;NSMutableString *&gt; *mutableStringStack; stack = stringStack;stack = mutableStringStack;stringStack = stack;stringStack = mutableStringStack;mutableStringStack = stack;mutableStringStack = stringStack 在Xcode中我们可以看到，不指定泛型类型的 Stack 可以和任意泛型类型转化，但指定了泛型类型后，两个不同类型间是不可以强转的，假如你希望主动控制转化关系，就需要使用泛型的协变性和逆变性修饰符了： 12__covariant - 协变性，子类型可以强转到父类型（里氏替换原则）__contravariant - 逆变性，父类型可以强转到子类型（WTF） 协变1@interface Stack&lt;__covariant ObjectType&gt; : NSObject 逆变1@interface Stack&lt;__contravariant ObjectType&gt; : NSObject 协变是非常好理解的，像 NSArray 的泛型就用了协变的修饰符。 __kindof__kindof 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 UITableView 的这个方法来说：1- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier; 使用时前面基本会使用 UITableViewCell 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 UITableViewCell 或 UITableViewCell 子类的实例，于是新的 __kindof 关键字解决了这个问题： 1- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier; 既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView 的 subviews 属性被修改成了： 1@property (nonatomic, readonly, copy) NSArray&lt;__kindof UIView *&gt; *subviews; 这样，写下面的代码时就没有任何警告了： 1UIButton *button = view.subviews.lastObject; NS_ENUM &amp; NS_OPTIONS枚举是指将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。 枚举本质上是一个整数，枚举的作用是把值限定在指定的范围内，并且增加代码的可读性。 枚举的成员如果没有显示指定值，那么第一个成员的值总是0，后面成员的值依次递增。枚举可以直接用于比较。 一般我们声明枚举： 123456789#import &lt;Foundation/Foundation.h&gt;// 声明枚举类型enum Direction &#123;up, down, left = 10, right&#125;;int main(int argc, const char * argv[])&#123; ...&#125;其中up = 0, down = 1, left = 10, right = 11。 我们会发现枚举中一些不可自定义的部分，例如，枚举名。 NS_ENUM 和 NS_OPTIONS 都不算太古老的宏，在iOS 6 / OS X Mountain Lion才开始有，它们都是代替 enum 的更好的办法。 NS_ENUM如果要在早期的iOS或OS X系统中使用这两个宏，简单定义一下就好 123#ifndef NS_ENUM#define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type#endif 在OS X 10.4 中的原始定义如下： 12#define NS_ENUM(_type, _name) CF_ENUM(_type, _name)#define NS_OPTIONS(_type, _name) CF_OPTIONS(_type, _name) 在之前枚举可以这么定义： 123456typedef enum &#123; UITableViewCellStyleDefault, UITableViewCellStyleValue1, UITableViewCellStyleValue2, UITableViewCellStyleSubtitle&#125;; 或者 1typedef NSInteger UITableViewCellStyle; 现在，有了统一的风格 123456typedef NS_ENUM(NSInteger, UITableViewCellSelectionStyle) &#123; UITableViewCellSelectionStyleNone, UITableViewCellSelectionStyleBlue, UITableViewCellSelectionStyleGray, UITableViewCellSelectionStyleDefault&#125;; NS_ENUM 的第一个参数是用于存储的新类型的类型。在64位环境下，UITableViewCellStyle 和 NSInteger 一样有8 bytes长。你要保证你给出的所有值能被该类型容纳，否则就会产生错误。第二个参数是新类型的名字。大括号里面和以前一样，是你要定义的各种值。 NS_OPTIONS语法和 NS_ENUM 完全相同，但这个宏提示编译器值是如何通过位掩码 | 组合在一起的。 123456typedef NS_OPTIONS(NSUInteger, AMGResizing) &#123; AMGResizingNone = 0, AMGResizingFlexibleWidth = 1 &lt;&lt; 0, AMGResizingFlexibleHeight = 1 &lt;&lt; 1, AMGResizingFlexibleUnicorn = 1 &lt;&lt; 2&#125;; attribute((always_inline))我们知道一般的函数调用都会通过call的方式来调用，这样让攻击很容易对一个函数做手脚，如果是以inline的方式编译的会，会把该函数的code拷贝到每次调用该函数的地方。而static会让生成的二进制文件中没有清晰的符号表，让逆向的人很难弄清楚逻辑。 __attribute__((always_inline)) 的意思是强制内联，所有加了__attribute__((always_inline)) 的函数再被调用时不会被编译成函数调用而是直接扩展到调用函数体内，比如定义了函数__attribute__((always_inline)) void a()和 123void b()｛ a();｝ b 调用 a 函数的汇编代码不会是跳转到a执行，而是 a 函数的代码直接在 b 内成为 b 的一部分。#define __inline __attribute__((always_inline)) 的意思就是用__inline 代替__attribute__((always_inline))内声明a的时候可以直接写成__inline void a() 这样比较方便因为__attribute__((always_inline)) 字多。 undef这是预编译指令，和#define搭配使用，意思是取消之前的宏定义。 123456789101112#define PROC_ADD void main(void) &#123;#ifdef PROC_ADD // Do this code here then undefined it to run the code in the else // processing work #undef PROC_ADD #else // now that PROC_ADD has been undefined run this code // processing work #endif &#125; __unsafe_unretained__unsafe_unretained是对对象的非zeroing的weak reference，意思是当对象所指向的内存被销毁了，对象还存在，称为“野指针”。 在iOS引入了Automatic Reference Count（ARC）之后，编译器可以在编译时对obj-c对象进行内存管理。大致规则如下： 12345alloc的要release;retain/copy的要release;NSAutoreleasePool在ARC中被禁止使用,替换成@autoreleasepool 函数体;使用@ autoreleasepool,在函数入口的时候,autorelease pool入栈,正常退出时,autorelease pool出栈,从而释放变量.注意:@ autoreleasepool在非ARC模式下,也能使用,并据说使用@autoreleasepool比使用NSAutoreleasePool速度能快6倍, 明显提升程序性能. @package为了强制一个对象隐藏其数据，编译器限制实例变量范围以限制其在程序中的可见性，但是为了提供灵活性，苹果也让开发者显式设置范围。 以下是这些关键字的使用范围： @private The instance variable is accessible only within the class that declares it. 实例变量只能被声明它的类访问. @protected The instance variable is accessible within the class that declares it and within classes that inherit it. All instance variables without an explicit scope directive have @protected scope. 实例变量能被声明它的类和子类访问，所有没有显式制定范围的实例变量都是. @public The instance variable is accessible everywhere. 实例变量可以被在任何地方访问. @package Using the modern runtime, an @package instance variable has @public scope inside the executable image that implements the class, but acts like @private outside.使用modern运行时，一个@package实例变量在实现这个类的可执行文件镜像中实际上是@public的，但是在外面就是@private【runtime需要再看一下苹果文档Runtime Programming Guide】 The @package scope for Objective-C instance variables is analogous to private_extern for C variables and functions. Any code outside the class implementation’s image that tries to use the instance variable gets a link error. Objective-C中的@package与C语言中变量和函数的private_extern类似。任何在实现类的镜像之外的代码想使用这个实例变量都会引发link error This scope is most useful for instance variables in framework classes, where @private may be too restrictive but @protected or @public too permissive. 这个类型最常用于框架类的实例变量，使用@private太限制，使用@protected或者@public又太开放. |]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 并发概念浅析]]></title>
      <url>%2F2016%2F05%2F26%2Fios-simultaneously%2F</url>
      <content type="text"><![CDATA[摘要：并发（concurrency）是一个常用且较好的解决APP的流畅度方法，但并发涉及串行、并发、并行、同步、异步、多线程、GCD、NSOperation和NSOperationQueue等诸多容易混淆的概念。本文主要分享对一些易混淆概念的理解。 前言在进行iOS开发过程中，我们常会遇到网络请求、复杂计算、数据存取等比较耗时的操作，如果处理不合理，将对APP的流畅度产生较大影响。除了优化APP架构，并发（concurrency）是一个常用且较好的解决方法，但并发涉及串行、并发、并行、同步、异步、多线程、GCD、NSOperation和NSOperationQueue等诸多容易混淆的概念。接下来，主要分享对一些易混淆概念的理解。 一、线程和任务线程（thread） 和任务（task）是其他并发概念的基础，因此也是首要需理清的概念，以下是其要点，详细可参考Thread (computing)和Task (computing)。 1）任务（task）a）任务（task）是从程序中划分出来，可以独立执行的代码片段； b）任务间可以添加依赖关系，如B任务依赖A任务，taskB.addDependency(taskA)，这意味着B任务的执行以A任务完成为前提。 需要注意的是一个任务是否可以添加依赖，完全取决于任务封装类和其相关管理类的具体实现，GCD不支持任务依赖，NSOperationQueue就支持任务依赖。 下面的代码是对一个任务的简单封装，并支持任务间的依赖。 12345678910111213141516171819202122//Task是一个任务的简单封装类class Task &#123; let taskBlock: () -&gt; () var dependencies = [Task]() init(block: () -&gt; ()) &#123; taskBlock = block &#125; func addDependency(task: Task) &#123; dependencies.append(task) &#125;&#125;//初始化两个自定义任务var taskA = Task()&#123; //自定义任务A，自定义需要执行的代码 //...&#125;var taskB = Task()&#123; //自定义任务B，自定义需要执行的代码 //...&#125;//添加依赖关系taskB.addDependency(taskA) 2）线程（thread）a）线程（thread）是代码执行的独立路径，一条线程只能同时执行一行代码（一行代码，其实就是一条处理器命令）。 b）线程中代码管理是以任务（task）为单位，一条线程逐行执行一个任务中的代码（任务可以取消），完成后再逐行执行下一个任务中的代码。 c）一条线程跳出一个任务的执行，即意味着这个任务的完成。因此，一条线程不能执行taskA一段时间后，还未完成就开始执行taskB，然后又返回执行taskA（这其实是单线程内的并发，与单核处理器的并发概念相同，具体实践中不存在线程内并发）。 二、概念释疑1）并行（parallelism）和并发（concurrency）并发和并行都是指多个任务可以同时执行，都属于多线程编程概念，因此二者必然十分相近，容易混淆。二者区别只有一点，即是否多任务执行于严格的同一时刻。并发不是，而并行是。 单核处理器时代（一个处理器同一时刻只能执行一条命令），为了实现多任务的同时执行，系统利用时间分片（time-slicing）技术，将处理器的执行时间切分为多个小片段，一会执行threadA，一会执行threadB，一会再执行threadA，即在多个线程（任务是在线程上执行的）之间来回跳动执行。虽不是真的多线程多任务同时执行，但由于处理器的处理速度非常快，在用户看来，仍然是同时执行的。这种伪多线程就是并发。 多核处理器时代（不同处理器相互独立，可以同时执行各自的命令），多条线程完全可以严格同一时刻执行，这种真多线程就是并行。 1234//三个线程的并发thread1 -&gt; |---A---| -&gt;|---A---|thread2 ------&gt; -&gt;|------B----|thread3 ------------------------------------&gt; |------C------| 上述代码是三个线程的并发执行，可以看出thread1、thread2和thread3不可能严格同一时刻执行，但也都获得了处理器的一小段执行时间。 1234//三个线程的并行thread1 -&gt; |-----A-----|thread2 -&gt; |------B----|thread3 -&gt; |------C------| 上述代码是三个线程的并行执行，可以看出thread1、thread2和thread3有一段时间同时执行。 现在的终端设备无论是手机还是PC的处理器，大多都已是多核处理器，可以实现并行计算，但为了最大化的利用处理器的性能，现代处理器还是融合了time-slicing技术和多核技术，因此实际运行中，有时并发，有时并行。但相对来说，并发是个更广泛的概念，因此Apple的多线程编程叫做concurrency programming并发编程。汉语中，并发和并行的区别其实没那么清晰，可以互用，而且有时用并行更加明确，如串并行比串行、并发针对性更强。（为概念清晰起见，下文中有时会用并行，其实即是并发。） 2）串并行与线程串行（serial）和并行串行和并行主要区别在于一个任务的执行是否以上一个任务的完成为前提。串行中，一个任务的执行必须以上一个任务执行结束为前提；并行中，一个任务的执行与上一个任务的执行状态无关。以排队买票为例，串行像单个买票队伍，单个卖票窗口，必须一个一个来；串行像单个买票队伍，多个卖票窗口，多个人可以同时买票。 12//三个串行任务|-----A-----||------B--------||----C--| 上文为三个串行任务，任务A完成后，才执行任务B，B结束后，才最后执行任务C。 1234//三个并发任务|-----A-----| |------B----| |--C---| 上文为三个并行任务，任务A早于任务C开始，却晚于任务C结束。 串并行与线程串并行主要关注多个任务之间的相互依赖关系，与线程无关。但实际中，任务是在线程中执行的，是否串行一定在单线程上执行，并行一定在多个线程中执行呢？并非如此。 单线程既可以实现串行，也可以实现并行。 12345678//单线程串行1 thread -&gt; |----A-----||-----B-----------||-------C------|//单线程并行（理论上，实际中不可行） A-Start ---------------------------------------- A-End | B-Start ----------------------------------------|--- B-End | | C-Start -------------------- C-End | | V V V V V V 1 thread-&gt; |-A-|---B---|-C-|-A-|-C-|--A--|-B-|--C--|---A-----|--B--| 需要指出的是单线程内的并行已经类似单核处理器，并不是本文提及的常规线程，现实中也不常见。 多线程既可以实现串行，也可以实现并行，实际上，多线程串行和并行都很常见。 12345678910//多线程串行thread1 -&gt; |----A-----| \ thread2 ---------------&gt;|-----B-----------| \ thread3 -----------------------------------&gt;|-------C------|//多线程并发thread1 -&gt; |----A-----|thread2 -----&gt; |-----B-----------|thread3 ---------&gt; |-------C----------| 3）同步（synchronize）、异步（asynchronous）与线程同步和异步是站在当前线程的角度，考察添加任务到新线程后，何时返回到当前线程执行下面的代码的问题，也即新添加的线程阻不阻塞当前线程。 同步 12345678910override viewDidLoad() &#123; super.viewDidLoad() let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) dispatch_sync(queue) &#123; //block1 print(&quot;-----1-----&quot;) //1 return &#125; print(&quot;-----2-----&quot;) //2&#125; block1是添加到系统全局队列中的新任务，由于是同步的，因此block1执行返回后，才会回到当前主线程，执行//2及以后的代码。输出结果为： 12-----1----------2----- 异步 1234567891011//viewDidLoad()在主线程中执行，因此当前线程为主线程override viewDidLoad() &#123; super.viewDidLoad() let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) dispatch_async(queue) &#123; //block1 print(&quot;-----1-----&quot;) //1 return &#125; print(&quot;-----2-----&quot;) //2&#125; block1是添加到系统全局队列中的新任务，由于是异步的，因此block1添加全局队列后（会在另外一个线程上执行），不等到执行完成，就会返回到当前主线程，执行//2及以后的代码，所以输出结果可能为 21 12。但由于block1和主线程中的任务都是不耗时的简单任务，而创建新的线程是要消耗一定时间的（主线程一直存在，不用新创建），因此很可能的输出结果是： 12-----2----------1----- 同异步结合的情形 如果同异步结合: 123456789101112131415161718//viewDidLoad()在主线程中执行，因此当前线程为主线程override viewDidLoad() &#123; super.viewDidLoad() let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) dispatch_async(queue) &#123; //block1 print(&quot;-----A-----&quot;) //1 dispatch_async(dispatch_get_main_queue()) &#123; //block2 print(&quot;-----B-----&quot;) //2 &#125; print(&quot;-----C-----&quot;) //3 return &#125; print(&quot;-----D-----&quot;) //4 while(true) &#123; &#125; //5 print(&quot;-----E-----&quot;) //6&#125; block1是添加到系统全局队列中的新任务，由于是异步的，因此block1添加全局队列后（会在另外一个线程上执行），不等到执行完成，就返回到当前主线程，执行//4及以后的代码，结果是block1所在的线程与主线程同时执行，因此理论上，D和A谁先输出不一定。但由于block1和主线程中的任务都是不耗时的简单任务，而创建新的线程是要消耗一定时间的（主线程一直存在，不用新创建），因此一般输出结果为DA。 block1所在线程输出完A后，将block2添加到主调度队列中，由于是异步的，因此block2添加主调度队列后（会在主线程上执行），不等到执行完成，就返回到block2所在的线程，继续执行，因此A和C一定会输出，且C一定在A之后输出。但block2却不一定能执行，因为block1在执行时，主线程也在执行（主线程是串行单线程，任务按顺序一个一个执行），如果此时主线程执行到//5对应的死循环，则block2一定不能被执行，B一定不能被输出，如果此时主线程尚未执行到//5对应的死循环，block2已经添加到主线程中，则block2会被执行，B能被输出。但由于主线程无需另外创建，block1（所对应的线程需另外创建）执行到添加block2到主调度队列时，主线程很可能已经执行到//5对应的死循环，因此block2很可能不被执行。 //6前有个死循环，因此E一定不会被输出。 因此可能的输出结果是；DAC ADC ADCB DACB ACDB ACBD ABDC ABCD 但很可能的输出结果为： 123-----D----------A----------C----- 4）同异步与串并行串行和同步，并行和异步似是完全不同的概念，一个关注任务的独立关系，一个看中的是返回的时机。但事实上，串行和同步近似，并发和异步相同，他们指代的事情几乎完全相同。就同步和串行而言，需要任务执行结束后才能返回，其实就是一个任务执行完成后，才能执行其他的任务，反应的就是串行依赖关系。 而异步和并行就更相同了，不等任务执行完成，就直接返回，反应的就是并发任务之间的独立性。 当然，同异步所暗含的串行和并行是当前线程的任务与新线程的任务之间的相互关系。 三、GCD与NSOperationQueueGCD(grand central dispatch)和NSOperationQueue二者均是系统级的多线程封装，在使用时，我们只需创建任务队列即可，其他的如线程创立、任务分配等，均由系统自动处理。不得不说，这让多线程编程变得更高效，更简单，当然并不是没有坑。需要强调的是，GCD和NSOperationQueue的使用核心是任务（task）和任务队列（task queue），暂时可以忘了线程（thread）这烦人的概念。 关于GCD和NSOperationQueue网上已经有不少高质量的文章对其详细介绍，推荐《iOS并行开发：从NSOperation和调度队列开始》，其对基本概念、使用方法等的介绍非常清晰详尽，这里就不再赘述，只写一些个人认为容易忽略却影响认知深度的小知识点。当然如果你英语过硬，去直接看官方文档《ConcurrencyProgrammingGuide》是最好的。 1）GCDGCD是基于C的API，因此比较底层。 GCD所管理的调度队列（dispatch queue）主要有三类：串行队列（private dispatch queue）、并发队列 （global dispatch queue，又称全局调度队列）和主队列（main dispatch queue）。 我们常用的 dispatch_get_globalqueue(: _:)所获得的dispatch queue就是全局调度队列(global dispatch queue)，并发，而且全局调度队列是全局共用的，每一个优先级的全局调度队列只有一个实体。四种不同优先级的全局调度队列对应的四种优先级的线程，同一个优先级的全局调度队列可以同时拥有多条相应优先级的线程。 dispatch_get_main_queue()所获得的dispatch queue是主调度队列，主调度队列是串行队列。 2）NSOperationQueueNSOperationQueue是对GCD的Objective-C封装，相对于GCD具有更多先进的特性，如可以添加NSOperation依赖，取消NSOperation等。 NSOperationQueue是并发队列，且不遵循先进先出（FIFO）排序原则。 四、总结与感悟1）串并行、同异步与线程无关，单线程、多线程都可以实现串并行和同异步。 2）串行和同步相同，异步和并行相同，他们只是看待同一件事物的角度不同。 3）GCD和NSOperationQueue的使用核心是任务（task）和任务队列（task queue）。 4）全局调度队列(global dispatch queue)是全局共用的，系统有时也会向这些调度队列添加系统任务。 5) App的主调度队列是串行单线程队列。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitHub 使用]]></title>
      <url>%2F2016%2F05%2F20%2Fgithub-using%2F</url>
      <content type="text"><![CDATA[摘要：GitHub就是程序员的facebook，在这个开源、大神云集的地方，小菜是可以学到，找到很多很棒的资源的。那么，如何进入这个圈子呢？我们从使用开始。这篇文章主要讲解如何使用GitHub托管自己的代码，注意，托管是公开的喔，私有的要付费的。 下载github客户端软件 官网下载 Google搜索，一般用于windows7以前的系统 安装github软件根据软件安装指导，按步骤安装即可。 使用git命令提交git config安装Git后首先要做的事情是设置用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中： 12git config --global user.name &quot;Chars Davy&quot;git config --global user.email chars_d@example.com 重申一遍，只需要做一次这个设置。如果传递了 --global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要--global选项。 git clone这是一种较为简单的初始化方式，当你已经有一个远程的Git版本库，只需要在本地克隆一份: 1git clone git://github.com/someone/some_project.git some_project 上面的命令就是将git://github.com/someone/some_project.git这个URL地址的远程版本库，完全克隆到本地some_project目录下。 git init 和 git remote这种方式稍微复杂一些，当你本地创建了一个工作目录，你可以进入这个目录，使用git init命令进行初始化；Git以后就会对该目录下的文件进行版本控制，这时候如果你需要将它放到远程服务器上，可以在远程服务器上创建一个目录，并把可访问的URL记录下来，此时你就可以利用git remote add命令来增加一个远程服务器端， 1git remote add origin git://github.com/someone/another_project.git 上面的命令就会增加URL地址为git: //github.com/someone/another_project.git，名称为origin的远程服务器，以后提交代码的时候只需要使用 origin别名即可。 git add将当前更改或者新增的文件加入到Git的索引中，加入到Git的索引中就表示记入了版本历史中，这也是提交之前所需要执行的一步， 1git add app/model/user.rb 就会增加app/model/user.rb文件到Git的索引中，该功能类似于SVN的add， 1git add . 上面的命令会将所有改动过的文件及文件夹迭代全部添加进本地代码仓库。 git commit提交当前工作空间的修改内容，类似于SVN的commit命令， 1git commit -m story #3, add user model 提交的时候必须用-m来输入一条提交信息，该功能类似于SVN的commit， 1git commit –m beta 上面的命令会将beta作为log显示在代码提交记录中。 git push将本地commit的代码更新到远程版本库中， 1git push origin 上面的命令就会将本地的代码更新到名为orgin的远程版本库中。 git代码提交中可能遇到的问题问题1： 12You can&apos;t push to git://github.com/example/example_pro.gitUse https://github.com/ example/example_pro.git 解决办法： 123git remote remove origingit remote add origin git@github.com:user_name/user_repo.gitgit push origin 原因： 如果在git clone的时候用的是git://github.com:xx/xxx.git 的形式, 那么就会出现这个问题，因为这个protocol是不支持push的，而使用git clone git@github.com:lujinjianst/myNCCL.git就可以用git push。 问题2： 12Permission denied(publickey).fatal:Could not read from remote repository. 解决办法： 在终端输入: 1ssh-keygen -t rsa -C &quot;chars&quot;//注意,chars为用户名 如果执行成功。返回: 12Generating public/private rsa key pair. Enter file in which to save the key (/home/forwhat.cn/.ssh/id_rsa): 在这里就是设置存储地址了.反正我是直接按的回车,然后还会返回: 1Enter passphrase (empty for no passphrase): 再次直接回车。 1Enter same passphrase again: 再次回车。 123Your identification has been saved in /home/forwhat.cn/.ssh/id_rsa. Your public key has been saved in /home/forwhat.cn/.ssh/id_rsa.pub. The key fingerprint is: 123456789101112The key&apos;s randomart image is: +--[ RSA 2048]----+ | | | | | | | o | | + . S | | . = . o | | o + +o.o | |E o . o.=+. | |.+ ==+ooo. | +-----------------+ 这样SSH key就生成了。直接cat一下就好了。 1:~/a$ cat /home/forwhat.cn/.ssh/id_rsa.pub 把显示出来的直接添加到github账户设置里边的SSH keys。回来再git pull就开始远程拷贝代码了。 原因： 没有在github账号添加SSH key。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flappy bird 游戏实现]]></title>
      <url>%2F2016%2F05%2F05%2Fflappy-bird-game%2F</url>
      <content type="text"><![CDATA[摘要：在博主还是学生的时候，flappyBird这款游戏非常火爆，最后等到Android版的出来之后，也是很痴迷的玩了一把。可是，博主游戏天赋一直平平，几度玩得想摔手机。本文主要介绍如何开发iOS平台的flappyBird，游戏中使用了原本软件的图片资源，仅作学习交流使用。博主实现的flappyBird游戏包含游戏等级设定，排行榜，音效等功能。 技术点flappyBird是单机游戏，主要涉及界面逻辑、图片资源、游戏动画、得分排行。 为了实现这几个功能，需要使用以下几个技术框架： AVFoundation 归档 模态视图 NSTimer 视图控件，包括UIImageView、UILabel、UITableView等 实现过程1、创建工程 1）打开Xcode，点击新建工程，选择Single View Application模板 2）填写工程信息 2、移除Main.storyboard文件 上图是flappyBird的文件目录，因为Xcode6使用模板创建工程时会自动生成Main.storyboard文件，而工程中本人使用代码布局，所以可以移除Main.storyboard文件。具体操作方法可以参看本人另一篇文章：《iOS学习之移除Main.storyboard》 3、游戏界面布局整体效果图如下 需要说明的是，Game Over这个界面，首先需要隐藏或者等到游戏结束才创建。本人是选择在游戏判定结束时才创建并显示。 4、游戏运行这款游戏的两个关键点： 使用定时器驱动游戏界面运行，即游戏界面中的柱子高低变化与柱子的消失与产生。 游戏结束的判定，这里涉及两个问题，一是碰撞检测，二是计分统计。 具体实现部分代码1、计分统计 123456-(void)columnLabelClick &#123; if (topPipeFrame.origin.x == (100 + 30 - 70)) &#123; columnNumber++; columnLabel.text = [NSString stringWithFormat:@&quot;%zi&quot;,columnNumber]; &#125;&#125; 2、绘制柱子 12345678910111213141516171819202122232425262728-(void)pipe &#123; //通道高度 NSInteger tunnelHeight = 0; //根据游戏难度设定通道高度 if([[DataTool stringForKey:kRateKey] isEqualToString:@&quot;ordinary&quot;]) &#123; tunnelHeight = 100; &#125;else if([[DataTool stringForKey:kRateKey] isEqualToString:@&quot;general&quot;]) &#123; tunnelHeight = 90; &#125;else if([[DataTool stringForKey:kRateKey] isEqualToString:@&quot;difficult&quot;]) &#123; tunnelHeight = 80; &#125;else if([[DataTool stringForKey:kRateKey] isEqualToString:@&quot;hard&quot;]) &#123; tunnelHeight = 75; &#125; else if([[DataTool stringForKey:kRateKey] isEqualToString:@&quot;crazy&quot;]) &#123; tunnelHeight = 70; &#125; //柱子图像 NSInteger tall = arc4random() % 200 + 40; topPipe = [[UIImageView alloc]initWithFrame:CGRectMake(320, -20, 70, tall)]; topPipe.image = [UIImage imageNamed:@&quot;pipe&quot;]; [self.view addSubview:topPipe]; bottomPipe = [[UIImageView alloc]initWithFrame:CGRectMake(320, tall + tunnelHeight, 70, 400)]; bottomPipe.image = [UIImage imageNamed:@&quot;pipe&quot;]; [self.view addSubview:bottomPipe]; //把底部图片视图放在柱子视图上面 [self.view insertSubview:roadView aboveSubview:bottomPipe];&#125; 3、使用定时器，驱动游戏界面运行，并进行碰撞检测 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//添加定时器timer = [NSTimer scheduledTimerWithTimeInterval:0.01 target:self selector:@selector(onTimer) userInfo:nil repeats:YES];//定时器操作-(void)onTimer &#123; //底部动画移动 CGRect frame = roadView.frame; if (frame.origin.x == -15) &#123; frame.origin.x = 0; &#125; frame.origin.x--; roadView.frame = frame; //上升 if (isTap == NO) &#123; CGRect frame = birdsView.frame; frame.origin.y -= 3; number += 3; birdsView.frame = frame; if (number &gt;= 60) &#123; isTap = YES; &#125; &#125; //下降 if(isTap == YES &amp;&amp; birdsView.frame.origin.y &lt; 370)&#123; CGRect frame = birdsView.frame; frame.origin.y++; number -= 2; birdsView.frame = frame; number = 0; &#125; //柱子移动 topPipeFrame = topPipe.frame; CGRect bottomPipeFrame = bottomPipe.frame; topPipeFrame.origin.x--; bottomPipeFrame.origin.x--; topPipe.frame = topPipeFrame; bottomPipe.frame = bottomPipeFrame; if (topPipeFrame.origin.x &lt; -70) &#123; [self pipe]; &#125; //碰撞检测（交集） bool topRet = CGRectIntersectsRect(birdsView.frame, topPipe.frame); bool bottomRet = CGRectIntersectsRect(birdsView.frame, bottomPipe.frame); if (topRet == true || bottomRet == true) &#123; [self.soundTool playSoundByFileName:@&quot;punch&quot;]; [self onStop]; &#125; if (topPipeFrame.origin.x == (100 + 30 - 70)) &#123; [self.soundTool playSoundByFileName:@&quot;pipe&quot;]; [self columnLabelClick]; &#125;&#125; 4、更新分数，更新最佳分数与排行榜分数，并使用归档将数据持久化 123456789101112131415161718192021222324252627282930-(void)updateScore &#123; //更新最佳成绩 if (columnNumber &gt; [DataTool integerForKey:kBestScoreKey]) &#123; [DataTool setInteger:columnNumber forKey:kBestScoreKey]; &#125; //更新本局分数 [DataTool setInteger:columnNumber forKey:kCurrentScoreKey]; //更新排行榜 NSArray *ranks = (NSArray *)[DataTool objectForKey:kRankKey]; NSMutableArray *newRanksM = [NSMutableArray array]; NSInteger count = ranks.count; BOOL isUpdate = NO; for (NSInteger i = 0; i &lt; count; i++) &#123; NSString *scoreStr = ranks[i]; NSInteger score = [scoreStr integerValue]; if (score &lt; columnNumber &amp;&amp; isUpdate == NO) &#123; scoreStr = [NSString stringWithFormat:@&quot;%zi&quot;, columnNumber]; [newRanksM addObject:scoreStr]; isUpdate = YES; i--; &#125; else &#123; scoreStr = [NSString stringWithFormat:@&quot;%zi&quot;, score]; [newRanksM addObject:scoreStr]; &#125; &#125; if (newRanksM.count &gt; count) &#123; [newRanksM removeLastObject]; &#125; [DataTool setObject:newRanksM forKey:kRankKey];&#125; 5、绘制GameOver提示显示 123456-(void)pullGameOver &#123; //游戏结束操作界面 gameOver = [[GameOverView alloc] initWithFrame:CGRectMake(20, 160, 280, 300)]; gameOver.delegate = self; [self.view addSubview:gameOver];&#125; 6、游戏停止操作 12345678-(void)onStop &#123; //更新分数 [self updateScore]; //停止定时器 [timer setFireDate:[NSDate distantFuture]]; //弹出游戏结束操作界面 [self pullGameOver];&#125; 小结这款游戏的实现还是很简单的，主要使用UIImageView自带的动画实现方式，即可实现bird的动画效果。使用NSTimer即可实现游戏场景的柱子移动，至于柱子的高度，则可以使用随机数方式在一定范围内实现高低变化。最后可以使用CGRectIntersectsRect来实现边界碰撞检测来判定游戏是否结束。 以上是博主开发iOS版flappyBird的简要过程介绍，其中只包含了关键点的代码实现，具体完整游戏源代码地址：https://github.com/CharsDavy/flappyBird]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[均匀分布随机函数的实现]]></title>
      <url>%2F2016%2F04%2F30%2Funiform-random%2F</url>
      <content type="text"><![CDATA[摘要：随机函数可以说是用途很广。可是，系统提供的random函数，一般符合正态分布，所以说，这是伪随机函数。甚至在一些场合是非随机函数。为了满足项目需要，必须实现均匀分布。在此，分享博主实现均匀随机函数的实现过程与方法。 前言随机函数就是产生数的函数，C语言里使用rand(),srand()等随机函数实现随机数生成。 函数简介1int rand( void ); 返回的是一个界于0～32767（0x7FFF）之间的伪随机数，包括0和32767。C预先生成一组随机数，每次调用随机函数时从指针所指向的位置开始取值，因此使用rand()重复运行程序产生的随机数都是相同的，可以通过srand()函数来改变指针位置。srand()会设置供rand()使用的随机数种子。如果在第一次使用rand()之前没有调用srand()，那么系统会自动调用srand()。而使用同种子相同的数调用 rand()会导致相同的随机数序列被生成。 1void srand( unsigned int seed ); 改变随机数表的指针位置（用seed变量控制）。使用系统定时/计数器的值作为随机种子。每个种子对应一组根据算法预先生成的随机数，所以，在相同的平台环境下，不同时间产生的随机数会是不同的，相应的，若将srand（unsigned）time(NULL)改为srand(TP)（TP为任一常量），则无论何时运行、运行多少次得到的“随机数”都会是一组固定的序列，因此srand生成的随机数是伪随机数。一般配合time(NULL)使用，因为时间每时每刻都在改变，产生的seed值都不同。 场景使用rand函数生成的随机数严格满足正态分布。而在很多时候，我们希望随机数的生成不要满足正态分布，特别是在处理网络通信报文的时候。例如，我们需要在交换机处理到海量报文时，能够使远端的从设备尽可能的分段同时向局端回应报文，以减轻局部报文处理压力。 均匀分布随机函数实现开发环境 实现步骤1）打开Qt Creater，创建GUI工程 2）在mainwindow.h中添加函数声明 1void paintEvent(QPaintEvent *); 3）在mainwindow.cpp中添加函数实现 导入头文件 1#include &lt;QPainter&gt; 实现void paintEvent(QPaintEvent *)函数 12345678910111213141516171819202122232425/* *Qt中函数paintEvent(QPaintEvent*)是被系统自动调用。 *paintEvent(QPaintEvent *)函数是QWidget类中的虚函数，用于ui的绘制，会在多种情况下被其他函数自动调用。*/void MainWindow::paintEvent(QPaintEvent *)&#123; QPainter painter(this); QPen pen; //画笔 pen.setColor(QColor(255,0,0)); //设置画笔颜色 painter.setPen(pen); //添加画笔 long int r[kSum] = &#123;0&#125;; int i = 0; int j = 0; do&#123; r[i] = Uniform(0, 300); i++; &#125;while(i &lt; kSum); while((j + 30) &lt; (kSum + 30))&#123; painter.drawPoint(j, r[j]); j++; &#125;&#125; 4）添加随机函数实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define kSum 1000//算法一/* *均匀分布随机函数均匀化*/double _uniform(double min, double max, long int *seed) &#123; double t = 0; *seed = 2045 * (*seed) + 1; *seed = *seed - (*seed / 1048576) * 1048576; t = (*seed) / 1048576.0; t = min + (max - min) * t; return t;&#125;/* *均匀分布随机函数产生随机数*/long int Uniform(double min, double max) &#123; long int s = 0; double r = 0; //srand((unsigned int)time(NULL)); /*同一个时间种子可能会从产生相同的随机数列*/ s = rand(); r = _uniform(min, max, &amp;s); return ((long int)r);&#125;//算法二double AverageRandom(double min, double max) &#123; int minInteger = (int)(min * 10000); int maxInteger = (int)(max * 10000); int randInteger = rand() * rand(); int diffInteger = maxInteger - minInteger; int resultInteger = randInteger % diffInteger + minInteger; return (resultInteger/10000.0);&#125; 实现效果 小结从图中可以看出，使用上述函数生成的随机数符合均匀分布。本案例主要使用了Qt的绘图功能，用来直观展示生成随机数的效果。检验随机函数生成随机数的效果。 附录最后附上该算法实现的全部代码： 123456789101112131415161718192021222324//mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;namespace Ui &#123;class MainWindow;&#125;class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: explicit MainWindow(QWidget *parent = 0); ~MainWindow(); void paintEvent(QPaintEvent *);private: Ui::MainWindow *ui;&#125;;#endif // MAINWINDOW_H 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//mainwindow.cpp#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;#include &lt;QPainter&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define kSum 1000MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this);&#125;MainWindow::~MainWindow()&#123; delete ui;&#125;/* *均匀分布随机函数均匀化*/double _uniform(double min, double max, long int *seed) &#123; double t = 0; *seed = 2045 * (*seed) + 1; *seed = *seed - (*seed / 1048576) * 1048576; t = (*seed) / 1048576.0; t = min + (max - min) * t; return t;&#125;/* *均匀分布随机函数产生随机数*/long int Uniform(double min, double max) &#123; long int s = 0; double r = 0; //srand((unsigned int)time(NULL)); /*同一个时间种子可能会从产生相同的随机数列*/ s = rand(); r = _uniform(min, max, &amp;s); return ((long int)r);&#125;/* *Qt中函数paintEvent(QPaintEvent*)是被系统自动调用。 *paintEvent(QPaintEvent *)函数是QWidget类中的虚函数，用于ui的绘制，会在多种情况下被其他函数自动调用。*/void MainWindow::paintEvent(QPaintEvent *)&#123; QPainter painter(this); QPen pen; //画笔 pen.setColor(QColor(255,0,0)); //设置画笔颜色 painter.setPen(pen); //添加画笔 long int r[kSum] = &#123;0&#125;; int i = 0; int j = 0; do&#123; r[i] = Uniform(0, 300); i++; &#125;while(i &lt; kSum); while((j + 30) &lt; (kSum + 30))&#123; painter.drawPoint(j, r[j]); j++; &#125;&#125; 123456789101112//main.cpp#include &quot;mainwindow.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); MainWindow w; w.show(); return a.exec();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[VFL 语言简介]]></title>
      <url>%2F2016%2F04%2F17%2FVFL-introduction%2F</url>
      <content type="text"><![CDATA[摘要：VFL（Visual Format Language），“可视化格式语言”。VFL是苹果公司为了简化autolayout的编码而推出的抽象语言。本文分享VFL的基本使用方法。 什么是VFL语言VFL（Visual Format Language），“可视化格式语言”。 VFL 是苹果公司为了简化autolayout的编码而推出的抽象语言。 语法说明1234567891011H:[cancelButton(72)]-12-[acceptButton(50)]cancelButton宽72，acceptButton宽50，它们之间间距12 H:[wideView(&gt;=60@700)]wideView宽度大于等于60point，该约束条件优先级为700（优先级最大值为1000，优先级越高的约束条件越先被满足） V:[redBox][yellowBox(==redBox)]垂直方向上，先有一个redBox，其下方紧接一个高度等于redBox高度的yellowBox H:|-10-[Find]-[FindNext]-[FindField(&gt;=20)]-|水平方向上，Find距离父view左边缘间隔10，之后是FindNext距离Find间隔默认宽度；再之后是宽度不小于20的FindField，它和FindNext以及父view右边边缘的间距都是默认宽度。（竖线“|”表示superview的边缘）。 使用方法12345678910使用VFL来创建约束数组+(NSArray *)constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)opts metrics:(NSDictionary *)metrics views:(NSDictionary *)views; format：VFL语句opts：约束类型metrics：VFL语句中用到的具体数值views：VFL语句中用到的控件 创建一个字典（内部包含VFL语句中用到的控件）的快捷宏定义NSDictionaryOfVariableBindings(...) 实例展示效果图如下： 实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950-(void)horizontalLayout&#123; //1.添加两个控件 UIView *blueView = [[UIView alloc] init]; blueView.backgroundColor = [UIColor blueColor]; blueView.translatesAutoresizingMaskIntoConstraints = NO; [self.view addSubview:blueView]; UIView *redView = [[UIView alloc] init]; redView.backgroundColor = [UIColor redColor]; redView.translatesAutoresizingMaskIntoConstraints = NO; [self.view addSubview:redView]; //2.添加约束 //2.1水平方向的约束 NSString *hVFL = @&quot;H:|-30-[blueView]-30-[redView(==blueView)]-30-|&quot;; NSArray *hCons = [NSLayoutConstraint constraintsWithVisualFormat:hVFL options:NSLayoutFormatAlignAllBottom | NSLayoutFormatAlignAllTop metrics:nil views:@&#123;@&quot;blueView&quot;:blueView, @&quot;redView&quot;:redView&#125;]; [self.view addConstraints:hCons]; //2.2垂直方向的约束 NSString *vVFL = @&quot;V:[blueView(50)]-30-|&quot;; NSArray *vCons = [NSLayoutConstraint constraintsWithVisualFormat:vVFL options:0 metrics:nil views:@&#123;@&quot;blueView&quot;:blueView&#125;]; [self.view addConstraints:vCons];&#125;-(void)verticalLayout&#123; //1.添加两个控件 UIView *blueView = [[UIView alloc] init]; blueView.backgroundColor = [UIColor blueColor]; blueView.translatesAutoresizingMaskIntoConstraints = NO; [self.view addSubview:blueView]; UIView *redView = [[UIView alloc] init]; redView.backgroundColor = [UIColor redColor]; redView.translatesAutoresizingMaskIntoConstraints = NO; [self.view addSubview:redView]; //2.添加约束 //2.1水平方向的约束 NSString *hVFL = @&quot;H:|-30-[blueView]-30-|&quot;; NSArray *hCons = [NSLayoutConstraint constraintsWithVisualFormat:hVFL options:0 metrics:nil views:@&#123;@&quot;blueView&quot;:blueView&#125;]; [self.view addConstraints:hCons]; //2.2垂直方向的约束 NSString *vVFL = @&quot;V:|-30-[blueView(50)]-30-[redView(==blueView)]&quot;; NSArray *vCons = [NSLayoutConstraint constraintsWithVisualFormat:vVFL options:NSLayoutFormatAlignAllRight metrics:nil views:@&#123;@&quot;blueView&quot;:blueView, @&quot;redView&quot;:redView&#125;]; [self.view addConstraints:vCons]; NSLayoutConstraint *redLeftCon = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:blueView attribute:NSLayoutAttributeCenterX multiplier:1.0 constant:0]; [self.view addConstraint:redLeftCon];&#125; 小结最后对格式的字符串作一个总结介绍： 功能 表达式 水平方向 H: 垂直方向 V: Views [view] SuperView 竖线符号 关系 &gt;=,==,&lt;= 空间，间隙 - 优先级 @value]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GCD（Grand Central Dispatch）]]></title>
      <url>%2F2016%2F04%2F14%2FGrand-Central-Dispatch%2F</url>
      <content type="text"><![CDATA[摘要：GCD（Grand Central Dispatch），是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如NSThread,NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术。文章分享关于GCD的种种概念以及使用。 前言GCD（Grand Central Dispatch），是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如NSThread,NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术。 GCD 和 block 的配合使用，可以方便地进行多线程编程。 优势1） 苹果官方为多核的并行运算提出的解决方案。 2） 会自动利用更多的CPU内核。 3） 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）。 核心概念1） 任务：执行什么操作。block 2） 队列：用来存放任务。 串行队列：顺序，一个一个执行。一个任务执行完毕后才执行下一个任务。 并发队列：同时，同时执行很多个任务。自动开启多个线程同时执行任务。并发功能只有在异步函数下才生效。 使用步骤：1） 定制任务 确定想要做的事情。 2） 将任务添加到队列中 GCD会自动将队列中的任务取出，放到对应的线程中执行。 任务的取出原则遵循队列的原则：先进先出，后进后出。 执行任务的函数1）同步方式 dispatch_sync(dispatch_queue_t queue, dispatch_block_t block); queue:队列 block:任务 2）异步方式 dispatch_async(dispatch_queue_t queue, dispatch_block_t block); queue:队列 block:任务 同步和异步的区别： 同步：在当前线程中执行。 异步：在另一条线程中执行。 同步任务的作用： 1） 用户登录 2） 下载任务1 3） 下载任务2 术语1） 同步和异步决定了是否要开辟新线程。 同步：在当前线程中执行任务，不具备开启新线程的能力。 异步：在新的线程中执行任务，具备开启新线程的能力。 2） 并发和串行决定了任务执行的方式。 并发：多个任务同时执行。 串行：一个任务执行完毕后，再执行下一个任务。 代码使用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/*串行队列*//*创建队列参数：1.队列标签。 2.队列属性。*/dispatch_queue_t queue = dispatch_queue_create(”dengw”,DISPATCH_QUEUE_SERIAL);/*同步执行任务，不会开辟新线程，在当前线程中顺序执行。一般只要使用“同步”执行，串行队列对添加的同步任务，立马执行*/dispatch_sync(queue, ^&#123; NSLog(@”%@”, [NSThread currentThread]);&#125;);/*异步执行任务，开辟新线程，在新线程中执行。开辟新线程的数量与队列模式有关。串行队列中异步执行只会开启一个新线程。*/for(int I = 0; I &lt; 10; I++)&#123; dispatch_async(queue, ^&#123; NSLog(@”%@”, [NSThread currentThread]); &#125;);&#125; /*并发队列：需要程序员释放。*//*创建队列参数：1.队列标签。 2.队列属性。*/dispatch_queue_t queue = dispatch_queue_create(”dengw”,DISPATCH_QUEUE_CONCURRENT);/*异步执行任务，开辟新线程，在新线程中执行。开辟新线程的数量程序员无法控制。*/for(int I = 0; I &lt; 10; I++)&#123; dispatch_async(queue, ^&#123; NSLog(@”%@”, [NSThread currentThread]); &#125;);&#125;/*同步执行任务，不开辟新线程，顺序执行*/for(int I = 0; I &lt; 10; I++)&#123; dispatch_sync(queue, ^&#123; NSLog(@”%@”, [NSThread currentThread]); &#125;);&#125;/*主队列，专门负责在主线程上调度任务。程序启动以后至少有一个主线程，则会创建主队列。*//*主队列不允许开辟新线程。不会在子线程调度任务。*//*获得主队列*/dispatch_queue_t queue = dispatch_get_main_queue();/*异步执行任务，在主队列中，只能顺序执行。*/for(int I = 0; I &lt; 10; I++)&#123;/*异步：把任务放到主队列中，但不需要马上执行。*/ dispatch_async(queue, ^&#123; NSLog(@”%@”, [NSThread currentThread]); &#125;);&#125;/*同步执行任务*/for(int I = 0; I &lt; 10; I++)&#123;/*同步：把任务放到主队列中，需要马上执行。*//*阻塞*/ dispatch_sync(queue, ^&#123; NSLog(@”%@”, [NSThread currentThread]); &#125;);&#125;/*全局队列：本质是并发队列。与并发队列的区别：1）全局队列没有名字，而并发队列有名字。2）全局队列，是供所有的应用程序使用。3）在MRC中，全局队列不需要释放，并发队列需要释放。*//*获得全局队列参数：参数1iOS7中DISPATCH_QUEUE_PRIORITY_HEGH 2 高优先级DISPATCH_QUEUE_PRIORITY_DEFAULT 0 默认优先级DISPATCH_QUEUE_PRIORITY_LOW (-2) 低优先级DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN 后台优先级（最低）iOS8中DISPATCH_QUEUE_PRIORITY_HEGH:QOS_CLASS_USER_INITIATEDDISPATCH_QUEUE_PRIORITY_DEFAULT:QOS_CLASS_USER_DEFAULTDISPATCH_QUEUE_PRIORITY_LOW:QOS_CLASS_USER_UTILITYDISPATCH_QUEUE_PRIORITY_BACKGROUND: QOS_CLASS_USER_BACKGROUND参数2保留参数。*/dispatch_queue_t queue = dispatch_get_global_queue(QOS_CLASS_USER_DEFAULT,0);/*异步执行任务*/for(int I = 0; I &lt; 10; I++)&#123; dispatch_async(queue, ^&#123; NSLog(@”%@”, [NSThread currentThread]); &#125;);&#125; 各队列的执行效果 全局并行队列 手动创建串行队列 主队列 同步（sync） 没有开启新线程。串行执行任务。 没有开启新线程。串行执行任务。 会死锁 异步（async） 有开启新线程。并行执行任务。 有开启新线程。串行执行任务。 没有开启新线程。串行执行任务。 队列的选择1）串行队列异步执行 开一条线程，顺序执行。 效率不高，执行比较慢，资源占用小，省电。 应用场景：一般3G网络，对性能要求不高。 2）并发队列异步执行 开启多条线程，并发执行。 效率高，执行快，资源消耗大，费电。 应用场景：WIFI网络，或需要快速响应，用户体验要求高，对任务执行顺序没有要求。 3） 同步任务 一般只会在并发队列，需要阻塞后续任务，必须等待同步任务执行完毕，再去执行其他任务。“依赖关系” 线程间通信12345678/*从子线程回到主线程*/dispatch_async( dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; //执行耗时的异步操作… dispatch_async(dispatch_get_main_queue(), ^&#123; //回到主线程，执行UI刷新操作 &#125;);&#125;); 延时操作1）方式一，调用NSObject的方法 12//2秒后再调用run方法[self performSelector:@selector(run) withObject:nil afterDelay:2.0]; 2）方式二，使用GCD函数 123dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)),dispatch_get_main_queue(), ^&#123; //2秒后再异步执行这里的代码&#125;); 调度组（分组）应用场景：开发的时候，有的时候出现多个网络请求（每一个网络请求时间长短不一），都完成以后统一更新UI或通知用户。 1234567891011121314151617/*实例化一个调度组*/dispatch_group_t group = dispatch_group_create();//队列dispatch_queue_t queue = dispatch_get_global_queue(0, 0);//将任务添加到队列dispatch_group_async(group, queue, ^&#123; NSLog(@”A %@”, [NSThread currentThread]);&#125;);dispatch_group_async(group, queue, ^&#123; NSLog(@”B %@”, [NSThread currentThread]);&#125;);//获得所有调度组里面的异步任务完成的通知/*在调度组完成通知里，可以跨队列通信*/dispatch_group_notifity(group, queue, ^&#123; //异步的 NSLog(@”finished”);&#125;); 一次性执行常见于单例模型中代码使用。 12345static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; //只执行一次 NSLog(@”hi”);&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ruby 正则表达式]]></title>
      <url>%2F2016%2F04%2F13%2Fruby-regular-expression%2F</url>
      <content type="text"><![CDATA[摘要：正则表达式是一种特殊序列的字符，它通过使用有专门语法的模式来匹配或查找字符串集合。正则表达式用事先定义好的一些特定字符、及这些特定字符的组合，组成一个”规则字符串”，这个”规则字符串”用来表达对字符串的一种过滤逻辑。文章分享关于Ruby中的正则表达式的相关知识与使用。 语法正则表达式从字面上看是一种介于斜杠之间或介于跟在 %r 后的任意分隔符之间的模式，如下所示： 123/pattern//pattern/im # 可以指定选项%r!/usr/local! # 使用分隔符的正则表达式 实例123456789#!/usr/bin/rubyline1 = &quot;Cats are smarter than dogs&quot;;line2 = &quot;Dogs also like meat&quot;;if ( line1 =~ /Cats(.*)/ ) puts &quot;Line1 contains Cats&quot;endif ( line2 =~ /Cats(.*)/ ) puts &quot;Line2 contains Dogs&quot;end 实例运行输出结果为： 1Line1 contains Cats 正则表达式修饰符正则表达式从字面上看可能包含一个可选的修饰符，用于控制各方面的匹配。修饰符在第二个斜杠字符后指定，如上面实例所示。下标列出了 可能的修饰符： 修饰符 描述 i 当匹配文本时忽略大小写。 o 只执行一次 #{} 插值，正则表达式在第一次时就进行判断。 x 忽略空格，允许在整个表达式中放入空白符和注释。 m 匹配多行，把换行字符识别为正常字符。 u,e,s,n 把正则表达式解释为 Unicode（UTF-8）、EUC、SJIS 或 ASCII。如果没有指定修饰符，则认为正则表达式使用的是源编码。 就像字符串通过 %Q 进行分隔一样，Ruby 允许您以 %r 作为正则表达式的开头，后面跟着任意分隔符。这在描述包含大量您不想转义的斜杠字符时非常有用。 # 下面匹配单个斜杠字符，不转义 %r|/| # Flag 字符可通过下面的语法进行匹配 %r[&lt;/(.*)&gt;]i 正则表达式模式除了控制字符，(+ ? . * ^ $ ( ) [ ] { } | )，其他所有字符都匹配本身。您可以通过在控制字符前放置一个反斜杠来对控制字符进行转义。 下表列出了 Ruby 中可用的正则表达式语法。 模式 描述 ^ 匹配行的开头。 $ 匹配行的结尾。 . 匹配除了换行符以外的任意单字符。使用 m 选项时，它也可以匹配换行符。 […] 匹配在方括号中的任意单字符。 [^…] 匹配不在方括号中的任意单字符。 re* 匹配前面的子表达式零次或多次。 re+ 匹配前面的子表达式一次或多次。 re? 匹配前面的子表达式零次或一次。 re{ n} 匹配前面的子表达式 n 次。 re{ n,} 匹配前面的子表达式 n 次或 n 次以上。 re{ n, m} 匹配前面的子表达式至少 n 次至多 m 次。 (re) 对正则表达式进行分组，并记住匹配文本。 (?imx) 暂时打开正则表达式内的 i、 m 或 x 选项。如果在圆括号中，则只影响圆括号内的部分。 (?-imx) 暂时关闭正则表达式内的 i、 m 或 x 选项。如果在圆括号中，则只影响圆括号内的部分。 (?: re) 对正则表达式进行分组，但不记住匹配文本。 (?imx: re) 暂时打开圆括号内的 i、 m 或 x 选项。 (?-imx: re) 暂时关闭圆括号内的 i、 m 或 x 选项。 (?#…) 注释。 (?= re) 使用模式指定位置。没有范围。 (?! re) 使用模式的否定指定位置。没有范围。 (?&gt; re) 匹配无回溯的独立模式。 \w 匹配单词字符。 \W 匹配非单词字符。 \s 匹配空白字符。等价于 [\t\n\r\f]。 \S 匹配非空白字符。 \d 匹配数字。等价于 [0-9]。 \D 匹配非数字。 \A 匹配字符串的开头。 \Z 匹配字符串的结尾。如果存在换行符，则只匹配到换行符之前。 \z 匹配字符串的结尾。 \G 匹配最后一个匹配完成的点。 \b 当在括号外时匹配单词边界，当在括号内时匹配退格键（0x08）。 \B 匹配非单词边界。 \n, \t, etc. 匹配换行符、回车符、制表符，等等。 \1…\9 匹配第 n 个分组子表达式。 \10 如果已匹配过，则匹配第 n 个分组子表达式。否则指向字符编码的八进制表示。 补充： a|b ：匹配 a 或 b。 正则表达式实例字符 实例 描述 /ruby/ 匹配 “ruby” ¥ 匹配 Yen 符号。Ruby 1.9 和 Ruby 1.8 支持多个字符。 字符类 实例 描述 /[Rr]uby/ 匹配 “Ruby” 或 “ruby” /rub[ye]/ 匹配 “ruby” 或 “rube” /[aeiou]/ 匹配任何一个小写元音字母 /[0-9]/ 匹配任何一个数字，与 /[0123456789]/ 相同 /[a-z]/ 匹配任何一个小写 ASCII 字母 /[A-Z]/ 匹配任何一个大写 ASCII 字母 /[a-zA-Z0-9]/ 匹配任何一个括号内的字符 /[^aeiou]/ 匹配任何一个非小写元音字母的字符 /[^0-9]/ 匹配任何一个非数字字符 特殊字符类 实例 描述 /./ 匹配除了换行符以外的其他任意字符 /./m 在多行模式下，也能匹配换行符 /\d/ 匹配一个数字，等同于 /[0-9]/ /\D/ 匹配一个非数字，等同于 /[^0-9]/ /\s/ 匹配一个空白字符，等同于 /[ \t\r\n\f]/ /\S/ 匹配一个非空白字符，等同于 /[^ \t\r\n\f]/ /\w/ 匹配一个单词字符，等同于 /[A-Za-z0-9_]/ /\W/ 匹配一个非单词字符，等同于 /[^A-Za-z0-9_]/ 重复 实例 描述 /ruby?/ 匹配 “rub” 或 “ruby”。其中，y 是可有可无的。 /ruby*/ 匹配 “rub” 加上 0 个或多个的 y。 /ruby+/ 匹配 “rub” 加上 1 个或多个的 y。 /\d{3}/ 刚好匹配 3 个数字。 /\d{3,}/ 匹配 3 个或多个数字。 /\d{3,5}/ 匹配 3 个、4 个或 5 个数字。 非贪婪重复这会匹配最小次数的重复。 实例 描述 /&lt;.*&gt;/ 贪婪重复：匹配 “perl&gt;” /&lt;.*?&gt;/ 非贪婪重复：匹配 “perl&gt;” 中的 ““ 通过圆括号进行分组 实例 描述 /\D\d+/ 无分组： + 重复 \d /(\D\d)+/ 分组： + 重复 \D\d 对 /([Rr]uby(, )?)+/ 匹配 “Ruby”、”Ruby, ruby, ruby”，等等 反向引用这会再次匹配之前匹配过的分组。 实例 描述 /([Rr])uby&amp;\1ails/ 匹配 ruby&amp;rails 或 Ruby&amp;Rails /([‘“])(?:(?!\1).)*\1/ 单引号或双引号字符串。\1 匹配第一个分组所匹配的字符，\2 匹配第二个分组所匹配的字符，依此类推。 替换 实例 描述 /ruby rube/ 匹配 “ruby” 或 “rube” /rub(y le))/ 匹配 “ruby” 或 “ruble” /ruby(!+ \?)/ “ruby” 后跟一个或多个 ! 或者跟一个 ? 锚这需要指定匹配位置。 实例 描述 /^Ruby/ 匹配以 “Ruby” 开头的字符串或行 /Ruby$/ 匹配以 “Ruby” 结尾的字符串或行 /\ARuby/ 匹配以 “Ruby” 开头的字符串 /Ruby\Z/ 匹配以 “Ruby” 结尾的字符串 /\bRuby\b/ 匹配单词边界的 “Ruby” /\brub\B/ \B 是非单词边界：匹配 “rube” 和 “ruby” 中的 “rub”，但不匹配单独的 “rub” /Ruby(?=!)/ 如果 “Ruby” 后跟着一个感叹号，则匹配 “Ruby” /Ruby(?!!)/ 如果 “Ruby” 后没有跟着一个感叹号，则匹配 “Ruby” 圆括号的特殊语法 实例 描述 /R(?#comment)/ 匹配 “R”。所有剩余的字符都是注释。 /R(?i)uby/ 当匹配 “uby” 时不区分大小写。 /R(?i:uby)/ 与上面相同。 补充 /rub(?:y|le))/ ：只分组，不进行 \1 反向引用 搜索和替换sub 和 gsub 及它们的替代变量 sub! 和 gsub! 是使用正则表达式时重要的字符串方法。 所有这些方法都是使用正则表达式模式执行搜索与替换操作。sub 和 sub! 替换模式的第一次出现，gsub 和 gsub! 替换模式的所有出现。 sub 和 gsub 返回一个新的字符串，保持原始的字符串不被修改，而 sub! 和 gsub! 则会修改它们调用的字符串。 下面是一个实例： 123456789101112131415161718192021#!/usr/bin/ruby# -*- coding: UTF-8 -*-phone = &quot;138-3453-1111 #这是一个电话号码&quot;# 删除 Ruby 的注释phone = phone.sub!(/#.*$/, &quot;&quot;) puts &quot;电话号码 : #&#123;phone&#125;&quot;# 移除数字以外的其他字符phone = phone.gsub!(/\D/, &quot;&quot;) puts &quot;电话号码 : #&#123;phone&#125;&quot;以上实例运行结果：电话号码 : 138-3453-1111 电话号码 : 13834531111下面是另一个实例：#!/usr/bin/ruby# -*- coding: UTF-8 -*-text = &quot;rails 是 rails, Ruby on Rails 非常好的 Ruby 框架&quot;# 把所有的 &quot;rails&quot; 改为 &quot;Rails&quot;text.gsub!(&quot;rails&quot;, &quot;Rails&quot;)# 把所有的单词 &quot;Rails&quot; 都改成首字母大写text.gsub!(/\brails\b/, &quot;Rails&quot;)puts &quot;#&#123;text&#125;&quot; 以上实例运行结果： 1Rails 是 Rails, Ruby on Rails 非常好的 Ruby 框架]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[单例模式]]></title>
      <url>%2F2016%2F04%2F13%2Fsingleton-pattern%2F</url>
      <content type="text"><![CDATA[摘要：单例模式的作用是解决“应用中只有一个实例”的一类问题。本文主要介绍单例模式所谓何物，以及如何实现。 问题的提出 在一个iOS 应用的生命周期中，有时候我们只需要某个类的一个实例。例如，iOS 设备都有一个重力加速计硬件设备，要访问设备在x轴、y轴和z轴上的重力加速度，就必然要有一个类能够与硬件设备沟通来实时获得这些数据，这个类就是UIAccelerometer 。除了实时地获得数据，该类还能够保持x 轴、y轴和z 轴的状态。但是这个类只需要一个实例就够了，如果有多个实例，就会占用过多的内存。 再有，当应用程序启动时，应用的状态由UIApplication 类的一个实例维护，这个实例代表了整个“应用程序对象”，它只能是一个实例，其作用是实现应用程序中一些共享资源的访问和状态的保持等。 实现原理单例模式一般会封装一个静态属性，并提供静态实例的创建方法，其UML类图如图所示。 示例代码：12345678910111213141516171819202122//Singleton.h//@interface Singleton : NSObject+ (Singleton*)sharedManager;@property (nonatomic ,strong) NSString* singletonData;@end //Singleton.m //#import &quot;Singleton.h&quot;@implementation Singleton@synthesize singletonData = _singletonData;static Singleton *sharedManager = nil;+ (Singleton*)sharedManager&#123; static dispatch_once_t once; dispatch_once(&amp;once, ^&#123; sharedManager = [[self alloc] init]; &#125;); return sharedManager;&#125;@end 其中static Singleton *sharedManager 为静态变量，类方法为+ (Singleton*)sharedManager。sharedManager 方法采用了GCD（Grand Central Dispatch）技术，这是一种基于C语言的多线程访问技术。在上述代码中，dispatch_once 函数就是由GCD提供的，它的作用是在整个应用程序生命周期中只执行一次代码块（^{…}）。 dispatch_once_t 是GCD提供的结构体，使用时需要将GCD地址传给dispatch_once 函数。dispatch_once 函数能够记录该代码块是否被调用过。dispatch_once函数不仅意味着代码仅会被运行一次，而且还意味着此运行还是线程同步的。也就是说，当我们使用了dispatch_once函数时，就不再需要使用诸如@synchronized之类的语句。 将以上单例实现代码，抽成宏，代码如下： 1234567891011121314151617181920212223// @interface#define singleton_interface(className) \+ (className *)shared##className; // @implementation#define singleton_implementation(className) \static className *_instance; \+ (id)allocWithZone:(NSZone *)zone \&#123; \ static dispatch_once_t onceToken; \ dispatch_once(&amp;onceToken, ^&#123; \ _instance = [super allocWithZone:zone]; \ &#125;); \ return _instance; \&#125; \+ (className *)shared##className \&#123; \ static dispatch_once_t onceToken; \ dispatch_once(&amp;onceToken, ^&#123; \ _instance = [[self alloc] init]; \ &#125;); \ return _instance; \&#125; 应用案例在Cocoa Touch框架中，有UIApplication、UIAccelerometer 、NSUserDefaults和NSNotificationCenter等单例类。另外，NSFileManager 和NSBundle 类虽然属于Cocoa框架的内容，但也可以在Cocoa Touch框架中使用（Cocoa框架中的单例类有NSFileManager 、NSBundle 、NSWorkspace和NSApplication 等）。 1. UIApplicationUIApplication 类的实例提供了应用程序的集中控制点来保持应用的状态。UIApplication 实例总是分配给应用程序委托对象（UIApplicationDelegate ），通过应用程序委托对象来响应低内存、应用启动、后台运行和应用终止等事件。在HelloWorld 案例中，AppDelegate 就是这个应用程序的委托对象，它实现了UIApplicationDelegate协议。 UIApplication 类有很多方法和属性，下面我们重点介绍其中几个：+ sharedApplication 方法。创建和获得UIApplication 实例的方法。idleTimerDisabled属性。设定和获得“空闲时间禁止”的状态。idleTimerDisabled属性的默认值是NO，即默认情况下系统会锁定屏幕。当idleTimerDisabled = YES 时，则不会开启“空闲时间禁止”状态，系统不会锁定屏幕。开启这项设定需要谨慎，它会使你的应用比较耗电。- openURL:方法。可以打开一些内置的iOS 应用，其中包括打开浏览器、打开Google 地图、拨打电话、发送短信和发送E-mail 等。 打开浏览器的示例代码如下：12NSURL *url = [NSURL URLWithString:@&quot;http://www.cnblogs.com/chars&quot;];[[UIApplication sharedApplication] openURL:url]; 打开Google 地图时，实际上是通过内置浏览器来打开，示例代码如下：1234NSString* searchQuery = @&quot;清华大学&quot;;searchQuery = [searchQuery stringByAddingPercentEscapesUsingEncoding: NSUTF8StringEncoding];NSString* urlString = [NSString stringWithFormat: @&quot;http://maps.google.com/maps?q=%@&quot;, searchQuery];[[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString]]; 其中NSString 的stringByAddingPercentEscapesUsingEncoding方法将字符串转换为URL编码，例如 “%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6 ”是“清华大学”的 URL 编码。 拨打电话时，苹果官方要求使用该方法调用内置拨号程序，示例代码如下：1[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;tel://10010&quot;]]; 发送短信时，苹果官方要求使用该方法调用内置发送短信程序，示例代码如下：1[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;sms:10010&quot;]]; 发送E-mail 时，这种方式可以发送简单的不带附件的E-mail ，示例代码如下：1[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;mailto://eorient@sina.com&quot;]]; 2. UIAccelerometer单例类UIAccelerometer 前面也讲过，它可以访问重力加速计硬件设备，实时获得设备在x 轴、y轴和z 轴方向上的重力加速度。+ sharedAccelerometer方法是创建和获得UIAccelerometer实例的共享方法。 与UIApplication类似，UIAccelerometer也有对应的委托对象，其委托对象为UIAccelerometerDelegate。UIAccelerometer 将实例分配给委托对象UIAccelerometerDelegate ，然后由委托对象响应重力加速计事件。 3. NSUserDefaults单例类NSUserDefaults可以很方便地读取应用设置项目。+ standardUserDefaults方法是创建和获得NSUserDefaults实例的静态方法。 4. NSNotificationCenter单例类NSNotificationCenter提供信息广播通知，它采用观察者模式的通知机制。+ defaultCenter方法是创建和获得NSNotificationCenter实例的共享方法。 5. NSFileManagerNSFileManager 提供了访问文件系统的通用操作，可以定位、创建、复制文件和文件夹。在iOS 5和Mac OS X v10.7之后，它还可以管理存储在iCloud 上的数据。 + defaultManager方法是创建和获得NSFileManager 实例的方法。除了该方法外，创建NSFileMa nager对象时还可以使用实例构造方法– init。这两种方法有着比较大的差别，+ defaultManager方法总是返回相同的NSFileManager 对象，但如果要使用委托（NSFileManagerDelegate）完成基于文件的操作并接收通知，应该使用– init 方法创建一个新的实例，而不是使用共享的对象。 6. NSBundleNSBundle 提供了动态加载（或卸载）可执行代码、定位资源文件以及资源本地化、访问文件系统等功能。+ mainBundle方法是创建和获得NSBundle 实例的共享方法。 尾声单例模式无疑是Cocoa框架下最重要的设计模式之一。灵活而有机地运用设计模式，意味着编程工作的高效性和产品健壮性、安全性的提高。因此，我们应该要善于使用设计模式，将自己的开发经验与代码、设计模式完美融合起来，提高软件代码质量。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式 - 概述]]></title>
      <url>%2F2016%2F04%2F12%2Fdesign-pattern-introduction%2F</url>
      <content type="text"><![CDATA[摘要：设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 什么是 GOF（四人帮，全拼 Gang of Four）？在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 设计模式的使用设计模式在软件开发中的两个主要用途。开发人员的共同平台设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。最佳的实践设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。 设计模式的类型根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 创建型模式这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） 结构型模式这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 过滤器模式（Filter、Criteria Pattern） 组合模式（Composite Pattern） 装饰器模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern） 行为型模式这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern） J2EE 模式这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 MVC 模式（MVC Pattern） 业务代表模式（Business Delegate Pattern） 组合实体模式（Composite Entity Pattern） 数据访问对象模式（Data Access Object Pattern） 前端控制器模式（Front Controller Pattern） 拦截过滤器模式（Intercepting Filter Pattern） 服务定位器模式（Service Locator Pattern） 传输对象模式（Transfer Object Pattern） 下面用一个图片来整体描述一下设计模式之间的关系： 设计模式的六大原则1、开闭原则（Open Close Principle）开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。2、里氏代换原则（Liskov Substitution Principle）里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。3、依赖倒转原则（Dependence Inversion Principle）这个原则是开闭原则的基础，具体内容：针对对接口编程，依赖于抽象而不依赖于具体。4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。5、迪米特法则，又称最少知道原则（Demeter Principle）最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。6、合成复用原则（Composite Reuse Principle）合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World in Hexo]]></title>
      <url>%2F2016%2F04%2F10%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[list.h文件分析]]></title>
      <url>%2F2016%2F03%2F29%2Flist-code-reading%2F</url>
      <content type="text"><![CDATA[123structlist_head &#123; struct list_head *next, *prev; &#125;; 一上来就放这么一个数据结构，那么，这个到底要做什么呢？没错，就如上面代码所示，本文的主角就是它，由它衍生而来的一些问题。首先自我介绍，它，来自Linux系统中的链表。 就是个链表的头！是不觉得很奇怪？怎么只有两个指针域，没有数据域呢？其实笔者现在也纠结这这个问题着呢！没事，咱们先往下看。说不定什么时候，咱就明白了这是怎么一回事情呢。 123#define LIST_HEAD_INIT(name) &#123; &amp;(name), &amp;(name) &#125;#defineLIST_HEAD(name) \ struct list_head name = LIST_HEAD_INIT(name) 这俩是宏没错吧！来看看这个俩到底是个什么意思。 先来看看这个LIST_HEAD_INIT(name)，当程序当中出现了这个东西的时候，它立马就会替换成后面的东西，例如出现了：LIST_HEAD_INIT(headnode)；它立马就会替换成{&amp;(headnode),&amp;(headnode)}.假设有这么一段C代码 12struct list_head headnode ;//定义了一个headnode节点headnode = LIST_HEAD_INIT(headnode); 那么它是不应该再编译阶段就立马的被替换成这样呢？ 12struct list_head headnode ;//定义了一个headnode节点headnode = &#123; &amp;(headnode), &amp;(headnode) &#125;; 注意：这里面对标准的C进行了拓展叫：GNU C，这个意思呢就是说，对headnode的两个成员赋值。这赋值之后成了什么样子了呢？看下图： 是不是自己指向了自己？至于为什么可以这么赋值，不是本文讨论的重点，详细的可以Google. 其实这里的LIST_HEAD_INIT(name)宏是用来初始化的；而LIST_HEAD(name)宏则是用来定义+初始化。你看LIST_HEAD(name)宏是不比LIST_HEAD_INIT(name)宏多了这句 struct list_head name ？ 记住： LIST_HEAD_INIT(name)宏是用来初始化的； LIST_HEAD(name)宏则是用来定义+初始化。 OK，我们接着往下看： 12345static inline void INIT_LIST_HEAD(struct list_head *list)&#123; list-&gt;next = list; list-&gt;prev = list;&#125; 奇怪这里怎么好像又是在初始化，而且还和上面的功能一样。笔者觉得，他们这样做有如下考虑： 有些人习惯于调用函数进行初始化，而有的人喜欢代码简洁而直接使用宏来进行初始化，但是不论是那种方式，都达到了一样的功能,即初始化。 往下看，有关链表添加的 1234567891011#ifndef CONFIG_DEBUG_LISTstatic inline void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next)&#123; next-&gt;prev = new; new-&gt;next = next; new-&gt;prev = prev; prev-&gt;next = new;&#125;#elseextern void __list_add(struct list_head *new, struct list_head *prev, struct list_head *next);#endif 注意 __list_add前面可是两个下划线；这个就是说，这个函数是linux内核的东西，使用的时候，就得注意了。一看名字就知道是增加链表节点；其实我们学习双向链表的时候，那么多的指针操作，能把人绕死，而且到最后也搞得不清楚，看看人家linux源代码是咋实现的：是不觉得有差距？ 往下看： 1234static inline void list_add(struct list_head *new, struct list_head *head)&#123; __list_add(new, head, head-&gt;next);&#125; 刚才不说了么，前头俩下划线的让谨慎的使用么，这不？又弄了一个函数，可以调用这个函数来进行链表的添加。 实际上，还是调用的是刚才的那个有两个下划线的函数。这里体现了两个思想： 1、封装，其实这个概念是C++等一类程序设计语言的OOP思想，用在了这里。 2、重用，很多时候，代码其实都是可以不用自己写的，有一些现成的东西你可以去调用，这样可以很好的提高生产效率，而且linux源代码使用的是GPL许可证，没有什么版权啊乱七八糟的东西，有这么好的东西干嘛不用呢？其实下来的这个你会体会的更深： 1234static inline void list_add_tail(struct list_head *new, struct list_head*head)&#123; __list_add(new, head-&gt;prev, head);&#125; 看名字，看看list_add_tail这个名字。是不是“尾插法”？还是调用了前头的那个有两个下划线的函数吧？而且，仅仅只是调换了一下参数的次序。高明吧！ 好！再接着往下看： 12345678910111213141516static inline void __list_del(struct list_head * prev, struct list_head * next)&#123; next-&gt;prev = prev; prev-&gt;next = next;&#125; #ifndef CONFIG_DEBUG_LISTstatic inline void list_del(struct list_head *entry)&#123; __list_del(entry-&gt;prev, entry-&gt;next); entry-&gt;next = LIST_POISON1; entry-&gt;prev = LIST_POISON2;&#125;#elseextern void list_del(struct list_head *entry);#endif 这里是删除一节点，这里再一次的体现了封装和重用的思想。不过这里注意： 在将entry这个节点删除之后你得将它指向一个正确的错误区域！什么意思呢，就是说，你的将它放在一个大家公认的错误的地方，因为所有的人都不会去碰那个错误的地方，所以，你这个entry就不会引起各种不必要的麻烦。其实这里有一个问题：你free了某个节点之后，其实，我们还是可以使用这个节点的，这个在一篇博文里讲述的很清楚：http://blog.sina.com.cn/s/blog_6e9342530100yaef.html 其实这里，LIST_POISON1= 0x00100100. LIST_POISON2=0x00200200。为什么，笔者不知道。 下来接着看这个替换函数。将链表当中某个节点用新的节点替换掉。 1234567static inline void list_replace(struct list_head *old, struct list_head *new)&#123; new-&gt;next = old-&gt;next; new-&gt;next-&gt;prev = new; new-&gt;prev = old-&gt;prev; new-&gt;prev-&gt;next = new;&#125; 下面在给出图例： 大家可以根据图例来理解。 下来这个函数就是将某个链表里头的节点删除，然后添加到另外一个链表当中。你会发现代码很简单 12345static inline void list_move(struct list_head *list, struct list_head *head)&#123; __list_del(list-&gt;prev, list-&gt;next); list_add(list, head);&#125; 下面这两个函数，一个用来判断是否为链表的最后一个节点，一个用来判断该链表是否为空。 123456789static inline int list_is_last(const struct list_head *list, const struct list_head *head)&#123; return list-&gt;next == head;&#125; static inline int list_empty(const struct list_head *head)&#123; return head-&gt;next == head;&#125; 详细情况如下图： 然而实际上，我们用这种方式来判断链表是否为空是不太精确的。它同时判断头指针的next和prev，仅当两者都指向自己时才返回真。这主要是为了应付另一个cpu正在处理同一个链表而造成next、prev不一致的情况。但代码注释也承认，这一安全保障能力有限：除非其他cpu的链表操作只有list_del_init()，否则仍然不能保证安全，也就是说，还是需要加锁保护。 两个链表合并： 1234567891011121314151617static inline void __list_splice(const struct list_head *list, struct list_head *prev, struct list_head *next)&#123; struct list_head *first = list-&gt;next; struct list_head *last = list-&gt;prev; first-&gt;prev = prev; prev-&gt;next = first; last-&gt;next = next; next-&gt;prev = last;&#125; static inline void list_splice(const struct list_head *list, struct list_head *head)&#123; if (!list_empty(list)) __list_splice(list, head, head-&gt;next);&#125; 假设当前有两个链表，表头分别是list1和list2（都是struct list_head变量），当调用list_splice(&amp;list1,&amp;list2)时，只要list1非空，list1链表的内容将被挂接在list2链表上，位于list2和list2.next（原list2表的第一个节点）之间。新list2链表将以原list1表的第一个节点为首节点，而尾节点不变。如图（虚箭头为next指针）： 由于篇幅限制，当中其实，还有一些很有用的函数：比如切割啊，判断是否为单链表啊等等，其实当你再了解了这些函数之后，后面的都是大同小异。可以自己在做研究，下面将重点放在list.h当中的几个很重要的宏当中。还是顺着list.h往下看，你会看到第一宏： 12#define list_entry(ptr, type, member) \ container_of(ptr, type, member) 看到上面的那英文注释：获得结构体入口！ ptr：这个参数是指向list_head 类型的指针（注意这里，很容易再代码当中用错）。 type：看到那英文解释了么？这个type可不是list_head！他是list_head嵌入的那个结构体类型。详细会给出一断源代码，帮助大家理解。 member：这个看到名字就知道这个是结构体的一个成员。 list_entry(ptr,type,member)这个宏到底是干嘛的，是不应该看container_of这个宏是干嘛的呢？用Sorce Insight 查看，会发现它在很多文件里头都存在，它们都是一样的，这里选取/include/linux/kernel.h当中的container_of宏来说明。 123#define container_of(ptr, type, member) (&#123; \ const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \ (type *)( (char *)__mptr - offsetof(type,member) );&#125;) 这个宏的作用是：计算结构体成员member再结构体当中的相对位置（相对地址）。现在想想，开头的时候，是不是看到了这个链表的结构体定义只有指针域而没有数据域？现在就是要计算出嵌入了list_head结构的结构体的数据域的地址。 1234struct stu&#123; int id； struct list_head *next，*prev；&#125;； 就是要根据list_head类型的结构体计算出struct stu结构体当中成员id的地址。 现在假设有如下定义: 123struct stu *p；struct list_head *r;r = p-&gt;next; 现在我们肯定是可以直接通过p来访问struct stu结构体当中的id的。但是这样做旧失去了其通用性，要知道内核当中链表的组织形式可是list_head。现在要如何才能够通过r访问的id呢？ 我们将宏container_of分开成两部分来看。 1const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); 这里的typeof也是GNU C所拓展的。Typeof(x) 就是返回x的数据类型。我们先从最里面的括号开始看起吧， (type *)0先将0转化成type 类型的指针，此时地址为0x0。然后再引用member成员，即就是:((type *)0)-&gt;member 然后再加上typeof() 不就是返回member的数据类型么。再加上前面的const 后面的 * __mptr 。这是个什么意思？ 我们来个一个假设。假设member返回的数据类型是int。那么是不是就成了const int * __mptr = (ptr)?现在是不是明白了？typeof( ((type *)0)-&gt;member ) 这个东西，就是为了要得到member的数据类型。 总结一下：这个就是为了定义一个member类型的指针，并且指向ptr(list_head类型) 1(type *)( (char *)__mptr - offsetof(type,member) ); （char *）__mptr 将mptr强制转化成char *类型，为什么转化成char* ，就是要获得mptr指针的地址。而不是其他的类型呢？先来看offsetof这个宏吧。它被定义在/include/linux/stddef.h当中。 1#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER) 不着急，还是先从最里面的括号开始看起。(TYPE *)0)-&gt;MEMBER 这不是为了获取member么。在加个&amp; 获得他的地址、在加上(size_t) 强制转化成size_t 类型(其实也就是 unsigned int)。现在该注意了。刚才是不是说得到了type类型的指针的地址是0x0 ？ 你这里又得到了type类型指针成员member的地址。这个就是member的偏移地址吧！ 再将这两个合并起来看。将获得的_mptr指针的地址 ，减去member成员在其中的偏移量。就是member的地址了吧！！O(∩∩)O~ 还有一个重要的问题？就是为什么要转化成char*，而不是其他的*？char类型的数据不论在什么类型的机器上，存储方式应该只是占了一个字节？因为它的实质是ascii码。这样的话，就好理解了，对char*减一 那就是实实在在的减一个字节；但是你要是对int*减一会实实在在的减多少？是不是4？（32位机器下）。这样一来，你怎么知道他的真实地址？可以根据下图来理解： 下面再来看看和这个宏很类似的宏 12#define list_first_entry(ptr, type, member) \ list_entry((ptr)-&gt;next, type, member) 和刚才唯一的区别就是ptr所代表的意思不同了，list_entry这个宏是用来获得链表的入口的。但是这里却是为了得到链表的第一个元素。详细的不再赘述。 下来看看这个遍历宏： 123#define list_for_each(pos, head) \ for (pos = (head)-&gt;next; prefetch(pos-&gt;next), pos != (head); \ pos = pos-&gt;next) 这里prefetch其实还是一个宏，其作用是预取。作用是使得的便利更加快速、高效、安全，我们这里基本上可以不用考虑这些问题，故，使用的时候可以将该宏去掉。 再来看看向前遍历的宏： 123#define list_for_each_prev(pos, head) \ for (pos = (head)-&gt;prev; prefetch(pos-&gt;prev), pos != (head); \ pos = pos-&gt;prev) 跟上面遍历宏一样，其本质还是for循环，结束条件是遍历到了头！ 具体的双向循环链表就分析到这里，后面的还有一大堆的遍历宏，只不过也就是上面这几种宏的组合使用罢了；更有甚者，考虑了很多的安全性问题；比如：多线程、并发访问一链表等等，这些应该说在用户级别的程序不大会出现这类问题，我们大可不必注意；但是考虑到在OS当中，有很多是用到了链表；比如：在进程调度的时候，就绪队列、等等。在这个时候就不仅仅需要考虑链表的实现问题了，而且还得考虑安全问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode插件开发教程指南]]></title>
      <url>%2F2016%2F03%2F25%2Fxcode-plugin-develop%2F</url>
      <content type="text"><![CDATA[摘要：对于Xcode而言，我们苹果开发者并不陌生，对于Xcode的插件，我们也不陌生。但是，有几个人做过Xcode插件呢？！Who care？显然，博主是关心的，这里分享一下博主自己开发插件的过程。 在平时开发过程中我们使用了很多的Xcode插件，虽然官方对于插件制作没有提供任何支持，但是加载三方的插件，默认还是被允许的。第三方的插件，存放在 ~/Library/Application Support/Developer/Shared/Xcode/Plug-ins文件夹中，后缀名必须是.xcplugin ，其实际上是一种bundle。所以我们创建一个插件工程，直接创建bundle工程即可。然后通过修改后缀名为.xcplugin，将其放到~/Library/Application Support/Developer/Shared/Xcode/Plug-ins目录中即可。 Xcode插件开发现在主要通过两种方式实现，其实也就是一种，只不过其中一种是使用别人提供的开发模板来省去很多中间步骤而已。文章会依次详细介绍两种的实现方法。 准备工作方式一：通过Bundle实现1.创建Bundle工程 2.工程设置 插件工程和普通的bundle工程还是有区别的,所以需要进行特殊的设置。 1）工程的plist文件 添加三项： XCPluginHasUI = NO XC4Compatible = YES DVTPlugInCompatibilityUUIDs 这是一个数组。数组内容字符串，指示了该插件兼容的Xcode版本，只有对应版本的Xcode的UIID加入这个数组，插件才能被加载。 否则，即使将插件放入Xcode的插件文件夹，插件也不会被加载。获取当前版本的Xcode的UUID方式： 在terminal中输入命令： 1defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID terminal会返回一串字符串，这就是Xcode的DVTPlugInCompatibilityUUID。 2）Build Setting Installation Build Products Location 设置为 ${HOME} [显示的时候,显示的是你的用户目录]，这个是products的根目录。 Installation Directory 设置为 /Library/Application Support/Developer/Shared/Xcode/Plug-ins，这个是指定你的插件安装的目录。 注意，这里填入的其实是相对目录。 插件的绝对目录是这样的，例如 /Users/yohunl/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin ，最后的绝对目录是 Installation Build Products Location和Installation Directory的结合，这也是为什么两者都要设置的原因。 Deployment Location 设置为 YES，这个是指示该工程不使用设置里的build location，而是用Installation Directory来确定build后放置的位置。 默认工程生成的相关文件位置都是 Build Locations指定的，通过Deployment Location 设置为 YES告诉工程，我们不使用这个默认的设置，而是我们自定义的。 Wrapper extension 设置为 xcplugin，后缀名必须为xcplugin，否则不会被加载。 方式二：通过模板实现1）下载Xcode插件开发模板 地址：https://github.com/kattrali/Xcode-Plugin-Template 2）将下载下来的template复制到 ~/Library/Developer/Xcode/Templates/Project Templates/Application Plug-in/Xcode Plugin.xctemplate文件夹中，如果没有对应的文件夹就自己手动创建一个。 3）重启Xcode，当你新建一个工程的时候就可以在OS X中看到一个Application Plug-in的选项，里面有一个Xcode Plug-in模板。 实现通过以上的两种准备方式，我们已可以创建Xcode插件工程，接下来就是如何实现插件功能。 1.功能需求在当前选中文件中实现代码风格重构，目前主要实现setter方法这一风格重构。例如， [self setName:@&quot;Davy&quot;]; ==&gt; self.name = @&quot;Davy&quot;; 2.思路分析 1）找到当前文件中符合setter方法命名风格的方法调用。 2）替换找到的符合重构风格的代码，提醒用户保存。 3.技术难点 1）Xcode代码编辑框文件内容操作。 2）正则表达式书写。 3）Xcode代码编辑框提醒用户保存文件。 关于最后一点，因为Xcode对于没有保存的已修改过的文件会显灰以提示用户该文件需要保存，我们可以借鉴这种方式。另外，在查找时，如果能够实现高亮并且跟随滚动，效果会更佳。 4.关键代码 以上这些问题，本人在“Refactor Code”插件中全部实现，现在放上关键方法。 1）添加菜单 1234567891011121314-(void) setupMenuItem &#123; // Menu Item: NSMenuItem *editMenuItem = [[NSApp mainMenu] itemWithTitle:@&quot;Edit&quot;]; if (editMenuItem) &#123; [[editMenuItem submenu] addItem:[NSMenuItem separatorItem]]; NSMenu *refactorCodeMenu = [[NSMenu alloc] initWithTitle:@&quot;Refactor Code&quot;]; NSMenuItem *menuItem; menuItem = [[NSMenuItem alloc] initWithTitle:@&quot;Refactor Method Style&quot; action:@selector(refactorMethodStyleMenuAction) keyEquivalent:@&quot;&quot;]; [menuItem setTarget:self]; [refactorCodeMenu addItem:menuItem]; NSMenuItem *refactorCodeMenuItem = [[NSMenuItem alloc] initWithTitle:@&quot;Refactor Code&quot; action:nil keyEquivalent:@&quot;&quot;]; [refactorCodeMenuItem setSubmenu:refactorCodeMenu]; [[editMenuItem submenu] addItem:refactorCodeMenuItem]; &#125;&#125; 效果图如下： 2）显示操作面板 123456789101112131415- (void)refactorMethodStyleMenuAction &#123; [self.operateController showWindow:nil]; NSURL *url = [[NSBundle bundleForClass:[self class]] URLForResource:@&quot;DZOperateController&quot; withExtension:@&quot;nib&quot;]; if (!url) &#123; NSAlert *alert = [[NSAlert alloc] init]; alert.messageText = @&quot;Refactor Method Style could not be shown because the plugin is corrupted.&quot;; alert.informativeText = @&quot;If you build the plugin from sources using Xcode, make sure to perform “Clean Build Folder“ in Xcode and then build the plugin again.\n\nIf you installed the plugin via Alctraz, there is a pending issue causing some files to be missing in the plugin. Prefer to install it via the plugin webpage.&quot;; [alert addButtonWithTitle:@&quot;Download Latest&quot;]; [alert addButtonWithTitle:@&quot;Cancel&quot;]; NSModalResponse result = [alert runModal]; if (result == NSAlertFirstButtonReturn) &#123; [[NSWorkspace sharedWorkspace] openURL:[NSURL URLWithString:@&quot;https://github.com/CharsDavy/RefactorCodePlugin-Xcode&quot;]]; &#125; &#125;&#125; 效果图如下： 3）查找替换代码风格 这一部分是重点部分，包括如何书写正则表达式，并且利用正则表达式生成替换字符。还包括高亮代码，具体可以参见本人源码：https://github.com/CharsDavy/RefactorCodePlugin-Xcode 4）最终效果图 提交插件至Alcatraz1.打开Alcatraz的插件包仓库，地址：https://github.com/supermarin/alcatraz-packages 2.在简介里可以看到Alcatraz的包分为三类，分别为：插件(plugins)，配色方案(color schemes)和模板(templates)。每个包都必须包含”name”、”url”和”description”字段，还有一个可选的”screenshot”字段。 3.Fork这个仓库，再克隆到本地。 4.以添加”Refactor Code”插件为例，打开packages.json文件，在”plugins”数组里加入： 123456&#123; &quot;name&quot;: &quot;Refactor Code&quot;, &quot;url&quot;: &quot;https://github.com/CharsDavy/RefactorCodePlugin-Xcode.git&quot;, &quot;description&quot;: &quot;Refactor code style,such as setter method.&quot;, &quot;screenshot&quot;: &quot;https://github.com/CharsDavy/RefactorCodePlugin-Xcode/raw/master/Screenshots/window.png&quot;&#125; 5.提交代码到Fork的地址，再提交一个pull request到Master即可。 6.merged成功之后，即可看见以下效果图 希望对大家有所帮助。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[聊聊 class-dump 使用]]></title>
      <url>%2F2016%2F03%2F23%2Fclass-dump-using%2F</url>
      <content type="text"><![CDATA[class-dump is a command-line utility for examining the Objective-C segment of Mach-O files. It generates declarations for the classes, categories and protocols. This is the same information provided by using ‘otool -ov’, but presented as normal Objective-C declarations. 上面是class-dump的官方解释，我们用的最多就是做iOS的逆向工程。class-dump，是可以把Objective-C运行时的声明的信息导出来的工具。其实就是可以导出.h文件。用class-dump可以把未经加密的app的头文件导出来。 官方网址：http://stevenygard.com/projects/class-dump/ 安装class-dump的下载地址：http://stevenygard.com/download/class-dump-3.5.tar.gz 点击下载后解压后会有class-dump和源码文件。将class-dump 复制到/usr/bin/class-dump。如果是OS X 10.11，因为没有/usr/bin文件夹的写权限，所以将class-dump复制到/usr/local/bin/class-dump即可。 同时打开Terminal，执行命令赋予其执行权限： 1$ sudo chmod 777 /usr/bin/class-dump 使用使用class-dump导出头文件的命令格式： 1class-dump -H 需要导出的框架路径 -o 导出的头文件存放路径 示例：导出Xcode中DVTKit框架的头文件1）找到DVTKit框架路径 2）使用上述的操作命令格式 1$ class-dump -H /Applications/Xcode.app/Contents/SharedFrameworks/DVTKit.framework/Versions/A/DVTKit -o ~/local/DVTKit 附录class-dump AppKit: class-dump /System/Library/Frameworks/AppKit.framework class-dump UIKit: class-dump /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS4.3.sdk/System/Library/Frameworks/UIKit.framework class-dump UIKit and all the frameworks it uses: class-dump /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS4.3.sdk/System/Library/Frameworks/UIKit.framework -r --sdk-ios 4.3 class-dump UIKit (and all the frameworks it uses) from developer tools that have been installed in /Dev42 instead of /Developer: class-dump /Dev42/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS5.0.sdk/System/Library/Frameworks/UIKit.framework -r --sdk-root /Dev42/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS5.0.sdk]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[说说那些iOS笔试题]]></title>
      <url>%2F2016%2F03%2F18%2Fios-test-in-writing%2F</url>
      <content type="text"><![CDATA[摘要：博主之前从事嵌入式开发，本科专业软件工程。毕业后一直从事嵌入式C语言。之所以进入嵌入式行业，完全是个人兴趣。不过，在从业两年之后发现不是自己喜欢的菜。毅然决然的转型到iOS行业。然，博主并非参加培训学校出来，完全利用工作之余时间自学，现在已经在ZAKER工作，从事ZAKER客户端的iPhone版本开发。这里，博主分享一下之前找工作时，总结的笔试题。 题目与答案答案仅供参考，如有异议或者错误，请指正。 中文试题 #import 跟#include、@class有什么区别？#import&lt;&gt;跟 #import&quot;&quot;又什么区别？ 1231) #import和#include都能完整地包含某个文件的内容，#import能防止同一个文件被包含多次2) @class仅仅是声明一个类名，并不会包含类的完整声明;@class还能解决循环包含的问题3) #import &lt;&gt;用来包含系统自带的文件，#import “”用来包含自定义的文件 属性readwrite，readonly，assign，retain，copy，nonatomic各是什么作用，在那种情况下用？ 123456readwrite：同时生成get方法和set方法的声明和实现readonly：只生成get方法的声明和实现assign：set方法的实现是直接赋值，用于基本数据类型retain：set方法的实现是release旧值，retain新值，用于OC对象类型copy：set方法的实现是release旧值，copy新值，用于NSString、block等类型nonatomic：非原子性，set方法的实现不加锁（比atomic性能高） 写一个setter方法用于完成@property （nonatomic,retain）NSString *name,写一个setter方法用于完成@property（nonatomic，copy）NSString *name. 12345678@property (nonatomic, retain) NSString *name;- (void)setName:(NSString *)name&#123; if (_name != name) &#123; [_name release]; _name = [name retain];&#125;&#125; 12345678@property(nonatomic, copy) NSString *name;- (void)setName:(NSString *)name&#123; if (_name != name) &#123; [_name release]; _name = [name copy];&#125;&#125; 对于语句NSString*obj = [[NSData alloc] init]; ，编译时和运行时obj分别是什么类型？ 12编译时是NSString类型运行时是NSData类型 常见的object-c的数据类型有那些，和C的基本数据类型有什么区别？ 12常用OC类型：NSString、NSArray、NSDictionary、NSData、NSNumber等OC对象需要手动管理内存，C的基本数据类型不需要管理内存 id 声明的变量有什么特性？ 1id声明的变量能指向任何OC对象 Objective-C如何对内存管理的,说说你的看法和解决方法? 1234每个对象都有一个引用计数器，每个新对象的计数器是1，当对象的计数器减为0时，就会被销毁通过retain可以让对象的计数器+1、release可以让对象的计数器-1还可以通过autorelease pool管理内存如果用ARC，编译器会自动生成管理内存的代码 内存管理的几条原则时什么？按照默认法则.哪些方法生成的对象需要手动释放？在和property结合的时候怎样有效的避免内存泄露？ 1234只要调用了alloc、copy、new方法产生了一个新对象，都必须在最后调用一次release或者autorelease只要调用了retain，都必须在最后调用一次release或者autorelease@property如果用了copy或者retian，就需要对不再使用的属性做一次release操作如果用了ARC，另外讨论. 看下面的程序,三次NSLog会输出什么？为什么？ 1234567891011NSMutableArray* ary = [[NSMutableArray array] retain]; NSString *str = [NSString stringWithFormat:@&quot;test&quot;]; // 1 [strretain]; // 2[aryaddObject:str]; // 3 NSLog(@&quot;%d&quot;,[str retainCount]); [strretain]; // 4[strrelease]; // 3[strrelease]; // 2NSLog(@&quot;%d&quot;,[str retainCount]); [aryremoveAllObjects]; // 1 NSLog(@&quot;%d&quot;,[str retainCount]); 结果：3、2、1 OC中创建线程的方法是什么？如果指定在主线程中执行代码？如何延时执行代码？ 1234创建线程的方法NSThreadNSOperationQueue和NSOperationGCD 12345主线程中执行代码[self performSelectorOnMainThread: withObject: waitUntilDone:];[self performSelector: onThread:[NSThreadmainThread] withObject: waitUntilDone:];dispatch_async(dispatch_get_main_queue(), ^&#123;&#125;); 12345678延时执行double delayInSeconds = 2.0;dispatch_time_tpopTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123; &#125;);[self performSelector: withObject: afterDelay:];[NSTimer scheduledTimerWithTimeInterval: target: selector: userInfo: repeats:]; 英文试题提示： 一定要把英文题目过一遍，有些公司的题目故意弄成英文的。 Difference between shallow copy and deep copy? 12浅拷贝：指针（地址）拷贝，不会产生新对象深拷贝：内容拷贝，会产生新对象 What is advantage of categories? What is difference between implementing a category and inheritance? 123分类可以在不修改原来类模型的基础上拓充方法分类只能扩充方法、不能扩充成员变量；继承可以扩充方法和成员变量继承会产生新的类 Difference between categories and extensions? 123分类是有名称的，类扩展没有名称分类只能扩充方法、不能扩充成员变量；类扩展可以扩充方法和成员变量类扩展一般就写在.m文件中，用来扩充私有的方法和成员变量（属性） Difference between protocol in objective c and interfaces in java? 12Java的接口中声明的方法必须都实现Oc的protocol中声明的方法并不一定要实现 What are KVO and KVC? 12KVC是键值编码，可以通过一个字符串的key（属性名）修改对象的属性值KVO是键值监听，可以监听一个对象属性值的改变 What is purpose of delegates? 12两个对象之间传递数据和消息解耦，拆分业务逻辑 What are mutable and immutable types in Objective C? 12mutable是可变类型，比如NSMutableArray，可以动态往里面添加元素immutable是不可变类型，比如NSArray，固定的存储空间，不能添加元素 When we call objective c is runtime language what does it mean? 123动态绑定：对象类型在运行时才真正确定多态性消息机制 what is difference between NSNotification and protocol? 12通过NSNotification可以给多个对象传递数据和消息通过protocol（代理模式）只能给一个对象传递数据和消息 What is push notification? 12本地推送：程序内部弹出通知到用户设备远程推送：由推送服务器推送通知到用户设备 What is Polymorphism？ 1多态：父类指针指向子类对象 What is Singleton? 12单例：保证程序运行过程中，永远只有一个对象实例目的是：全局共享一份资源、节省不必要的内存开销 What is responder chain? 123响应者链：UIResponder有一个nextResponder属性，通过该属性可以组成一个响应者链，事件或消息在其路径上进行传递如果UIResponder没有处理传给它的事件，会将未处理的消息转发给自己的nextResponder Difference between frame and bounds? 12frame以父控件的左上角为坐标原点bounds以控件本身的左上角为坐标原点 Difference between method and selector? 1通过一个selector可以找到方法地址，进而调用一个方法 Is there any garbage collection mechanism in Objective C.? 123OC 1.0没有垃圾回收OC 2.0有垃圾回收，只能用在Mac上iOS中有ARC机制，是编译器特性，垃圾回收是运行时特性 What is NSOperation queue? 12用来存放NSOperation对象的队列，可以用来异步执行一些操作一般可以用在网络请求等耗时操作 Can we use one tableview with two different datasources? How you will achieve this? 1从对象属性上分析，tableView只有一个dataSource属性。当然，真要使用两个不同的数据源，还是有其他办法解决的 Can we use two tableview controllers on one viewcontroller? 1从技术角度上分析，一个控制器内部添加两个表格控制器是没有问题的 What is lazy loading? 1延迟加载：比如控制器的view，在第一次用到view时才会调用loadView方法进行创建 链表不具备的特点是（） A. 可随机访问任何一个元素 B. 插入，删除操作不需要移动元素 C. 无需事先估计存储空间大小 D. 所欲存储空间可以是不连续的 参考答案： （A）链表不同于数组。链表之所有叫链表，就是像一条链一样，要过到某个节点处，就得遍历着找；而数组才具备随机访问任何一个元素的能力，数组可以通过索引直接访问元素，时间复杂度为常量，效率非常高，因此在某些场合上，我们需要数组这样的数据结构。 B. 链表的插入、删除都不需要移动元素，只需要修改指针的指向就可以了，因为链表上的每个节点都是动态分配的，分配在堆上，通过指针来指向每个节点的内存区，要获取某个节点的值，是需要遍历一遍才能找到对应的节点的。 C. 因为链表上的每个节点是分配在堆上，需要开发人员手动申请内存空间的，因此不像数组在定义时就要指定存储空间大小。对于链表，需要增加一个节点时，直接在堆上申请。当需要删除某个节点时，可以直接将该节点的内存给释放掉。 D. 因为链接中的节点都是存储在堆上的，而每个节点之间都有一个指向前一个节点和后一个节点的指针，只要知道链表头指针，就可以通过遍历查找到任何一个节点。因此，链表不同于数组，数组是要连续的内存存储空间，才能保证以常量时间复杂度快速访问任意元素；而链表不要求每个节点是连接，在堆上申请的内存空间很难得到连续的，而且空间产生内存碎片。 关于多线程和多进程编程，下面描述正确的是（） A. 多进程里，子进程可获取父进程的所有堆和栈的数据；而线程会与同进程的其他线程共享数据，拥有自己的栈空间。 B. 线程因为有自己的独立栈空间且共享数据，所有执行的开销相对较大，同时不利于资源管理和保护。 C. 线程的通信速度更快，切换更快，因为他们在同一地址空间内。 D. 线程使用公共变量/内存时需要使用同步机制，因为他们在同一地址空间内。 设两个变量a=19;b=29;在不创建新实例的情况下使a、b的值互换？ 参考答案： 这道题要求不创建新的实例，只有a、b两个变量，要交换这两个变量的值，通常的做法是使用临时变量来临时存储，但是现在要求不使用新的实例，那么有什么办法呢？ 方法就是通过位运算来操作： 123a = a ^ b;b = a ^ b;a = a ^ b; 对于题目中的a = 19，也就是对应二进制00010011；而b=29，也就是对应二进制00011101 第一步：a = 00010011 ^ 00011101 =&gt; 00001110，将a、b的值都记录下来了 第二步：b = 00001110 ^ 00011101 =&gt; 00010011（值为19，也就是b得到了原来的a的值） 第三步：a = 00001110 ^ 00010011 =&gt; 00011101 (值为29，也就是a得到了原来的b的值) 注意，符号表示按位异或。所谓按位异或是指对应位置上的二进制数值相同为0，不同为1。 使用block时什么情况会发生引用循环，如何解决？ 参考答案：http://www.henishuo.com/ios-block-memory-cycle 为什么要序列化，对象序列化方式？ 参考答案： 将对象JSON序列化： 123456NSLog(@&quot;%s&quot;, __FUNCTION__);NSDictionary *dict = @&#123;@&quot;key&quot; : @&quot;value&quot;, @&quot;key1&quot; : @&quot;value1&quot;, @&quot;key2&quot; : @&quot;value2&quot;&#125;;NSData *data = [NSJSONSerialization dataWithJSONObject:dict options:NSJSONWritingPrettyPrinted error:nil];NSLog(@&quot;%@&quot;, [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]); 将对象归档：需要遵守NSCoding协议，实现如下方法： 123- (void)encodeWithCoder:(NSCoder *)aCoder &#123; [aCoder encodeObject:self.title forKey:@&quot;title&quot;];&#125; 简述如何处理UI与耗时操作的通信，有哪些方式及各自的优缺点？ 参考答案： 1）将耗时的计算和IO操作放在子线程去处理，然后到主线程更新UI。优点是采用预加载方式，将耗时操作提前处理。优点是可让UI更流畅；缺点是内存会增多，控制加载逻辑比较复杂。 2）采用延迟加载方式，将耗时操作而不立刻使用时，采用延迟加载。优点是界面可提高流畅度；缺点是在需要显示时还需要加载才能显示，需要稍稍等待。 如何优化一个TableView？ 参考答案： 1）若高度一定，直接使用rowHeight属性而不是使用heightForRowAtIndexPath方法，以减少调用的消耗。若高度是不固定的，heightForRowAtIndexPath所计算的高度应该缓存起来，每次数据源发生变化时，比如删除、插入、更新行都会重新请求所有的高度。若有100个行，就会有调用100次，因为将高度缓存起来是应该的。同理，heightForHeaderInSection、heightForFooterInSection也应该缓存起来。 2）不要在tableView:cellForRowAtIndexPath:中做太多的计算和IO操作，比如可以将需要的计算提前计算好、IO操作也提前计算好。它应该直接调用来显示就可以。 3）将计算行高的时间提前到从服务器获取数据的时候，计算完了高度一并写回数据库或者通过转型为model，将高度放到模型中。但是，最好将高度缓存起来。若一个model的数据有不同的状态，比如展开与收起状态，应该也将高度都缓存起来。注意使用异步去计算，计算完成后再回到主线程显示。 4）在设置显示图片时，不要直接设置UIImageView的contentMode属性自动适应，图片变形会计算transform，压缩时会乘以一个矩阵，消耗性能。对于要求性能较高的app，应该将得到的图片经过处理成UIImageView大小后再呈现。 5）不要将视图的opaque属性设置为NO，默认为YES,它表示不透明度。当opque为NO的时候，图层的半透明取决于图片和其本身合成的图层为结果。 6）layer添加圆角是比较耗时的，这样会离屏渲染，需要牺牲更多的性能。比如，图片显示有圆角时，可以通过core graphics来生成带圆角的图片等。 7）手动绘制cell。绘制cell不建议使用UIView，建议使用CALayer。 UIView的绘制是建立在CoreGraphic上的，其使用的是CPU。CALayer使用的是Core Animation，CPU、GPU都可以使用且由系统自动决定使用哪一个。UIView的绘制，使用的是自下向上的一层一层的绘制，而后渲染。Layer处理的是纹理，利用GPU的 Texture Cache和独立的浮点数计算单元可以加速纹理的处理。 8）重用cell。防止重复的绘制，减少渲染次数，可提高性能。 9）减少subviews的数量。尽量放在同一层view上显示。 10）尽量少动态给cell添加子view。用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示。 更多参看：http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/ 简答题 假设类SomeClass中声明了一个委托属性delegate，该属性遵守自定义委托协议SomeDelegate，请写出该类和对应委托协议的定义？ 1234567@protocol SomeDelegate&lt;NSObject&gt;@required //必须要实现的方法@optional //可选实现的方法@end@interface SomeClass@property (nonatomic, assign)id &lt;SomeDelegate&gt; delegate;@end 简述UITableView的重用机制，并写出实现该机制的关键代码？ 关键代码： 1234UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cellId&quot;]; if (cell == nil) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@&quot;cellId&quot;]; &#125; 简述推送实现步骤？ 定义一个带参宏，返回两个参数中较小的那个？ strong和weak分别起什么作用？有什么区别？ 执行下面程序后NSLog的输出结果为（ C ）？ A.1，1 B.2，1 C.2，5 D.运行错误 123int a[5] = &#123;1,2,3,4,5&#125;;int *ptr = (int *)(&amp;a+1);NSLog(@“%d,%d”, *(a+1), *(ptr-1)); 执行下面程序后NSLog的输出结果为（ B ）？ A.a，a1，a1 B.a1，a1，a1 C.a1，a，a D.a1，a1，a 123456789int main(int argc, char *argv[])&#123; NSArray *mArray1 = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@&quot;a&quot;], @&quot;b&quot;, @&quot;c&quot;, nil]; NSArray *mArrayCopy2 = [mArray1 copy]; NSMutableArray *mArrayMCopy1 = [mArray1 mutableCopy]; NSMutableString *testString = [mArray1 objectAtIndex:0]; [testString appendString:@&quot;1&quot;]; NSLog(@&quot;%@,%@,%@&quot;, [mArray1 objectAtIndex:0],[mArrayCopy2 objectAtIndex:0],[mArrayMCopy1 objectAtIndex:0]); return 0;&#125; Cocoa中所有的类都是（ NSObject和NSProxy ）的子类。 列举几个Cocoa Touch框架？ Foundation、UIKit、Core Data 下面机型屏幕分辨率分别是多少？ 12345678iPhone4、4S：960X640iPhone5、5S、5C：1136X640iPhone6：375X667iPhone6 Plus：414X736iPad mini：1024X768iPad mini 2：2048X1536iPad Air：2048X1536iPad Air 2：2048X1536 Objective-C中的线程类是（ NSThread ），常见方法有哪些（ dispatch_async ）、（ dispatch_sync ），处理多线程同步有哪些类（ ）。 数据库现有MySQL数据库，分别对下表写出要求的SQL语句，用到实例数据请自行给出即可。 表结构如下： 字段名 类型 UserID Integer UserName varchar(20) Password varchar(20) 创建表： 12345CREATE TABLE `test`.`table_a` ( `UserID` INT NOT NULL , `UserName` VARCHAR(20) NULL , `Password` VARCHAR(20) NULL , PRIMARY KEY (`UserID`) ); 增加记录： 1insert into `test`.`table_a` ( `UserName`, `UserID`, `Password`) values ( &apos;cd&apos;, &apos;10&apos;, &apos;123&apos;) 删除记录： 12delete from `test`.`table_a` where `UserID`=’10&apos;修改记录：update `test`.`table_a` set `Password`=&apos;12346&apos; where `UserID`=&apos;10&apos; 编程题1.请通过接口“http://someurl/somefunc”获取数据，并在UI上显示。接口入参argu是一个字符串类型的变量，返回值是字典。 1）使用NSURL相关API实现网络加载类，其中：通过post方法发送请求，建立异步连接； 2）报文采用JSON格式； 3）多线程采用GCD或NSOperation实现； 4）以左边键右边值的格式在界面上显示结果。 2.传入数组*array和数组长度length，实现冒泡排序算法。 123456789101112131415161718int *BubbleSort(int *array, int length);int *BubbleSort(int *array, int length) &#123; int i = 0, j = 0, temp = 0; if (NULL == array) &#123; return NULL; &#125; for (i = 0; i &lt; length; i++) &#123; for (j = i; j &lt; length; j++) &#123; if (*(array + i) &gt; *(array + j)) &#123; temp = *(array + i); *(array + i) = *(array + j); *(array + j) = temp; &#125; &#125; &#125; return array;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objective-C中的引用计数]]></title>
      <url>%2F2016%2F03%2F15%2Fobjc-quote-count%2F</url>
      <content type="text"><![CDATA[摘要：Objective-C语言使用引用计数来管理内存，也就是说，每个对象都有个可以递增或递减的计数器。如果想使某个对象继续存活，那就递增其引用计数；用完了之后，就递减其计数。计数为0，就表示没人关注此对象了，于是，就可以把它销毁。在Objective-C中称之为引用计数，本文主要分享引用计数相关知识。 导言Objective-C语言使用引用计数来管理内存，也就是说，每个对象都有个可以递增或递减的计数器。如果想使某个对象继续存活，那就递增其引用计数；用完了之后，就递减其计数。计数为0，就表示没人关注此对象了，于是，就可以把它销毁。 从Mac OS X 10.8开始，“垃圾收集器”（garbage collector）已经正式废弃了，以Objective-C代码编写Mac OS X程序时不应再使用它，而iOS则从未支持过垃圾收集。因此，掌握引用计数机制对于学好Objective-C来说十分重要。Mac OS X程序已经不能再依赖垃圾收集器了，而iOS系统不支持此功能，将来也不会支持。 已经用过ARC的人可能会知道：所有与引用计数有关的方法都无法编译，然而现在先暂时忘掉这件事。那些方法确实无法用在ARC中，不过本文就是要从Objective-C的角度讲解引用计数，而ARC实际上也是一种引用计数机制，所以，还是要谈谈这些在开启ARC功能时不能直接调用的方法。 工作原理在引用计数架构下，对象有个计数器，用以表示当前有多少个事物想令此对象继续存活下去。这在Objective-C中叫做“保留计数”（retain count），不过也可以叫“引用计数”（reference count）。NSObject协议声明了下面三个方法用于操作计数器，以递增或递减其值： 1）retain 递增保留计数。 2）release 递减保留计数。 3）autorelease 待稍后清理“自动释放池”（autorelease pool）时，再递减保留计数。 上图是对象创建及保留计数操作的效果图。 上图对象图中，ObjectB与ObjectC都引用了ObjectA。若ObjectB与ObjectC都不再使用ObjectA，则其保留计数降为0，于是便可摧毁了。还有其他对象想令ObjectB与ObjectC继续存活，而应用程序里又有另外一些对象想令那些对象继续存活。如果按“引用树”回溯，那么最终会发现一个“根对象”（root object）。在Mac OS X应用程序中，此对象是NSApplication对象；而在iOS应用程序中，则是UIApplication对象。两者都是应用程序启动时创建的单例。 下面这段代码有助于理解这些方法的用法： 123456NSMutableArray *array = [[NSMutableArray alloc] init];NSNumber *number = [[NSNumber alloc] initWithInt:1337];[array addObject:number];[number release];//do something with &apos;array&apos;[array release]; 由于代码中直接调用了release方法，所以在ARC下无法编译。在Objective-C中，调用alloc方法所返回的对象由调用者所拥有。也就是说，调用者已通过alloc方法表达了想令该对象继续存活下去的意愿。不过，这并不是说对象此时的保留计数就是1。在alloc或“initWithInt:”方法的代码实现中，也许还有其他对象也保留了此对象。绝不能说保留计数一定是某个值，只能说你所执行的操作的递增了该计数还是递减了该计数。 创建完数组后，把number对象加入其中。调用数组的“addObject:”方法时，数组也会在number上调用retain方法，以期继续保留此对象。这时，保留计数至少为2。接下来，代码不再需要number对象了，于是将其释放。现在的保留计数至少为1。这样就不能照常使用number变量了。调用release之后，已经无法保证所指的对象仍然存活。当然，根据本例中的代码，我们显然知道number对象在调用了release之后仍然存活，因为数组还在引用着它。然而绝不应该假设此对象一定存活，也就是说，不要像下面这样子编写代码： 1234NSNumber *number = [[NSNumber alloc] initWithInt:1337];[array addObject:number];[number release];NSLog(@&quot;number = %@&quot;, number); 即便上述代码在本例中可以正常执行，也仍然不是个好办法。如果调用release之后，基于某些原因，其保留计数降至为0，那么number对象所占内存也许会回收，这样的话，再调用NSLog可能就将使程序崩溃了。为什么是“可能”，因为对象所占的内存在“解除分配”（deallocated）之后，只是放回“可用内存池”（avaiable pool）。如果执行NSLog时还尚未覆写对象内存，那么该对象仍然有效，这是程序不会崩溃。故，因过早释放对象而导致的bug很难调试。 为避免在不经意间使用了无效对象，一般调用完release之后都会清空指针。这就能保证不会出现可能指向无效对象的指针，这种指针通常称为“悬挂指针”（dangling pointer）。例如，可以这样编写代码来防止此情况发生： 1234NSNumber *number = [[NSNumber alloc] initWithInt:1337];[array addObject:number];[number release];number = nil; 属性存取方法中的内存管理如前所述，对象图由相互关联的对象所构成。刚才那个例子中的数组通过在其元素上调用retain方法来保留那些对象。不光数组，其他对象也可以保留别的对象，这一般通过访问“属性”来实现，而访问属性时，会用到相关实例变量的获取方法和设置方法。若属性为“strong关系”（strong relationship），则设置的属性值会保留。比方说，有个名叫foo的属性由名为_foo的实例变量所实现，那么，该属性的设置方法会是这样： 12345-(void)setFoo:(id)foo &#123; [foo retain]; [_foo release]; _foo = foo;&#125; 此方法将保留新值并释放旧值，然后更新实例变量，令其指向新值。顺序很重要。假如还未保留新值就先把旧值释放了，而两个值又指向同一个对象，那么，先执行release操作就可能导致系统将此对象永久回收。而后续的retain操作则无法令这个已经彻底回收的对象复生，于是实例变量就成了悬挂指针。 自动释放池在Objective-C的引用计数架构中，自动释放池是一项重要特性。调用release会立刻递减对象的保留计数（而且还可能令系统回收此对象），然而有时候可以不调用它，改为调用autorelease，此方法会在稍后递减计数，通常是在下一次“事件循环”（event loop）时递减，不过也可能执行得更早些。 此特性很有用，尤其是在方法中返回对象时更应该用它。在这种情况下，我们并总是想令方法调用者手工保留其值。比方说，有下面这个方法： 1234-(NSString *)stringValue &#123; NSString *str = [[NSString alloc] initWithFormat:@&quot;I am this: %@&quot;, self]; return str;&#125; 此时返回的str对象其保留计数比期望值要多1，因为调用者alloc会令保留计数加1，而又没有与之对应的释放操作。保留计数多1，就意味着调用者要负责处理多出来的这一次保留操作。必须设法将其抵消。这并不是说保留计数本身就一定是1，它可能大于1，不过那取决于“initWithFormat:”方法内的实现细节。你要考虑的是如何将多出来的这一次保留操作抵消掉。但是，不能在方法呢你释放str，否则还没等方法返回，系统就把该对象回收了。这里应该用autorelease，它会在稍后释放对象，从而给调用者留下了足够长的时间，使其可以在需要时先保留返回值。换句话说，此方法可以保证对象在跨越“方法调用边界”（method call boundary）后一定存活。实际上，释放操作会在清空最外层的自动释放池时执行，除非你有自己的自动释放池，否则这个时机指的就是当前线程的下一次事件循环。改写stringValue方法，使用autorelease来释放对象： 1234-(NSString *)stringValue &#123; NSString *str = [[NSString alloc] initWithFormat:@&quot;I am this: %@&quot;, self]; return [str autorelease];&#125; 修改之后，stringValue方法把NSString对象返回给调用者，此对象必然存活。所以我们能够如此使用它： 12NSString *str = [self stringValue];NSLog(@&quot;The string is: %@&quot;, str); 由于返回的str对象将于稍后自动释放，所以多出来的那一次保留操作时自然就会抵消，无须再执行内存管理操作。因为自动释放池中的释放操作要等到下一次事件循环时才会执行，所以NSLog语句在使用str对象前不需要手工执行保留操作。但是，假如要持有此对象的话（比如将其设置给实例变量），那就需要保留，并于稍后释放： 123_instanceVariable = [[self stringValue] retain];//...[_instaceVariable release]; 由此可见，autorelease能延长对象生命期，使其在跨越方法调用边界后依然可以存活一段时间。 保留环使用引用计数机制时，经常要注意的一个问题就是“保留环”（retain cycle），也就是呈环状相互引用的多个对象。这将导致内存泄露，因为循环中的对象其保留计数不会降为0。对于循环中的每个对象来说，至少还有另外一个对象引用着它。 如上图，在这个循环里，所以对象的保留计数都是1。在垃圾收集环境中，通常将这种情况认定为“孤岛”（island of isolation）。此时，垃圾收集器会把三个对象全部回收。而在Objective-C的引用计数架构中，则享受不到这一便利。通常采用“弱引用”（weak reference）来解决此问题，或是从外界命令循环中的某个对象不再保留另外一个对象。这两种办法都能打破保留环，从而避免内存泄露。 小结引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1。若保留计数为正，则对象继续存活。当保留计数降为0时，对象就被销毁。 在对象生命周期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[socket 通信简介]]></title>
      <url>%2F2016%2F03%2F09%2Fsocket-communicate-introduction%2F</url>
      <content type="text"><![CDATA[摘要：我们深谙信息交流的价值，那网络中进程之间如何通信，如我们每天打开浏览器浏览网页时，浏览器的进程怎么与web服务器通信的？当你用QQ聊天时，QQ进程怎么与服务器或你好友所在的QQ进程通信？这些都得靠socket？那什么是socket？socket的类型有哪些？还有socket的基本函数，这些都是本文想介绍的。 1 网络中进程之间如何通信本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类： 消息传递（管道、FIFO、消息队列） 同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量） 共享内存（匿名的和具名的） 远程过程调用（Solaris门和Sun RPC） 但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。 使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆socket”。 2 什么是socket上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写read /write –&gt; 关闭close”模式来操作。我的理解就是socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。 socket一词的起源在组网领域的首次使用是在1970年2月12日发布的文献IETF RFC33中发现的，撰写者为Stephen Carr、Steve Crocker和Vint Cerf。根据美国计算机历史博物馆的记载，Croker写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。” 3 socket的基本操作既然Socket是“open—read/write—close”模式的一种实现，那么Socket就提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。 3.1 socket()函数int socket(int domain, int type, int protocol); socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。 正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为： 1）domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。 2）type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。 3）protocol：顾名思义，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。 注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。 当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。 3.2 bind()函数正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。 int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 函数的三个参数分别为： 1）sockfd：即socket描述字，它是通过socket()函数创建，唯一标识一个socket。bind()函数就是给这个描述字绑定一个名字。 2）addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，例如，ipv4对应的是： 12345678910struct sockaddr_in &#123; sa_family_t sin_family; /* address family: AF_INET */ in_port_t sin_port; /* port in network byte order */ struct in_addr sin_addr; /* internet address */&#125;;/* Internet address. */struct in_addr &#123; uint32_t s_addr; /* address in network byte order */&#125;; ipv6对应的是： 1234567891011struct sockaddr_in6 &#123; sa_family_t sin6_family; /* AF_INET6 */ in_port_t sin6_port; /* port number */ uint32_t sin6_flowinfo; /* IPv6 flow information */ struct in6_addr sin6_addr; /* IPv6 address */ uint32_t sin6_scope_id; /* Scope ID (new in 2.4) */ &#125;;struct in6_addr &#123; unsigned char s6_addr[16]; /* IPv6 address */ &#125;; Unix域对应的是： 12345#define UNIX_PATH_MAX 108struct sockaddr_un &#123; sa_family_t sun_family; /* AF_UNIX */ char sun_path[UNIX_PATH_MAX]; /* pathname */ &#125;; 3）addrlen：对应的是地址的长度。 通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，由系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。 网络字节序与主机字节序主机字节序就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下： a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。 b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。（所见即所得） 网络字节序：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。字节序，顾名思义，字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。 因此，在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。 3.3 listen()、connect()函数如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。 12int listen(int sockfd, int backlog);int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。 connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。 3.4 accept()函数TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址。TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数去接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。 int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。 注意： accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接收的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。 3.5 read()、write()等函数万事具备只欠东风，至此服务器与客户已经建立好连接。可以调用网络I/O进行读写操作了，即实现了网络中不同进程之间的通信！网络I/O操作有下面几组： 12345read()/write()recv()/send()readv()/writev()recvmsg()/sendmsg()recvfrom()/sendto() 推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。它们的声明如下： 12345678910111213141516#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t count);ssize_t write(int fd, const void *buf, size_t count);#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t send(int sockfd, const void *buf, size_t len, int flags);ssize_t recv(int sockfd, void *buf, size_t len, int flags);ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags); read函数是负责从fd中读取内容。当成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。 write函数将buf中的nbytes字节内容写入文件描述符fd。成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有两种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。 其它的就不一一介绍这几对I/O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send/recv。 3.6 close()函数在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。 close一个TCP socket的缺省行为是把该socket标记为已关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。 注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。 4 socket中TCP的三次握手建立连接详解我们知道TCP建立连接要进行“三次握手”，即交换三个分组。大致流程如下： 1）客户端向服务器发送一个SYN J 2）服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1 3）客户端再向服务器发一个确认ACK K+1 这样就完成了三次握手，但是这个三次握手发生在socket的哪几个函数中呢？请看下图： 从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。 总结：客户端的connect在三次握手的第二次返回，而服务器端的accept在三次握手的第三次返回。 5 socket中TCP的四次挥手释放连接详解上面介绍了socket中TCP的三次握手建立过程，与涉及的socket函数。现在我们介绍socket中的四次挥手释放连接的过程，请看下图： 图示过程如下： 1）某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M； 2）另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认，返回一个ACK M+1。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据； 3）一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N； 4）接收到这个FIN的源发送端TCP对它进行确认，返回一个ACK N+1。这样每个方向上都有一个FIN和ACK。 6 一个例子说了这么多了，动手实践一下。下面编写一个简单的服务器、客户端（使用TCP）——服务器端一直监听本机的6666号端口，如果收到连接请求，将接收请求并接收客户端发来的消息；客户端与服务器端建立连接并发送一条消息。 服务器端代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//server#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;errno.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;#include&lt;netinet/in.h&gt;#define MAXLINE 4096int main(int argc, char** argv)&#123; int listenfd, connfd; struct sockaddr_in servaddr; char buff[4096]; int n; if( (listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1 )&#123; printf(&quot;create socket error: %s(errno: %d)\n&quot;,strerror(errno),errno); exit(0); &#125; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(6666); if( bind(listenfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) == -1)&#123; printf(&quot;bind socket error: %s(errno: %d)\n&quot;,strerror(errno),errno); exit(0); &#125; if( listen(listenfd, 10) == -1)&#123; printf(&quot;listen socket error: %s(errno: %d)\n&quot;,strerror(errno),errno); exit(0); &#125; printf(&quot;======waiting for client&apos;s request======\n&quot;); while(1)&#123; if( (connfd = accept(listenfd, (struct sockaddr*)NULL, NULL)) == -1)&#123; printf(&quot;accept socket error: %s(errno: %d)\n&quot;,strerror(errno),errno); continue; &#125; n = recv(connfd, buff, MAXLINE, 0); buff[n] = &apos;/0&apos;; printf(&quot;recv msg from client: %s\n&quot;, buff); close(connfd); &#125; close(listenfd);&#125; 客户端代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//client#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;errno.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;#include&lt;netinet/in.h&gt;#define MAXLINE 4096int main(int argc, char** argv)&#123; int sockfd, n; char recvline[4096], sendline[4096]; struct sockaddr_in servaddr; if( argc != 2)&#123; printf(&quot;usage: ./client &lt;ipaddress&gt;\n&quot;); exit(0); &#125; if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)&#123; printf(&quot;create socket error: %s(errno: %d)\n&quot;, strerror(errno),errno); exit(0); &#125; memset(&amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(6666); if( inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;= 0)&#123; printf(&quot;inet_pton error for %s\n&quot;,argv[1]); exit(0); &#125; if( connect(sockfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) &lt; 0)&#123; printf(&quot;connect error: %s(errno: %d)\n&quot;,strerror(errno),errno); exit(0); &#125; printf(&quot;send msg to server: \n&quot;); fgets(sendline, 4096, stdin); if( send(sockfd, sendline, strlen(sendline), 0) &lt; 0)&#123; printf(&quot;send msg error: %s(errno: %d)\n&quot;, strerror(errno), errno); exit(0); &#125; close(sockfd); exit(0);&#125; 当然上面的代码很简单，也有很多缺点，这只是简单的演示socket的基本函数使用。其实不管多复杂的网络程序，都使用的这些基本函数。上面的服务器使用的是迭代模式，即只有处理完一个客户端请求才会去处理下一个客户端的请求，这样的服务器处理能力是很弱的，现实中的服务器都需要有并发处理能力！为了需要并发处理，服务器需要fork()一个新的进程或者线程去处理请求等。 7 动动手留下一个问题。是否熟悉Linux下网络编程？如熟悉，编写如下程序完成如下功能： 服务器端： 接收地址192.168.100.2的客户端信息，如信息为“Client Query”，则打印“Receive Query” 客户端： 向地址192.168.100.168的服务器端顺序发送信息“Client Query test”，“Cleint Query”，“Client Query Quit”，然后退出。 题目中出现的IP地址可以根据实际情况而定。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objective-C中的alloc和init问题]]></title>
      <url>%2F2016%2F03%2F07%2Fobjc-alloc-init%2F</url>
      <content type="text"><![CDATA[摘要：这些都是小知识点，没有办法，博主自学过来的，关于一些知识并没有形成系统，这里也是博主自己的学习笔记。发现这个问题，拿出来和大家分享，有什么不足，还请指正。 从开始学的NSString *name=[[NSString alloc] init]起，仅知道这句话是分配内存空间，一直在用，从来没考虑过它的内部是怎么实现的。今天无意中看到了这一句代码： 1234NSString *name = [NSString alloc];NSLog(@&quot;%p&quot;,name);name = [name init];NSLog(@&quot;%p&quot;,name); 试着打印了一下，发现两个的内存地址不一样： alloc是开辟一个内存空间，init是初始化，为什么初始化不在原有的内存空间上初始化，而是重新开辟一个内存空间。于是开始查资料，这时又发现了一个新的迷惑： 1234NSObject *obj = [NSObject alloc];NSLog(@&quot;%p&quot;,obj);obj = [obj init];NSLog(@&quot;%p&quot;,obj); 打印结果： 怎么地址又变一样了？再打印NSArray的试一试： 1234NSArray *person = [NSArray alloc];NSLog(@&quot;%p&quot;,person);person = [person init];NSLog(@&quot;%p&quot;,person); 再次打印结果： 仍然是不一样的。原因是什么呢？首先看看NSStrng的init方法吧： 123456-(id)init&#123; if(self = [super init]) &#123; // 重新赋值 //… &#125;&#125; 从代码中可以分析，self=[super init]如果不为nil，就重新分配内存空间，这就解释了为什么 NSString，NSArray的调用alloc]init]方法后，内存地址会不一样，但是NSObject为什么会一样呢，我们知道NSObject是一切类的基类，当[[NSString alloc]init]执行时，调用的[super init]就是 NSObject中的init方法，既然NSObject身为基类，它也就无法调用super init，所以当NSObject执行[[NSObject alloc]init]时，也就没有了init重新分配空间这一环节。 至于苹果公司为什么初始化一个实例要分两步，个人认为是方便构造后初始化不同的方法，如果用 new关键字，只能调用一个init，而不能调用initWithName等方法。 知识拓展： NSString alloc之后，没有init，那么这部分alloc后的内存空间可不可以用？答案是显而易见的，如果可以用，苹果公司也就没必要提供一个init方法，那么alloc后的指针称为什么呢？ ——悬挂指针。 如果一个地方指针既不为空，也没有被设置为指向一个已知的对象，则这样的指针称为悬挂指针。在程序里面是很危险的事。当程序运行使用该指针时，程序不能判断指针的合法性，将会产生很严重的错误。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS Project与OS X Project中plist使用区别]]></title>
      <url>%2F2016%2F03%2F06%2Fios-application-plist-diff%2F</url>
      <content type="text"><![CDATA[摘要：这篇文章来源于开源中国的一道题目，因为答题，所以coding，所以发现了原来还有这样子的区别。因此，拿出来和大家分享。 之前在开源中国看到一个求源代码的问题: 123456789模拟一个动物园系统MyZoo 1、动物园里面有三种动物:Panda,Elephant,Kangaroo 2、三种动物都有一定的数量(不止一只) 3、动物有各自不同的食量(以天为单位的食量),并且每天都在消耗食物。 4、动物园里的食物有固定的储备,而且假设三种动物都吃这一种食物。 5、每个动物都有不同的生产周期,每当到了这种动物的生产周期,动物园就会出现一位新生宝宝(假设其食量和成年动物是一样的)。 6、在主循环里模拟动物园的运转情况,要求在控制台上输出如下内容:第几天、动物的数量、动物园饲料的余量,直到饲料不够吃为止。 7、动物的数量,食量,生产周期,饲料总量都应该是可以配置的(在同一个文件中统一配置) 因此创建了一个OS X Project，使用plist当做这个动物园系统的初始数据的配置，代码结构如下： 在main.m文件中实现上述题目的要求： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#import &lt;Foundation/Foundation.h&gt;#import &quot;Tool.h&quot; int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... Panda *panda = [[Panda alloc] init]; Elephant *elephant = [[Elephant alloc] init]; Kangaroo *kangaroo = [[Kangaroo alloc] init]; //读取plist NSString *plistPath = [[NSBundle mainBundle] pathForResource:@&quot;data&quot; ofType:@&quot;plist&quot;]; NSMutableDictionary *data = [[NSMutableDictionary alloc] initWithContentsOfFile:plistPath]; NSLog(@&quot;%@&quot;, plistPath); [Tool initWithAnimalDictionary:panda andDict:data]; [Tool initWithAnimalDictionary:elephant andDict:data]; [Tool initWithAnimalDictionary:kangaroo andDict:data]; int fooder_num = 0; int surplus = 0; int day = 1; NSDictionary *fooderDict = [data objectForKey:@&quot;fodder&quot;]; fooder_num = [[fooderDict objectForKey:@&quot;count_num&quot;] intValue]; surplus = fooder_num; while(surplus &gt; 0)&#123; if(0 == (day % [panda parturitionDays]))&#123; [panda setCount:([panda count] + 1)]; &#125; if(0 == (day % [elephant parturitionDays]))&#123; [elephant setCount:([elephant count] + 1)]; &#125; if(0 == (day % [kangaroo parturitionDays]))&#123; [kangaroo setCount:([kangaroo count] + 1)]; &#125; surplus = fooder_num - ([panda count] * [panda foodConsumption] + [elephant count] * [elephant foodConsumption] + [kangaroo count] * [kangaroo foodConsumption]); fooder_num = surplus; if(surplus)&#123; NSLog(@&quot;第 %d 天，熊猫:%d 只，大象:%d 头，袋鼠:%d 只，饲料余量:%d 。\n&quot;, day, [panda count], [elephant count], [kangaroo count], surplus); &#125; day++; &#125; &#125; return 0;&#125; 而这个时候遇见了问题，下面这句代码： 1NSString *plistPath = [[NSBundle mainBundle] pathForResource:@&quot;data&quot; ofType:@&quot;plist&quot;]; 在执行时一直是null，无法找到文件路径。而后在iOS Application Project – Single View Application中，plistPath是正确值,这下就不知道问题是什么了。看了[NSBundle mainBundle]中对于不同文件夹使用不同的方法,确定将文件放在工程下是使用上述代码。最后尝试各种方法，找到了一种解决方案： 如上图所示，在Build Phase中Compile Sources中添加data.plist文件即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode 使用小记]]></title>
      <url>%2F2016%2F03%2F05%2Fxcode-console-cli%2F</url>
      <content type="text"><![CDATA[摘要：Xcode 是iOS开发者的福利，不得不说乔帮主给爱疯开发者提供了从业便利。我们这些后继者都发自内心的膜拜。也正是乔帮主的偏执，成就了苹果的伟大。Xcode 的可视化操作便捷，可是为了更灵活地debug，我们还是需要掌握一些提供效率的debug命令，文章分享迄今为止博主所知晓的debug命令，也会保持本文的持续更新。希望对大家有所帮助。 debug 命令表 命令 解释 break NUM 在指定的行上设置断点 bt 显示所有的调用栈帧，该命令可用来显示函数的调用顺序 clear 删除设置在特定源文件、特定行上的断点，其用法为：clear FILENAME:NUM continue 继续执行正在调试的程序，该命令用在程序由于处理信号或断点而导致停止运行时 display EXPR 每次程序停止后显示表达式的值。表达式由程序定义的变量组成 file FILE 装载指定的可执行文件进行调试 help NAME 显示指定命令的帮助信息 info break 显示当前断电清单，包括到达断点处的次数等 info files 显示被调试文件的详细信息 info func 显示所有的函数名称 info local 显示当前函数中的局部变量信息 info prog 显示被调试程序的执行状态 info var 显示所有的全局和静态变量名称 kill 终止正被调试的程序 list 显示源代码段 make 在不退出gdb的情况下运行make工具 next 在不单步执行进入其他函数的情况下，向前执行一行源代码 print EXPR 显示表达式EXPR的值 print-object 打印一个对象 print (int) name 打印一个类型 print-object [artist description] 调用一个函数 set artist - @”test” 设置变量值 help 查看帮助 快捷键 文件 按键 作用 CMD + N 新文件 CMD + SHIFT + N 新项目 CMD + O 打开 CMD + S 保存 CMD + SHIFT + S 另存为 CMD + W 关闭窗口 CMD + SHIFT + W 关闭文件 编辑 按键 作用 CMD + [ 左缩进 CMD + ] 右缩进 CMD + CTRL + LEFT 折叠 CMD + CTRL + RIGHT 取消折叠 CMD + CTRL + TOP 折叠全部函数 CMD + CTRL + BOTTOM 取消全部函数折叠 CTRL + U 取消全部折叠 CMD + D 添加书签 CMD + / 注释或取消注释 CTRL + . 参数提示 ESC 自动提示列表 调试 按键 作用 CMD + \ 设置或取消断点 CMD + OPT + \ 允许或禁用当前断点 CMD + OPT + B 查看全部断点 CMD + RETURN 编译并运行（根据设置决定是否启用断点） CMD + R 编译并运行（不触发断点） CMD + Y 编译并调试（触发断点） CMD + SHIFT + RETURN 终止运行或调试 CMD + B 编译 CMD + SHIFT + K 清理 窗体 按键 作用 CMD + SHIFT + B 编译窗口 CMD + SHIFT + Y 调试代码窗口 CMD + SHIFT + R 调试控制台 CMD + SHIFT + E 主编辑窗口调整 帮助 按键 作用 CMD + OPT + ? 开发手册 CMD + CTRL + ? 快速帮助 Command + Shift + E 扩展编辑器 Command + [ 左移代码块 Command + ] 右移代码块 Tab 接受代码提示 Esc 显示代码提示菜单 Ctrl + . （句点） 循环浏览代码提示 Shift + Ctrl + . （句点） 反向循环浏览代码提示 Ctrl + / 移动到代码提示中的下一个占位符 Command + Ctrl + S 创建快照 Ctrl + F 前移光标 Ctrl + B 后移光标 Ctrl + P 移动光标到上一行 Ctrl + N 移动光标到下一行 Ctrl + A 移动光标到本行行首 Ctrl + E 移动光标到本行行尾 Ctrl + T 交换光标左右两边的字符 Ctrl + D 删除光标右边的字符 Ctrl + K 删除本行 Ctrl + L 将插入点置于窗口正中 Command + Alt + D 显示open quickly 窗口 Command + Alt + 上方向键 打开配套文件 Command + D 添加书签 Option + 双击 在文档中搜索 Command + Y 以调试方式运行程序 Command + Alt + P 继续（在调试中） Command + Alt + 0 跳过 Command + Alt + I 跳入 Command + Alt + T 跳出]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OAuth2.0 协议]]></title>
      <url>%2F2016%2F03%2F02%2Foauth2-protocol%2F</url>
      <content type="text"><![CDATA[摘要：OAuth（Open Authorization），协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是OAuth的授权不会使第三方触及到用户的帐号信息（如用户名和密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户的授权，因此，OAuth是安全的。这些解释都是官方的，本文中博主会根据自己的学习所得，整理分享对OAuth协议的理解。 简介OAuth（Open Authorization），协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是OAuth的授权不会使第三方触及到用户的帐号信息（如用户名和密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户的授权，因此，OAuth是安全的。 这些解释其实都是可以在网上搜索到的。为了解释的更加清楚，接下来博主结合实例绘图解释： 整个OAuth授权过程中，三者都获得了自己的便利。用户可以不用注册帐号，可以直接使用关联帐号就可登录新的网站使用资源，且不用担心帐号失窃，因为这个授权过程是安全的。慕课网可以更加轻易的获取用户量。腾讯将海量的数据开放给第三方网站，既是为其他小企业做的贡献，也增大了自身的知名度。 版本OAuth1.0 发布于2007年末，存在严重安全漏洞。 OAuth2.0 发布于2010年初，解决上一版本的安全漏洞，现被各大网站公司一直使用。 应用场景1）QQ用户授权慕课网使用其QQ帐号相关信息。 2）获取授权后，在符合权限规则的情况下访问各种API。 3）淘宝帐号，可在支付宝，阿里云中使用。 总的来说，OAuth是某一独立系统，开放其用户资源给另一系统使用的协议。 实现过程（三个步骤） 步骤一：请求OAuth登录页面Request Token URL，未授权的令牌请求服务地址。 慕课网请求QQ登录页面时使用的带有特定参数的URL。 例如， 123 https://graph.qq.com/oauth/...?... &amp;client_id=100490398&amp;... &amp;redirect_uri=http://www.mukewang.com/... 第一行为QQ登录OAuth页面的地址。 第二行为一个唯一的站点ID，必须和预置服务器上的一致。 第三行为一个回调地址，必须和预置服务器上的一致。 步骤二：用户使用QQ号登录并授权123 https://graph.qq.com/oauth/...?... &amp;client_id=100490398&amp;... &amp;redirect_uri=http://www.mukewang.com/... 跳转到 1 http://www.mukewang.com/user/qqcallback?code=xxxxx.... 慕课网服务器使用 1 $_GET[&apos;code&apos;]; 获取加密字符。 步骤三：返回登录结果User Authorization URL，用户授权的令牌请求服务地址 为保证安全，确保code是合法服务器获得，没有被劫持，则需要合法接收服务器再发送一个请求（User Authorization URL）。 例如，用户QQ登录授权之后需要请求一个带有特定参数的URL。 1234 https://xxx.qq.com/oauth/...?... &amp;client_id=100490398&amp;... &amp;client_secret=xxxxxx&amp;... &amp;code=xxxxx...... code在短期内会过期且只可使用一次，通常是10秒左右。基于安全考虑。 关于AccessTokenAccessToken，用户通过第三方应用访问OAuth接口的令牌，具有较长生命周期（10天半个月甚至更长）。如果AccessToken过期，可以重新登录授权，或在User Authorization URL中指定参数（刷新AccessToken的参数，各平台各有不同）”……&amp;need_refresh_token=true&amp;……”。 获取AccessToken就可以访问授权帐号的资源，例如，通过慕课网把自己喜欢的课程分享到QQ空间。 AccessToken与RefreshTokenRefreshToken也是有生命周期的，不过比AccessToken生命周期要长，各大平台不一样。 使用实例类比AccessToken 将返回的XML或JSON解析成我们想要的数据 希望对大家有所帮助。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用的算法思想总结]]></title>
      <url>%2F2016%2F02%2F22%2Falgorithm-idea%2F</url>
      <content type="text"><![CDATA[摘要：对于计算机科学而言，算法是一个非常重要的概念。它是程序设计的灵魂，是将实际问题同解决该问题的计算机程序建立起联系的桥梁。文章主要介绍一些常用的算法思想。 一、穷举法思想穷举法，又称为强力法。它是一种最为直接，实现最为简单，同时又最为耗时的一种解决实际问题的算法思想。 基本思想：在可能的解空间中穷举出每一种可能的解，并对每一个可能解进行判断，从中得到问题的答案。 使用穷举法思想解决实际问题，最关键的步骤是划定问题的解空间，并在该解空间中一一枚举每一个可能的解。这里有两点需要注意，一是解空间的划定必须保证覆盖问题的全部解，二是解空间集合及问题的解集一定是离散的集合，也就是说集合中的元素是可列的、有限的。 穷举法用时间上的牺牲换来了解的全面性保证，因此穷举法的优势在于确保得到问题的全部解，而瓶颈在于运算效率十分低下。但是穷举法算法思想简单，易于实现，在解决一些规模不是很大的问题，使用穷举法不失为一种很好地选择。 现在我们通过具体的实例来理解穷举法思想。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 实例：寻找[1,100]之间的素数 * */#include &lt;stdio.h&gt; /** * 判断n是否是素数，是则返回1，不是则返回0 */int isPrime(int n)&#123; int i = 0; for (i = 2; i &lt; n; i++) &#123; if (0 == n % i) &#123; return 0; &#125; &#125; return 1;&#125; /** * 寻找[low,high]之间的素数 */void getPrime(int low, int high)&#123; int i = 0; for (i = low; i &lt;= high; i++) &#123; if (isPrime(i)) &#123; printf(&quot;%d &quot;, i); &#125; &#125;&#125; int main(int argc, const char * argv[]) &#123; // insert code here... int low = 0, high = 0; printf(&quot;Please input the domain for searching prime\n&quot;); printf(&quot;low limitation:&quot;); scanf(&quot;%d&quot;, &amp;low); printf(&quot;high limitation:&quot;); scanf(&quot;%d&quot;, &amp;high); printf(&quot;The whole primes in this domain are\n&quot;); getPrime(low, high); getchar(); return 0;&#125; 程序运行结果： 12345Please input the domain for searching primelow limitation:1high limitation:100The whole primes in this domain are1 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 二、递归与分治思想递归与分治的算法思想往往是相伴而生的，它们在各类算法中使用非常频繁，应用递归和分治的算法思想有时可以设计出代码简洁且比较高效的算法来。 在解决一些比较复杂的问题，特别是解决一些规模较大得问题时，常常将问题进行分解。具体来说，就是将一个规模较大的问题分割成规模较小的同类问题，然后将这些小问题的子问题逐个加以解决，最终也就将整个大问题解决了。这种思想称之为分治。在解决一些问题比较复杂、计算量庞大的问题时经常被用到。 最为经典的使用分治思想设计的算法就是“折半查找算法”。折半查找算法利用了元素之间的顺序关系（有序序列），采用分而治之的策略，不断缩小问题的规模，每次都将问题的规模减小至上一次的一半。 而递归思想也是一种常见的算法设计思想，所谓递归算法，就是一种直接或间接地调用原算法本身的一种算法。 接下来我们通过实例代码来理解递归、分治思想。 分治思想： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 有一个数组A[10]，里面存放了10个整数，顺序递增 * A[10] = &#123;2, 3, 5, 7, 8, 10, 12, 15, 19, 21&#125; * */ #include &lt;stdio.h&gt; int bin_search(int A[], int n, int key)&#123; int low = 0, high = 0, mid = 0; high = n - 1; while (low &lt;= high) &#123; mid = (low + high) / 2; if (A[mid] == key) &#123; //查找成功，返回mid return mid; &#125; if (A[mid] &lt; key) &#123; //在后半序列中查找 low = mid + 1; &#125; if (A[mid] &gt; key) &#123; //在前半序列中查找 high = mid - 1; &#125; &#125; return -1; //查找失败&#125; int main(int argc, const char * argv[]) &#123; // insert code here... int A[10] = &#123;2, 3, 5, 7, 8, 10, 12, 15, 19, 21&#125;; int i = 0, n = 0, addr = 0; printf(&quot;The contents of the Array A[10] are\n&quot;); for (i = 0; i &lt; 10; i++) &#123; printf(&quot;%d &quot;,A[i]); //显示数组A中的内容 &#125; printf(&quot;\nPlease input a interger for search\n&quot;); scanf(&quot;%d&quot;, &amp;n); //输入待查找得元素 addr = bin_search(A, 10, n); //折半查找，返回该元素在数组中的下标 if (-1 != addr) &#123; printf(&quot;%d is at the %dth unit is array A\n&quot;, n, addr); &#125;else&#123; printf(&quot;There is no %d in array A\n&quot;, n); //查找失败 &#125; getchar(); return 0;&#125; 运行结果： 12345The contents of the Array A[10] are2 3 5 7 8 10 12 15 19 21Please input a interger for search1212 is at the 6th unit is array A 递归思想： 123456789101112131415161718192021222324252627/** * 计算n的阶乘n! * */ #include &lt;stdio.h&gt; int factorial(int n)&#123; if (0 == n) &#123; return 1; &#125;else&#123; return n * factorial(n - 1); &#125;&#125; int main(int argc, const char * argv[]) &#123; // insert code here... int n = 0, result = 0; printf(&quot;Please input factorial number\n&quot;); scanf(&quot;%d&quot;, &amp;n); result = factorial(n); printf(&quot;result is %d&quot;, result); getchar(); return 0;&#125; 运行结果： 123Please input factorial number6result is 720 三、贪心算法思想贪心算法的思想非常简单且算法效率很高，在一些问题的解决上有着明显的优势。 先来看一个生活中的例子。假设有3种硬币，面值分别为1元、5角、1角。这3种硬币各自的数量不限，现在要找给顾客3元6角钱，请问怎样找才能使得找给顾客的硬币数量最少呢？你也许会不假思索的说出答案：找给顾客3枚1元硬币，1枚5角硬币，1枚1角硬币。其实也可以找给顾客7枚5角硬币，1枚1角硬币。可是在这里不符合题意。在这里，我们下意识地应用了所谓贪心算法解决这个问题。 所谓贪心算法，就是总是做出在当前看来是最好的选择的一种方法。以上述的题目为例，为了找给顾客的硬币数量最少，在选择硬币的面值时，当然是尽可能地选择面值大的硬币。因此，下意识地遵循了以下方案： （1）首先找出一个面值不超过3元6角的最大硬币，即1元硬币。 （2）然后从3元6角中减去1元，得到2元6角，再找出一个面值不超过2元6角的最大硬币，即1元硬币。 （3）然后从2元6角中减去1元，得到1元6角，再找出一个面值不超过1元6角的最大硬币，即1元硬币。 （4）然后从1元6角中减去1元，得到6角，再找出一个面值不超过6角的最大硬币，即5角硬币。 （5）然后从6角中减去5角，得到1角，再找出一个面值不超过1角的最大硬币，即1角硬币。 （6）找零钱的过程结束。 这个过程就是一个典型的贪心算法思想。 因此，不难看出应用贪心算法求解问题，并不从问题的整体最优上加以考虑，它所作出的每一步选择只是在某种意义上得局部最优选择。因此，严格意义上讲，要使用贪心算法求解问题，该问题应当具备以下性质。 （1）贪心选择性质 所谓贪心选择性质，就是指所求解的问题的整体最优解可以通过一系列的局部最优解得到。所谓局部最优解，就是指在当前的状态下做出的最好选择。 （2）最优子结构性质 当一个问题的最优解包含着它的子问题的最优解时，就称此问题具有最优子结构性质。 我们经常使用的哈夫曼（Huffman Tree）编码算法，求解最小生成树的克鲁斯卡尔（Kruskal）算法和普利姆（Prim）算法，求解图的单源最短路径的迪克斯特拉（Dijkstra）算法都是基于贪心算法的思想设计的。 下面，我们来通过实例代码来理解贪心算法思想。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * 最优装船问题 * 有一批集装箱要装入一个载质量为C的货船中，每个集装箱的质量由用户自己输入指定，在货船的装载体积不限的前提下，如何装载集装箱才能尽可能多地将集装箱装入货船中。 */#include &lt;stdio.h&gt; void sort(int w[], int t[], int n)&#123; int i = 0, j = 0, tmp = 0; //存放w[]中的内容，用于排序 int *w_tmp = (int *)malloc(sizeof(int) * n); for (i = 0; i &lt; n; i++) &#123; t[i] = i; //初始化数组t &#125; for (i = 0; i &lt; n; i++) &#123; w_tmp[i] = w[i]; &#125; for (i = 0; i &lt; n - 1; i++) &#123; //冒泡排序 for (j = 0; j &lt; n - i - 1; j++) &#123; if (w_tmp[j] &gt; w_tmp[j+1]) &#123; tmp = w_tmp[j]; w_tmp[j] = w_tmp[j+1]; w_tmp[j+1] = tmp; tmp = t[j]; t[j] = t[j+1]; t[j+1] = tmp; &#125; &#125; &#125;&#125; void Loading(int x[], int w[], int c, int n)&#123; int i = 0; //存放w[]的下标，如果t[i]、t[j]、i&lt;j，则w[i]&lt;=w[j] int *t = (int *)malloc(sizeof(int) * n); //排序，用数组t[[]存放w[]的下标 sort(w, t, n); for (i = 0; i &lt; n; i++) &#123; x[i] = 0; //初始化数组x[] &#125; for (i = 0; i &lt; n &amp;&amp; w[t[i]] &lt;= c; i++) &#123; x[t[i]] = 1; //将第t[i]个集装箱装入货船中 c = c - w[t[i]]; //变量c中存放货船的剩余载质量 &#125;&#125; int main(int argc, const char * argv[]) &#123; // insert code here... int x[5], w[5], c = 0, i = 0; printf(&quot;Please input the maximum loading of the sheep\n&quot;); scanf(&quot;%d&quot;, &amp;c); // printf(&quot;Please input the weight of FIVE box\n&quot;); for (i = 0; i &lt; 5; i++) &#123; // scanf(&quot;%d&quot;, &amp;w[i]); &#125; Loading(x, w, c, 5); // printf(&quot;The following boxes will be loaded\n&quot;); for (i = 0; i &lt; 5; i++) &#123; // if (1 == x[i]) &#123; printf(&quot;BOX:%d &quot;, i); &#125; &#125; getchar(); return 0;&#125; 运行结果： 123456Please input the maximum loading of the sheep13Please input the weight of FIVE box5 7 6 3 2The following boxes will be loadedBOX:0 BOX:3 BOX:4 以上，就是对算法设计中几个常见的思想的总结。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Apk 反编译]]></title>
      <url>%2F2016%2F02%2F18%2Fapk-decompile%2F</url>
      <content type="text"><![CDATA[摘要：最近看见一些正版软件，便想到pc端软件的破解，便在网络上大肆搜索，终于找到了一个办公软件破解key的软件，对其实现非常感兴趣，想着反编译其apk，在网上也找了很多相关的实现方式，这里，本文介绍博主使用的简约方法与工具。 步骤1、将apk文件解压，得到其中的classes.dex（java文件编译再通过dx工具打包而成的）。 将classes.dex复制到d2j-dex2jar.bat所在目录dex2jar-0.0.9.13文件夹。 在命令行下定位到d2j-dex2jar.bat所在目录，运行 d2j-dex2jar.bat classes.dex 生成classes_dex2jar.jar dex2jar工具下载 2、使用jdgui.exe打开classes_dex2jar.jar，即可看见源码。 jdgui工具下载 只需以上两步，即可获得apk源码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objective-C 中 new、alloc和init的区别]]></title>
      <url>%2F2016%2F02%2F16%2Fobjc-new-alloc-init%2F</url>
      <content type="text"><![CDATA[在实际开发中很少会用到new，一般创建对象我们看到的全是[[className alloc] init]，但是并不意味着你不会接触到new，在一些代码中还是会看到[className new]，还有去面试的时候，也很可能被问到这个问题。 那么，它们两者之间到底有什么区别呢？我们先来看源码： 12345678+ new &#123; id newObject = (*_alloc)((Class)self, 0); Class metaClass = self-&gt;isa; if (class_getVersion(metaClass) &gt; 1) return [newObject init]; else return newObject; &#125; 而 alloc/init 像这样 1234567+ alloc &#123; return (*_zoneAlloc)((Class)self, 0, malloc_default_zone()); &#125; - init &#123; return self; &#125; 通过源码中我们发现，[className new]基本等同于[[className alloc] init]，区别只在于alloc分配内存的时候使用了zone。 那么，这个zone是个什么东西呢？ 它是给对象分配内存的时候，把关联的对象分配到一个相邻的内存区域内，以便于调用时消耗很少的代价，提升了程序处理速度。 为什么不推荐使用new？ 不知大家发现了没有，如果使用new的话，初始化方法被固定死只能调用init。而你想调用initXXX怎么办？没门儿！据说最初的设计是完全借鉴Smalltalk语法来的。传说那个时候已经有allocFromZone:这个方法，但是这个方法需要传个参数id myCompanion = [[TheClass allocFromZone:[self zone]] init]; 这个方法像下面这样： 123+ allocFromZone:(void *) z &#123; return (*_zoneAlloc)((Class)self, 0, z); &#125; 后来简化为下面这个： 123+ alloc &#123; return (*_zoneAlloc)((Class)self, 0, malloc_default_zone()); &#125; 但是，出现个问题：这个方法只是给对象分配了内存，并没有初始化实例变量。 是不是又回到new那样的处理方式：在方法内部隐式调用init方法呢？后来发现“显示调用总比隐式调用更好”，所以后来就把两个方法分开了。 概括来说，new和alloc/init在功能上几乎是一致的，分配内存并完成初始化。差别在于，采用new的方式只能采用默认的init方法完成初始化，采用alloc的方式可以用其他定制的初始化方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[内存对齐详解]]></title>
      <url>%2F2016%2F02%2F10%2Fmemory-alignment%2F</url>
      <content type="text"><![CDATA[摘要：现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问， 这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是内存对齐。本文分享博主对内存对齐的一些理解。 一、什么是内存对齐现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问， 这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是内存对齐。 二、内存对齐的原因1、平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 2、性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。 三、对齐规则每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。程序员可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16 来改变这一系数，其中的n 就是你要指定的“对齐系数”。 规则1数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0 的地方，以后每个数据成员的对齐按照#pragma pack 指定的数值和这个数据成员自身长度中，比较小的那个进行。 规则2结构（或联合）的整体对齐规则：在数据成员完成各自对齐之后，结构（或联合）本身也要进行对齐，对齐将按照#pragma pack 指定的数值和结构（或联合）最大数据成员长度中，比较小的那个进行。 规则3结合1、2 可推断：当#pragma pack 的n 值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。 四、试验接下来我们通过实际例子来说明这些规则。 试验环境：编译器包括GCC 3.4.2 和VC6.0 的C 编译器。 平台：Windows XP SP2。 我们将用典型的struct 对齐来说明。首先我们定义一个struct： 1234567#pragma pack(n) /* n = 1, 2, 4, 8, 16 */struct test_t&#123; int a; char b; short c; char d;&#125;; #pragma pack(n) 首先我们首先确认在试验平台上的各个类型的size，经验证两个编译器的输出均为： 123sizeof(char) = 1sizeof(short) = 2sizeof(int) = 4 验证过程如下：通过#pragma pack(n)改变“对齐系数”，然后查看sizeof(struct test_t)的值。 字节对齐(#pragma pack(1))输出结果：sizeof(struct test_t) = 8 [两个编译器输出一致] 分析过程： 成员数据对齐123456789101112#pragma pack(1)struct test_t &#123; /* 长度4 &lt; 1 按1 对齐；起始offset=0 0%1=0；存放位置区间[0,3] */ int a; /* 长度1 = 1 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */ char b; /* 长度2 &gt; 1 按1 对齐；起始offset=5 5%1=0；存放位置区间[5,6] */ short c; /* 长度1 = 1 按1 对齐；起始offset=7 7%1=0；存放位置区间[7] */ char d;&#125;; #pragma pack() 成员总大小=8 整体对齐整体对齐系数= min((max(int,short,char), 1) = 1 整体大小(size)=$(成员总大小) 按$(整体对齐系数) 圆整= 8 / 8%1=0 / [注1] [注1] 什么是圆整 举例说明：如上面的8 字节对齐中的“整体对齐”，整体大小=9 按4 圆整= 12 圆整的过程：从9 开始每次加一，看是否能被4 整除，这里9，10，11 均不能被4 整除，到12 时可以，则圆整结束。 字节对齐(#pragma pack(2))输出结果：sizeof(struct test_t) = 10 [两个编译器输出一致] 分析过程： 成员数据对齐123456789101112#pragma pack(2)struct test_t &#123; /* 长度4 &gt; 2 按2 对齐；起始offset=0 0%2=0；存放位置区间[0,3] */ int a; /* 长度1 &lt; 2 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */ char b; /* 长度2 = 2 按2 对齐；起始offset=6 6%2=0；存放位置区间[6,7] */ short c; /* 长度1 &lt; 2 按1 对齐；起始offset=8 8%1=0；存放位置区间[8] */ char d;&#125;; #pragma pack() 成员总大小=9 整体对齐整体对齐系数= min((max(int,short,char), 2) = 2 整体大小(size)=$(成员总大小) 按$(整体对齐系数) 圆整= 10 / 10%2=0 / 字节对齐(#pragma pack(4))输出结果：sizeof(struct test_t) = 12 [两个编译器输出一致] 分析过程： 成员数据对齐123456789101112#pragma pack(4)struct test_t &#123; /* 长度4 = 4 按4 对齐；起始offset=0 0%4=0；存放位置区间[0,3] */ int a; /* 长度1 &lt; 4 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */ char b; /* 长度2 &lt; 4 按2 对齐；起始offset=6 6%2=0；存放位置区间[6,7] */ short c; /* 长度1 &lt; 4 按1 对齐；起始offset=8 8%1=0；存放位置区间[8] */ char d;&#125;; #pragma pack() 成员总大小=9 整体对齐整体对齐系数= min((max(int,short,char), 4) = 4 整体大小(size)=$(成员总大小) 按$(整体对齐系数) 圆整= 12 / 12%4=0 / 字节对齐(#pragma pack(8))输出结果：sizeof(struct test_t) = 12 [两个编译器输出一致] 分析过程： 成员数据对齐12345678910111213#pragma pack(8)struct test_t &#123; /* 长度4 &lt; 8 按4 对齐；起始offset=0 0%4=0；存放位置区间[0,3] */ int a; /* 长度1 &lt; 8 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */ char b; /* 长度2 &lt; 8 按2 对齐；起始offset=6 6%2=0；存放位置区间[6,7] */ short c; /* 长度1 &lt; 8 按1 对齐；起始offset=8 8%1=0；存放位置区间[8] */ char d;&#125;; #pragma pack() 成员总大小=9 整体对齐整体对齐系数= min((max(int,short,char), 8) = 4 整体大小(size)=$(成员总大小) 按$(整体对齐系数) 圆整= 12 / 12%4=0 / 字节对齐(#pragma pack(16))输出结果：sizeof(struct test_t) = 12 [两个编译器输出一致] 分析过程： 成员数据对齐12345678910111213#pragma pack(16)struct test_t &#123; /* 长度4 &lt; 16 按4 对齐；起始offset=0 0%4=0；存放位置区间[0,3] */ int a; /* 长度1 &lt; 16 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */ char b; /* 长度2 &lt; 16 按2 对齐；起始offset=6 6%2=0；存放位置区间[6,7] */ short c; /* 长度1 &lt; 16 按1 对齐；起始offset=8 8%1=0；存放位置区间[8] */ char d;&#125;; #pragma pack() 成员总大小=9 整体对齐整体对齐系数= min((max(int,short,char), 16) = 4 整体大小(size)=$(成员总大小) 按$(整体对齐系数) 圆整= 12 / 12%4=0 / 五、结论8 字节和16 字节对齐试验证明了“规则”的第3 点：“当#pragma pack 的n 值等于或超过所有数据成员长度的时候，这个n 值的大小将不产生任何效果”。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[拆拆 iOS 数据持久化]]></title>
      <url>%2F2016%2F01%2F19%2Fios-data-persistence%2F</url>
      <content type="text"><![CDATA[持久存储是一种非易失性存储，在重启设备时也不会丢失数据。Cocoa框架提供了几种数据持久化机制： 1）属性列表； 2）对象归档； 3）iOS的嵌入式关系数据库SQLite3； 4）Core Data。 在iOS开发中，持久化数据的方法也并不限于属性列表、对象归档、SQLite3和Core Data。它们只是四种最常用且简单的方法。其实也可以使用传统C语言I/O调用（比如，fopen()）读写数据，也可以使用Cocoa的底层文件管理工具。只不过这两种方法都需要写很多代码，并且没有必要这么做。 一、应用的沙盒Cocoa提供的四种数据持久化机制都涉及一个共同因素，即应用的/Documents文件夹。每个应用都有自己的/Documents文件夹，且能读写各自的/Documents目录中的内容。 为了便于理解，我们先来看一下iPhone模拟器使用的文件夹布局，从而了解iOS中应用是如何组织的。打开Finder窗口，找到主目录，找到Library（资源库）目录，找到Developer/CoreSimulator/Devices/，在该目录中可以看到一些子目录，分别对应Xcode中的模拟器。子目录的名称是Xcode自动生成的GUID（Globally Unique Identifier，全局唯一标识符），因此无法确定每个目录对应哪一个模拟器。解决这个问题的方法是找到模拟器目录中名为device.plist的文件，并打开它，就可以看见一个对应模拟器设备名称的键。 虽然这是模拟器的目录，但实际设备上的文件结构与此相似。如果想看到设备上应用程序的沙盒，就将它连接到Mac上并打开Xcode的Devices窗口，在窗口边侧栏可以看到该设备，选中它然后在Installed Apps表中选择一个应用程序。在表的下方有一个看起来像齿轮的图表。点击它并在弹出菜单中选择Show Container选项就可以看到应用程序沙盒的内容。 每个应用程序沙盒都包含以下三个目录： 1）Documents：应用程序可以将数据存储在Documents目录中。如果这个应用程序启用了iTunes文件分享功能，用户就可以在iTunes中看到目录的内容（以及应用程序创建的所有子目录），还可以对其更新文件。 如果要为应用程序启用文件分享功能，需要打开它的Info.plist文件并添加键为Application supports iTunes file sharing值为YES的条目。 2）Library：应用程序也可以在这里存储数据。它用来存放不想共享给用户的文件。需要时可以创建自己的子目录。系统创建了名为Cache和Preferences的子目录。后者包含了存储应用程序偏好设置的plist文件，通过NSUserDefaults来操作。 3）tmp：tmp目录供应用存储临时文件。当iOS设备执行同步时，iTunes不会备份tmp中的文件。在不需要这些文件时，应用要负责删除tmp中的文件，以免占用文件系统空间。 获取Documents目录12NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *documentsDirectory = paths[0]; 常量NSDocumentDirectory表明我们正在查找Documents目录的路径。第二个常量NSUserDomainMask表明我们希望将搜索限制在应用的沙盒内，在OS X中表明我们希望该函数查看用户的主目录。 1NSString *filename = [documentsDirectory stringByAppendingPathComponent:@”theFile.txt”]; 完成此调用之后，filename就包含了指向应用Documents目录中theFile.txt文件的完整路径。 获取Library目录12NSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);NSString *libraryDirectory = paths[0]; 常量NSLibraryDirectory表明我们正在查找Library目录的路径。第二个常量NSUserDomainMask表明我们希望将搜索限制在应用的沙盒内，在OS X中表明我们希望该函数查看用户的主目录。 获取tmp目录12NSString *tempPath = NSTemporaryDirectory();NSString *filename = [tempPath stringByAppendingPathComponent:@”theFile.txt”]; 二、文件保存方案Cocoa提供的四种实现数据持久化的方法，都使用iOS的文件系统。使用SQLite3将创建一个SQLite3数据库文件，并让SQLite3去存储和检索数据。Core Data则以其最简单的形式帮助开发者完成所有的文件系统的管理工作。使用属性列表则需要考虑将数据存储在一个文件中，还是存储在多个文件中。 单文件持久化把数据保存在一个文件中是最简单的方法，而且对于许多应用，这也是完全可以接受的方法。首先，创建一个根对象，通常是数组或字典（使用归档容器的情况下根对象可以给予这个自定义类）。接下来，使用所有需要保存的程序数据填充根对象。真正保存时，代码会将该根对象的全部内容重新写入单个文件。应用在启动时会将该文件的全部内容读入内存，并在退出时注销。 使用单文件的缺点：必须将全部数据加载到内存中，并且不管有多小的更改也必须将所有数据全部重新写入文件系统。 多文件持久化使用多文件持久化是另一种实现持久化的方法。例如，电子邮件应用可能会将每封邮件都单独存储在一个文件中。 这种方法的优点，例如应用可以只加载用户请求的数据（另一种形式的延迟加载），当用户进行更改时只保存更改的文件。此方法允许开发者在收到内存不足通知时释放内存。用户当前未查看的任何数据都可以从内存中删除，下次需要时再从文件系统重新加载即可。 使用多文件持久化的缺点：它大大增加了应用的复杂性。 三、属性列表属性列表使用起来非常方便，可以使用Xcode或Property List Editor应用手动编辑它们。而且只要字典或数组包含特定可序列化对象，就可以将NSDictionary和NSArray实例写入属性列表或者从属性列表创建它们。 属性列表序列化序列化对象，是指可以被转换为字节流以便于存储到文件中或通过网络进行传输的对象。虽然任何对象都可以被序列化，但是只有某些对象才能放置到某个集合类中（如NSDictionary或NSArray中），然后才使用该集合类的writeToFile:atomically:或writeToURL:atomically:方法将它们存储到属性列表中。可以按照该方法序列化下面的类： 1）NSArray、NSMutableArray 2）NSDictionary、NSMutableDictionary 3）NSData、NSMutableData 4）NSString、NSMutableString 5）NSNumber 6）NSDate 如果只使用这些对象构建数据模型，就可以使用属性列表来方便地保护和加载数据。如果打算使用属性列表持久保存应用数据，则可以使用数组或字典。假设放到字典或数组中的所有对象都是前面列出的可序列化对象，则可以通过对字典或数组的实例调用writeToFile:atomically:方法来写入属性列表。 1[myArray writeToFile:@”/some/file/location/output.plist” atomically:YES]; 说明：这里的atomically参数让该方法将数据写入辅助文件，而不是写入指定位置。成功写入该文件之后，辅助文件将被复制到第一个参数指定的位置。这是更安全的写入文件的方法，因为如果应用在保存期间崩溃，则现有文件（如果有）不会被破坏。尽管增加一点开销，但是多数情况下还是值得的。 属性列表方法的一个问题就是，无法将自定义对象序列化到属性列表中，另外也不能使用没有在可序列化对象类型列表中指定的Cocoa Touch的其他类。这意味着无法使用NSURL、UIImage和UIColor等类。 且不说序列化问题，将这些模型对象保存到属性列表中还意味着无法轻松创建派生的或需要计算的属性（例如，等于两个属性之后的属性），并且必须将实际上应该包含在模型中的某些代码移动到控制器类。这些限制也适用于简单数据模型和简单应用。但在多数情况下，如果创建了专用的模型类，则应用更容易维护。 在复杂的应用中，简单属性列表仍然非常有用。它们是将静态数据包含在应用中的最佳方法。例如，当应用包含一个选取器时，创建一个属性列表文件并将其放在项目的Resources文件夹中，就是将项目列表包含到选取器中的最佳方法，这样能把项目列表编译到应用中。 创建工程在Xcode中，使用Single View Application模板创建一个项目，命名Persistence，点击Main.storyboard，布局如下图 连线，添加处理函数： 12345@interface PlistViewController ()- (IBAction)saveClicked:(id)sender;@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;@end 12345678910111213141516171819202122232425- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. NSString *filePath = [self dataFilePath]; if ([[NSFileManager defaultManager] fileExistsAtPath:filePath]) &#123; NSArray *array = [[NSArray alloc] initWithContentsOfFile:filePath]; for (int i = 0; i &lt; 4; i++) &#123; UITextField *theField = self.lineFields[i]; theField.text = array[i]; &#125; &#125;&#125;-(NSString *)dataFilePath&#123; NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *documentsDirectory = [paths objectAtIndex:0]; return [documentsDirectory stringByAppendingPathComponent:@&quot;data.plist&quot;];&#125;- (IBAction)saveClicked:(id)sender &#123; NSString *filePath = [self dataFilePath]; NSArray *array = [self.lineFields valueForKey:@&quot;text&quot;]; [array writeToFile:filePath atomically:YES];&#125; 四、归档在Cocoa世界中，归档是指另一中形式的序列化，但它是任何对象都可以实现的更常规的类型。专门编写用于保存数据的任何模型对象都应该支持归档。使用对模型对象进行归档的技术可以轻松将复杂的对象写入文件，然后再从中读取它们。 只要在类中实现的每个属性都是标量（如整型或浮点型）或都是遵循NSCoding协议的某个类的实例，就可以对整个对象进行完全的归档。由于大多数支持存储数据的Foundation和Cocoa Touch类都遵循NSCoding协议（不过，有一些例外，如UIImage），对于大多数类来说，归档相对而言比较容易实现。 尽管对归档的使用没有严格要求，但还有一个协议应该与NSCoding一起实现，即NSCopying协议。后者允许复制对象，这使开发者在使用数据模型对象时具备了较大的灵活性。 遵循NSCoding协议NSCoding协议声明了两个必须实现的方法，一个方法将对象编码到归档中，另一个方法对归档解码来创建一个新对象。这两个方法都传递一个NSCoder实例，使用方式与NSUserDefaults非常相似。也可以使用KVC对对象和原生数据类型进行编码和解码。 编码方法： 1-(void)encodeWithCoder: (NSCoder *)encoder; 解码方法： 1-(id)initWithCoder: (NSCoder *)decoder; 实现NSCopying协议遵循NSCopying对于任何数据模型对象来说都是非常好的事情。NSCopying有一个copyWithZone:方法，可用来复制对象。实现NSCopying与实现initWithCoder:非常相似，只需要创建一个同一类的新实例，然后将新实例的所有属性都设置为与该对象属性相同的值即可。 说明：不要过于担心NSZone参数。它指向系统用于管理内存的struct。只有在极少数情况下，开发者才需要关注zone或者创建自己的zone。目前，还没有使用多个zone的说法。对某个对象调用copy的方法与使用默认zone调用copyWithZone的方法完全相同，几乎始终能满足你的需求。事实上，现在的iOS上完全可以忽略zone。NSCopying用zone在本质上是考虑向后兼容性所致。 创建工程按照上文创建工程，设计界面（与上文界面相同），连线，添加响应方法： 12345678910#import &quot;ArchiverViewController.h&quot;#import &quot;Lines.h&quot;static NSString *const kRootKey = @&quot;kRootKey&quot;;@interface ArchiverViewController ()- (IBAction)saveClicked:(id)sender;@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;@end 12345678910111213141516171819202122232425262728293031323334- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. NSString *filePath = [self dataFilePath]; if ([[NSFileManager defaultManager] fileExistsAtPath:filePath]) &#123; NSData *data = [[NSMutableData alloc] initWithContentsOfFile:filePath]; NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data]; Lines *lines = [unarchiver decodeObjectForKey:kRootKey]; [unarchiver finishDecoding]; for (int i = 0; i &lt; 4; i++) &#123; UITextField *theField = self.lineFields[i]; theField.text = lines.lines[i]; &#125; &#125;&#125;-(NSString *)dataFilePath&#123; NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *documentsDirectory = [paths objectAtIndex:0]; return [documentsDirectory stringByAppendingPathComponent:@&quot;data.archive&quot;];&#125;- (IBAction)saveClicked:(id)sender &#123; NSString *filePath = [self dataFilePath]; Lines *lines = [[Lines alloc] init]; lines.lines = [self.lineFields valueForKey:@&quot;text&quot;]; NSMutableData *data = [[NSMutableData alloc] init]; NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data]; [archiver encodeObject:lines forKey:kRootKey]; [archiver finishEncoding]; [data writeToFile:filePath atomically:YES];&#125; 与属性列表序列化实现多几行代码，那么是否就是使用归档比使用序列化属性列表更有优势呢？答案是否定的。如果我们拥有一个包含可归档对象的数组，则可以对数组实例本身进行归档来归档整个数组。对集合类（如数组）进行归档时，也会归档其包含的所有对象。只要放入数组或字典中的对象遵循NSCoding，就可以归档数组或字典并还原它。这样，对其进行归档时，其中所有对象都将位于已还原的数组和字典中。这一点并不适用于属性链接的持久化，它只支持一小部分的Foundation对象类型。如果没有编写额外的代码，来将这些自定义类的实例与字典通过每个对象属性的键进行互相转化，就不能对其进行持久化。 换句话说，NSCoding方法具有非常好的伸缩性，因为无论添加多少对象，将这些对象写入磁盘的方式都完全相同。不过使用属性列表的话，工作量会随着添加对象而增加。 五、SQLite3SQLite3在存储和检索大量数据方面非常有效。它能够对数据进行复杂的聚合，与使用对象执行这些操作相比，获得结果的速度更快。 SQLite3使用SQL（Structured Query Language，结构化查询语言），SQL是与关系数据库交互的标准语言。 这里推荐两篇SQLite3深入研究探索的参考文章： An Introduction to the SQLite3 C/C++ Interface (www.sqlite.org/cintro.html) SQL As Understood by SQLite (www.sqlite.org/lang.html) 关系数据库（包括SQLite3）和面向对象的编程语言使用完全不同的方法来存储和组织数据。这些方法差异很大，因而出现了在两者之间进行转换的各种技术以及很多库和工具。这些技术统称为ORM（Object-Relational-Mapping，对象关系映射）。目前有很多种ORM工具可用于Cocoa Touch。 绑定变量虽然可以通过创建SQL字符串来插入值，但常用的方法是使用绑定变量来执行数据库插入操作。正确处理字符串并确保它们没有无效字符（以及引号处理过的属性）是非常烦琐的事情。借助绑定变量，这些问题将迎刃而解。 要使用绑定变量插入值，只需要按正常方式创建SQL语句即可，不过要在SQL字符串中添加一个问号。每个问号都表示一个需要在语句执行之前进行绑定的变量。然后，准备好SQL语句，将值绑定到各个变量并执行命令。 1234567891011121314/*将整型数据绑定到第一个变量，将字符串绑定到第二个变量，然后执行并结束语句*/char *sql = “insert into foo values (?, ?);”;sqlite3_stmt *stmt;if(sqlite3_prepare_v2(database, sql, -1, &amp;stmt, nil) == SQLITE_OK)&#123; sqlite3_bind_int(stmt, 1, 235); sqlite3_bind_text(stmt, 2, “Bar”, -1, NULL);&#125;if(sqlite3_step(stmt) != SQLITE_DONE)&#123; NSLog(@”This should be real error checking!”);&#125;sqlite3_finalize(stmt); 根据希望使用的数据类型，可以选择不同的绑定语句。大部分绑定函数都只有3个参数。 1）无论针对哪种数据类型，任何绑定函数的第一个参数都指向之前在sqlite3_prepare_v2()调用中使用的sqlite3_stmt。 2）第二个参数是被绑定变量的索引。它是一个有序索引值，者这表示SQL语句中的第一个问号是索引1，其后面的每个问号都依次按序增加1。 3）第三个参数始终表示应该替换问号的值。 有些绑定函数（比如用于绑定文本和二进制数据的绑定函数）拥有另外两个参数。 1）一个参数是在上面第三个参数中传递的数据长度。对于C字符串，可以传递-1来代替字符串长度，这样函数将使用整个字符串。对于所有其他情况，需要指定所传递数据的长度。 2）另外一个参数是可选的函数回调，用于在语句执行后完成内存清理工作。通常，这种函数使用malloc()释放已分配的内存。 创建工程创建工程，设计布局，与前文工程相同操作，连线，添加响应方法： 12345678#import &quot;SqliteViewController.h&quot;#import &lt;sqlite3.h&gt;@interface SqliteViewController ()- (IBAction)saveClicked:(id)sender;@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;@end 导入sqlite库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. sqlite3 *database; //打开数据库 if (sqlite3_open([[self dataFilePath] UTF8String], &amp;database) != SQLITE_OK) &#123; sqlite3_close(database); NSAssert(0, @&quot;Failed to open database&quot;); &#125; /** 有用的C语言知识： 如果两个内联的字符串之间只有空白（包括换行符）而没有其他字符， 那么这两个字符串会被连接为一个字符串。 */ //创建数据库SQL NSString *createSQL = @&quot;create table if not exists fields (row integer primary key, field_data text);&quot;; char *errorMsg; //执行SQL语句 if (sqlite3_exec(database, [createSQL UTF8String], NULL, NULL, &amp;errorMsg) != SQLITE_OK) &#123; sqlite3_close(database); NSAssert(0, @&quot;Error creating table: %s&quot;, errorMsg); &#125; //查询数据库 NSString *query = @&quot;select row, field_data from fields order by row;&quot;; sqlite3_stmt *statement; if (sqlite3_prepare_v2(database, [query UTF8String], -1, &amp;statement, nil) == SQLITE_OK) &#123; //遍历返回的每行 while (sqlite3_step(statement) == SQLITE_ROW) &#123; int row = sqlite3_column_int(statement, 0); char *rowData = (char *)sqlite3_column_text(statement, 1); NSString *fieldValue = [[NSString alloc] initWithUTF8String:rowData]; UITextField *field = self.lineFields[row]; field.text = fieldValue; &#125; sqlite3_finalize(statement); &#125; //关闭数据库 sqlite3_close(database);&#125;-(NSString *)dataFilePath&#123; NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *documentsDirectory = [paths objectAtIndex:0]; return [documentsDirectory stringByAppendingPathComponent:@&quot;data.sqlite&quot;];&#125;- (IBAction)saveClicked:(id)sender &#123; sqlite3 *database; if (sqlite3_open([[self dataFilePath] UTF8String], &amp;database) != SQLITE_OK) &#123; sqlite3_close(database); NSAssert(0, @&quot;Failed to open database&quot;); &#125; for (int i = 0; i &lt; 4; i++) &#123; UITextField *field = self.lineFields[i]; //内联字符串的连接，又一次派上用场 char *update = &quot;insert or replace into fields (row, field_data) values (?, ?);&quot;; char *errorMsg = NULL; sqlite3_stmt *stmt; //绑定变量 if (sqlite3_prepare_v2(database, update, -1, &amp;stmt, nil) == SQLITE_OK) &#123; sqlite3_bind_int(stmt, 1, i); sqlite3_bind_text(stmt, 2, [field.text UTF8String], -1, NULL); &#125; //判断执行更新是否成功 if (sqlite3_step(stmt) != SQLITE_DONE) &#123; NSAssert(0, @&quot;Error updating table: %s&quot;, errorMsg); &#125; sqlite3_finalize(stmt); &#125; sqlite3_close(database);&#125; 其实，以上者三种方式没有什么差异，只不过是三种不同的持久化机制而已。 六、Core DataCore Data是一款稳定、功能全面的持久化工具。 术语实体：表示对对象的描述。 托管对象：表示在运行时创建该实体的具体实例。 注意，在数据模型编辑器中，你将创建实体；而在代码中，你将创建并检索托管对象。实体和托管对象之间的差异类似于类与类的实例。 实体由属性组成，属性分为3种类型： 1）特性（attribute）：特性在Core Data实体中的作用与实例变量在Objective-C类中的作用完全相同，它们都用于保存数据。 2）关系（relationship）：关系用于定义实体之间的关系。举例来说，假设要定义一个Person实体，你可能首先会定义一些特性，比如height和weight，还可以定义地址特性，比如state和zipCode，或者将它们嵌入到单独的HomeAddr实体中。使用后面这种方法，你可能希望在Person与HomeAddr之间创建一个关系。关系可以是一对一或一对多。从Person到HomeAddr的关系可以是“一对一”，因为大多数人都只有一个家庭地址。从HomeAddr到Person的关系则可以是“一对多”，因为可能多个人住在同一个家庭地址。 3）提取属性（fetched property）：提取属性是关系的备选方法。用提取属性可以创建一个能在提取时被评估的查询，从而确定哪些对象属于这个关系。沿用刚才的例子，一个Person对象可以拥有一个名为Neighbors的提取属性，该属性查找数据存储中与这个Person的HomeAddr拥有相同zipCode的所有HomeAddr对象。由于提取属性的结构和使用方式，它们通常都是一对一关系。提取属性也是唯一一种能够让你跨越多个数据存储的关系。 创建工程依旧如前文方式创建工程，添加响应参数，不过在这里要注意的是，Core Data的创建方法步骤： 1）创建Model文件 2）编辑Model文件，点击“Add Entity”添加实体，点击“Add Attribute”添加特性 3）创建NSManagedObject文件，关联数据模型 123456789101112#import &quot;CoreDataViewController.h&quot;#import &lt;CoreData/CoreData.h&gt;static NSString *const kLineEntityName = @&quot;Line&quot;;static NSString *const kLineNumberKey = @&quot;lineNumber&quot;;static NSString *const kLineTextKey = @&quot;lineText&quot;;@interface CoreDataViewController ()- (IBAction)saveClicked:(id)sender;@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. NSManagedObjectContext *context = [self myContext]; NSFetchRequest *request = [[NSFetchRequest alloc] initWithEntityName:kLineEntityName]; NSError *error; NSArray *objects = [context executeFetchRequest:request error:&amp;error]; if (objects == nil) &#123; NSLog(@&quot;There was an error!&quot;); &#125; for (NSManagedObject *oneObject in objects) &#123; int lineNum = [[oneObject valueForKey:kLineNumberKey] intValue]; NSString *lineText = [oneObject valueForKey:kLineTextKey]; UITextField *theField = self.lineFields[lineNum]; theField.text = lineText; &#125;&#125;-(NSManagedObjectContext *)myContext&#123; //上下文 关联Company.xcdatamodeld模型文件 NSManagedObjectContext *context = [[NSManagedObjectContext alloc] init]; //模型文件 NSManagedObjectModel *model = [NSManagedObjectModel mergedModelFromBundles:nil]; //持久化存储调度器 NSPersistentStoreCoordinator *store = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:model]; NSString *doc = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSString *sqlitePath = [doc stringByAppendingPathComponent:@&quot;line.sqlite&quot;]; //数据存储的类型 数据库存储路径 [store addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:[NSURL fileURLWithPath:sqlitePath] options:nil error:nil]; context.persistentStoreCoordinator = store; return context;&#125;- (IBAction)saveClicked:(id)sender &#123; NSManagedObjectContext *context = [self myContext]; NSError *error; for (int i = 0; i &lt; 4; i++) &#123; UITextField *theField = self.lineFields[i]; NSFetchRequest *request = [[NSFetchRequest alloc] initWithEntityName:kLineEntityName]; NSPredicate *pred = [NSPredicate predicateWithFormat:@&quot;(%K = %d)&quot;, kLineNumberKey, i]; [request setPredicate:pred]; NSArray *objects = [context executeFetchRequest:request error:&amp;error]; if (objects == nil) &#123; NSLog(@&quot;There was an error!&quot;); &#125; NSManagedObject *theLine = nil; if ([objects count] &gt; 0) &#123; theLine = [objects objectAtIndex:0]; &#125;else&#123; theLine = [NSEntityDescription insertNewObjectForEntityForName:kLineEntityName inManagedObjectContext:context]; &#125; [theLine setValue:[NSNumber numberWithInt:i] forKey:kLineNumberKey]; [theLine setValue:theField.text forKey:kLineTextKey]; &#125; [context save:nil]; &#125; Core Data版本与之前的版本功能完全相同。Core Data需要的工作量很大。对于这种简单的应用，它并没有提供明显的优势。但是在比较复杂的应用中，Core Data可以显著减少设计和编写数据模型所需的时间。 七、总结四种数据持久化机制，各有优势，根据使用情况选择对应机制进行数据持久化。 Demo on Github]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS App 偏好设置]]></title>
      <url>%2F2016%2F01%2F15%2Fios-preference-setting%2F</url>
      <content type="text"><![CDATA[如今，即便是最简单的计算机程序也会包含一个偏好设置窗口，用户可以在其中设置应用专属的选项。在MAC OS X中，Preferences…菜单通常位于应用菜单中。选择该菜单项会弹出一个窗口，用户可以在其中输入和更改各种选项。iPhone和其他iOS设备有一个专门的“设置”应用程序来进行各种设置，你肯定用过很多次了。 设置捆绑包通过应用设置，用户可以输入和更改任何带有设置捆绑包（settings bundle）的应用中的偏好设置。设置捆绑包是应用自带的一组文件，用于告诉设置该应用期望得到用户的哪些偏好设置。下图是实例效果图： 对于iOS用户默认设置（User Defaults）机制，设置应用充当着通用用户界面的角色。用户默认设置是保存和获取偏好设置的系统的一部分。 在iOS应用中，用户默认设置由NSUserDefaults类实现。应用通过NSUserDefaults用键值对的方式来读取和保存偏好设置数据，与通过键从NSDictionary对象中获取数据一样。不同之处在于NSUserDefaults数据会被持久保存在文件系统中，而不是存储在内存的对象实例中。 应用接下来的部分，通过创建一个简单的应用，来实现应用设置控制应用程序。 创建应用在Xcode中，创建Tabbed Application工程。 使用设置捆绑包设置应用使用每个应用中设置捆绑包的内容构建出一个应用的设置视图。如果应用没有设置捆绑包，则设置应用不会显示出应用程序的任何信息。每个设置捆绑包必须包含一个名为Root.plist的属性列表，它定义了根级偏好设置视图。此属性列表必须遵循一种非常严格的格式。 当设置应用启动时，它会检查每个应用程序的设置捆绑包并为包含设置捆绑包的每个应用添加设置组。 在项目中添加设置捆绑包新建设置捆绑包，操作如下图 在iOS－－&gt;Resource－－&gt;Settings Bundle点击Next，名字保留默认，最后点击Create即可。 编辑属性列表文件接下来需要编辑Root.plist文件，具体内容如下图 在Item8中，引用的More.plist文件，具体内容如下图 这里需要补充说明一点： iOS上的应用不能从其他应用的沙盒中读取文件。设置捆绑包并不是我们应用沙盒的一部分，而是设置应用沙盒的一部分。 设计展示界面数据准备好之后，添加图标资源，设计数据展示界面。效果图如下 界面是通过代码实现的，主要使用了如下几个控件： 12345678910111213@interface FirstViewController ()@property (nonatomic, strong) UILabel *officerLabel;@property (nonatomic, strong) UILabel *authorizationCodeLabel;@property (nonatomic, strong) UILabel *rankLabel;@property (nonatomic, strong) UILabel *warpDriveLabel;@property (nonatomic, strong) UILabel *warpFactorLabel;@property (nonatomic, strong) UILabel *favoriteTeaLabel;@property (nonatomic, strong) UILabel *favoriteCaptainLabel;@property (nonatomic, strong) UILabel *favoriteGadgetLabel;@property (nonatomic, strong) UILabel *favoriteAlienLabel;@end 1234567@interface SecondViewController ()@property (nonatomic, strong) UISwitch *engineSwitch;@property (nonatomic, strong) UISlider *warpFactorSlider;@property (nonatomic, strong) UIButton *settingInfo;@end 读取应用中的设置我们将使用NSUserDefaults类访问用户设置。NSUserDefaults作为单例类，意味着应用中只能有一个NSUserDefaults实例在运行。为了访问这个实例，需要调用standardUserDefaults。 键宏定义1234567891011121314#ifndef BridgeControl_Constants_h#define BridgeControl_Constants_h#define kOfficerKey @&quot;officer&quot;#define kAuthorizationCodeKey @&quot;authorizationCode&quot;#define kRankKey @&quot;rank&quot;#define kWarpDriveKey @&quot;warp&quot;#define kWarpFactorKey @&quot;warpFactor&quot;#define kFavoriteTeaKey @&quot;favoriteTea&quot;#define kFavoriteCaptionKey @&quot;favoriteCaptain&quot;#define kFavoriteGadgetKey @&quot;favoriteGadget&quot;#define kFavoriteAlienKey @&quot;favoriteAlien&quot;#endif 更新主视图控制器1234567891011121314151617181920//FirstViewController.m- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [self refreshFields];&#125;-(void)refreshFields&#123; NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; self.officerLabel.text = [defaults objectForKey:kOfficerKey]; self.authorizationCodeLabel.text = [defaults objectForKey:kAuthorizationCodeKey]; self.rankLabel.text = [defaults objectForKey:kRankKey]; self.warpDriveLabel.text = [defaults boolForKey:kWarpDriveKey] ? @&quot;engaged&quot; : @&quot;Disabled&quot;; self.warpFactorLabel.text = [[defaults objectForKey:kWarpFactorKey] stringValue]; self.favoriteTeaLabel.text = [defaults objectForKey:kFavoriteTeaKey]; self.favoriteCaptainLabel.text = [defaults objectForKey:kFavoriteCaptionKey]; self.favoriteGadgetLabel.text = [defaults objectForKey:kFavoriteGadgetKey]; self.favoriteAlienLabel.text = [defaults objectForKey:kFavoriteAlienKey];&#125; 12345678910111213//SecondViewController.m- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [self refreshFields];&#125;-(void)refreshFields&#123; NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; self.engineSwitch.on = [defaults boolForKey:kWarpDriveKey]; self.warpFactorSlider.value = [defaults floatForKey:kWarpFactorKey];&#125; 添加控件响应事件为SecondViewController中的UIButton，UISwitch和UISlider控件添加监听事件。 123456789101112131415- (void)engineSwitchTapped &#123; NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; [defaults setBool:self.engineSwitch.on forKey:kWarpDriveKey]; [defaults synchronize];&#125;- (void)warpSliderTouched &#123; NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; [defaults setFloat:self.warpFactorSlider.value forKey:kWarpFactorKey]; [defaults synchronize];&#125;//切换到“设置”应用程序-(void)settingInfoClicked&#123; [[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];&#125; 注册默认值12345678910111213//AppDelegate.m- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // Override point for customization after application launch. //程序启动后的一些自定义设置 NSDictionary *defaults = @&#123;kWarpDriveKey:@YES, kWarpFactorKey:@2, kFavoriteAlienKey:@&quot;Vulcan&quot; &#125;; [[NSUserDefaults standardUserDefaults] registerDefaults:defaults]; return YES;&#125; 保证设置有效如果现在将应用运行，查看设置信息并按下主屏幕按钮来修改一些值。然后再按Home键，再重新打开应用，结果发现设置并没有生效。 原因在于：在iOS中，当应用正在运行时按Home键并不会退出该应用，而是由操作系统在后台将其暂停，这样它就能随时快速启动。 在这个例子中，我们需要添加一点工作，以实现应用被唤醒时，能重新加载用户偏好设置并重新显示它们。 通知，时对象之间进行通信的轻量级机制。任何对象都能定义一个或多个发送到应用通知中心的通知。通知中心是一个单例对象，作用在于对象之间传送通知。 UIApplication类会发送大量的通知，大多数通知的用途从命名就能看出来，这个例子中我们就使用到了通知。 将下列代码添加到两个控制器的viewDidLoad方法中： 12UIApplication *app = [UIApplication sharedApplication]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationWillEnterForeground:) name:UIApplicationWillEnterForegroundNotification object:app]; 然后添加相应的响应方法 12345-(void)applicationWillEnterForeground:(NSNotification *)notification&#123; NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; [defaults synchronize]; [self refreshFields];&#125; 小结本文主要讲解了如何使用应用设置，如何使用NSUserDefaults读取偏好设置，以及如何让用户在应用内修改偏好设置。 Source code on Github]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP 状态码清单]]></title>
      <url>%2F2016%2F01%2F11%2Fhttp-state-code-list%2F</url>
      <content type="text"><![CDATA[HTTP 我们常用的网络请求之一，然因为各种网络或者硬件原因，网络请求之后总能拿到一些状态返回码，那么它们到底代表什么意思呢？本文就是将这些常见的状态码加以收集，整理归类。 1xx消息这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。 100 Continue客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。 101 Switching Protocols服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。: 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。 102 Processing由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。 2xx成功这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。 200 OK请求已成功，请求所希望的响应头或数据体将随此响应返回。 201 Created请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回’202 Accepted’。 202 Accepted服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。:返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。 203 Non-Authoritative Information服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。 204 No Content服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。 205 Reset Content服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。 206 Partial Content服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含Range头信息来指示客户端希望得到的内容范围，并且可能包含If-Range来作为请求条件。响应必须包含如下的头部域： Content-Range用以指示本次响应中返回的内容的范围；如果是Content-Type为multipart/byteranges的多段下载，则每一multipart段中都应包含Content-Range域用以指示本段的内容范围。假如响应中包含Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。DateETag和／或Content-Location，假如同样的请求本应该返回200响应。Expires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了If-Range强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了If-Range弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。假如ETag或Last-Modified头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。任何不支持Range以及Content-Range头的缓存都禁止缓存206响应返回的内容。 207 Multi-Status由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 3xx重定向这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。 当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。 300 Multiple Choices被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。除非这是一个HEAD请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由Content-Type定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的URI；浏览器可能会将这个Location值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。 301 Moved Permanently被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。 302 Found请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。 303 See Other对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。注意：许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。 304 Not Modified如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将Date字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。ETag和／或Content-Location，假如同样的请求本应返回200响应。Expires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的GET请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。 305 Use Proxy被请求的资源必须通过指定的代理才能被访问。Location域中将给出指定的代理所在的URI信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能创建305响应。注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器创建。忽视这些限制可能导致严重的安全后果。 306 Switch Proxy在最新版的规范中，306状态码已经不再被使用。 307 Temporary Redirect请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的URI发出访问请求。如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 4xx客户端错误这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。 如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。 400 Bad Request由于包含语法错误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 401 Unauthorized当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。 402 Payment Required该状态码是为了将来可能的需求而预留的。 403 Forbidden服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 404 Not Found请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。 405 Method Not Allowed请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 406 Not Acceptable请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。 407 Proxy Authentication Required与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个Proxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy-Authorization信息头用以验证。参见RFC 2617。 408 Request Timeout请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。 409 Conflict由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。冲突通常发生于对PUT请求的处理中。例如，在采用版本检查的环境下，某次PUT提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。 410 Gone被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。 411 Length Required服务器拒绝在没有定义Content-Length头的情况下接受请求。在添加了表明请求消息体长度的有效Content-Length头之后，客户端可以再次提交该请求。 412 Precondition Failed服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。 413 Request Entity Too Large服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个Retry-After的响应头，以告知客户端可以在多少时间以后重新尝试。 414 Request-URI Too Long请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。重定向URI“黑洞”，例如每次重定向把旧的URI作为新的URI的一部分，导致在若干次重定向后URI超长。客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的URI，当GET后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。 415 Unsupported Media Type对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。 416 Requested Range Not Satisfiable如果请求中包含了Range请求头，并且Range中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义If-Range请求头，那么服务器就应当返回416状态码。假如Range使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个Content-Range实体头，用以指明当前资源的长度。这个响应也被禁止使用multipart/byteranges作为其Content-Type。 417 Expectation Failed在请求头Expect中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect的内容无法被满足。 418 I’m a teapot本操作码是在1998年作为IETF的传统愚人节笑话, 在RFC 2324 超文本咖啡壶控制协议中定义的，并不需要在真实的HTTP服务器中定义。 421 There are too many connections from your internet address从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422 Unprocessable Entity请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV） 423 Locked当前资源被锁定。（RFC 4918 WebDAV） 424 Failed Dependency由于之前的某个请求发生的错误，导致当前请求失败，例如PROPPATCH。（RFC 4918 WebDAV） 425 Unordered Collection在WebDav Advanced Collections草案中定义，但是未出现在《WebDAV顺序集协议》（RFC 3658）中。 426 Upgrade Required客户端应当切换到TLS/1.0。（RFC 2817） 449 Retry With由微软扩展，代表请求应当在执行完适当的操作后进行重试。 5xx服务器错误这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。 这些状态码适用于任何响应方法。 500 Internal Server Error服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。 501 Not Implemented服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。 502 Bad Gateway作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503 Service Unavailable由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。 504 Gateway Timeout作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。注意：某些代理服务器在DNS查询超时时会返回400或者500错误 505 HTTP Version Not Supported服务器不支持，或者拒绝支持在请求中使用的HTTP版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。 506 Variant Also Negotiates由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。 507 Insufficient Storage服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV（RFC 4918） 509 Bandwidth Limit Exceeded服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。 510 Not Extended获取资源所需要的策略并没有没满足。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS 二维码扫描]]></title>
      <url>%2F2015%2F12%2F26%2Fios-qrcode-scaner%2F</url>
      <content type="text"><![CDATA[二维条码/二维码（2-dimensional bar code）是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理：它具有条码技术的一些共性：每种码制有其特定的字符集；每个字符占有一定的宽度；具有一定的校验功能等。同时还具有对不同行的信息自动识别功能、及处理图形旋转变化点。 在这么一个二维码泛滥的时代，一般的App都会支持二维码扫描，那么这个功能应该如何实现呢？ 这几天博主高仿新浪微博的项目进行一个阶段性的tag，在此也将这个项目在实现二维码扫描这个功能来做一个简要的记录。关于高仿新浪微博的源代码，已经将全部代码托管到github。 关于二维码的扫描，网上说的最多的框架莫过于ZBar和ZXing框架，刚开始也是想使用第三方框架，但是，在iOS7之后苹果官方已经提供了二维码扫描方法，而且实现起来还是蛮简单的，故而选择原生态方法。不过，我们还是来看看，如何使用ZBar实现二维码扫描。 首先在github上下载ZBar代码，然后将如下的相关类库添加进去： AVFoundation.framwork CoreMedia.framework CoreVideo.framework libiconv.dylib libzbar.a 接下来在.h文件中#import “ZBarSDK.h”，同时添加代理ZBarReaderDelegate，然后在.m文件中添加如下代码： 12345678910111213141516171819202122232425262728-(void)sysbutbuttonclick&#123; ZBarReaderViewController *reader = [ZBarReaderViewController new]; reader.readerDelegate = self; ZBarImageScanner *scanner = reader.scanner; [scanner setSymbology: ZBAR_I25 config: ZBAR_CFG_ENABLE to: 0]; [self presentModalViewController: reader animated: YES]; &#125; - (void) imagePickerController: (UIImagePickerController*) reader didFinishPickingMediaWithInfo: (NSDictionary*) info &#123; NSLog(@&quot;info=%@&quot;,info); // 得到条形码结果 id&lt;NSFastEnumeration&gt; results =[info objectForKey: ZBarReaderControllerResults]; ZBarSymbol *symbol = nil; for(symbol in results) // EXAMPLE: just grab the first barcode break; UIAlertView *alert=[[UIAlertView alloc] initWithTitle:@&quot;信息提示!&quot; message:symbol.data delegate:self cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:@&quot;确定&quot;, nil]; [alert show]; &#125; 最后触发扫描事件的时候调用sysbutbuttonclick即可。 博主在项目中使用的是苹果官方提供的，并将其实现单独封装，以方便使用。 其实我们只需要三个步骤即可实现二维码扫描功能： 1）导入AVFoundation框架，import &lt;AVFoundation/AVFoundation.h&gt;； 2）设置一个用于显示扫描的view； 3）实例化AVCaptureSession、AVCaptureVideoPreviewLayer。 具体实现方式如下： 1）添加开始扫描方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162- (void)startReading&#123; NSError *error; //1.初始化捕捉设备（AVCaptureDevice），类型为AVMediaTypeVideo AVCaptureDevice *captureDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo]; //2.用captureDevice创建输入流 AVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:captureDevice error:&amp;error]; if (!input) &#123; NSLog(@&quot;%@&quot;, [error localizedDescription]); &#125; //3.创建媒体数据输出流 AVCaptureMetadataOutput *captureMetadataOutput = [[AVCaptureMetadataOutput alloc] init]; //4.实例化捕捉会话 _captureSession = [[AVCaptureSession alloc] init]; //4.1.将输入流添加到会话 [_captureSession addInput:input]; //4.2.将媒体输出流添加到会话中 [_captureSession addOutput:captureMetadataOutput]; //5.创建串行队列，并加媒体输出流添加到队列当中 dispatch_queue_t dispatchQueue; dispatchQueue = dispatch_queue_create(&quot;myScanQueue&quot;, NULL); //5.1.设置代理 [captureMetadataOutput setMetadataObjectsDelegate:self queue:dispatchQueue]; //5.2.设置输出媒体数据类型为QRCode [captureMetadataOutput setMetadataObjectTypes:[NSArray arrayWithObject:AVMetadataObjectTypeQRCode]]; //6.实例化预览图层 _videoPreviewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:_captureSession]; //7.设置预览图层填充方式 [_videoPreviewLayer setVideoGravity:AVLayerVideoGravityResizeAspectFill]; //8.设置图层的frame [_videoPreviewLayer setFrame:_viewPreview.layer.bounds]; //9.将图层添加到预览view的图层上 [_viewPreview.layer addSublayer:_videoPreviewLayer]; //10.设置扫描范围 captureMetadataOutput.rectOfInterest = CGRectMake(0.2f, 0.2f, 0.8f, 0.8f); //10.1.扫描框 _boxView = [[UIView alloc] initWithFrame:CGRectMake(_viewPreview.bounds.size.width * 0.1f, _viewPreview.bounds.size.height * 0.2f, _viewPreview.bounds.size.width * 0.8f, _viewPreview.bounds.size.width * 0.8f)]; _boxView.layer.borderColor = kRangeColor; _boxView.layer.borderWidth = 1.0f; [_viewPreview addSubview:_boxView]; //10.2.扫描线 _scanLayer = [[CALayer alloc] init]; _scanLayer.frame = CGRectMake(0, 0, _boxView.bounds.size.width, kLineBorad); _scanLayer.backgroundColor = kLineColor; [_boxView.layer addSublayer:_scanLayer]; NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:0.2f target:self selector:@selector(moveScanLayer:) userInfo:nil repeats:YES]; [timer fire]; //11.开始扫描 [_captureSession startRunning];&#125; 2）实现代理方法： 12345678910111213141516171819#pragma mark - AVCaptureMetadataOutputObjectsDelegate- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection&#123; NSString *urlStr; //判断是否有数据 if (metadataObjects != nil &amp;&amp; [metadataObjects count] &gt; 0) &#123; AVMetadataMachineReadableCodeObject *metadataObj = [metadataObjects objectAtIndex:0]; //判断回传的数据类型 if ([[metadataObj type] isEqualToString:AVMetadataObjectTypeQRCode]) &#123; urlStr = metadataObj.stringValue; [self performSelectorOnMainThread:@selector(stopReading) withObject:nil waitUntilDone:NO]; &#125; &#125; _videoPreviewLayer.hidden = YES; _webView.hidden = NO; NSURLRequest *request =[NSURLRequest requestWithURL:[NSURL URLWithString:urlStr]]; [self.webView loadRequest:request]; &#125; 3）设置好页面布局，用来显示扫描结果即可。 以上就是两种二维码扫描实现简要过程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP MVC模式简单实现]]></title>
      <url>%2F2015%2F11%2F30%2Fphp-mvc-framework%2F</url>
      <content type="text"><![CDATA[MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 代码结构 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?php //function.php //控制器调用函数 function C($name, $method)&#123; require_once('libs/Controller/'.$name.'Controller.class.php'); //$testController = new testController(); //$testController-&gt;show(); eval('$obj = new '.$name.'Controller(); $obj-&gt;'.$method.'();'); &#125; //模型调用函数 function M($name)&#123; require_once('libs/Model/'.$name.'Model.class.php'); eval('$obj = new '.$name.'Model();'); return $obj; &#125; //视图调用函数 function V($name)&#123; require_once('libs/View/'.$name.'View.class.php'); eval('$obj = new '.$name.'View();'); return $obj; &#125; //过滤非法值 function daddslashes($str)&#123; return (!get_magic_quotes_gpc())?addslashes($str):$str; &#125;?&gt; &lt;?php//test.php/*第一步 浏览者 -&gt; 调用控制器,对它发出指令第二步 控制器 -&gt; 按指令选取一个合适的模型第三步 模型 -&gt; 按控制器指令取相应数据第四步 控制器 -&gt; 按指令选取相应视图第五步 视图 -&gt; 把第三步取到的数据按用户想要的样子显示出来*/require_once('View/testView.class.php');require_once('Model/testModel.class.php');require_once('Controller/testController.class.php');$testController = new testController();$testController-&gt;show();?&gt;&lt;?php//testController.class.php/*控制器的作用是调用模型,并调用视图,将模型产生的数据传递给视图,并让相关视图去显示*/ class testController&#123; function show()&#123; /*$testModel = new testModel(); $data = $testModel-&gt;get(); $testView = new testView(); $testView-&gt;display($data);*/ $testModel = M('test'); $data = $testModel-&gt;get(); $testView = V('test'); $testView-&gt;display($data); &#125; &#125;?&gt; &lt;?php//testModel.class.php/*模型的作用是获取数据并处理,返回数据*/ class testModel&#123; function get()&#123; return "hello world"; &#125; &#125;?&gt; &lt;?php//testView.class.php/*视图的作用是将获得的数据进行组织,美化等,并最终向用户终端输出*/ class testView&#123; function display($data)&#123; echo $data; &#125; &#125;?&gt; 运行结果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 实现自适应窗口大小的网页]]></title>
      <url>%2F2015%2F11%2F26%2Fjs-adjust-window-page%2F</url>
      <content type="text"><![CDATA[随着移动互联网的兴起，网页浏览端不再仅仅只是电脑，更多的用户选择在移动端使用，那么，我们肯定不能再使用电脑版的页面布局，那么我们将如何适应纷繁多样的界面尺寸呢，本问主要介绍如何使用JavaScript实现自适应窗口大小的网页。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt; &lt;meta http-equiv="imagetoolbar" content="no"&gt; &lt;meta name="viewport" content="width=device-width,inital-scale=1"/&gt; &lt;title&gt;Login&lt;/title&gt; &lt;style type="text/css"&gt;body&#123; text-align: left; background-color: F6F6F6; background-attachment: fixed;&#125;#imgcenter&#123; position:relative; height: auto; width:50%; left:20%; top:250px;&#125;#center&#123; position:relative; height: auto; width:50%; left:20%; top:220px;&#125;#account&#123; position:relative; height: auto; left:60%; top:-110px; padding:2%; width:50%;&#125;#pwd&#123; position:relative; height: auto; left:60%; top:-100px; padding:2%; width: 50%;&#125;#login&#123; position:relative; height: auto; left:60%; top:-95px; padding:1%; width: 25%;&#125;#logo&#123; padding:3%; width: 50%; height: auto;&#125;#div_forgetpwd&#123; position:relative; height: 30%; left: 90%; top:-115px; width: 25%; font-size: 1pt; white-space:nowrap;&#125;#div_forgetpwd a&#123; text-decoration: none; margin: auto;&#125;#div_forgetpwd a:hover&#123; text-decoration: underline; margin: auto;&#125;.Clew&#123; position:relative; height: 15px; left:-10%; top:-80%; padding:2% 50%; white-space:nowrap; color: #FFFFD5; font-weight: bold; font-family: century gothic, arial; background: #FCBE47; border-top: 2px solid #db6e3c; border-bottom: 2px solid #db6e3c;&#125;&lt;/style&gt; &lt;script type="text/javascript" src="E:\MyProject\html\KServer\jquery-1.4.2.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt;//error clewvar userFlag=0;var pwdFlag=0;$().ready(function() &#123; $("form :input").blur(function() &#123; var $parent = $(this).parent(); $parent.find(".clew").remove(); if($(this).is(".username")) &#123; if(this.value=="" || this.value.length &lt; 0) &#123; var errorMsg = "Please enter your account."; $parent.append("&lt;span class='clew Clew'&gt;"+errorMsg+"&lt;/span&gt;"); &#125;else userFlag=1; &#125; if($(this).is(".password")) &#123; if(this.value=="" || this.value.length &lt; 0) &#123; var errorMsg = "Please enter your password."; $parent.append("&lt;span class='clew Clew'&gt;"+errorMsg+"&lt;/span&gt;"); &#125;else pwdFlag=1; &#125; &#125;).keyup(function() &#123; $(this).triggerHandler("blur"); &#125;).focus(function() &#123; $(this).triggerHandler("blur"); &#125;);&#125;);//提交检验function validate_form(thisform)&#123; with (thisform)&#123; if (userFlag==0||pwdFlag==0)&#123; username.focus(); return false; &#125; &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body bgcolor="#F6F6F6" &gt;&lt;!--&lt;form action="#" method="get" name="form" id="form"&gt; 当前窗口高度： &lt;input type="text" name="availHeight" size="6"&gt; &lt;br&gt; 当前窗口宽度： &lt;input type="text" name="availWidth" size="6"&gt; &lt;br&gt; &lt;/form&gt;--&gt; &lt;div id="imgcenter"&gt; &lt;img src="E:\MyProject\html\KServer\login\login.png" id="logo" align="left" &gt;&lt;/div&gt; &lt;div id="center"&gt; &lt;form method="post" action="db.html" onsubmit="return validate_form(this);"&gt; &lt;input type=text name="username" value="请输入用户名.." id="account" class="username"&gt; &lt;br&gt; &lt;input type=password name="password" value=".." id="pwd" class="password"&gt; &lt;br&gt; &lt;input type=submit value="登录" id="login"&gt; &lt;div id="div_forgetpwd"&gt; &lt;a href="E:\MyProject\html\KServer\register\register.html" &gt;注册帐号&lt;/a&gt; &lt;a href="E:\MyProject\html\KServer\forget_pwd\forget_pwd.html" &gt;忘记密码&lt;/a&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; //更改元素CSS属性 function set()&#123; var setImgDiv = document.getElementById("imgcenter"); setImgDiv.style.top = "150px"; setImgDiv.style.left = "36%"; var setTextDiv = document.getElementById("center"); setTextDiv.style.top = "280px"; setTextDiv.style.left = "8%"; var setLogo=document.getElementById("logo"); setLogo.style.height="100px"; setLogo.style.width="240px"; var setAccount=document.getElementById("account"); setAccount.style.height="15px"; setAccount.style.width="240px"; var setPwd=document.getElementById("pwd"); setPwd.style.height="15px"; setPwd.style.width="240px"; var setLogin=document.getElementById("login"); setLogin.style.height="25px"; setLogin.style.width="100px"; var setForgetPwd=document.getElementById("div_forgetpwd"); setForgetPwd.style.width="100px"; setForgetPwd.style.left="100%"; &#125; function reSet()&#123; var reSetImgDiv = document.getElementById("imgcenter"); reSetImgDiv.style.top = "250px"; reSetImgDiv.style.left = "20%"; var reSetTextDiv = document.getElementById("center"); reSetTextDiv.style.top = "220px"; reSetTextDiv.style.left = "20%"; var reSetLogo=document.getElementById("logo"); reSetLogo.style.height="auto"; reSetLogo.style.width="50%"; var reSetAccount=document.getElementById("account"); reSetAccount.style.height="auto"; reSetAccount.style.width="50%"; var reSetPwd=document.getElementById("pwd"); reSetPwd.style.height="auto"; reSetPwd.style.width="50%"; var reSetLogin=document.getElementById("login"); reSetLogin.style.height="auto"; reSetLogin.style.width="25%"; var reSetForgetPwd=document.getElementById("div_forgetpwd"); reSetForgetPwd.style.width="100px"; reSetForgetPwd.style.left="90%"; &#125; function setSizeMid()&#123; var setSizeMidImgDiv = document.getElementById("imgcenter"); setSizeMidImgDiv.style.top = "150px"; setSizeMidImgDiv.style.left = "22%"; var setSizeMidTextDiv = document.getElementById("center"); setSizeMidTextDiv.style.top = "280px"; setSizeMidTextDiv.style.left = "-35px"; var setSizeMidLogo=document.getElementById("logo"); setSizeMidLogo.style.height="100px"; setSizeMidLogo.style.width="240px"; var setSizeMidAccount=document.getElementById("account"); setSizeMidAccount.style.height="15px"; setSizeMidAccount.style.width="240px"; var setSizeMidPwd=document.getElementById("pwd"); setSizeMidPwd.style.height="15px"; setSizeMidPwd.style.width="240px"; var setSizeMidLogin=document.getElementById("login"); setSizeMidLogin.style.height="25px"; setSizeMidLogin.style.width="80px"; var setSizeMidForgetPwd=document.getElementById("div_forgetpwd"); setSizeMidForgetPwd.style.width="80px"; setSizeMidForgetPwd.style.left="110%"; &#125; function setSizeMini()&#123; var setSizeMiniImgDiv = document.getElementById("imgcenter"); setSizeMiniImgDiv.style.top = "150px"; setSizeMiniImgDiv.style.left = "6%"; var setSizeMiniTextDiv = document.getElementById("center"); setSizeMiniTextDiv.style.top = "280px"; setSizeMiniTextDiv.style.left = "-60px"; var setSizeMiniLogo=document.getElementById("logo"); setSizeMiniLogo.style.height="100px"; setSizeMiniLogo.style.width="240px"; var setSizeMiniAccount=document.getElementById("account"); setSizeMiniAccount.style.height="15px"; setSizeMiniAccount.style.width="240px"; var setSizeMiniPwd=document.getElementById("pwd"); setSizeMiniPwd.style.height="15px"; setSizeMiniPwd.style.width="240px"; var setSizeMiniLogin=document.getElementById("login"); setSizeMiniLogin.style.height="25px"; setSizeMiniLogin.style.width="80px"; var setSizeMiniForgetPwd=document.getElementById("div_forgetpwd"); setSizeMiniForgetPwd.style.width="80px"; setSizeMiniForgetPwd.style.left="125%"; &#125; //获取当前窗口尺寸 var winWidth = 0; var winHeight = 0; function findDimensions() //函数：获取尺寸 &#123; //获取窗口宽度 if (window.innerWidth) winWidth = window.innerWidth; else if ((document.body) &amp;&amp; (document.body.clientWidth)) winWidth = document.body.clientWidth; //获取窗口高度 if (window.innerHeight) winHeight = window.innerHeight; else if ((document.body) &amp;&amp; (document.body.clientHeight)) winHeight = document.body.clientHeight; //通过深入Document内部对body进行检测，获取窗口大小 if (document.documentElement &amp;&amp; document.documentElement.clientHeight &amp;&amp; document.documentElement.clientWidth) &#123; winHeight = document.documentElement.clientHeight; winWidth = document.documentElement.clientWidth; &#125; //结果输出至两个文本框 if(winWidth&lt;420||winHeight&lt;537) setSizeMini(); else if(420&lt;=winWidth&amp;&amp;winWidth&lt;=595) setSizeMid(); else if(595&lt;winWidth&amp;&amp;winWidth&lt;850||537&lt;winHeight&amp;&amp;winHeight&lt;590) set(); else reSet(); &#125; findDimensions(); //调用函数，获取数值 window.onresize=findDimensions; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MD5 算法解析]]></title>
      <url>%2F2015%2F11%2F21%2Falgorithm-md5-resolve%2F</url>
      <content type="text"><![CDATA[MD5的全称是Message-Digest Algorithm 5，在90年代初由MIT的计算机科学实验室和RSA Data Security Inc发明，经MD2、MD3和MD4发展而来。 MD5将任意长度的“字节串”变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，换句话说就是，即使你看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的数学函数。 MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹)，以防止被“篡改”。举个例子，你将一段话写在一个叫 readme.txt文件中，并对这个readme.txt产生一个MD5的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内容，你对这个文件重新计算MD5时就会发现。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。 MD5还广泛用于加密和解密技术上，在很多操作系统中，用户的密码是以MD5值（或类似的其它算法）的方式保存的， 用户Login的时候，系统是把用户输入的密码计算成MD5值，然后再去和系统中保存的MD5值进行比较，而系统并不“知道”用户的密码是什么。 在一些初始化处理后，MD5以512位分组来处理输入文本，每一分组又划分为16个32位子分组。算法的输出由四个32位分组组成，将它们级联形成一个128位散列值。 首先填充消息使其长度恰好为一个比512位的倍数仅小64位的数。填充方法是附一个1在消息后面，后接所要求的多个0，然后在其后附上64位的消息长度（填充前）。这两步的作用是使消息长度恰好是512位的整数倍（算法的其余部分要求如此），同时确保不同的消息在填充后不相同。 四个32位变量初始化为： 1234A=0×01234567 B=0×89abcdef C=0xfedcba98 D=0×76543210 它们称为链接变量（chaining variable） 接着进行算法的主循环，循环的次数是消息中512位消息分组的数目。 将上面四个变量复制到别外的变量中：A到a，B到b，C到c，D到d。 主循环有四轮（MD4只有三轮），每轮很相拟。第一轮进行16次操作。每次操作对a，b，c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量，文本的一个子分组和一个常数。再将所得结果向右环移一个不定的数，并加上a，b，c或d中之一。最后用该结果取代a，b，c或d中之一。 以下是每次操作中用到的四个非线性函数（每轮一个）。 12345F(X,Y,Z)=(X&amp;Y)|((~X)&amp;Z) G(X,Y,Z)=(X&amp;Z)|(Y&amp;(~Z)) H(X,Y,Z)=X^Y^Z I(X,Y,Z)=Y^(X|(~Z)) (&amp;是与,|是或,~是非,^是异或) 这些函数是这样设计的：如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。 函数F是按逐位方式操作：如果X，那么Y，否则Z。函数H是逐位奇偶操作符。设Mj表示消息的第j个子分组（从0到15），&lt;&lt;&lt; s表示循环左移s位，则四种操作为： 1234FF(a,b,c,d,Mj,s,ti)表示a=b+((a+(F(b,c,d)+Mj+ti)&lt;&lt;&lt; s) GG(a,b,c,d,Mj,s,ti)表示a=b+((a+(G(b,c,d)+Mj+ti)&lt;&lt;&lt; s) HH(a,b,c,d,Mj,s,ti)表示a=b+((a+(H(b,c,d)+Mj+ti)&lt;&lt;&lt; s) II(a,b,c,d,Mj,s,ti)表示a=b+((a+(I(b,c,d)+Mj+ti)&lt;&lt;&lt; s) 这四轮（64步）是： 第一轮 12345678910111213141516FF(a,b,c,d,M0,7,0xd76aa478) FF(d,a,b,c,M1,12,0xe8c7b756) FF(c,d,a,b,M2,17,0×242070db) FF(b,c,d,a,M3,22,0xc1bdceee) FF(a,b,c,d,M4,7,0xf57c0faf) FF(d,a,b,c,M5,12,0×4787c62a) FF(c,d,a,b,M6,17,0xa8304613) FF(b,c,d,a,M7,22,0xfd469501) FF(a,b,c,d,M8,7,0×698098d8) FF(d,a,b,c,M9,12,0×8b44f7af) FF(c,d,a,b,M10,17,0xffff5bb1) FF(b,c,d,a,M11,22,0×895cd7be) FF(a,b,c,d,M12,7,0×6b901122) FF(d,a,b,c,M13,12,0xfd987193) FF(c,d,a,b,M14,17,0xa679438e) FF(b,c,d,a,M15,22,0×49b40821) 第二轮 12345678910111213141516GG(a,b,c,d,M1,5,0xf61e2562) GG(d,a,b,c,M6,9,0xc040b340) GG(c,d,a,b,M11,14,0×265e5a51) GG(b,c,d,a,M0,20,0xe9b6c7aa) GG(a,b,c,d,M5,5,0xd62f105d) GG(d,a,b,c,M10,9,0×02441453) GG(c,d,a,b,M15,14,0xd8a1e681) GG(b,c,d,a,M4,20,0xe7d3fbc8) GG(a,b,c,d,M9,5,0×21e1cde6) GG(d,a,b,c,M14,9,0xc33707d6) GG(c,d,a,b,M3,14,0xf4d50d87) GG(b,c,d,a,M8,20,0×455a14ed) GG(a,b,c,d,M13,5,0xa9e3e905) GG(d,a,b,c,M2,9,0xfcefa3f8) GG(c,d,a,b,M7,14,0×676f02d9) GG(b,c,d,a,M12,20,0×8d2a4c8a) 第三轮 12345678910111213141516HH(a,b,c,d,M5,4,0xfffa3942) HH(d,a,b,c,M8,11,0×8771f681) HH(c,d,a,b,M11,16,0×6d9d6122) HH(b,c,d,a,M14,23,0xfde5380c) HH(a,b,c,d,M1,4,0xa4beea44) HH(d,a,b,c,M4,11,0×4bdecfa9) HH(c,d,a,b,M7,16,0xf6bb4b60) HH(b,c,d,a,M10,23,0xbebfbc70) HH(a,b,c,d,M13,4,0×289b7ec6) HH(d,a,b,c,M0,11,0xeaa127fa) HH(c,d,a,b,M3,16,0xd4ef3085) HH(b,c,d,a,M6,23,0×04881d05) HH(a,b,c,d,M9,4,0xd9d4d039) HH(d,a,b,c,M12,11,0xe6db99e5) HH(c,d,a,b,M15,16,0×1fa27cf8) HH(b,c,d,a,M2,23,0xc4ac5665) 第四轮 12345678910111213141516II(a,b,c,d,M0,6,0xf4292244) II(d,a,b,c,M7,10,0×432aff97) II(c,d,a,b,M14,15,0xab9423a7) II(b,c,d,a,M5,21,0xfc93a039) II(a,b,c,d,M12,6,0×655b59c3) II(d,a,b,c,M3,10,0×8f0ccc92) II(c,d,a,b,M10,15,0xffeff47d) II(b,c,d,a,M1,21,0×85845dd1) II(a,b,c,d,M8,6,0×6fa87e4f) II(d,a,b,c,M15,10,0xfe2ce6e0) II(c,d,a,b,M6,15,0xa3014314) II(b,c,d,a,M13,21,0×4e0811a1) II(a,b,c,d,M4,6,0xf7537e82) II(d,a,b,c,M11,10,0xbd3af235) II(c,d,a,b,M2,15,0×2ad7d2bb) II(b,c,d,a,M9,21,0xeb86d391) 常数ti可以如下选择： 在第i步中，ti是4294967296*abs(sin(i))的整数部分,i的单位是弧度。(2的32次方) 所有这些完成之后，将A，B，C，D分别加上a，b，c，d。然后用下一分组数据继续运行算法，最后的输出是A，B，C和D的级联。 MD5的安全性 MD5相对MD4所作的改进： 增加了第四轮。 每一步均有唯一的加法常数。 为减弱第二轮中函数G的对称性从(X&amp;Y)|(X&amp;Z)|(Y&amp;Z)变为(X&amp;Z)|(Y&amp;(~Z)) 第一步加上了上一步的结果，这将引起更快的雪崩效应。 改变了第二轮和第三轮中访问消息子分组的次序，使其更不相似。 近似优化了每一轮中的循环左移位移量以实现更快的雪崩效应。各轮的位移量互不相同。 MD5源码: md5.h 12345678910111213141516171819202122232425/* md5.h */#ifndef _MD5_H_#define _MD5_H_#define R_memset(x, y, z) memset(x, y, z)#define R_memcpy(x, y, z) memcpy(x, y, z)#define R_memcmp(x, y, z) memcmp(x, y, z)typedef unsigned long UINT4;typedef unsigned char *POINTER;/* MD5 context. */typedef struct &#123; /* state (ABCD) */ /*四个32bits数，用于存放最终计算得到的消息摘要。当消息长度〉512bits时，也用于存放每个512bits的中间结果*/ UINT4 state[4]; /* number of bits, modulo 2^64 (lsb first) */ /*存储原始信息的bits数长度,不包括填充的bits，最长为 2^64 bits，因为2^64是一个64位数的最大值*/ UINT4 count[2]; /* input buffer */ /*存放输入的信息的缓冲区，512bits*/ unsigned char buffer[64]; &#125; MD5_CTX;void MD5Init(MD5_CTX *);void MD5Update(MD5_CTX *, unsigned char *, unsigned int);void MD5Final(unsigned char [16], MD5_CTX *);#endif /* _MD5_H_ */ md5.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271/* md5.cpp */#include &quot;stdafx.h&quot;/* Constants for MD5Transform routine. *//*md5转换用到的常量，算法本身规定的*/#define S11 7#define S12 12#define S13 17#define S14 22#define S21 5#define S22 9#define S23 14#define S24 20#define S31 4#define S32 11#define S33 16#define S34 23#define S41 6#define S42 10#define S43 15#define S44 21static void MD5Transform(UINT4 [4], unsigned char [64]);static void Encode(unsigned char *, UINT4 *, unsigned int);static void Decode(UINT4 *, unsigned char *, unsigned int);/*用于bits填充的缓冲区，为什么要64个字节呢？因为当欲加密的信息的bits数被512除其余数为448时，需要填充的bits的最大值为512=64*8 。*/static unsigned char PADDING[64] = &#123; 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;;/*接下来的这几个宏定义是md5算法规定的，就是对信息进行md5加密都要做的运算。据说有经验的高手跟踪程序时根据这几个特殊的操作就可以断定是不是用的md5*//* F, G, H and I are basic MD5 functions.*/#define F(x, y, z) (((x) &amp; (y)) | ((~x) &amp; (z)))#define G(x, y, z) (((x) &amp; (z)) | ((y) &amp; (~z)))#define H(x, y, z) ((x) ^ (y) ^ (z))#define I(x, y, z) ((y) ^ ((x) | (~z)))/* ROTATE_LEFT rotates x left n bits.*/#define ROTATE_LEFT(x, n) (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n))))/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4. Rotation is separate from addition to prevent recomputation.*/#define FF(a, b, c, d, x, s, ac) &#123; \ (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \ (a) = ROTATE_LEFT ((a), (s)); \ (a) += (b); \&#125;#define GG(a, b, c, d, x, s, ac) &#123; \ (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \ (a) = ROTATE_LEFT ((a), (s)); \ (a) += (b); \&#125;#define HH(a, b, c, d, x, s, ac) &#123; \ (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \ (a) = ROTATE_LEFT ((a), (s)); \ (a) += (b); \&#125;#define II(a, b, c, d, x, s, ac) &#123; \ (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \ (a) = ROTATE_LEFT ((a), (s)); \ (a) += (b); \&#125;/* MD5 initialization. Begins an MD5 operation, writing a new context. *//*初始化md5的结构*/void MD5Init (MD5_CTX *context)&#123; /*将当前的有效信息的长度设成0,这个很简单,还没有有效信息,长度当然是0了*/ context-&gt;count[0] = context-&gt;count[1] = 0; /* Load magic initialization constants.*/ /*初始化链接变量，算法要求这样，这个没法解释了*/ context-&gt;state[0] = 0x67452301; context-&gt;state[1] = 0xefcdab89; context-&gt;state[2] = 0x98badcfe; context-&gt;state[3] = 0x10325476;&#125;/* MD5 block update operation. Continues an MD5 message-digest operation, processing another message block, and updating the context. *//*将与加密的信息传递给md5结构，可以多次调用context：初始化过了的md5结构input：欲加密的信息，可以任意长inputLen：指定input的长度*/void MD5Update(MD5_CTX *context,unsigned char * input,unsigned int inputLen)&#123;unsigned int i, index, partLen;/* Compute number of bytes mod 64 *//*计算已有信息的bits长度的字节数的模64, 64bytes=512bits。用于判断已有信息加上当前传过来的信息的总长度能不能达到512bits，如果能够达到则对凑够的512bits进行一次处理*/index = (unsigned int)((context-&gt;count[0] &gt;&gt; 3) &amp; 0x3F);/* Update number of bits *//*更新已有信息的bits长度*/if((context-&gt;count[0] += ((UINT4)inputLen &lt;&lt; 3)) &lt; ((UINT4)inputLen &lt;&lt; 3)) context-&gt;count[1]++;context-&gt;count[1] += ((UINT4)inputLen &gt;&gt; 29);/*计算已有的字节数长度还差多少字节可以 凑成64的整倍数*/partLen = 64 - index;/* Transform as many times as possible. *//*如果当前输入的字节数 大于 已有字节数长度补足64字节整倍数所差的字节数*/if(inputLen &gt;= partLen) &#123; /*用当前输入的内容把context-&gt;buffer的内容补足512bits*/ R_memcpy((POINTER)&amp;context-&gt;buffer[index], (POINTER)input, partLen); /*用基本函数对填充满的512bits（已经保存到context-&gt;buffer中） 做一次转换，转换结果保存到context-&gt;state中*/ MD5Transform(context-&gt;state, context-&gt;buffer);/*对当前输入的剩余字节做转换（如果剩余的字节&lt;在输入的input缓冲区中&gt;大于512bits的话 ），转换结果保存到context-&gt;state中*/ for(i = partLen; i + 63 &lt; inputLen; i += 64)/*把i+63&lt;inputlen改为i+64&lt;=inputlen更容易理解*/ MD5Transform(context-&gt;state, &amp;input[i]); index = 0; &#125; else i = 0;/* Buffer remaining input *//*将输入缓冲区中的不足填充满512bits的剩余内容填充到context-&gt;buffer中，留待以后再作处理*/R_memcpy((POINTER)&amp;context-&gt;buffer[index], (POINTER)&amp;input[i], inputLen-i);&#125;/* MD5 finalization. Ends an MD5 message-digest operation, writing the the message digest and zeroizing the context. *//*获取加密 的最终结果digest：保存最终的加密串context：你前面初始化并填入了信息的md5结构*/void MD5Final (unsigned char digest[16],MD5_CTX *context)&#123;unsigned char bits[8];unsigned int index, padLen;/* Save number of bits *//*将要被转换的信息(所有的)的bits长度拷贝到bits中*/Encode(bits, context-&gt;count, 8);/* Pad out to 56 mod 64. *//* 计算所有的bits长度的字节数的模64, 64bytes=512bits*/index = (unsigned int)((context-&gt;count[0] &gt;&gt; 3) &amp; 0x3f);/*计算需要填充的字节数，padLen的取值范围在1-64之间*/padLen = (index &lt; 56) ? (56 - index) : (120 - index);/*这一次函数调用绝对不会再导致MD5Transform的被调用，因为这一次不会填满512bits*/MD5Update(context, PADDING, padLen);/* Append length (before padding) *//*补上原始信息的bits长度（bits长度固定的用64bits表示），这一次能够恰巧凑够512bits，不会多也不会少*/MD5Update(context, bits, 8);/* Store state in digest *//*将最终的结果保存到digest中。ok，终于大功告成了*/Encode(digest, context-&gt;state, 16);/* Zeroize sensitive information. */R_memset((POINTER)context, 0, sizeof(*context));&#125;/* MD5 basic transformation. Transforms state based on block. *//*对512bits信息(即block缓冲区)进行一次处理，每次处理包括四轮state[4]：md5结构中的state[4]，用于保存对512bits信息加密的中间结果或者最终结果block[64]：欲加密的512bits信息*/static void MD5Transform (UINT4 state[4], unsigned char block[64])&#123;UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];Decode(x, block, 64);/* Round 1 */FF(a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */FF(d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */FF(c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */FF(b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */FF(a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */FF(d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */FF(c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */FF(b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */FF(a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */FF(d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */FF(c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */FF(b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */FF(a, b, c, d, x[12], S11, 0x6b901122); /* 13 */FF(d, a, b, c, x[13], S12, 0xfd987193); /* 14 */FF(c, d, a, b, x[14], S13, 0xa679438e); /* 15 */FF(b, c, d, a, x[15], S14, 0x49b40821); /* 16 *//* Round 2 */GG(a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */GG(d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */GG(c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */GG(b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */GG(a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */GG(d, a, b, c, x[10], S22, 0x2441453); /* 22 */GG(c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */GG(b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */GG(a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */GG(d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */GG(c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */GG(b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */GG(a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */GG(d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */GG(c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */GG(b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 *//* Round 3 */HH(a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */HH(d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */HH(c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */HH(b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */HH(a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */HH(d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */HH(c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */HH(b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */HH(a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */HH(d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */HH(c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */HH(b, c, d, a, x[ 6], S34, 0x4881d05); /* 44 */HH(a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */HH(d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */HH(c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */HH(b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 *//* Round 4 */II(a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */II(d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */II(c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */II(b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */II(a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */II(d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */II(c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */II(b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */II(a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */II(d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */II(c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */II(b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */II(a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */II(d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */II(c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */II(b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */state[0] += a;state[1] += b;state[2] += c;state[3] += d;/* Zeroize sensitive information. */R_memset((POINTER)x, 0, sizeof(x));&#125;/* Encodes input (UINT4) into output (unsigned char). Assumes len is a multiple of 4. *//*将4字节的整数copy到字符形式的缓冲区中output：用于输出的字符缓冲区input：欲转换的四字节的整数形式的数组len：output缓冲区的长度，要求是4的整数倍*/static void Encode(unsigned char *output, UINT4 *input,unsigned int len)&#123;unsigned int i, j;for(i = 0, j = 0; j &lt; len; i++, j += 4) &#123; output[j] = (unsigned char)(input[i] &amp; 0xff); output[j+1] = (unsigned char)((input[i] &gt;&gt; 8) &amp; 0xff); output[j+2] = (unsigned char)((input[i] &gt;&gt; 16) &amp; 0xff); output[j+3] = (unsigned char)((input[i] &gt;&gt; 24) &amp; 0xff);&#125;&#125;/* Decodes input (unsigned char) into output (UINT4). Assumes len is a multiple of 4. *//*与上面的函数正好相反，这一个把字符形式的缓冲区中的数据copy到4字节的整数中（即以整数形式保存）output：保存转换出的整数input：欲转换的字符缓冲区len：输入的字符缓冲区的长度，要求是4的整数倍*/static void Decode(UINT4 *output, unsigned char *input,unsigned int len)&#123;unsigned int i, j;for(i = 0, j = 0; j &lt; len; i++, j += 4) output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) &lt;&lt; 8) | (((UINT4)input[j+2]) &lt;&lt; 16) | (((UINT4)input[j+3]) &lt;&lt; 24);&#125; md5test.cpp 123456789101112131415161718192021222324// md5test.cpp : Defines the entry point for the console application.//#include &quot;stdafx.h&quot;#include &quot;string.h&quot;int main(int argc, char* argv[])&#123; MD5_CTX md5; MD5Init(&amp;md5); //初始化用于md5加密的结构 unsigned char encrypt[200]; //存放于加密的信息 unsigned char decrypt[17]; //存放加密后的结果 scanf(&quot;%s&quot;,encrypt); //输入加密的字符 MD5Update(&amp;md5,encrypt,strlen((char *)encrypt)); //对欲加密的字符进行加密 MD5Final(decrypt,&amp;md5); //获得最终结果 printf(&quot;加密前:%s\n加密后:&quot;,encrypt); for(int i=0;i&lt;16;i++) printf(&quot;%2x &quot;,decrypt[i]); printf(&quot;\n\n\n加密结束!\n&quot;); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[地图定位异常问题]]></title>
      <url>%2F2015%2F11%2F04%2Flocation-map-debug-error%2F</url>
      <content type="text"><![CDATA[地图定位是做LBS服务的App通常用到的模块。但是，随着iOS系统的升级，地图定位模块出现了不一样的异常，这里将遇到的并解决的问题分享出来。 一、CLLocationManagerDelegate不调用didUpdateLocations 这是因为xcode升级造成的定位权限设置问题。 升级xcode6以后打开以前xcode5工程，程序不能定位。工程升级到xcode6编译时需要iOS8 要自己写授权，不然没权限定位。 解决方法： 首先在 info.plist里加入对应的缺省字段，值设置为YES（前台定位写上边字段，前后台定位写下边字段） 12NSLocationWhenInUseUsageDescription //允许在前台获取GPS的描述NSLocationAlwaysUsageDescription //允许在前、后台获取GPS的描述 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#import "ViewController.h"#import &lt;CoreLocation/CoreLocation.h&gt;@interface ViewController ()&lt;CLLocationManagerDelegate&gt;@property (nonatomic, strong)CLLocationManager *locationManager;@end@implementation ViewController // 1. 懒加载初始化：- (CLLocationManager *)locationManager&#123; if(!_locationManager)&#123; self.locationManager= [[CLLocationManager alloc] init]; self.locationManager.delegate= self; &#125; return_locationManager;&#125;- (void)viewDidLoad &#123; [superviewDidLoad];// 2. 调用请求： if ([[[UIDevicecurrentDevice] systemVersion] doubleValue] &gt; 8.0)&#123; //设置定位权限 仅ios8有意义 [self.locationManagerrequestWhenInUseAuthorization];// 前台定位 //[self.locationManagerrequestAlwaysAuthorization];// 前后台同时定位 &#125; [self.locationManagerstartUpdatingLocation];&#125; // 3.代理方法- (void)locationManager:(CLLocationManager*)manager didUpdateLocations:(NSArray *)locations&#123; NSLog(@"%ld",locations.count);&#125;@end 二、ErrorDomain=kCLErrorDomain Code=0 “The operation couldn’t be completed. 环境：XCODE6.0.1 + iPhone / iOS8 错误：使用CoreLocation获取地理位置信息，报错 1Error Domain=kCLErrorDomain Code=0&quot;The operation couldn’t be completed. (kCLErrorDomain error 0.)&quot; 解决方法： 1.确定模拟器（手机）已经联网并且允许程序获取地理位置 2.重置地理位置服务或者网络服务 PS：如果是模拟器就果断直接重置模拟器 重置模拟器方法：iOS Simulator -&gt; Reset Content andSettings…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objective-C 继承和多态]]></title>
      <url>%2F2015%2F09%2F26%2FObjc-inherit-multimodal%2F</url>
      <content type="text"><![CDATA[学习Java我们知道类有三大特征，封装，继承，多态。而在Objective-C中也有继承的概念，今天就来看看Objective-C中的继承和多态。 首先,我们来看看示例代码: 1234567891011121314151617181920212223//Animal.h#import &lt;Foundation/Foundation.h&gt; @interface Animal : NSObject&#123; int food_consumption; //食量 int count; //数量 int parturition_days; //生产周期&#125; -(int)count; -(void)setCount:(int)c; -(int)foodConsumption; -(void)setFoodConsumption:(int)food_c; -(int)parturitionDays; -(void)setParturitionDays:(int)parturition_day; @end 123456789101112131415161718192021222324252627282930//Animal.m#import &quot;Animal.h&quot; @implementation Animal -(int)count&#123; return count;&#125; -(void)setCount:(int)c&#123; count = c;&#125; -(int)foodConsumption&#123; return food_consumption;&#125; -(void)setFoodConsumption:(int)food_c&#123; food_consumption = food_c;&#125; -(int)parturitionDays&#123; return parturition_days;&#125; -(void)setParturitionDays:(int)parturition_day&#123; parturition_days = parturition_day;&#125; @end 123456//Panda.h#import &quot;Animal.h&quot; @interface Panda : Animal @end 123456//Panda.m#import &quot;Panda.h&quot; @implementation Panda @end 12345678910//Tool.h#import &lt;Foundation/Foundation.h&gt;#import &quot;Animal.h&quot;#import &quot;Panda.h&quot; @interface Tool : NSObject +(void) initWithAnimalDictionary:(Animal *)animal andDict:(NSDictionary *)dict; @end 12345678910111213141516171819//Tool.m#import &quot;Tool.h&quot; @implementation Tool +(void) initWithAnimalDictionary:(Animal *)animal andDict:(NSDictionary *)dict&#123; NSDictionary *animalDict; if(YES == [animal isKindOfClass:[Panda class]])&#123; animalDict = [dict objectForKey:@&quot;Panda&quot;]; &#125;else&#123; NSLog(@&quot;error class!&quot;); &#125; [animal setCount:[[animalDict objectForKey:@&quot;count&quot;] intValue]]; [animal setFoodConsumption:[[animalDict objectForKey:@&quot;food_consumption&quot;] intValue]]; [animal setParturitionDays:[[animalDict objectForKey:@&quot;parturition_days&quot;] intValue]];&#125; @end data.plist文件 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;fodder&lt;/key&gt; &lt;dict&gt; &lt;key&gt;count_num&lt;/key&gt; &lt;string&gt;1024&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;Panda&lt;/key&gt; &lt;dict&gt; &lt;key&gt;food_consumption&lt;/key&gt; &lt;string&gt;2&lt;/string&gt; &lt;key&gt;count&lt;/key&gt; &lt;string&gt;6&lt;/string&gt; &lt;key&gt;parturition_days&lt;/key&gt; &lt;string&gt;76&lt;/string&gt; &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt; 1234567891011121314151617181920212223242526272829303132333435363738//main.m#import &lt;Foundation/Foundation.h&gt;#import &quot;Tool.h&quot; int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... Panda *panda = [[Panda alloc] init]; //读取plist NSString *plistPath = [[NSBundle mainBundle] pathForResource:@&quot;data&quot; ofType:@&quot;plist&quot;]; NSMutableDictionary *data = [[NSMutableDictionary alloc] initWithContentsOfFile:plistPath]; [Tool initWithAnimalDictionary:panda andDict:data]; int fooder_num = 0; int surplus = 0; int day = 1; NSDictionary *fooderDict = [data objectForKey:@&quot;fodder&quot;]; fooder_num = [[fooderDict objectForKey:@&quot;count_num&quot;] intValue]; surplus = fooder_num; while(surplus &gt; 0)&#123; if(0 == (day % [panda parturitionDays]))&#123; [panda setCount:([panda count] + 1)]; &#125; surplus = fooder_num - ([panda count] * [panda foodConsumption]); fooder_num = surplus; if(surplus)&#123; NSLog(@&quot;第 %d 天，熊猫:%d 只，饲料余量:%d 。\n&quot;, day, [panda count], surplus); &#125; day++; &#125; &#125; return 0;&#125; 继承 继承是类中的一个重要的特性，它的出现使得我们没必要别写重复的代码，可重用性很高。当然Objective-C中的继承和Java中是一样的，没多大区别。不仅仅Java，C++也有继承特性，但C++支持多继承，而Objective-C不支持多继承。 概念:(1)超类(superclass)，是你所继承的类。例如，Panda的超类是Animal，Animal的超类是NSObject。 (2)父类(parentclass)，是超类的另一种表达方式。例如，Animal是Panda的父类。 (3)子类(subclass)，是实施继承的类。例如，Panda是Animal的子类。 (4)孩子类(childclass)，是子类的另一种表达方式。例如，Panda是Animal的孩子类。 继承的工作机制:(1)方法调度 当代码发送消息时，Objective-C的方法调度程序将在当前类中搜索相应的方法。如果调度程序无法在接收消息的对象类中找到相应的方法，它就在该对象的超类中进行查找。 (2)实例变量 接下来我们看看Objective-C如何访问实例变量。创建一个新类时，其对象首先从自身的超类中继承实例变量，然后(可选)添加它们自己的实例变量。 最后，说说重写方法，制作自己全新的子类时，通常需要添加自己的方法。有时，为了在类中引入某个独特的特性，需要添加新方法。还有些时候，可能需要替换或增强由这个新类的某个超类所定义的现有方法。当遇到我们子类特有的方法时，则只需要在子类中重写该方法即可。 多态在Objective-C中，多态就是指，父类指针可以指向子类。 1+(void) initWithAnimalDictionary:(Animal *)animal andDict:(NSDictionary *)dict; 上例代码中的从字典中获取数据的类方法就很好地使用了多态。该方法主要是从字典中读取数据，示例中只有Panda一个子类，若是以后拥有更多的类，那么该功能的方法需要为每一个子类写一个方法，而使用多态特性，则只需根据传入的参数进行分别处理即可，减少代码冗余问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NSString 字符串使用（基础篇）]]></title>
      <url>%2F2015%2F09%2F13%2Fnsstring-using%2F</url>
      <content type="text"><![CDATA[摘要：iOS字符串主要分为两大类：NSString和NSMutableString。即不可变和可变字符串。在很多时候两者使用差异不大。文章分享字符串使用方法。 一、不可变字符NSString是不可变字符串，它产生的其他字符串方法都是生成一个新的字符串，而不会改变原来字符串。 1.创建方式1）字面量，它是常量字符串，存储常量区 1NSString *str=@&quot;hello&quot;; 2）通过快捷构造法，存储堆区 1NSString *str = [NSString stringWithFormat:@&quot;hello %@&quot;, @&quot;world&quot;]; 3）初始化方法 1NSString *str = [[NSString alloc] initWithFormat:@&quot;%@&quot;,@&quot;hello&quot;]; 2.字符串的获取1）获取字符串长度 12NSString *str=@&quot;hello&quot;;long length = str.length; 2）获取子串 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273NSString *str=@&quot;hello&quot;;/*从索引字符串开始截取，直到字符串末尾，包含索引上的字符*/NSString *strSub = [str substringFormIndex:2];/*从字符串开头开始截取，直到索引位置，不包含索引上的字符*/NSString *strSubT = [str substringToIndex:2];/*从哪个位置开始，截取多长*/NSRange range = &#123;2,4&#125;;NSString *strSubR = [str substringWithRange:range];/*获取某个子串所在的区域*/NSRange rangeS = [str rangeOfString&quot;@&quot;el&quot;];/*单词首字母转大写*/[str capitalizedString];/*字符替换*/NSString *newStr = [str stringByReplacingOccurencesOfString:@&quot;ll&quot; withString:@&quot;al&quot;];/*使用某个字符串替换掉原来字符串中某个区间的字符串*/NSRange range = [str rangeOfString:@&quot;ll&quot;];NSString *newStr = [str stringByReplacingCharactersInRange:range withSring:@&quot;hi&quot;];/*删除原字符串中的所有指定字符串*/NSString *newStr = [str stringByReplacingOccurencesOfString:@&quot;ll&quot; withString:@&quot;&quot;];/*去掉两头空格*/NSString *newStr = [str stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];/*在原来路径上拼接一个路径*/NSString *path = @&quot;/Users/dengwei&quot;;path = [path stringByAppendingPathComponent:@&quot;Desktop&quot;];/*获取扩展名*/NSString *path = @&quot;/Users/dengwei/Desktop/apple.txt&quot;;path = [path stringByDeletingPathExtension];path = [path stringByAppendingPathExtension:@&quot;png&quot;];/*把字符串写入文件*/NSString *str = @&quot;today is cold!&quot;;NSString *path = @&quot;/Users/dengwei/Desktop/apple.txt&quot;;NSError *error;BOOL isSuccess = [str writeToFile:path atomically:YES encoding:NSUTF8StringEncoding error:&amp;error];/*读取文件*/NSString *string = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:&amp;error];/*字符串与URL*//*URL：Uniform Resource Locator 统一资源定位符URL：格式 协议头://主机名称/资源路径http://www.baidu.com/some/images/pic.png404：没有找到资源*/NSString *str = @&quot;today is cold!&quot;;/*url路径中不支持中文，若是有中文则需将中文转码*/NSURL *url = [NSURL URLWithString:@&quot;file:///Users/dengwei/Desktop/apple.txt&quot;];/*将中文转码*/NSString *url_cn = @&quot;file:///Users/dengwei/Desktop/中文.txt&quot;;/*编码，把UTF8编码的字符串编码成URL中可用的字符串*/url_cn = [url_cn stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];/*解码，把URL中可用的字符串编码的字符串解码成UTF8编码的字符串*/url_cn = [url_cn stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];url_cn = [NSURL URLWithString:url_cn];NSError *error;/*写入*/BOOL isSuccess = [str writeToURL:url atomically:YES encoding:NSUTF8StringEncoding error:&amp;error];/*读取*/NSString *string = [str stringWithContentsOfURL:url atomically:YES encoding:NSUTF8StringEncoding error:&amp;error]; 3.字符串范围获取123/*计算文本大小*/CGSize maxSize = CGSizeMake(MAXFLOAT, MAXFLOAT);/*width与height都不限制*/CGSize nameSize = [self.microBlogModel.name boundingRectWithSize:maxSize options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:15]&#125; context:nil].size; 二、可变字符NSMutableString，可变字符，是NSString的子类。一个字符串需要经常修改其中的内容，则使用NSMutableString。 123NSMutableString *strM = [NSMutableString string];/*Capacity表示容量，可以容纳多少字符，如果超过这个存储空间，就会扩展它*/NSMutableString *strM = [NSMutableString stringWithCapacity:10];]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[VC 调用 DLL]]></title>
      <url>%2F2013%2F01%2F24%2Fvc-invoke-dll%2F</url>
      <content type="text"><![CDATA[DLL 动态数据链路库。 调用DLL有两种方法：静态调用和动态调用. (一).静态调用其步骤如下: 1.把你的youApp.DLL拷到你目标工程(需调用youApp.DLL的工程)的Debug目录下; 2.把你的youApp.lib拷到你目标工程(需调用youApp.DLL的工程)目录下; 3.把你的youApp.h(包含输出函数的定义)拷到你目标工程(需调用youApp.DLL的工程)目录下; 4.打开你的目标工程选中工程,选择Visual C++的Project主菜单的Settings菜单; 5.执行第4步后，VC将会弹出一个对话框，在对话框的多页显示控件中选择Link页。然后在Object/library modules输入框中输入:youApp.lib 6.选择你的目标工程Head Files加入：youApp.h文件; 7.最后在你目标工程(*.cpp,需要调用DLL中的函数)中包含你的:#include “youApp.h” 注：youApp是你DLL的工程名。 (二).动态调用其程序如下: 动态调用时只需做静态调用 12345678910111213141516&#123; HINSTANCE hDllInst = LoadLibrary("youApp.DLL"); if(hDllInst) &#123; typedef DWORD (WINAPI *MYFUNC)(DWORD,DWORD); MYFUNC youFuntionNameAlias = NULL; // youFuntionNameAlias 函数别名 youFuntionNameAlias = (MYFUNC)GetProcAddress(hDllInst,"youFuntionName"); // youFuntionName 在DLL中声明的函数名 if(youFuntionNameAlias) &#123; youFuntionNameAlias(param1,param2); &#125; FreeLibrary(hDllInst); &#125;&#125; 显式（静态）调用： LIB + DLL + .H，注意.H中dllexport改为dllimport 隐式（动态）调用： DLL + 函数原型声明，先LoadLibrary，再GetProcAddress（即找到DLL中函数的地址），不用后FreeLibrary]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Factory模式与Prototype模式的异同]]></title>
      <url>%2F2013%2F01%2F23%2Ffactory-prototype-diff%2F</url>
      <content type="text"><![CDATA[设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 原型模式与工厂模式的定义，本文不想在这讲太多，本文主要想在这讲一下对原型模式的一些误解－－将原型模式等价于工厂模式。 为什么会产生这种误导呢？其实也不是我们的错，关键在于设计模式这本书以及网上的其它资料很喜欢将原型和工厂方法进行比较，从而导致我们误解了原型引入的本质意义。 按博主的理解，原型引入的根本原因就是在于它可以利用一个原型对象（指的是实例，而非类），快速地生成一批和原型对象一样的实例。举个例子来说，你有一个类A的实例a (A a=new A()),现在你想生成一个和a一样的实例b,那么，按照原型的定义，你应该可以这样做b=a.clone()。这样，你就可以得到一个和a一模一样的实例b(即a和部b的数据成员的值完全一样）。 上面是原型的一个简单说明，那么引入原型有什么好处呢？按博主的理解，就是在于：你如果要生成一大批很相像的类的实例时，省得每次去做重复的赋值工作。再举个例子，如果你有一个类A,它有十个成员变量，现在你打算生成100个A的实例，而这些实例的变量值大部分相同（比如说七个相同），只有一小部分不一样（比如说三个），那么如果没有Prototype,那么你就得每次New一个A的对像，然后赋值，这样，你要重复100次同样的七个变量的赋值工作，显然，这样很麻烦。现在你有了原型，那么问题就简单了，你只要生成一个A的实例，再通过clone来生成其它的实例，然后再一一修改其它实例不同的地方。 可能这么讲，大家不信，那下面，再让我们来看看Java中活生生的原型应用。 学过Java的人都知道，在Java中,有一个clone()函数，这个函数的功能，就是返回一个和当前调用它的对象一样的实例。那么Java中为什么要引入这个函数呢？ 在【Think in Java】一书中，作者如是解释：“如果，你要将一个对象的引用作为参数传进去，但又不希望函数改变对象的值，那么，你该怎么办？由于在Java中对象没有像C++那样的Const修饰符，所以，为了实现这个功能，Java中引入了clone函数，使得你将对象的引用作为参数传进函数时，这个函数可以调用该对象的Clone方法生成该对象的一份拷贝，从而达到不修改原对象的目的。” 之所以用上面这么多篇幅来讲述原型本质，目的就在于希望各位不要把原型的功能与它的意义给混了，以致于当真正要使用原型来解决问题时，却不知可以使用它。 好了，上面说了原型的本质意义。那为什么很多资料喜欢将原型同工厂模式进行比较呢？不知是不是巧合，虽然原型引入的初衷是像上面所说，但它实现起来，却又完全可以达到工厂模式的效果。而且，用起来甚至比工厂模式更方便、灵活。对于工厂模式与原型模式在功能上的这点巧合，也许是因为本来工厂模式和原型模式都是创建型模式，这样，它们的基本功能都能生成对象，因而使得原型模式在功能上可以代替工厂模式。 对这两种模式在功能上的相同点，程序员2001年第11期杂志上有一篇”非鱼“写的文章，作者理解得非常巧妙，即：如果你将工厂模式的UML图对折，你得到的就是Prototype原型的UML图。有兴趣比较这两种模式的朋友，可以去参考这篇文章。 接下来，让我们在实现机制上来看看原型模式为什么可以实现工厂模式的功能(本文只限于Java语言）。在Java中，对于原型的实现，其实根本不用我们做，在object类中早就定义了一个clone函数，而这个函数，就使得我们可以动态地生成对象的当前拷贝。既然这样，那么让我们来看看，如果要实现工厂模式的功能，我们该如何使用原型模式为做到呢？ 工厂模式实现生产产品的功能，关键是利用了继承的特性。也就是说，你生成的产品，一定是由同一个抽象产品类派生出来的。所以，在工厂模式下，你如果要生成一类产品，就要引入一个抽像产品类，然后再由它派生出具体产品。同样，在原型模式中，你完全可以同样定义一个这样的“抽象产品－－具体产品”层次，再利用具体产品本身的clone功能来产生具体产品本身。从而达到实现工厂模式功能的目的。可能说到这，大家有点糊涂了。实际上，在原型模式中，每个具体产品就扮演了工厂模式里的具体工厂的角色（为什么会这样，其实很简单，因为，每个具体产品都具有生成自己拷贝的功能？从这种意义上讲，难道这不正是工厂的作用吗？）。 另外，要在Java中利用原型模式实现工厂模式的功能，则更为简单，因为object已经为我们实现了clone函数，且对于clone方法，Java中默认是：如果A是父类且A实现了clone函数，B是A的子类，则B不用实现clone函数，它只要调用父类的clone函数，Java就会在运行时动态地为我们生成正确的B的对象。理解这点的关键在于，所有类实现的clone操作都是调用object的clone方法。这也就是说，上面所说的父类A根本就不用自己实现clone方法，而仅仅是调用父类（object)的clone方法而已。 好，到了这，读者也许又有疑问了，既然所有的clone操作都是由object实现的，而在Java中所有的自定义类默认都是由object派生而来，那这样的话，应该所有的类都自动就具有了clone自己的能力？确实，如果object不将它的clone函数声明为protect的话，情况的确如此。但Java为了安全方面的原因，所以没有将clone方法公开，而是声明为保护类型，这样的话，子类是不可以直接调用object类的clone方法的，而必须做到如下两点： 1.必须实现Cloneable接口； 2.必须声明一个clone方法，来调用object的clone函数； Java在调用父类的clone函数时，都会在运行时动态地进行检查，如果发现调用的类不符合上面的任何一点，则会抛出一个异常。明白了上面的原因，那么如果我们希望某个类具备clone自身的能力，那么，我们可以这样做： 1.直接按上面所说，自己实现clone操作； 2.声明一个抽象父类，实现上面的clone操作并将它声明为公开方法，再由此类派生出子类，这样，所有的子类只要调用父类的clone方法，就能够正确地拷贝自己。 通常，我们都是使用第一种方式，但在我们现在讨论的如何用原型模式实现工厂模式的功能的问题中，我们最好是采用第二种方式。 最后，让我们通过具体的代码来看看如何用Prototype模式实现工厂模式的功能。 问题： 现有两类产品 1－Ram,2–Cpu,现在要生成具体的产品MacRam,MacCpu和WinRam,WinCpu. 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/**A:Abstract*C:Concrete *//* 定义抽象产品Ram的类 APrototypeRam * 同时它也是抽象工厂*/abstract class APrototypeRam implements Cloneable &#123; public Object clone() &#123; Object o=null; try &#123; o=super.clone();//调用父类，即Object的clone() &#125; catch(CloneNotSupportedException e) &#123; System.err.println("APrototypeRam is not cloneable!"); &#125; return o; &#125;&#125;/* 定义抽象产品Ram的类APrototypeProductCpu* 同时它也是抽象工厂*/abstract class APrototypeCpu implements Cloneable &#123; public Object clone() &#123; Object o=null; try &#123; o=super.clone();//调用父类，即Object的clone() &#125; catch(CloneNotSupportedException e) &#123; System.err.println("APrototypeCpu is not cloneable!"); &#125; return o; &#125;&#125;/* 定义具体产品MacRam的类CPrototypeMacRam* 同时它也是具体工厂*/class CPrototypeMacRam extends APrototypeRam&#123; public String toString() &#123; return "MacRam"; &#125;&#125;/* 定义具体产品WinRam的类CPrototypeWinRam* 同时它也是具体工厂*/class CPrototypeWinRam extends APrototypeRam &#123; public String toString() &#123; return "WinRam"; &#125;&#125;/* 定义具体产品MacCpu的类CPrototypeMacCpu* 同时它也是具体工厂*/class CPrototypeMacCpu extends APrototypeCpu&#123; public String toString() &#123; return "MacCpu"; &#125;&#125;/* 定义具体产品WinCpu的类CPrototypeWinCpu* 同时它也是具体工厂*/class CPrototypeWinCpu extends APrototypeCpu&#123; public String toString() &#123; return "WinCpu"; &#125;&#125;/* 客户端，使用CPrototypeRam和CPrototypeCpu生成如下产品* MacRam,MacCpu,WinRam,WinCpu*/public class Prototype &#123; public static void main(String[] args) &#123; /* * 在生成产品之前，先生成原型产品，以便后面利用它们成批生产相同产品 * 其作用等价于产品工厂 */ CPrototypeMacRam prototypeMacRam=new CPrototypeMacRam(); CPrototypeWinRam prototypeWinRam=new CPrototypeWinRam(); CPrototypeMacCpu prototypeMacCpu=new CPrototypeMacCpu(); CPrototypeWinCpu prototypeWinCpu=new CPrototypeWinCpu(); CPrototypeMacRam MacRam=(CPrototypeMacRam)prototypeMacRam.clone(); CPrototypeWinRam WinRam=(CPrototypeWinRam)prototypeWinRam.clone(); CPrototypeMacCpu MacCpu=(CPrototypeMacCpu)prototypeMacCpu.clone(); CPrototypeWinCpu WinCpu=(CPrototypeWinCpu)prototypeWinCpu.clone(); System.out.println("打印原型产品与它的克隆产品与比较异同!"); System.out.println("prototypeMacRam:"+prototypeMacRam+" Cloned:"+MacRam); System.out.println("prototypeWinRam:"+prototypeWinRam+" Cloned:"+WinRam); System.out.println("prototypeMacCpu:"+prototypeMacCpu+" Cloned:"+MacCpu); System.out.println("prototypeWinCpu:"+prototypeWinCpu+" Cloned:"+WinCpu); &#125;&#125; 通过上面代码，我们可以清楚地看到，用Prototype模式实现工厂模式更为简单，如果再配上原型管理器的话，那么Prototype模式则会变得更为灵活。但同时，我们也发现，使用原型模式时，有一个不足之处，即在客户端代码里，我们必须显式进行类型转换，这样可能导致错误。为了改正这一点，我们可以使用真正的工厂模式将Prototype模式再封装一遍。对工厂模式的这项功能，恐怕，Prototype原型模式就无能为力了。 总之，工厂模式和原型模式虽然在引入目的上不同，但在实现上，原型模式可以实现工厂模式同样的功能。但读者也不要因为这样，而将两者混为一体，因为，反过来，在将原型模式作为生成本身拷贝的这项功能使用时，工厂模式根本无法取代它。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL Server 错误代码和解释 (下篇)]]></title>
      <url>%2F2013%2F01%2F22%2Fsql-server-state-code-list-3%2F</url>
      <content type="text"><![CDATA[承接《下篇》继续罗列分享SQL Server状态码。 5001 因为其它资源需要它，不能将群集资源移到另一个组。5002 找不到此群集资源的依存。5003 因为已经处于依存状态，此群集资源不能依存于指定的资源。5004 此群集资源未联机。5005 此操作没有可用的群集节点。5006 没有群集资源。5007 找不到群集资源。5008 正在关闭群集。5009 因为联机，群集节点无法从群集中脱离。5010 对象已存在。5011 此对象已在列表中。5012 新请求没有可用的群集组。5013 找不到群集组。5014 因为群集组未联机，此操作不能完成。5015 群集节点不是此资源的所有者。5016 群集节点不是此资源的所有者。5017 群集资源不能在指定的资源监视器中创建。5018 群集资源不能通过资源监视器来联机。5019 因为群集资源联机，此操作不能完成。5020 由于是仲裁资源，群集资源不能被删除或脱机。5021 由于没有能力成为仲裁资源，此群集不能使指定资源成为仲裁资源。5022 群集软件正关闭。5023 组或资源的状态不是执行请求操作的正确状态。5024 属性已被存储，但在下次资源联机前，不是所有的修改将生效。5025 由于不属于共享存储类别，群集不能使指定资源成为仲裁资源。5026 由于是内核资源，无法删除群集资源。5027 仲裁资源联机失败。5028 无法成功创建或装入仲裁日志。5029 群集日志损坏。5030 由于该日志已超出最大限量，无法将记录写入群集日志。5031 群集日志已超出最大限量。5032 群集日志没有发现检查点记录。5033 不满足日志所需的最小磁盘空间。5034 群集节点未能控制仲裁资源，因为它被另一个活动节点拥有。5035 这个操作的群集网络无效。5036 此操作没有可用的群集节点。5037 所有群集节点都必须运行才能执行这个操作。5038 群集资源失败。5039 该群集节点无效。5040 该群集节点已经存在。5041 一个节点正在加入该群集。5042 找不到群集节点。5043 找不到群集本地节点信息。5044 群集网络已经存在。5045 找不到群集网络。5046 群集网络界面已经存在。5047 找不到群集网络界面。5048 群集请求在这个对象中无效。5049 群集网络提供程序无效。5050 群集节点坏了。5051 无法连接到群集节点。5052 该群集节点不是群集的一个成员。5053 群集加入操作正在进行中。5054 该群集网络无效。5055 Mar5056 该群集节点可以使用。5057 该群集 IP 地址已在使用中。5058 该群集节点没有中止。5059 没有有效的群集安全上下文。5060 该群集网络不是为内部群集通讯配置的。5061 群集节点已经开始。5062 群集节点已经坏了。5063 群集网络已经联机。5064 群集网络已经脱机。5065 群集节点已经是该群集的成员。5066 该群集网络是唯一个为两个或更多活动群集节点进行内部群集通讯的配置。不能从网络上删除内部通讯能力。5067 一个或更多的群集资源依靠网络来向客户提供服务。不能从网络上删除客户访问能力。5068 该操作不能在群集资源上作为仲裁资源执行。您不能将仲裁资源脱机或修改它的所有者名单。5069 该群集仲裁资源不允许有任何依存关系。5070 该群集节点暂停。5071 群集资源不能联机。所有者节点不能在这个资源上运行。5072 群集节点没有准备好，不能执行所请求的操作。5073 群集节点正在关闭。5074 放弃群集节点加入操作。5075 由于加入节点和支持者之间的软件版本不兼容，该群集加入操作失败。5076 由于该群集已经到达其所能监督的资源限制，不能创建这个资源。5077 系统配置在群集加入或形成操作时已更改。放弃加入或形成操作。5078 找不到指定的资源种类。5079 指定的节点不支持这种资源，这也许是由于版本不一致或是由于在这个节点上没有资源 DLL。5080 该资源 DLL 不支持指定的资源名称。这可能是由于一个提供给源 DLL 名称是错误的(或经过更改的)。5081 不能在 RPC 服务器上注册任何身份验证包。5082 由于组的所有者不在组的首选列表中，不能将组联机。要改变组的所有者节点，请移动组。5083 群集数据库的系列号已改变，或者与锁定程序节点不相容，因此加入操作没有成功。如果在加入操作期间群集数据库有任何改动，这都可能发生。5084 资源在其当前状态下，资源监视器不允许执行失败操作。资源处于挂起状态时，这都可能发生。5085 非锁定程序代码收到一个为全局更新保留锁定的请求。5086 群集服务找不到仲裁磁盘。5087 已备份的群集数据库可能已损坏。5088 DFS 根目录已在这个群集节点中。5089 由于与另一个现有属性冲突，未能修改资源属性。5090 西班牙5091 丹麦5092 瑞典5093 挪威5094 德国5095 澳大利亚5096 日本5097 韩国5098 中国5099 台湾5100 亚洲5101 葡萄牙5102 芬兰5103 阿拉伯5104 希伯莱5153 UPS 服务即将执行最后的关机操作。5170 工作站必须用 NET START 才能启动。5175 远程 IPC5176 远程管理5177 默认共享5291 永不5292 永不5293 永不5295 NETUS.HLP5296 NET.HLP5300 网络控制块 (NCB) 请求运行成功。 NCB 是相关数据。5301 SEND DATAGRAM、SEND BROADCAST、ADAPTER STATUS 或 SESSION STATUS 的网络控制块 (NCB) 缓冲区长度无效。 NCB 是相关数据。5302 网络控制块 (NCB) 指定的数据描述数组无效。 NCB 是相关数据。5303 网络控制块 (NCB) 指定的命令无效。 NCB 是相关数据。5304 网络控制块 (NCB) 指定的消息交换码无效。 NCB 是相关数据。5305 网络控制块 (NCB) 命令超时。会话可能异常终止。 NCB 是相关数据。5306 接收的网络控制块 (NCB) 消息不完整。 NCB 是相关数据。5307 网络控制块 (NCB) 指定的缓冲区无效。 NCB 是相关数据。5308 网络控制块 (NCB) 指定的会话号码没有作用。 NCB 是相关数据。5309 网卡没有任何资源可用。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。5310 网络控制块 (NCB) 指定的会话已经关闭。 NCB 是相关数据。5311 网络控制块 (NCB) 命令已经取消。 NCB 是相关数据。5312 网络控制块 (NCB) 指定的消息块不合逻辑。 NCB 是相关数据。5313 该名称已经存在于本地适配器名称表中。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。5314 网卡名称表已满。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。5315 网络名称已经有活动的会话，现在取消注册。 网络控制块 (NCB) 命令运行完毕。NCB 是相关数据。5316 先前发出的 Receive Lookahead 命令对此会话仍起作用。 网络控制块 (NCB) 命令被拒绝。 NCB 是相关数据。5317 本地会话表已满。网络控制块 (NCB) 请求被拒绝。 NCB 是相关数据。5318 拒绝打开网络控制块 (NCB) 会话，远程计算机上没有侦听命令在执行。 NCB 是相关数据。5319 网络控制块 (NCB) 指定的名称号码无效。 NCB 是相关数据。5320 网络控制块 (NCB) 中指定的调用名称找不到， 或者没有应答。NCB 是相关数据。5321 网络控制块 (NCB) 中指定的名称找不到。无法将“*”或 00h 填入 NCB 名称。NCB 是相关数据。5322 网络控制块 (NCB) 中指定的名称正用于远程适配器。 NCB 是相关数据。5323 网络控制块 (NCB) 中指定的名称已经删除。 NCB 是相关数据。5324 网络控制块 (NCB) 中指定的会话异常终止。 NCB 是相关数据。5325 网络协议在网络上检测两个或数个 相同的名称。 网络控制块 (NCB) 是相关数据。5326 收到意外的协议数据包。 远程设备可能不兼容。网络控制块 (NCB) 是相关数据。5333 NetBIOS 界面正忙。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。5334 未完成的网络控制块 (NCB) 命令太多。 NCB 请求被拒绝。NCB 是相关数据。5335 网络控制块 (NCB) 中指定的适配器号无效。 NCB 是相关数据。5336 网络控制块 (NCB) 命令在取消的同时运行完毕。 NCB 是相关数据。5337 网络控制块 (NCB) 指定的名称已经保留。 NCB 是相关数据。5338 网络控制块 (NCB) 命令无法取消。 NCB 是相关数据。5351 同一个会话有多个网络控制块 (NCB)。 NCB 请求被拒绝。NCB 是相关数据。5352 网卡出错。 唯一可能发出的 NetBIOS 命令是 NCB RESET。 网络控制块 (NCB) 是相关数据。5354 超过应用程序数目上限。 网络控制区 (NCB) 请求被拒绝，NCB 是相关数据。5356 请求的资源无法使用。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。5364 系统出错。 网络控制块 (NCB) 请求被拒绝。NCB 即为数据。5365 “ROM 校验和”失败。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。5366 RAM 测试失败。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。5367 数字式环回失败。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。5368 模拟式环回失败。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。5369 界面失败。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。5370 收到的网络控制块 (NCB) 返回码无法识别。 NCB 是相关数据。5380 网卡故障。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。5381 网络控制块 (NCB) 命令仍然处于搁置状态。 NCB 是相关数据。5509 Windows 2000 无法按指定的配置启动， 将换用先前可工作的配置。5600 无法共享用户或脚本路径。5601 计算机的密码在本地安全 数据库中找不到。5602 访问计算机的本地或网络安全数据库时， 发生内部错误。5705 Netlogon 服务用于记录数据库更改数据的 日志高速缓存已损坏。 Netlogon 服务正在复位更改日志文件。5728 无法加载任何传输。5739 此域的全局组数目超过可以复制到 LanMan BDC 的限制。 请删除部分的全局组或删除域中的 LanMan BDC。5742 服务无法检索必要的消息，所以无法运行远程启动客户。5743 服务发生严重的错误，无法从远程启动 3Com 3Start 远程启动客户。5744 服务发生严重的系统错误，即将关机。5760 服务在分析 RPL 配置时出错。5761 服务在创建所有配置的 RPL 配置文件时出错。5762 服务在访问注册表时出错。5763 服务在替换可能过期的 RPLDISK.SYS 时出错。5764 服务在添加安全帐户或设置文件权限时出错。 这些帐户是独立 RPL 工作站的 RPLUSER 本地组 以及用户帐户。.5765 服务无法备份它的数据库。5766 服务无法从它的数据库初始化。 数据库可能找不到或损坏。 服务会试图从备份数据库恢复该数据库。5767 服务无法从备份数据库还原它的数据库。服务 将不启动。5768 服务无法从备份数据库还原它的数据库。5769 服务无法从它还原的数据库初始化。服务 将不启动。5771 远程启动数据库采用 NT 3.5 / NT 3.51 格式。NT 正在转换其为 NT 4.0 格式。完成转换后，JETCONV 转换器将写出应用事件日志。5773 该 DC 的 DNS 服务器不支持动态 DNS。 将文件 ‘SystemRoot\System32\Config\netlogon.dns’ 中的 DNS 记录添加到伺服那个文件中引用的域的 DNS 服务器。5781 由于没有可以使用的 DNS 服务器，一个或更多 DNS 记录的动态注册和注销未成功。6000 无法加密指定的文件。6001 指定的文件无法解密。6002 指定的文件已加密，而且用户没有能力解密。6003 这个系统没有有效的加密恢复策略配置。6004 所需的加密驱动程序并未加载到系统中。6005 文件加密所使用的加密驱动程序与目前加载的加密驱动程序不同。6006 没有为用户定义的 EFS 关键字。6007 指定的文件并未加密。6008 指定的文件不是定义的 EFS 导出格式。6009 指定的文件是只读文件。6010 已为加密而停用目录。6011 不信任服务器来进行远程加密操作。6118 此工作组的服务器列表当前无法使用6200 要正常运行，任务计划程序服务的配置必须在系统帐户中运行。单独的任务可以被配置成在其他帐户中运行。7001 指定的会话名称无效。7002 指定的协议驱动程序无效。7003 在系统路径上找不到指定的协议驱动程序。7004 在系统路径上找不到指定的终端连接。7005 不能为这个会话创建一个事件日志的注册键。7006 同名的一个服务已经在系统中存在。7007 在会话上一个关闭操作挂起。7008 没有可用的输出缓冲器。7009 找不到 MODEM.INF 文件。7010 在 MODEM.INF 中没有找到调制解调器名称。7011 调制解调器没有接受发送给它的指令。验证配置的调制解调器与连接的调制解调器是否匹配。7012 调制解调器没有接受发送给它的指令。验证该调制解调器是否接线正确并且打开了电源开关。7013 运载工具检测失败或者由于断开连接，运载工具已被丢弃。7014 在要求的时间内没有发现拨号音。 确定电话线连接正确并可使用。7015 在远程站点回叫时检测到了占线信号。7016 在回叫时远程站点上检测到了声音。7017 传输驱动程序错误7022 找不到指定的会话。7023 指定的会话名称已处于使用中。7024 由于终端连接目前正在忙于处理一个连接、断开连接、复位或删除操作，无法完成该请求的操作。7025 试图连接到其视频模式不受当前客户支持的会话。7035 应用程序尝试启动 DOS 图形模式。 不支持 DOS 图形模式。7037 您的交互式登录权限已被禁用。 请与您的管理员联系。7038 该请求的操作只能在系统控制台上执行。 这通常是一个驱动程序或系统 DLL 要求直接控制台访问的结果。7040 客户未能对服务器连接消息作出响应。7041 不支持断开控制台会话。7042 不支持重新将一个断开的会话连接到控制台。7044 远程控制另一个会话的请求被拒绝。7045 拒绝请求的会话访问。7049 指定的终端连接驱动程序无效。7050 不能远程控制该请求的会话。 这也许是由于该会话被中断或目前没有一个用户登录。而且，您不能从该系统控制台远程控制一个会话或远程控制系统控制台。并且，您不能远程控制您自己的当前会话。7051 该请求的会话没有配置成允许远程控制。7052 拒绝连接到这个终端服务器。终端服务器客户许可证目前正在被另一个用户使用。 请与系统管理员联系，获取一份新的终端服务器客户，其许可证号码必须是有效的、唯一的。7053 拒绝连接到这个终端服务器。还没有为这份终端服务器客户输入您的终端服务器客户许可证号码。 请与系统管理员联系，为该终端服务器客户输入一个有效的、唯一的许可证号码。7054 系统已达到其授权的登录限制。 请以后再试一次。7055 您正在使用的客户没有使用该系统的授权。您的登录请求被拒绝。7056 系统许可证已过期。您的登录请求被拒绝。8001 文件复制服务 API 被错误调用。8002 无法启动文件复制服务。8003 无法停止文件复制服务。8004 文件复制服务 API 终止了请求。 事件日志可能有详细信息。8005 该文件复制服务中断了该请求。 事件日志可能有详细信息。8006 无法联系文件复制服务。 事件日志可能有详细信息。8007 由于该用户没有足够特权，文件复制服务不能满足该请求。 事件日志可能有详细信息。8008 由于验证的 RPC 无效，文件复制服务不能满足该请求。 事件日志可能有详细信息。8009 由于该用户在域控制器上没有足够特权，文件复制服务不能满足该请求。 事件日志可能有详细信息。8010 由于在域控制器上的验证的 RPC 无效，文件复制服务不能满足该请求。 事件日志可能有详细信息。8011 该文件复制服务无法与在域控制器上的文件复制服务通讯。 事件日志可能有详细信息。8012 在域控制器上的文件复制服务无法与这台计算机上的文件复制服务通讯。 事件日志可能有详细信息。8013 由于内部错误，该文件复制服务不能进入该系统卷中。 事件日志可能有详细信息。8014 由于内部超时，该文件复制服务不能进入该系统卷中。 事件日志可能有详细信息。8015 该文件复制服务无法处理此请求。该系统卷仍在忙于前一个请求。8016 由于内部错误，该文件复制服务无法停止复制该系统卷。 事件日志可能有详细信息。8017 该文件复制服务检测到一个无效参数。8200 在安装目录服务时出现一个错误。有关详细信息，请查看事件日志。8201 目录服务在本地评估组成员身份。8202 指定的目录服务属性或值不存在。8203 指定给目录服务的属性语法无效。8204 指定给目录服务的属性类型未定义。8205 指定的目录服务属性或值已经存在。8206 目录服务忙。8207 该目录服务无效。8208 目录服务无法分配相对标识号。8209 目录服务已经用完了相对标识号池。8210 由于目录服务不是该类操作的主控，未能执行操作。8211 目录服务无法初始化分配相对标识号的子系统。8212 该请求的操作没有满足一个或多个与该对象的类别相关的约束。8213 目录服务只可以在一个页状对象上运行要求的操作。8214 目录服务不能在一个对象的 RDN 属性上执行该请求的操作。8215 目录服务检测出修改对象类别的尝试。8216 不能执行请求的通过域的移动操作。8217 无法联系全局编录服务器。8218 策略对象是共享的并只可在根目录上修改。8219 策略对象不存在。8220 请求的策略信息只在目录服务中。8221 域控制器升级目前正在使用中。8222 域控制器升级目前不在使用中8224 出现一个操作错误。8225 出现一个协议错误。8226 已经超过这个请求的时间限制。8227 已经超过这个请求的大小限制。8228 已经超过这个请求的管理限制。8229 比较的响应为假。8230 比较的响应为真。8231 这个服务器不支持请求的身份验证方式。8232 这台服务器需要一个更安全的身份验证方式。8233 不适当的身份验证。8234 未知的身份验证机制。8235 从服务器返回了一个建议。8236 该服务器不支持该请求的关键扩展。8237 这个请求需要一个安全的连接。8238 不恰当的匹配。8239 出现一个约束冲突。8240 在服务器上没有这样一个对象。8241 有一个别名问题。8242 指定了一个无效的 dn 语法。8243 该对象为叶对象。8244 有一个别名废弃问题。8245 该服务器不愿意处理该请求。8246 检查到一个循环。8247 有一个命名冲突。8248 结果设置太大。8249 该操作会影响到多个 DSA。8250 该服务器不可操作。8251 出现一个本地错误。8252 出现一个编码错误。8253 出现一个解码错误。8254 无法识别寻找筛选器。8255 一个或多个参数非法。8256 不支持指定的方式。8257 没有返回结果。8258 该服务器不支持该指定的控制。8259 客户检测到一个参考循环。8260 超过当前的参考限制。8301 根目录对象必须是一个命名上下文的头。该根目录对象不能有实例父类。8302 不能执行添加副本操作。名称上下文必须可写才能创建副本。8303 出现一个对架构中未定义的一个属性的参考。8304 超过了一个对象的最大尺寸。8305 尝试向目录中添加一个已在使用中的名称的对象。8306 尝试添加一个对象，该对象属于那类在架构中没有一个 RDN 定义的类别。8307 尝试添加一个使用 RDN 的对象，但该 RDN 不是一个在架构中定义的 RDN 。8308 在对象中找不到任何请求的属性。8309 用户缓冲区太小。8310 在操作中指定的属性不出现在对象上。8311 修改操作非法。不允许该修改的某个方面。8312 指定的对象太大。8313 指定的实例类别无效。8314 操作必须在主控 DSA 执行。8315 必须指定对象类别属性。8316 一个所需的属性丢失。8317 尝试修改一个对象，将一个对该类别来讲是非法的属性包括进来。8318 在对象上指定的属性已经存在。8320 指定的属性不存在或没有值。8321 为只有一个值的属性指定了多个值。8322 属性值不在接受范围内。8323 指定的值已存在。8324 由于不存在于对象上，不能删除该属性。8325 由于不存在于对象上，不能删除该属性值。8326 指定的根对象不能是子参考。8327 不允许链接。8328 不允许链接的评估。8329 由于对象的父类不是未实例化就是被删除了，所以不能执行操作。8330 不允许有一个用别名的父类。别名是叶对象。8331 对象和父类必须是同一种类，不是都是原件就是 都是副本。8332 由于子对象存在，操作不能执行。这个操作只能在叶对象上执行。8333 没有找到目录对象。8334 别名对象丢失。8335 对象名语法不对。8336 不允许一个别名参考另一个别名。8337 别名不能解除参考。8338 操作超出范围。8340 不能删除 DSA 对象。8341 出现一个目录服务错误。8342 操作只能在内部主控 DSA 对象上执行。8343 对象必须为 DSA 类别。8344 访问权不够不能执行该操作。8345 由于父类不在可能的上级列表上，不能添加该对象。8346 由于该属性处于“安全帐户管理器” (SAM)，不允许访问该属性。8347 名称有太多部分。8348 名称太长。8349 名称值太长。8350 目录服务遇到了一个错误分列名称。8351 目录服务找不到一个名称的属性种类。8352 该名称不能识别一个对象; 该名称识别一个幻象。8353 安全描述符太短。8354 安全描述符无效。8355 为删除的对象创建名称失败。8356 一个新子参考的父类必须存在。8357 该对象必须是一个命名上下文。8358 不允许添加一个不属于系统的属性。8359 对象的类别必须是有结构的; 您不能实例化一个抽象的类别。8360 找不到架构的对象。8361 有这个 GUID (非活动的的或活动的)的本地对象已经存在。8362 操作不能在一个后部链接上执行。8363 找不到指定的命名上下文的互交参考。8364 由于目录服务关闭，操作不能执行。8365 目录服务请求无效。8366 无法读取角色所有者属性。8367 请求的 FSMO 操作失败。不能连接当前的 FSMO 盒。8368 不允许跨过一个命名上下文修改 DN。8369 由于属于系统，不能修改该属性。8370 只有复制器可以执行这个功能。8371 指定的类别没有定义。8372 指定的类别不是一个子类别。8373 名称参考无效。8374 交叉参考已经存在。8375 不允许删除一个主控交叉参考。8376 只在 NC 头上支持子目录树通知。8377 通知筛选器太复杂。8378 架构更新失败: 重复的 RDN。8379 架构更新失败: 重复的 OID。8380 架构更新失败: 重复的 MAPI 识别符。8381 架构更新失败: 复制架构 id GUID。8382 架构更新失败: 重复的 LDAP 显示名称。8383 架构更新失败: 范围下部少于范围上部。8384 架构更新失败: 语法不匹配。8385 架构更新失败: 属性在必须包含中使用。8386 架构更新失败: 属性在可能包含中使用。8387 架构更新失败: 可能包含中的属性不存在。8388 架构更新失败:必须包含中的属性不存在。8389 架构更新失败: 在辅助类别列表中的类别不存在或不是一个辅助类别。8390 架构更新失败: poss-superior 中的类别不存在。8391 架构更新失败: 在 subclassof 列表中的类别不存在或不能满足等级规则。8392 架构更新失败: Rdn-Att-Id 语法不对。8393 架构更新失败: 类别作为辅助类别使用。8394 架构更新失败: 类别作为子类别使用。8395 架构更新失败: 类别作为 poss superior 使用。8396 架构更新在重新计算验证缓存时失败。8397 目录树删除没有完成。要继续删除目录树，必须再次发出请求。8398 不能执行请求的删除操作。8399 不能读取架构记录管理类别识别符。8400 属性架构语法不对。8401 不能缓存属性。8402 不能缓存类别。8403 不能从缓存删除属性。8404 无法从缓存中删除类别。8405 无法读取特殊名称的属性。8406 丢失一个所需的子参考。8407 不能检索范例种类属性。8408 出现一个内部错误。8409 出现一个数据错误。8410 丢失一个属性 GOVERNSID。8411 丢失一个所需要的属性。8412 指定的命名上下文丢失了一个交叉参考。8413 出现一个安全检查错误。8414 没有加载架构。8415 架构分配失败。请检查机器内存是否不足。8416 为属性架构获得所需语法失败。8417 全局编录验证失败。全局编录无效或不支持操作。目录的某些部分目前无效。8418 由于有关服务器之间的架构不匹配，复制操作失败。8419 找不到 DSA 对象。8420 找不到命名上下文。8421 在缓存中找不到命名上下文。8422 无法检索子对象。8423 由于安全原因不允许修改。8424 操作不能替换该隐藏的记录。8425 等级无效。8426 尝试建立等级表失败。8427 目录配置参数在注册中丢失。8428 尝试计算地址簿索引失败。8429 等级表的分配失败。8430 目录服务遇到一个内部失败。8431 目录服务遇到一个未知失败。8432 根对象需要一个 ‘top’ 类别。8433 这个目录服务器已关闭，并且不能接受新上浮单一主机操作角色的所有权。8434 目录服务没有必需的配置信息，并且不能决定新上浮单一主机操作角色的所有权。8435 该目录服务无法将一个或多个上浮单一主机操作角色传送给其它服务器。8436 复制操作失败。8437 为这个复制操作指定了一个无效的参数。8438 目录服务太忙，现在无法完成这个复制操作。8439 为这个复制操作指定的单一名称无效。8440 为这一个复制操作所指定的命名上下文无效。8441 为这个复制操作指定的单一名称已经存在。8442 复制系统遇到一个内部错误。8443 复制操作遇到数据库不一致问题。8444 不能连接到为这个复制操作指定的服务器上。8445 复制操作遇到一个有无效范例类型的对象。8446 复制操作无法分配内存。8447 复制操作遇到一个邮件系统错误。8448 目标服务器的复制参考信息已经存在。8449 目标服务器的复制参考信息不存在。8450 由于是由另一台服务器上复制的，因此不能删除命名上下文。8451 复制操作遇到一个数据库错误。8452 命名上下文要被删除或没有从指定的服务器上复制。8453 复制访问被拒绝。8454 这个版本的目录服务不支持请求的操作。8455 取消复制远程过程呼叫。8456 源服务器目前拒绝复制请求。8457 目标服务器当前拒绝复制请求。8458 由于对象名称冲突，复制操作失败。8459 复制源已被重新安装。8460 由于一个所需父对象丢失，复制操作失败。8461 复制操作被抢先。8462 由于缺乏更新，放弃复制同步尝试。8463 由于系统正在关闭，复制操作被中断了。8464 由于目标部分属性设置不是一个源部分属性设置的子设置，复制同步尝试失败。8465 由于主复制尝试从部分复制同步，复制同步尝试失败。8466 已经与为这个复制操作的指定的服务器联系，但是该服务器无法与完成这个操作所需的另外一个服务器联系。8467 在副本安装时，检测到一个使用的源和内部版本之间的架构不匹配，不能安装该副本。8468 架构更新失败: 有同一连接标识符的属性已经存在。8469 名称翻译: 常见处理错误。8470 名称翻译: 不能找到该名称或权限不够，不能看到名称。8471 名称翻译: 输入名称映射到多个输出名称。8472 名称翻译: 找到输出名称，但是找不到相应的输出格式。8473 名称翻译: 不能完全解析，只找到了域。8474 名称翻译: 不接到线上，无法在客户机上执行纯粹的语法映射。8475 不允许一个构造 att 修改。8476 指定的 OM-Object 类别对指定语法的一个属性是不正确的。8477 复制请求已暂停; 等待回答。8478 要求的操作需要一个目录服务，但没有可用的。8479 类别或属性的 LDAP 显示名称含有非 ASCII 字符。8480 请求的查找操作只支持基本查找。8481 查找未能从数据库检索属性。8482 架构更新操作试图添加一个反向链接，但该反向链接没有相应的正向链接。8483 跨域移动的来源和目标在对象日期上不一致。或者是来源，或者是目标没有对象的最后一个版本。8484 跨域移动的来源和目标在对象当前的名称上不一致。或者是来源，或者是目标没有对象的最后一个版本。8485 域间移动的来源和目标是一样的。调用程序应该使用本地移动操作，而不是域间移动操作。8486 域间移动的来源和目标与目录林中的命名上下文不一致。来源或目标没有分区容器的最近版本。8487 跨域移动的目标不是目标命名上下文的权威。8488 跨域移动的来源和目标提供的来源对象的身份不一样。 来源或目标没有来源对象的最近版本。8489 跨域移动的对象应该已经被目标服务器删除。来源服务器没有来源对象的最近版本。8490 要求对 PDC FSMO 的专门访问权的另一个操作正在进行中。8491 跨域移动没有成功，导致被移动对象有两个版本 - 一个在来源域，一个在目标域。需要删除目标对象，将系统还原到一致状态。8492 因为不允许这个类别的跨域移动，或者对象有一些特点，如: 信任帐户或防止移动的受限制的 RID；所以不能将该对象跨域移动。8493 一旦移动，不能将带有成员身份的对象跨域移动，这会侵犯帐户组的成员身份条件。从帐户组成员身份删除对象，再试一次。8494 命名上下文标题必须是另一个命名上下文标题的直接子标题，而不是一个内节点的子标题。8495 因为目录没有提议的命名上下文上面的命名上下文的副本，所以无法验证所提议的命名上下文的名称。请保证充当域命名主机的服务器已配置成全局编录服务器，并且服务器及其复制伙伴是最新的。8496 目标域必须在本机模式中。8497 因为服务器在指定域中没有基础结构容器，所以无法执行操作。8498 不允许跨域移动帐户组。8499 不允许跨域移动资源组。8500 属性的搜索标志无效。ANR 位只在 Unicode 或 Teletex 字符串的属性上有效。8501 不允许在将 NC 头作为子体的对象开始删除目录树。8502 因为目录树在使用中，目录服务未能为删除目录树而将其锁定。8503 删除目录树时，目录服务未能识别要删除的对象列表。8505 只有管理员才能修改管理组的成员列表。8506 不能改变域控制器帐户的主要组 ID。8507 试图修改基础架构。8508 不允许进行下列操作: 为现有类别添加新的强制属性；从现有类别删除强制属性；为没有向回链接属性的特殊类别 “Top” 添加可选属性，向回链接属性指的是直接或通过继承。例如: 添加或删除附属类别。8509 该域控制器上不允许架构更新。没有设置注册表项，或者 DC 不是架构 FSMO 角色所有者。8510 无法在架构容器下创建这个类别的对象。在架构容器下，您只能创建属性架构和类别架构对象。8511 副本/子项安装未能获取源 DC 上的架构容器的 objectVersion 属性。架构容器上的属性不存在，或者提供的凭据没有读取属性的权限。8512 副本/子项安装未能读取 system32 目录中的文件 schema.ini 的 SCHEMA 段中的 objectVersion 属性。8513 指定的组类型无效。8514 如果域是安全启用的，在混合型域中不能嵌套全局组。8515 如果域是安全启用的，在混合型域中不能嵌套本地组。8516 全局组不能将本地组作为成员。8517 全局组不能将通用组作为成员。8518 通用组不能将本地组作为成员。8519 全局组不能有跨域成员。8520 本地组不能将另一个跨域本地组作为成员。8521 包含主要成员的组不能改变为安全停用的组。8522 架构缓冲加载未能转换类架构对象上的字符串默认值 SD。8523 只有配置成全局编录服务器的 DSAs 才能充当域命名主机 FSMO 的角色。8524 由于 DNS 查找故障，DSA 操作无法进行。8525 处理一个对象的 DNS 主机名改动时，服务主要名称数值无法保持同步。8526 未能读取安全描述符属性。8527 没有找到请求的对象，但找到了具有那个密钥的对象。8528 正在添加的链接属性的语法不正确。正向链接只能有语法 2.5.5.1、2.5.5.7 和 2.5.5.14，而反向链接只能有语法 2.5.5.18529 安全帐户管理员需要获得启动密码。8530 安全帐户管理员需要从软盘获得启动密钥。8531 目录服务无法启动。8532 未能启动目录服务。8533 客户和服务器之间的连接要求数据包保密性。8534 来源域跟目标域不在同一个目录林中。8535 目标域必须在目录林中。8536 该操作要求启用目标域审核。8537 该操作无法为来源域找到 DC。8538 来源对象必须是一个组或用户。8539 来源对象的 SID 已经在目标目录林中。8540 来源对象和目标对象必须属于同一类型。8542 在复制请求中不能包括架构信息。8543 由于架构不兼容性，无法完成 复制操作。8544 由于前一个架构的不兼容性，无法完成复制操作。8545 因为源和目标都没有收到有关最近跨域启动操作的信息，所以无法应用复制更新。8546 因为还有主控这个域的域控制器，所以无法删除请求的域。8547 只能在全局编录服务器上执行请求的操作。8548 本地组只能是同一个域中其他本地组的成员。8549 外部安全主要成员不能是通用组的成员。8550 出于安全，无法将属性复制到 GC。8551 由于目前正在处理的修改太多，无法采取 PDC 的检查点。8552 操作需要启用那个源域审核。8553 安全主要对象仅能在域命名环境菜单中创建。8554 服务主要名称(SPN) 无法建造，因为提供的主机名格式不适合。8555 筛选器已传递建造的属性。8556 unicodePwd 属性值必须括在双引号中。8557 您的计算机无法加入域。已超出此域上允许创建的计算机帐户的最大值。请同系统管理员联系，复位或增加此限定值。8558 由于安全原因，操作必须在目标 DC 上运行。8559 由于安全原因，源 DC 必须是 Service Pack 4 或更新版本。8560 在树目录删除的操作中不能删除“关键目录服务系统”对象。数目录删除操作可能只进行了一部分。9001 DNS 服务器无法解释格式。9002 DNS 服务器失败。9003 DNS 名称不存在。9004 名称服务器不支持 DNS 请求。9005 拒绝 DNS 操作。9006 不应该存在的 DNS 名称仍然存在。9007 不应该存在的 DNS RR 集仍然存在。9008 应该存在的 DNS RR 集不存在。9009 DNS 服务器对区域没有权威。9010 在更新或 prereq 中的 DNS 名称不在区域中。9016 DNS 签名验证失败。9017 DNS 不正确密钥。9018 DNS 签名验证过期。9501 为 DNS 查询找不到记录。9502 无效 DNS 包。9503 没有 DNS 包。9504 DNS 错误，请检查 rcode。9505 为保险的 DNS 包。9551 无效的 DNS 种类。9552 无效的 IP 地址。9553 无效的属性。9554 稍后再试一次 DNS 操作。9555 给出的记录名称和种类不是单一的。9556 DNS 名称不符合 RFC 说明。9557 DNS 名称是一个完全合格的 DNS 名称。9558 DNS 名称以“.”分隔(多标签)。9559 DNS 名称是单一部分名称。9560 DNS 名称含有无效字符。9561 DNS 名称完全是数字的。9601 DNS 区域不存在。9602 DNS 区域信息无效。9603 DNS 区域无效操作。9604 无效 DNS 区域配置。9605 DNS 区域没有颁发机构记录的开始(SOA)。9606 DNS 区域没有“名称服务器” (NS)的记录。9607 DNS 区域已锁定。9608 DNS 区域创建失败。9609 DNS 区域已经存在。9610 DNS 自动区域已经存在。9611 无效的 DNS 区域种类。9612 次要 DNS 区域需要主 IP 地址。9613 DNS 区域不是次要的。9614 需要一个次要 IP 地址9615 WINS 初始化失败。9616 需要 WINS 服务器。9617 NBTSTAT 初始化呼叫失败。9618 颁发机构起始(SOA)删除无效9651 主要 DNS 区域需要数据文件。9652 DNS 区域的无效数据文件名称。9653 为 DNS 区域打开数据文件失败。9654 为 DNS 区域写数据文件失败。9655 为 DNS 区域读取数据文件时失败。9701 DNS 记录不存在。9702 DNS 记录格式错误。9703 DNS 中节点创建失败。9704 未知 DNS 记录类型。9705 DNS 记录超时。9706 名称不在 DNS 区域。9707 检测到 CNAME 循环。9708 节点为一个 CNAME DNS 记录。9709 指定名称的 CNAME 记录已经存在。9710 记录不在 DNS 区域根目录。9711 DNS 记录已经存在。9712 次要 DNS 区域数据错误。9713 不能创建 DNS 缓存数据。9714 DNS 名称不存在。9715 不能创建指针(PTR)记录。9716 DNS 域没有被删除。9717 该目录服务无效。9718 DNS 区域已经在目录服务中存在。9719 DNS 服务器没有为目录服务集合 DNS 区域创建或读取启动文件。9751 完成 DNS AXFR (区域复制)。9752 DNS 区域复制失败。9753 添加了本地 WINS 服务器。9801 安全更新呼叫需要继续更新请求。9851 TCP/IP 没有安装网络协议。9852 没有为本地系统配置 DNS 服务器。10004 一个封锁操作被对 WSACancelBlockingCall 的调用中断。10009 提供的文件句柄无效。10013 以一种访问权限不允许的方式做了一个访问套接字的尝试。10014 系统检测到在一个调用中尝试使用指针参数时的无效指针地址。10022 提供了一个无效的参数。10024 打开的套接字太多。10035 无法立即完成一个非阻挡性套接字操作。10036 目前正在执行一个阻挡性操作。10037 在一个非阻挡套接字上尝试了一个已经在进行的操作。10038 在一个非套接字上尝试了一个操作。10039 请求的地址在一个套接字中从操作中忽略。10040 一个在数据报套接字上发送的消息大于内部消息缓冲器或其它一些网络限制，或该用户用于接收数据报的缓冲器比数据报小。10041 在套接字函数调用中指定的一个协议不支持请求的套接字类别的语法。10042 在 getsockopt 或 setsockopt 调用中指定的一个未知的、无效的或不受支持的选项或层次。10043 请求的协议还没有在系统中配置，或者没有它存在的迹象。10044 在这个地址家族中不存在对指定的插槽种类的支持。10045 参考的对象种类不支持尝试的操作。10046 协议家族尚未配置到系统中或没有它的存在迹象。10047 使用了与请求的协议不兼容的地址。10048 通常每个套接字地址 (协议/网络地址/端口) 只允许使用一次。10049 在其上下文中，该请求的地址无效。10050 套接字操作遇到了一个已死的网络。10051 向一个无法连接的网络尝试了一个套接字操作。10052 当该操作在进行中，由于保持活动的操作检测到一个故障，该连接中断。10053 您的主机中的软件放弃了一个已建立的连接。10054 远程主机强迫关闭了一个现有的连接。10055 由于系统缓冲区空间不足或列队已满，不能执行套接字上的操作。10056 在一个已经连接的套接字上做了一个连接请求。10057 由于套接字没有连接并且 (当使用一个 sendto 调用发送数据报套接字时) 没有提供地址，发送或接收数据的请求没有被接受。10058 由于以前的关闭调用，套接字在那个方向已经关闭，发送或接收数据的请求没有被接受。10059 对某个内核对象的引用过多。10060 由于连接方在一段时间后没有正确的答复或连接的主机没有反应，连接尝试失败。10061 不能做任何连接，因为目标机器积极地拒绝它。10062 无法翻译名称。10063 名称组件或名称太长。10064 由于目标主机坏了，套接字操作失败。10065 套接字操作尝试一个无法连接的主机。10066 不能删除目录，除非它是空的。10067 一个 Windows 套接字操作可能在可以同时使用的应用程序数目上有限制。10068 超过限额。10069 超过磁盘限额。10070 文件句柄引用不再有效。10071 项目在本地不可用。10091 因为它使用提供网络服务的系统目前无效，WSAStartup 目前不能正常工作。10092 不支持请求的 Windows 套接字版本10093 应用程序没有调用 WSAStartup，或者 WSAStartup 失败。10101 由 WSARecv 或 WSARecvFrom 返回表示远程方面已经开始了关闭步骤。10102 WSALookupServiceNext 不能返回更多的结果。10103 在处理这个调用时，就开始调用 WSALookupServiceEnd。该调用被删除。10104 过程调用无效。10105 请求的服务提供程序无效。10106 没有加载或初始化请求的服务提供程序。10107 从来不应失败的系统调用失败了。10108 没有已知的此服务。在指定的名称空间中找不这个服务。10109 找不到指定的类别。10110 WSALookupServiceNext 不能返回更多的结果。10111 在处理这个调用时，就开始调用 WSALookupServiceEnd。该调用被删除。10112 由于被拒绝，数据查询失败。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL Server 错误代码和解释 (中篇)]]></title>
      <url>%2F2013%2F01%2F21%2Fsql-server-state-code-list-2%2F</url>
      <content type="text"><![CDATA[承接《上篇》继续罗列分享SQL Server状态码。 2001 指定的驱动程序无效。2002 窗口样式或类别属性对此操作无效。2003 不支持请求的图元操作。2004 不支持请求的变换操作。2005 不支持请求的剪切操作。2010 指定的颜色管理模块无效。2011 制定的颜色文件配置无效。2012 找不到指定的标识。2013 找不到所需的标识。2014 指定的标识已经存在。2015 指定的颜色文件配置与任何设备都不相关。2016 找不到该指定的颜色文件配置2017 指定的颜色空间无效。2018 图像颜色管理没有启动。2019 在删除该颜色传输时有一个错误。2020 该指定的颜色传输无效。2021 该指定的变换与位图的颜色空间不匹配。2022 该指定的命名颜色索引在配置文件中不存在。2102 没有安装工作站驱动程序。2103 无法定位服务器。2104 发生内部错误，网络无法访问共享内存段。2105 网络资源不足。2106 工作站不支持这项操作。2107 设备没有连接。2108 网络连接已成功，但需要提示用户输入一个不同于原始指定的密码。2114 没有启动服务器服务。2115 队列空。2116 设备或目录不存在。2117 无法在重定向的资源上执行这项操作。2118 名称已经共享。2119 服务器当前无法提供所需的资源。2121 额外要求的项目超过允许的上限。2122 对等服务只支持两个同时操作的用户 。2123 API 返回缓冲区太小。2127 远程 API 错误。2131 打开或读取配置文件时出错。2136 发生一般网络错误。2137 工作站服务的状态不一致。重新启动工作站服务之前，请先重新启动计算机。2138 工作站服务没有启动。2139 所需信息不可用。2140 发生 Windows 2000 内部错误。2141 服务器没有设置事务处理。2142 远程服务器不支持请求的 API。2143 事件名无效。2144 网络上已经有此计算机名。请更名后重新启动。2146 配置信息中找不到指定的组件。2147 配置信息中找不到指定的参数。2149 配置文件中有一个命令行太长。2150 打印机不存在。2151 打印作业不存在。2152 打印机目标找不到。2153 打印机目标已经存在。2154 打印机队列已经存在。2155 无法添加其它的打印机。2156 无法添加其它的打印作业。2157 无法添加其它的打印机目标。2158 此打印机目标处于空闲中，不接受控制操作。2159 此“打印机目标请求”包含无效的控制函数。2160 打印处理程序没有响应。2161 后台处理程序没有运行。2162 打印目标当前的状况，无法执行这项操作。2163 打印机队列当前的状况，无法执行这项操作。2164 打印作业当前的状况，无法执行这项操作。2165 无法为后台处理程序分配内存。2166 设备驱动程序不存在。2167 打印处理程序不支持这种数据类型。2168 没有安装打印处理程序。2180 锁定服务数据库。2181 服务表已满。2182 请求的服务已经启动。2183 这项服务没有响应控制操作。2184 服务仍未启动。2185 服务名无效。2186 服务没有响应控制功能。2187 服务控制处于忙碌状态。2188 配置文件包含无效的服务程序名。2189 在当前的状况下无法控制服务。2190 服务异常终止。2191 这项服务无法接受请求的 “暂停” 或 “停止” 操作。2192 服务控制“计划程序”在“计划表”中找不到服务名。2193 无法读取服务控制计划程序管道。2194 无法创建新服务的线程。2200 此工作站已经登录到局域网。2201 工作站没有登录到局域网。2202 指定的用户名无效。2203 密码参数无效。2204 登录处理器没有添加消息别名。2205 登录处理器没有添加消息别名。2206 注销处理器没有删除消息别名。2207 注销处理器没有删除消息别名。2209 暂停网络登录。2210 中心登录服务器发生冲突。2211 服务器没有设置正确的用户路径。2212 加载或运行登录脚本时出错。2214 没有指定登录服务器，计算机的登录状态是单机操作。2215 登录服务器找不到。2216 此计算机已经有一个登录域。2217 登录服务器无法验证登录。2219 安全数据库找不到。2220 组名找不到。2221 用户名找不到。2222 资源名找不到。2223 组已经存在。2224 帐户已经存在。2225 资源使用权限清单已经存在。2226 此操作只能在该域的主域控制器上执行。2227 安全数据库没有启动。2228 用户帐户数据库中的名称太多。2229 磁盘 I/O 失败。2230 已经超过每个资源 64 个项目的限制。2231 不得删除带会话的用户。2232 上层目录找不到。2233 无法添加到安全数据库会话高速缓存段。2234 这项操作不能在此特殊的组上执行。2235 用户帐户数据库会话高速缓存没有记录此用户。2236 用户已经属于此组。2237 用户不属于此组。2238 此用户帐户尚未定义。2239 此用户帐户已过期。2240 此用户不得从此工作站登录网络。2241 这时候不允许用户登录网络。2242 此用户的密码已经过期。2243 此用户的密码无法更改。2244 现在无法使用此密码。2245 密码不满足密码策略的需要。检查最小密码长度、密码复杂性和密码历史的需求。2246 此用户的密码最近才启用，现在不能更改。2247 安全数据库已损坏。2248 不需要更新此副本复制的网络/本地安全数据库。2249 此副本复制的数据库已过时；请同步处理其中的数据。2250 此网络连接不存在。2251 此 asg_type 无效。2252 此设备当前正在共享中。2270 计算机名无法作为消息别名添加。网络上可能已经有此名称。2271 信使服务已经启动。2272 信使服务启动失败。2273 网络上找不到此消息别名。2274 此消息别名已经转发出去。2275 已经添加了此消息别名，但是仍被转发。2276 此消息别名已在本地存在。2277 添加的消息别名已经超过数目上限。2278 无法删除计算机名。2279 消息无法转发回到同一个工作站。2280 域消息处理器出错。2281 消息已经发送出去，但是收件者已经暂停信使服务。2282 消息已经发送出去，但尚未收到。2283 消息别名当前正在使用中。请稍候片刻再试。2284 信使服务尚未启动。2285 该名称不在本地计算机上。2286 网络上找不到转发的消息别名。2287 远程通讯站的消息别名表已经满了。2288 此别名的消息当前没有在转发中。2289 广播的消息被截断。2294 设备名无效。2295 写入出错。2297 网络上的消息别名重复。2298 此消息别名会在稍后删除。2299 没有从所有的网络删除消息别名。2300 这项操作无法在使用多种网络的计算机上执行。2310 此共享的资源不存在。2311 设备没有共享。2312 带此计算机名的会话不存在。2314 没有用此识别号打开的文件。2315 执行远程管理命令失败。2316 打开远程临时文件失败。2317 从远程管理命令返回的数据已经被截断成 64K。2318 此设备无法同时共享为后台处理资源和非后台处理资源。2319 服务器清单中的信息可能不正确2320 计算机在此域未处于活动状态2321 在删除共享之前，需要将该共享从分布式文件系统中删除。2331 无法在此设备执行这项操作2332 此设备无法共享。2333 此设备未打开。2334 此设备名清单无效。2335 队列优先级无效。2337 没有任何共享的通讯设备。2338 指定的队列不存在。2340 此设备清单无效。2341 请求的设备无效。2342 后台处理程序正在使用此设备。2343 此设备已经被当成通讯设备来使用。2351 此计算机名无效。2354 指定的字符串及前缀太长。2356 此路径组成部分无效。2357 无法判断输入类型。2362 类型缓冲区不够大。2370 配置文件不得超过 64K。2371 初始偏移量越界。2372 系统无法删除当前到网络资源的连接。2373 系统无法分析此文件中的命令行。2374 加载配置文件时出错。\2375 保存配置文件时出错，只部份地保存了配置文件。2378 此日志文件在前后两次读取之间已经发生变化。2380 资源路径不可以是目录。2381 资源路径无效。2382 目标路径无效。2383 源路径及目标路径分属不同的服务器。2385 请求的 Run 服务器现在暂停。2389 与 Run 服务器通讯时出错。2391 启动后台处理时出错。2392 找不到您连接的共享资源。2400 LAN 适配器号码无效。2401 此网络连接有文件打开或请求挂起。2402 使用中的连接仍存在。2403 此共享名或密码无效。2404 设备正由活动进程使用，无法断开。2405 此驱动器号已在本地使用。2430 指定的客户已经在指定的事件注册。2431 警报表已满。2432 发出的警报名称无效或不存在。2433 警报接收者无效。2434 用户的登录时间长短不再合法。 所以已经删除用户与该服务器的会话。2440 日志文件中没有请求的记录号。2450 用户帐户数据库没有正确配置。2451 当 Netlogon 服务正在运行时，不允许执行这项操作。2452 这项操作无法在最后的管理帐户上执行。2453 找不到此域的域控制器。2454 无法设置此用户的登录信息。2455 Netlogon 服务尚未启动。2456 无法添加到用户帐户数据库。2457 此服务器的时钟与主域控制器的时钟不一致。2458 检测到密码不匹配。2460 服务器识别码没有指定有效的服务器。2461 会话标识没有指定有效的会话。2462 连接识别码没有指定有效的连接。2463 可用服务器表中无法再加上其它项。2464 服务器已经到了支持的会话数目上限。2465 服务器已经到了支持的连接数目上限。2466 服务器打开的文件到了上限，无法打开更多文件。2467 这台服务器没有登记替换的服务器。2470 请用低级的 API (远程管理协议)。2480 UPS 服务无法访问 UPS 驱动程序。2481 UPS 服务设置错误。2482 UPS 服务无法访问指定通讯端口 (Comm Port)。2483 UPS 显示线路中断或电池不足，服务没有启动。2484 UPS 服务无法执行系统关机的操作。2500 下面的程序返回一个 MS-DOS 错误码:2501 下面的程序需要更多的内存:2502 下面程序调用了不支持的 MS-DOS 函数:2503 工作站无法启动。2504 下面的文件已损坏。2505 启动块定义文件中没有指定引导程序。2506 NetBIOS 返回错误: NCB 及 SMB 数据转储。2507 磁盘 I/O 错误。2508 无法替换映像参数。2509 跨越磁盘扇区范围的映像参数太多。2510 不是从用 /S 格式化的 MS-DOS软盘产生的映像。2511 稍后会从远程重新启动。2512 无法调用远程启动服务器。2513 无法连接到远程启动服务器。2514 无法打开远程启动服务器上的映像文件。2515 正在连接到远程启动服务器…2516 正在连接到远程启动服务器…2517 远程启动服务已经停止，请检测错误记录文件，查明出错的原因。2518 远程启动失败，请检查错误日志文件，查明出错的原因。2519 不允许第二个远程启动 (Remoteboot) 资源连接。2550 浏览服务设置成 MaintainServerList=No。2610 因为没有网卡与这项服务一起启动，所以无法启动服务。2611 因为注册表中的启动信息不正确，所以无法启动服务。2612 无法启动服务，原因是它的数据库找不到或损坏。2613 因为找不到 RPLFILES 共享的资源，所以无法启动服务。2614 因为找不到 RPLUSER 组，所以无法启动服务。2615 无法枚举服务记录。2616 工作站记录信息已损坏。2617 工作站记录找不到。2618 其它的工作站正在使用此工作站名。2619 配置文件记录已损坏。2620 配置文件记录找不到。2621 其它的配置文件正在使用此名称。2622 有很多工作站正在使用此配置文件。2623 配置记录已损坏。2624 配置记录找不到。2625 适配器识别记录已损坏。2626 内部服务出错。2627 供应商识别记录已损坏。2628 启动块记录已损坏。2629 找不到此工作站的用户帐户记录。2630 RPLUSER 本地组找不到。2631 找不到启动块记录。2632 所选的配置文件与此工作站不兼容。2633 其它的工作站正在使用所选的网卡。2634 有些配置文件正在使用此配置。2635 有数个工作站、配置文件或配置正在使用此启动块。2636 服务无法制作远程启动数据库的备份。2637 找不到适配器记录。2638 找不到供应商记录。2639 其它供应商记录正在使用此供应商名称。2640 其它的启动区记录正在使用启动名称或供应商识别记录。2641 其它的配置正在使用此配置名称。2660 由 Dfs 服务所维护的内部数据库已损坏2661 内部数据库中的一条记录已 损坏2662 输入项路径与卷路径不匹配2663 给定卷名已存在2664 指定的服务器共享已在 Dfs 中共享2665 所显示的服务器共享不支持所显示的 Dfs 卷2666 此操作在非叶卷上无效。2667 此操作在叶卷上无效。2668 此操作不明确，因为该卷存在多服务器。2669 无法创建连接点2670 该服务器不是 Dfs 可识别的2671 指定的重命名目标路径无效。2672 指定 Dfs 卷脱线2673 指定的服务器不为此卷服务2674 检测到 Dfs 名中的环路2675 在基于服务器的 Dfs 上不支持该操作2676 这个卷已经受该指定服务器共享支持2677 无法删除这个卷的上一个服务器共享支持2678 Inter-Dfs 卷不支持该操作2679 Dfs 服务的内部状态已经变得不一致2680 Dfs 服务已经安装在指定的服务器上2681 被协调的 Dfs 数据是一样的2682 无法删除 Dfs 根目录卷 - 如需要请卸载 Dfs2683 该共享的子目录或父目录已经存在在一个 Dfs 中2690 Dfs 内部错误2691 这台机器已经加入域 。2692 这个机器目前未加入域。2693 这台机器是域控制器，而且无法从域中退出。2694 目标域控制器不支持在 OU 中创建的机器帐户。2695 指定的工作组名无效2696 指定的计算机名与域控制器上使用的默认语言不兼容。2697 找不到指定的计算机帐户。2999 这是 NERR 范围内的最后一个错误。3000 指定了未知的打印监视器。3001 指定的打印机驱动程序当前正在使用。3002 找不到缓冲文件。3003 未发送 StartDocPrinter 调用。3004 未发送 AddJob 调用。3005 指定的打印处理器已经安装。3006 指定的打印监视器已经安装。3007 该指定的打印监视器不具备所要求的功能。 3008 该指定的打印监视器正在使用中。3009 当打印机有作业排成队列时此操作请求是不允许的。3010 请求的操作成功。直到重新启动系统前更改将不会生效。3011 请求的操作成功。直到重新启动服务前更改将不会生效。3012 找不到打印机。3023 用户指定的关机命令文件，它的配置有问题。 不过 UPS 服务已经启动。3029 因为用户帐户数据库 (NET.ACC) 找不到或损坏， 而且也没有可用的备份数据库， 所以不能启动本地安全机制。 系统不安全！3037 @I 登录小时数3039 已经超过一个目录中文件的副本复制的限制。3040 已经超过副本复制的目录树深度限制。3046 无法登录。用户当前已经登录，同时参数 TRYUSER 设置为 NO。3052 命令行或配置文件中 没有提供必要的参数。3054 无法满足资源的请求。3055 系统配置有问题。3056 系统出错。3057 发生内部一致性的错误。3058 配置文件或命令行的选项不明确。3059 配置文件或命令行的参数重复。3060 服务没有响应控制， DosKillProc 函数已经停止服务。3061 运行服务程序时出错。3062 无法启动次级服务。3064 文件有问题。3070 内存3071 磁盘空间3072 线程3073 过程3074 安全性失败。3075 LAN Manager 根目录不正确或找不到。3076 未安装网络软件。3077 服务器未启动。3078 服务器无法访问用户帐户数据库 (NET.ACC)。3079 LANMAN 树中安装的文件不兼容。3080 LANMAN\LOGS 目录无效。3081 指定的域无法使用。3082 另一计算机正将此计算机名当作消息别名使用。3083 宣布服务器名失败。3084 用户帐户数据库没有正确配置。3085 服务器没有运行用户级安全功能。3087 工作站设置不正确。3088 查看您的错误日志文件以了解详细信息。3089 无法写入此文件。3090 ADDPAK 文件损坏。请删除 LANMAN\NETPROG\ADDPAK.SER 后重新应用所有的 ADDPAK。3091 因为没有运行 CACHE.EXE，所以无法启动 LM386 服务器。3092 安全数据库中找不到这台计算机的帐户。3093 这台计算机不是 SERVERS 组的成员。3094 SERVERS 组没有在本地安全数据库中。3095 此 Windows NT 计算机被设置为某个组的成员， 并不是域的成员。 此种配置下不需要运行 Netlogon 服务。3096 找不到此域的 Windows NT 域控制器。3098 服务无法与主域控制器进行验证。3099 安全数据库文件创建日期或序号有问题。3100 因为网络软件出错，所以无法执行操作。3102 这项服务无法长期锁定网络控制块 (NCB) 的段。 错误码就是相关数据。3103 这项服务无法解除网络控制块 (NCB) 段的长期锁定。 错误码就是相关数据。3106 收到意外的网络控制块 (NCB)。NCB 就是相关数据。3107 网络没有启动。3108 NETWKSTA.SYS 的 DosDevIoctl 或 DosFsCtl 调用失败。 显示的数据为以下格式: DWORD 值代表调用 Ioctl 或 FsCtl 的 CS:IP WORD 错误代码 WORD Ioctl 或 FsCtl 号3111 发生意外的 NetBIOS 错误。 错误码就是相关数据。3112 收到的服务器消息块 (SMB) 无效。 SMB 就是相关数据。3114 因为缓冲区溢出， 所以错误日志文件中部份的项目丢失。3120 控制网络缓冲区以外资源用量的初始化参数被设置大小， 因此需要的内存太多。3121 服务器无法增加内存段的大小。3124 服务器启动失败。三个 chdev 参数必须同时为零或者同时不为零。3129 服务器无法更新 AT 计划文件。 文件损坏。3130 服务器调用 NetMakeLMFileName 时出错。 错误码就是相关数据。3132 无法长期锁定服务器缓冲区。 请检查交换磁盘的可用空间，然后重新启动系统以启动服务器。3140 因为多次连续出现网络控制块 (NCB) 错误，所以停止服务。 最后一个坏的 NCB 以原始数据形式出现。3141 因为消息服务器共享的数据段被锁住， 所以消息服务器已经停止运行。3151 因为 VIO 调用出错，所以无法弹出显示消息。 错误码就是相关数据。3152 收到的服务器消息块 (SMB) 无效。SMB 就是相关数据。3160 工作站信息段大于 64K。 大小如下(以 DWORD 值的格式):3161 工作站无法取得计算机的名称号码。3162 工作站无法初始化 Async NetBIOS 线程。 错误码就是相关数据。3163 工作站无法打开最前面的共享段。 错误码就是相关数据。3164 工作站主机表已满。3165 收到的邮筒服务器消息块 (SMB) 有问题，SMB 就是相关数据。3166 工作站启动用户帐户数据库时出错。 错误码就是相关数据。3167 工作站响应 SSI 重新验证请求时出错。 函数码及错误码就是相关数据。3174 服务器无法读取 AT 计划文件。3175 服务器发现错误的 AT 计划记录。3176 服务器找不到 AT 计划文件，所以创建一个计划文件。3185 因为用户帐户数据库 (NET.ACC) 找不到或损坏， 而且也没有可用的备份数据库， 所以不能启动本地安全机制。 系统不安全！3204 服务器无法创建线程。 CONFIG.SYS 中的 THREADS 参数必须加大。3213 已经超过一个目录中文件的副本复制的限制。3214 已经超过副本复制的目录树深度限制。3215 邮筒中收到的消息无法识别。3217 无法登录。用户当前已经登录，同时参数 TRYUSER 设置为 NO。3230 检测到服务器的电源中断。3231 UPS 服务已经关掉服务器。3232 UPS 服务没有完成执行用户指定的 关机命令文件。3233 无法打开 UPS 驱动程序。 错误码就是相关数据。3234 电源已经恢复。3235 用户指定的关机命令文件 有问题。3256 该项服务的动态链接库 发生无法修复的错误。3257 系统返回意外的错误码。 错误码就是相关数据。3258 容错错误日志文件 - LANROOT\LOGS\FT.LOG 超过 64K。3259 容错错误日志文件 - LANROOT\LOGS\FT.LOG，在被打开时就已设置 更新进度位，这表示上次使用错误日志时， 系统死机。3301 Remote IPC3302 Remote Admin3303 Logon server share3304 网络出错。3400 内存不足，无法启动工作站服务。3401 读取 LAMAN.INI 文件的 NETWORKS 项目出错。3404 LAMAN.INI 文件中的 NETWORKS 项目太多。3408 程序无法用在此操作系统。3409 已经安装转发程序。3411 安装 NETWKSTA.SYS 时出错。 请按 ENTER 继续。3412 求解程序链接问题。3419 您已经打开文件或设备， 强制断开会造成数据丢失。3420 内部用的默认共享3421 信使服务3500 命令成功完成。3501 使用的选项无效。3503 命令包含无效的参数个数。3504 命令运行完毕，但发生一个或多个错误。3505 使用的选项数值不正确。3510 命令使用了冲突的选项。3512 软件需要新版的 操作系统。3513 数据多于 Windows 2000 所能够返回的。3515 此命令只能用在 Windows 2000 域控制器。3516 这个指令不能用于一个 Windows 2000 域控制器。3520 已经启动以下 Windows 2000 服务:3525 停止工作站服务也会同时停止服务器服务 。3526 工作站有打开的文件。3533 服务正在启动或停止中，请稍候片刻后再试一次。3534 服务没有报告任何错误。3535 正在控制设备时出错。3660 这些工作站在这台服务器上有会话:3661 这些工作站有会话打开了此台服务器上的文件:3666 消息别名已经转发出去。3670 您有以下的远程连接:3671 继续运行会取消连接。3676 会记录新的网络连接。3677 不记录新的网络连接。3678 保存配置文件时出错，原先记录的网络连接状态没有更改。3679 读取配置文件时出错。3682 没有启动任何网络服务。3683 清单是空的。3689 工作站服务已经在运行中，Windows 2000 会忽略工作站的命令选项。3694 在打印作业正在后台处理到队列时，无法删除共享的队列。3710 打开帮助文件时出错。3711 帮助文件是空的。3712 帮助文件已经损坏。3714 这是专为那些安装旧版软件的系统 提供的操作。3716 设备类型未知。3717 日志文件已经损坏。3718 程序文件名后必须以 .EXE 结束。3719 找不到匹配的共享，因此没有删除。3720 用户记录中的 “单位/星期” 的值不正确。3725 删除共享时出错。3726 用户名无效。3727 密码无效。3728 密码不匹配。3729 永久连接没有完全还原。3730 计算机名或域名错误。3732 无法设置该资源的默认权限。3734 没有输入正确的密码。3735 没有输入正确的名称。3736 该资源无法共享。3737 权限字符串包含无效的权限。3738 您只能在打印机或通讯设备上执行这项操作。3743 服务器没有设置远程管理的功能。3752 这台服务器上没有用户的会话。3756 响应无效。3757 没有提供有效的响应。3758 提供的目标清单与打印机队列目标清单不匹配。3761 指定的时间范围中结束的时间比开始的时间早。3764 提供的时间不是整点。3765 12 与 24 小时格式不能混用。3767 提供的日期格式无效。3768 提供的日期范围无效。3769 提供的时间范围无效。3770 NET USER 的参数无效。请检查最短的密码长度 和/或提供参数。3771 ENABLESCRIPT 的值必须是 YES。3773 提供的国家(地区)代码无效。3774 用户已经创建成功，但是无法添加到 USERS 本地组中。3775 提供的用户上下文无效。3777 文件发送功能已不再支持。3778 您可能没有指定 ADMIN$ 及 IPC$ 共享的路径。3784 只有磁盘共享可以标记为可以缓存。3802 此计划日期无效。3803 LANMAN 根目录无法使用。3804 SCHED.LOG 文件无法打开。3805 服务器服务尚未启动。3806 AT 作业标识不存在。3807 AT 计划文件已损坏。3808 因为 AT 计划文件发生问题，所以无法运行删除操作。3809 命令行不得超过 259 个字符。3810 因为磁盘已满，所以 AT 计划文件无法更新。3812 AT 计划文件无效。请删除此文件并创建新的文件。3813 AT 计划文件已经删除。3814 此命令的语法是: AT [id] [/Delete] AT 时间 [/EVERY:日期 | /NEXT:日期] 命令 AT 命令会在以后的 指定日期及时间，安排程序在服务器上运行。 它也会显示安排运行的程序及命令的清单。 您可以将日期指定为M、T、W、Th、F、Sa、Su 或 1-31 的格式。 您可以将时间指定为HH:38143815 AT 命令已经超时。 请稍后再试一次。3816 用户帐户的密码使用最短期限不得 大于密码最长使用期限。3817 指定的数值与安装下层软件的服务器不兼容。 请指定较小的值。3901 3902 意外到达消息的结尾 *3905 请按 ESC 退出3906 …3912 找不到时间服务器。3915 无法判断用户的主目录。3916 没有指定用户的主目录。3920 已经没有可用的驱动器号。3936 这台计算机目前没有配置成使用一个指定的 SNTP 服务器。3953 语法错误。3960 指定的文件号码无效。3961 指定的打印作业号码无效。3963 指定的用户或组帐户找不到。3965 已添加用户，但 NetWare 的文件和打印服务无法启用。3966 没有安装 NetWare 的文件和打印服务。3967 无法为 NetWare 的文件和打印服务设置用户属性。3969 NetWare 兼容登录4000 WINS 在处理命令时遇到错误。4001 本地的 WINS 不能删除。4002 文件导入操作失败。4003 备份操作失败。是否先前已作过完整备份?4004 备份操作失败。请检查您备份数据库的目录。4005 WINS 数据库中没有这个名称。4006 不允许复制一个尚未配置的伙伴。4100 DHCP 客户获得一个在网上已被使用的 IP 地址。 直到 DHCP 客户可以获得新的地址前，本地接口将被禁用。4200 无法识别传来的 GUID 是否为有效的 WMI 数据提供程序。4201 无法识别传来的实例名是否为有效的 WMI 数据提供程序。4202 无法识别传来的数据项目标识符是否为有效的 WMI 数据提供程序。4203 无法完成 WMI 请求，应该重试一次。4204 找不到 WMI 数据提供程序。4205 WMI 数据提供程序引用到一个未注册的实例组。4206 WMI 数据块或事件通知已启用。4207 WMI 数据块不再可用。4208 WMI 数据服务无法使用。4209 WMI 数据提供程序无法完成要求。4210 WMI MOF 信息无效。4211 WMI 注册信息无效。4212 WMI 数据块或事件通知已禁用。4213 WMI 数据项目或数据块为只读。4214 WMI 数据项目或数据块不能更改。4300 媒体标识符没有表示一个有效的媒体。4301 库标识符没有表示一个有效的库。4302 媒体缓冲池标识符没有表示一个有效的媒体缓冲池。4303 驱动器和媒体不兼容或位于不同的库中。4304 媒体目前在脱机库中，您必须联机才能运行这个操作。4305 操作无法在脱机库中运行。4306 库、驱动器或媒体缓冲池是空的。4307 库、磁盘或媒体缓冲池必须是空的，才能运行这个操作。4308 在这个媒体缓冲池或库中目前没有可用的媒体。4309 这个操作所需的资源已禁用。4310 媒体标识符没有表示一个有效的清洗器。4311 无法清洗驱动器或不支持清洗。4312 对象标识符没有表示一个有效的对象。4313 无法读取或写入数据库。4314 数据库已满。4315 媒体与设备或媒体缓冲池不兼容。4316 这个操作所需的资源不存在。4317 操作标识符不正确。4318 媒体未被安装，或未就绪。4319 设备未就绪。4320 操作员或系统管理员拒绝了请求。4321 驱动器标识符不代表一个有效的驱动器。4322 程序库已满。没有可使用的插槽。4323 传输程序不能访问媒体。4324 无法将媒体加载到驱动器中。4325 无法检索有关驱动器的状态。4326 无法检索有关插槽的状态。4327 无法检索传输的状态。4328 因为传输已在使用中，所以无法使用。4329 无法打开或关闭弹入/弹出端口。4330 因为媒体在驱动器中，无法将其弹出。4331 清洗器插槽已被保留。4332 没有保留清洗器插槽。4333 清洗器墨盒已进行了最大次数的驱动器清洗。4334 意外媒体标识号。4335 在这个组或源中最后剩下的项目不能被删除。4336 提供的消息超过了这个参数所允许的最大尺寸。4337 该卷含有系统和页面文件。4338 由于库中至少有一个驱动器可以支持该媒体类型，不能从库中删除媒体类型。4339 由于没有可以使用的已被启动的驱动器，无法将该脱机媒体装入这个系统。4340 (Y/N) [Y]4341 (Y/N) [N]4342 错误4343 OK4344 Y4345 N4346 任何4347 A4348 P4349 (找不到)4350 远程存储服务无法撤回文件。4351 远程存储服务此时不可操作。4352 远程存储服务遇到一个媒体错误。4354 请键入密码:4358 请键入用户的密码:4359 请键入共享资源的密码:4360 请键入您的密码:4361 请再键入一次密码以便确认:4362 请键入用户的旧密码:4363 请键入用户的新密码:4364 请键入您的新密码:4365 请键入复制器服务密码:4368 请键入您的用户名:4372 打印作业详细信息4378 控制下列正在运行的服务:4379 统计数据可用于正在运行的下列服务:4381 此命令的语法是:4382 此命令的选项是:4383 请键入主域控制器的名称:4385 Sunday4386 Monday4387 Tuesday4388 Wednesday4389 Thursday4390 此文件或目录不是一个重解析点。4391 重解析点的属性不能被设置，因为它与已有的属性冲突。4392 在重解析点缓冲区中的数据无效。4393 在重解析点缓冲区中的标签无效。4394 请求中指定的标签和重解析点中的不匹配。4395 W4396 Th4397 F4398 S4399 Sa4401 组名4402 注释4403 成员4406 别名4407 注释4408 成员4411 用户名4412 全名4413 注释4414 用户的注释4415 参数4416 国家(地区)代码4417 权限等级4418 操作员权限4419 帐户启用4420 帐户到期4421 上次设置密码4422 密码到期4423 密码可更改4424 允许的工作站4425 磁盘空间上限4426 无限制4427 本地组会员4428 域控制器4429 登录脚本4430 上次登录4431 全局组成员4432 可允许的登录小时数4433 全部4434 无4436 主目录4437 需要密码4438 用户可以更改密码4439 用户配置文件4440 已锁定4450 计算机名4451 用户名4452 软件版本4453 工作站活动在4454 Windows NT 根目录4455 工作站域4456 登录域4457 其它域4458 COM 打开超时 (秒)4459 COM 发送计数 (字节)4460 COM 发送超时 (毫秒)4461 DOS 会话打印超时 (秒)4462 错误日志文件大小上限 (K)4463 高速缓存上限 (K)4464 网络缓冲区数4465 字符缓冲区数4466 域缓冲区大小4467 字符缓冲区大小4468 计算机全名4469 工作站域 DNS 名称4470 Windows 20004481 服务器名称4482 服务器注释4483 发送管理警报到4484 软件版本4485 对等服务器4486 Windows NT4487 服务器等级4488 Windows NT Server4489 服务器正运行于4492 服务器已隐藏4500 零备份存储在这个卷上不可用。4506 登录的用户数量上限4507 同时可并存的管理员数量上限4508 资源共享数量上限4509 资源连接数量上限4510 服务器打开的文件数量上限4511 每个会话打开的文件数量上限4512 文件锁定数量上限4520 空闲的会话时间 (分)4526 共享等级4527 用户等级4530 未限制的服务器4570 强制用户在时间到期之后多久必须注销?:4571 多少次密码不正确后锁住帐户?:4572 密码最短使用期限 (天):4573 密码最长使用期限 (天):4574 密码长度下限:4575 保持的密码历史记录长度:4576 计算机角色:4577 工作站域的主域控制器:4578 锁定阈值:4579 锁定持续时间(分):4580 锁定观测窗口(分):4600 统计开始于4601 接受的会话4602 会话超时4603 会话出错4604 发送的 KB4605 接收的 KB4606 平均响应时间 (毫秒)4607 网络错误4608 访问的文件4609 后台处理的打印作业4610 系统出错4611 密码违规4612 权限违规4613 访问的通讯设备4614 会话已启动4615 重新连接的会话4616 会话启动失败4617 断开的会话4618 网络 I/O 执行4619 文件及管道被访问4620 时间缓冲区耗尽4621 大缓冲区4622 请求缓冲区4626 已做连接4627 连接失败4630 接收的字节数4631 接收的服务器消息块 (SMB)4632 传输的字节数4633 传输的服务器消息块 (SMB)4634 读取操作4635 写入操作4636 拒绝原始读取4637 拒绝原始写入4638 网络错误4639 已做连接4640 重新连接4641 服务器断开4642 会话已启动4643 会话挂起4644 失败的会话4645 操作失败4646 使用计数4647 使用计数失败4655 消息名称转发已经取消。4661 密码已经更改成功。4664 消息已经发给网络上所有的用户。4666 消息已经送到此服务器上的所有用户。4696 Windows NT Server4697 Windows NT Workstation4698 MS-DOS 增强型工作站4700 服务器名称 注释4701 资源共享名 类型 用途 注释4702 (UNC)4703 …4704 Domain4706 其它可用的网络:4710 Disk4711 Print4712 Comm4713 IPC4714 状态 本地 远程 网络4715 OK4716 休止4717 已暂停4718 断开4719 错误4720 正在连接4721 正在重新连接4722 状态4723 本地名称4724 远程名称4725 资源类型4726 # 打开4727 # 连接4728 不可用4730 共享名 资源 注释4731 共享名4732 资源4733 后台处理4734 权限4735 最多用户4736 无限制4737 用户4740 识别码 路径 用户名 # 锁定4741 文件识别码4742 锁定4743 权限4750 计算机 用户名 客户类型 打开空闲时间4751 计算机4752 会话时间4753 空闲时间4754 资源共享名 类型 # 打开4755 客户类型4756 来宾登录4770 脱机缓存被启用:手动恢复4771 脱机缓存被启用:自动恢复4772 脱机缓存被启用:用户之间没有共享4773 脱机缓存被停用4774 自动4775 手动4800 名称4801 转发到4802 已经从下列位置转发给您4803 这台服务器的用户4804 用户已经按 Ctrl+Break 中断网络发送。4810 名称 作业编号 大小 状态4811 作业4812 打印4813 名称4814 作业 #4815 大小4816 状态4817 分隔文件4818 注释4819 优先级4820 打印后于4821 打印直到4822 打印处理程序4823 附加信息4824 参数4825 打印设备4826 打印机活动中4827 打印机搁置4828 打印机出错4829 正在删除打印机4830 打印机状态未知4841 作业 #4842 正在提交用户4843 通知4844 作业数据类型4845 作业参数4846 正在等候4847 搁置于队列4848 正在后台处理4849 已暂停4850 脱机4851 错误4852 缺纸4853 需要干预4854 正在打印4855 on4862 驱动程序4930 用户名 类型 日期4931 锁定4932 服务4933 服务器4934 服务器已启动4935 服务器已暂停4936 服务器已继续操作4937 服务器已停止4938 会话4939 登录来宾4940 登录用户4941 登录管理员4942 正常注销4943 登录4944 注销错误4945 注销自动断开4946 注销管理员断开4947 注销受登录限制4948 服务4957 帐户4964 已修改帐户系统设置4965 登录限制4966 超过限制: 未知4967 超过限制: 登录时间4968 超过限制: 帐户过期4969 超过限制: 工作站识别码无效4970 超过限制: 帐户停用4971 超过限制: 帐户已删除4972 资源4978 密码不正确4979 需要管理员特权4980 访问4984 拒绝访问4985 未知4986 其它4987 持续时间:4988 持续时间: 无效4989 持续时间: 1 秒以下4990 (无)4994 访问结束4995 登录到网络4996 拒绝登录4997 程序 消息 时间4999 管理员已解除帐户的锁定状态5000 注销网络]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SQL Server 错误代码和解释 (上篇)]]></title>
      <url>%2F2013%2F01%2F20%2Fsql-server-state-code-list-1%2F</url>
      <content type="text"><![CDATA[SQL Server 是高校专业在教学数据库时一定会选用的案例之一，这个数据库是结合微软产品一起使用的，不仅贵，而且不好用。这是在使用之后的心得体会。在代码层面来说，这个是很难使用的。但是，老师说这个以后工作了都会使用到，所以，还是要好好学的。 文中罗列了各种状态码的解释，这些对调试SQL Server数据库程序是很有帮助的。 0 操作成功完成。1 功能错误。2 系统找不到指定的文件。3 系统找不到指定的路径。4 系统无法打开文件。5 拒绝访问。6 句柄无效。7 存储控制块被损坏。8 存储空间不足，无法处理此命令。9 存储控制块地址无效。10 环境错误。11 试图加载格式错误的程序。12 访问码无效。13 数据无效。14 存储器不足，无法完成此操作。15 系统找不到指定的驱动器。16 无法删除目录。17 系统无法将文件移到不同的驱动器。18 没有更多文件。19 介质受写入保护。20 系统找不到指定的设备。21 设备未就绪。22 设备不识别此命令。23 数据错误 (循环冗余检查)。24 程序发出命令，但命令长度不正确。25 驱动器无法找出磁盘上特定区域或磁道的位置。26 无法访问指定的磁盘或软盘。27 驱动器找不到请求的扇区。28 打印机缺纸。29 系统无法写入指定的设备。30 系统无法从指定的设备上读取。31 连到系统上的设备没有发挥作用。32 进程无法访问文件，因为另一个程序正在使用此文件。33 进程无法访问文件，因为另一个程序已锁定文件的一部分。36 用来共享的打开文件过多。38 到达文件结尾。39 磁盘已满。50 不支持网络请求。51 远程计算机不可用 。52 在网络上已有重复的名称。53 找不到网络路径。54 网络忙。55 指定的网络资源或设备不再可用。56 已到达网络 BIOS 命令限制。57 网络适配器硬件出错。58 指定的服务器无法运行请求的操作。59 发生意外的网络错误。60 远程适配器不兼容。61 打印机队列已满。62 无法在服务器上获得用于保存待打印文件的空间。63 删除等候打印的文件。64 指定的网络名不再可用。65 拒绝网络访问。66 网络资源类型错误。67 找不到网络名。68 超过本地计算机网卡的名称限制。69 超出网络 BIOS 会话限制。70 远程服务器已暂停，或正在启动过程中。71 当前已无法再同此远程计算机连接，因为已达到计算机的连接数目极限。72 已暂停指定的打印机或磁盘设备。80 文件存在。82 无法创建目录或文件。83 INT 24 失败。84 无法取得处理此请求的存储空间。85 本地设备名已在使用中。86 指定的网络密码错误。87 参数错误。88 网络上发生写入错误。89 系统无法在此时启动另一个进程。100 无法创建另一个系统信号灯。101 另一个进程拥有独占的信号灯。102 已设置信号灯且无法关闭。103 无法再设置信号灯。104 无法在中断时请求独占的信号灯。105 此信号灯的前一个所有权已结束。107 程序停止，因为替代的软盘未插入。108 磁盘在使用中，或被另一个进程 锁定。109 管道已结束。110 系统无法打开指定的 设备或文件。111 文件名太长。112 磁盘空间不足。113 无法再获得内部文件的标识。114 目标内部文件的标识不正确。117 应用程序制作的 IOCTL 调用错误。118 验证写入的切换参数值错误。119 系统不支持请求的命令。120 此功能只被此系统支持。121 信号灯超时时间已到。122 传递到系统调用的数据区太小。123 文件名、目录名或卷标语法不正确。124 系统调用级别错误。125 磁盘没有卷标。126 找不到指定的模块。127 找不到指定的程序。128 没有等候的子进程。130 试图使用操作(而非原始磁盘 I/O)的已打开磁盘分区的文件句柄。131 试图移动文件指针到文件开头之前。132 无法在指定的设备或文件上设置文件指针。133 包含先前加入驱动器的驱动器无法使用 JOIN 或 SUBST 命令。134 试图在已被合并的驱动器上使用 JOIN 或 SUBST 命令。135 试图在已被合并的驱动器上使用 JOIN 或 SUBST 命令。136 系统试图解除未合并驱动器的 JOIN。137 系统试图解除未替代驱动器的 SUBST。138 系统试图将驱动器合并到合并驱动器上的目录。139 系统试图将驱动器替代为替代驱动器上的目录。140 系统试图将驱动器合并到替代驱动器上的目录。141 系统试图替代驱动器为合并驱动器上的目录。142 系统无法在此时运行 JOIN 或 SUBST。143 系统无法将驱动器合并到或替代为相同驱动器上的目录。144 目录并非根目录下的子目录。145 目录非空。146 指定的路径已在替代中使用。147 资源不足，无法处理此命令。148 指定的路径无法在此时使用。149 企图将驱动器合并或替代为驱动器上目录是上一个替代的目标的驱动器。150 系统跟踪信息未在 CONFIG.SYS 文件中指定，或不允许跟踪。151 为 DosMuxSemWait 指定的信号灯事件个数错误。152 DosMuxSemWait 不可运行。已设置过多的信号灯。153 DosMuxSemWait 清单错误。154 输入的卷标超过目标文件系统的 长度限制155 无法创建另一个线程。156 接收进程已拒绝此信号。157 段已被放弃且无法锁定。158 段已解除锁定。159 线程标识的地址错误。160 传递到 DosExecPgm 的参数字符串错误。161 指定的路径无效。162 信号已暂停。164 无法在系统中创建更多的线程。167 无法锁定文件区域。170 请求的资源在使用中。173 对于提供取消区域进行锁定的请求不明显。174 文件系统不支持锁定类型的最小单元更改。180 系统检测出错误的段号。183 当文件已存在时，无法创建该文件。186 传递的标志错误。187 找不到指定的系统信号灯名称。196 操作系统无法运行此应用程序。197 操作系统当前的配置不能运行此应用程序。199 操作系统无法运行此应用程序。200 代码段不可大于或等于 64K。203 操作系统找不到已输入的 环境选项。205 命令子树中的进程 没有信号处理程序。206 文件名或扩展名太长。207 第 2 环堆栈已被占用。208 没有正确输入文件名通配符 或 ?，或指定过多的文件名通配符。209 正在发送的信号错误。210 无法设置信号处理程序。212 段已锁定且无法重新分配。214 连到该程序或动态链接模块的动态链接模块太多。215 无法嵌套调用 LoadModule。230 管道状态无效。231 所有的管道实例都在使用中。232 管道正在关闭中。233 管道的另一端上无任何进程。234 更多数据可用。240 取消会话。254 指定的扩展属性名无效。255 扩展属性不一致。258 等待的操作过时。259 没有可用的数据了。266 无法使用复制功能。267 目录名无效。275 扩展属性在缓冲区中不适用。276 装在文件系统上的扩展属性文件已损坏。277 扩展属性表格文件已满。278 指定的扩展属性句柄无效。282 装入的文件系统不支持扩展属性。288 企图释放并非呼叫方所拥有的多用户终端运行程序。298 发向信号灯的请求过多。299 仅完成部分的 ReadProcessMemoty 或 WriteProcessMemory 请求。300 操作锁定请求被拒绝。301 系统接收了一个无效的操作锁定确认。487 试图访问无效的地址。534 算术结果超过 32 位。535 管道的另一端有一进程。536 等候打开管道另一端的进程。994 拒绝访问扩展属性。995 由于线程退出或应用程序请求，已放弃 I/O 操作。996 重叠 I/O 事件不在信号状态中。997 重叠 I/O 操作在进行中。998 内存分配访问无效。999 错误运行页内操作。1001 递归太深；栈溢出。1002 窗口无法在已发送的消息上操作。1003 无法完成此功能。1004 无效标志。1005 此卷不包含可识别的文件系统。 请确定所有请求的文件系统驱动程序已加载，且此卷未损坏。1006 文件所在的卷已被外部改变，因此打开的文件不再有效。1007 无法在全屏幕模式下运行请求的操作。1008 试图引用不存在的令牌。1009 配置注册表数据库损坏。1010 配置注册表项无效。1011 无法打开配置注册表项。1012 无法读取配置注册表项。1013 无法写入配置注册表项。1014 注册表数据库中的某一文件必须使用记录或替代复制来恢复。恢复成功完成。1015 注册表损坏。包含注册表数据的某一文件结构损坏，或系统的文件内存映像损坏，或因为替代副本、日志缺少或损坏而无法恢复文件。1016 由注册表启动的 I/O 操作恢复失败。注册表无法读入、写出或清除任意一个包含注册表系统映像的文件。1017 系统试图加载或还原文件到注册表，但指定的文件并非注册表文件格式。1018 试图在标记为删除的注册表项上运行不合法的操作。1019 系统无法配置注册表日志中所请求的空间。1020 无法在已有子项或值的注册表项中创建符号链接。1021 无法在易变父项下创建稳定子项。1022 通知更改请求正在完成中，且信息并未返回到呼叫方的缓冲区中。当前呼叫方必须枚举文件来查找更改。1051 已发送停止控制到服务，该服务被其它正在运行的服务所依赖。1052 请求的控件对此服务无效1053 服务并未及时响应启动或控制请求。1054 无法创建此服务的线程。1055 锁定服务数据库。1056 服务的实例已在运行中。1057 帐户名无效或不存在，或者密码对于指定的帐户名无效。1058 无法启动服务，原因可能是它被禁用或与它相关联的设备没有启动。1059 指定了循环服务依存。1060 指定的服务并未以已安装的服务存在。1061 服务无法在此时接受控制信息。1062 服务未启动。1063 服务进程无法连接到服务控制器上。1064 当处理控制请求时，在服务中发生异常。1065 指定的数据库不存在。1066 服务已返回特定的服务错误码。1067 进程意外终止。1068 依存服务或组无法启动。1069 由于登录失败而无法启动服务。1070 启动后，服务停留在启动暂停状态。1071 指定的服务数据库锁定无效。1072 指定的服务已标记为删除。1073 指定的服务已存在。1074 系统当前以最新的有效配置运行。1075 依存服务不存在，或已被标记为删除。1076 已接受使用当前引导作为最后的有效控制设置。1077 上次启动之后，仍未尝试引导服务。1078 名称已用作服务名或服务显示名。1079 此服务的帐户不同于运行于同一进程上的其它服务的帐户。1080 只能为 Win32 服务设置失败操作，不能为驱动程序设置。1081 这个服务所运行的处理和服务控制管理器相同。 所以，如果服务处理程序意外中止的话，服务控制管理器无法进行任何操作。1082 这个服务尚未设置恢复程序。1083 配置成在该可执行程序中运行的这个服务不能执行该服务。1100 已达磁带的实际结尾。1101 磁带访问已达文件标记。1102 已达磁带或磁盘分区的开头。1103 磁带访问已达一组文件的结尾。1104 磁带上不再有任何数据。1105 磁带无法分区。1106 在访问多卷分区的新磁带时，当前的块大小不正确。1107 当加载磁带时，找不到分区信息。1108 无法锁定媒体弹出功能。1109 无法卸载介质。1110 驱动器中的介质可能已更改。1111 复位 I/O 总线。1112 驱动器中没有媒体。1113 在多字节的目标代码页中，没有此 Unicode 字符可以映射到的字符。1114 动态链接库 (DLL) 初始化例程失败。1115 系统关机正在进行。1116 因为没有任何进行中的关机过程，所以无法中断系统关机。1117 因为 I/O 设备错误，所以无法运行此项请求。1118 没有串行设备被初始化成功。串行驱动程序将卸载。1119 无法打开正在与其他设备共享中断请求(IRQ)的设备。至少有一个使用该 IRQ 的其他设备已打开。1120 序列 I/O 操作已由另一个串行口的写入完成。 (IOCTL_SERIAL_XOFF_COUNTER 已达零。)1121 因为已过超时时间，所以串行 I/O 操作完成。 (IOCTL_SERIAL_XOFF_COUNTER 未达零。)1122 在软盘上找不到 ID 地址标记。1123 软盘扇区 ID 字符域与软盘控制器磁道地址不相符。1124 软盘控制器报告软盘驱动程序不能识别的错误。1125 软盘控制器返回与其寄存器中不一致的结果。1126 当访问硬盘时，重新校准操作失败，重试仍然失败。1127 当访问硬盘时，磁盘操作失败，重试仍然失败。1128 当访问硬盘时，即使失败，仍须复位磁盘控制器。1129 已达磁带结尾。1130 服务器存储空间不足，无法处理此命令。1131 检测出潜在的死锁状态。1132 指定的基址或文件偏移量没有适当对齐。1140 改变系统供电状态的尝试被另一应用程序或驱动程序否决。1141 系统 BIOS 改变系统供电状态的尝试失败。1142 试图在一文件上创建超过系统允许数额的链接。1150 指定程序要求更新的 Windows 版本。1151 指定程序不是 Windows 或 MS-DOS 程序。1152 只能启动该指定程序的一个实例。1153 该指定程序适用于旧的 Windows 版本。1154 执行该应用程序所需的库文件之一被损坏。1155 没有应用程序与此操作的指定文件有关联。1156 在输送指令到应用程序的过程中出现错误。 1157 执行该应用程序所需的库文件之一无法找到。1158 当前程序已使用了 Window 管理器对象的系统允许的所有句柄。1159 消息只能与同步操作一起使用。1160 指出的源元素没有媒体。1161 指出的目标元素已包含媒体。1162 指出的元素不存在。1163 指出的元素是未显示的存储资源的一部分。1164 显示设备需要重新初始化，因为硬件有错误。1165 设备显示在尝试进一步操作之前需要清除。1166 设备显示它的门仍是打开状态。1167 设备没有连接。1168 找不到元素。1169 索引中没有同指定项相匹配的项。1170 在对象上不存在指定的属性集。1171 传递到 GetMouseMovePoints 的点不在缓冲区中。1172 跟踪(工作站)服务没运行。1173 找不到卷 ID。1175 无法删除要被替换的文件。1176 无法将替换文件移到要被替换的文件。要被替换的文件保持原来的名称。1177 无法将替换文件移到要被替换的文件。要被替换的文件已被重新命名为备份名称。1178 卷更改记录被删除。1179 卷更改记录服务不处于活动中。1180 找到一份文件，但是可能不是正确的文件。1181 日志项从日志中被删除。1200 指定的设备名无效。1201 设备当前未连接上，但其为一个记录连接。1202 企图记录先前已被记录的设备。1203 无任何网络提供程序接受指定的网络路径。1204 指定的网络提供程序名称无效。1205 无法打开网络连接配置文件。1206 网络连接配置文件损坏。1207 无法枚举空载体。1208 发生扩展错误。1209 指定的组名格式无效。1210 指定的计算机名格式无效。1211 指定的事件名格式无效。1212 指定的域名格式无效。1213 指定的服务名格式无效。1214 指定的网络名格式无效。1215 指定的共享名格式无效。1216 指定的密码格式无效。1217 指定的消息名格式无效。1218 指定的消息目标格式无效。1219 提供的凭据与已存在的凭据集冲突。1220 企图创建网络服务器的会话，但已对该服务器创建过多的会话。1221 工作组或域名已由网络上的另一部计算机使用。1222 网络未连接或启动。1223 操作已被用户取消。1224 请求的操作无法在使用用户映射区域打开的文件上执行。1225 远程系统拒绝网络连接。1226 网络连接已被适当地关闭了。1227 网络传输终结点已有与其关联的地址。1228 地址仍未与网络终结点关联。1229 企图在不存在的网络连接上进行操作。1230 企图在使用中的网络连接上进行无效的操作。1231 不能访问网络位置。有关网络排除故障的信息，请参阅 Windows 帮助。1232 不能访问网络位置。有关网络排除故障的信息，请参阅 Windows 帮助。1233 不能访问网络位置。有关网络排除故障的信息，请参阅 Windows 帮助。1234 没有任何服务正在远程系统上的目标网络终结点上操作。1235 请求被终止。1236 由本地系统终止网络连接。1237 操作无法完成。应该重试。1238 因为已达到此帐户的最大同时连接数限制，所以无法连接服务器。1239 试图在这个帐户未被授权的时间内登录。1240 此帐户并未得到从这个工作站登录的授权。1241 请求的操作不能使用这个网络地址。1242 服务器已经注册。1243 指定的服务不存在。1244 因为用户还未被验证，不能执行所要求的操作。1245 因为用户还未登录网络，不能执行所要求的操作。 指定的服务不存在。1246 正在继续工作。1247 试图进行初始操作，但是初始化已完成。1248 没有更多的本地设备。 1249 指定的站点不存在。1250 具有指定名称的域控制器已经存在。1251 只有连接到服务器上时，该操作才受支持。1252 即使没有改动，组策略框架也应该调用扩展。1253 指定的用户没有一个有效的配置文件。1254 Microsoft Small Business Server 不支持此操作。1300 并非所有被引用的特权都指派给呼叫方。1301 帐户名和安全标识间的某些映射未完成。1302 没有为该帐户特别设置系统配额限制。1303 没有可用的加密密钥。返回了一个已知加密密钥。1304 密码太复杂，无法转换成 LAN Manager 密码。返回的 LAN Manager 密码为空字符串。1305 修订级别未知。1306 表明两个修订级别是不兼容的。1307 这个安全标识不能指派为此对象的所有者。1308 这个安全标识不能指派为对象的主要组。1309 当前并未模拟客户的线程试图操作模拟令牌。1310 组可能未被禁用。1311 当前没有可用的登录服务器来服务登录请求。1312 指定的登录会话不存在。可能已被终止。1313 指定的特权不存在。1314 客户没有所需的特权。1315 提供的名称并非正确的帐户名形式。1316 指定的用户已存在。1317 指定的用户不存在。1318 指定的组已存在。1319 指定的组不存在。1320 指定的用户帐户已是指定组的成员，或是因为组包含成员所以无法删除指定的组。1321 指定的用户帐户不是指定组帐户的成员。1322 无法禁用或删除最后剩余的系统管理帐户。1323 无法更新密码。提供作为当前密码的值不正确。1324 无法更新密码。提供给新密码的值包含密码中不允许的值。1325 无法更新密码。为新密码提供的值不符合字符域的长度、复杂性或历史要求。1326 登录失败: 未知的用户名或错误密码。1327 登录失败: 用户帐户限制。1328 登录失败: 违反帐户登录时间限制。1329 登录失败: 不允许用户登录到此计算机。1330 登录失败: 指定的帐户密码已过期。1331 登录失败: 禁用当前的帐户。1332 帐户名与安全标识间无任何映射完成。1333 一次请求过多的本地用户标识符(LUIDs)。1334 无更多可用的本地用户标识符(LUIDs)。1335 对于该特别用法，安全 ID 的次级授权部分无效。1336 访问控制列表(ACL)结构无效。1337 安全 ID 结构无效。1338 安全描述符结构无效。1340 无法创建固有的访问控制列表(ACL)或访问控制项目(ACE)。1341 服务器当前已禁用。1342 服务器当前已启用。1343 提供给识别代号颁发机构的值为无效值。1344 无更多可用的内存以更新安全信息。1345 指定属性无效，或与整个群体的属性不兼容。1346 指定的模拟级别无效， 或所提供的模拟级别无效。1347 无法打开匿名级安全令牌。1348 请求的验证信息类别无效。1349 令牌的类型对其尝试使用的方法不适当。1350 无法在与安全性无关联的对象上运行安全性操作。1351 未能从域控制器读取配置信息，或者是因为机器不可使用，或者是访问被拒绝。1352 安全帐户管理器(SAM)或本地安全颁发机构(LSA)服务器处于运行安全操作的错误状态。1353 域处于运行安全操作的错误状态。1354 此操作只对域的主要域控制器可行。1355 指定的域不存在，或无法联系。1356 指定的域已存在。1357 试图超出每服务器域个数的限制。1358 无法完成请求操作，因为磁盘上的严重介质失败或数据结构损坏。1359 出现了内部错误。1360 通用访问类型包含于已映射到非通用类型的访问掩码中。1361 安全描述符格式不正确 (绝对或自相关的)。1362 请求操作只限制在登录进程中使用。调用进程未注册为一个登录进程。1363 无法使用已在使用中的标识启动新的会话。1364 未知的指定验证数据包。1365 登录会话并非处于与请求操作一致的状态中。1366 登录会话标识已在使用中。1367 登录请求包含无效的登录类型值。1368 在使用命名管道读取数据之前，无法经由该管道模拟。1369 注册表子树的事务处理状态与请求状态不一致。1370 安全性数据库内部出现损坏。1371 无法在内置帐户上运行此操作。1372 无法在内置特殊组上运行此操作。1373 无法在内置特殊用户上运行此操作。1374 无法从组中删除用户，因为当前组为用户的主要组。1375 令牌已作为主要令牌使用。1376 指定的本地组不存在。1377 指定的帐户名不是本地组的成员。1378 指定的帐户名已是本地组的成员。1379 指定的本地组已存在。1380 登录失败: 未授予用户在此计算机上的请求登录类型。1381 已超过在单一系统中可保存机密的最大个数。1382 机密的长度超过允许的最大长度。1383 本地安全颁发机构数据库内部包含不一致性。1384 在尝试登录的过程中，用户的安全上下文积累了过多的安全标识。1385 登录失败: 未授予用户在此计算机上的请求登录类型。1386 更改用户密码时需要交叉加密密码。1387 由于成员不存在，无法将成员添加到本地组中，也无法从本地组将其删除。1388 无法将新成员加入到本地组中，因为成员的帐户类型错误。1389 已指定过多的安全标识。1390 更改此用户密码时需要交叉加密密码。1391 表明 ACL 未包含任何可承继的组件。1392 文件或目录损坏且无法读取。1393 磁盘结构损坏且无法读取。1394 无任何指定登录会话的用户会话项。1395 正在访问的服务有连接数目标授权限制。 这时候已经无法再连接，原因是已经到达可接受的连接数目上限。1396 登录失败: 该目标帐户名称不正确。1397 相互身份验证失败。该服务器在域控制器的密码过期。1398 在客户机和服务器之间有一个时间差。1400 无效的窗口句柄。1401 无效的菜单句柄。1402 无效的光标句柄。1403 无效的加速器表句柄。1404 无效的挂钩句柄。1405 无效的多重窗口位置结构句柄。1406 无法创建最上层子窗口。1407 找不到窗口类别。1408 无效窗口；它属于另一线程。1409 热键已注册。1410 类别已存在。1411 类别不存在。1412 类别仍有打开的窗口。1413 无效索引。1414 无效的图标句柄。1415 使用专用 DIALOG 窗口字。1416 找不到列表框标识。1417 找不到通配字符。1418 线程没有打开的剪贴板。1419 没有注册热键。1420 窗口不是合法的对话窗口。1421 找不到控件 ID。1422 因为没有编辑控制，所以组合框的消息无效。1423 窗口不是组合框。1424 高度必须小于 256。1425 无效的设备上下文(DC)句柄。1426 无效的挂接程序类型。1427 无效的挂接程序。1428 没有模块句柄无法设置非本机的挂接。1429 此挂接程序只可整体设置。1430 Journal Hook 程序已安装。1431 挂接程序尚未安装。1432 单一选择列表框的无效消息。1433 LBSETCOUNT 发送到非被动的列表框。1434 此列表框不支持 Tab 键宽度。1435 无法毁坏由另一个线程创建的对象。1436 子窗口没有菜单。1437 窗口没有系统菜单。1438 无效的消息对话框样式。1439 无效的系统范围内的 (SPI) 参数。1440 已锁定屏幕。1441 多重窗口位置结构中窗口的所有句柄必须具有相同的上层。1442 窗口不是子窗口。1443 无效的 GW_* 命令。1444 无效的线程标识。1445 无法处理非多重文档界面 (MDI) 窗口中的消息。1446 弹出式菜单已经激活。1447 窗口没有滚动条。1448 滚动条范围不可大于 MAXLONG。1449 无法以指定的方式显示或删除窗口。1450 系统资源不足，无法完成请求的服务。1451 系统资源不足，无法完成请求的服务。1452 系统资源不足，无法完成请求的服务。1453 配额不足，无法完成请求的服务。1454 配额不足，无法完成请求的服务。1455 页面文件太小，无法完成操作。1456 找不到菜单项。1457 键盘布局句柄无效。1458 不允许使用挂钩类型。1459 该操作需要交互式窗口工作站。1460 由于超时时间已过，该操作返回。1461 无效监视器句柄。1500 事件日志文件损坏。1501 无法打开事件日志文件，事件日志服务没有启动。1502 事件日志文件已满。1503 事件日志文件已在读取间更改。1601 无法访问 Windows 安装服务。请与技术支持人员联系，确认 Windows 安装服务是否注册正确。1602 用户取消了安装。1603 安装时发生严重错误1604 安装已挂起，未完成。1605 这个操作只对当前安装的产品有效。1606 功能 ID 未注册。1607 组件 ID 并未注册。1608 未知属性。1609 句柄处于不正确的状态。1610 这个产品的配置数据已损坏。请与技术支持人员联系。1611 组件限制语不存在。1612 这个产品的安装来源无法使用。请验证来源是否存在，是否可以访问。1613 Windows 安装服务无法安装这个安装程序包。您必须安装含有 Windows 安装服务新版本的 Windows Service Park。1614 没有卸载产品。1615 SQL 查询语法不正确或不被支持。1616 记录字符域不存在。1617 设备已被删除.1618 正在进行另一个安装操作。请在继续这个安装操作之前完成那个操作。1619 未能打开这个安装程序包。请验证程序包是否存在，是否可以访问；或者与应用程序供应商联系，验证这是否是有效的 Windows 安装服务程序包。1620 未能打开这个安装程序包。请与应用程序供应商联系，验证这是否是有效的 Windows 安装服务程序包。1621 启动 Windows 安装服务用户界面时有错误。请与技术支持人员联系。1622 打开安装日志文件的错误。请验证指定的日志文件位置是否存在，是否可以写入。1623 安装程序包的语言不受系统支持。1624 应用变换时的错误。请验证指定的变换路径是否有效。1625 系统策略禁止这个安装。请与系统管理员联系。1626 无法执行函数。1627 执行期间，函数出了问题。1628 指定了无效的或未知的表格。1629 提供的数据类型不对。1630 这个类型的数据不受支持。1631 Windows 安装服务未能启动。请与技术支持人员联系。1632 临时文件夹已满或无法使用。请验证临时文件夹是否存在，是否可以写入。1633 这个处理器类型不支持该安装程序包。请与产品供应商联系。1634 组件没有在这台计算机上使用。1635 无法打开修补程序包。请验证修补程序包是否存在，是否可以访问；或者与应用程序供应商联系，验证这是否是 Windows 安装服务的修补程序包。1636 无法打开修补程序包。请与应用程序供应商联系，验证这是否是 Windows 安装服务的修补程序包。1637 Windows 安装服务无法处理这个插入程序包。您必须安装含有 Windows 安装服务新版本的 Windows Service Pack。1638 已安装这个产品的另一个版本。这个版本的安装无法继续。要配置或删除这个产品的现有版本，请用“控制面板”上的“添加/删除程序”。1639 无效的命令行参数。有关详细的命令行帮助，请查阅 Windows 安装服务的 SDK。1640 在终端服务远程会话期间，只有管理员有添加、删除或配置服务器软件的权限。如果您要在服务器上安装或配置软件，请与网络管理员联系。1641 要求的操作已成功结束。要使改动生效，必须重新启动系统。1642 Windows 安装服务无法安装升级修补程序，因为被升级的程序可能会丢失或是升级修补程序可能更新此程序的一个不同版本。请确认要被升级的程序在您的计算机上且您的升级修补程序是正确的。1700 串绑定无效。1701 绑定句柄类型不正确。1702 绑定句柄无效。1703 不支持 RPC 协议序列。1704 RPC 协议序列无效。1705 字符串通用唯一标识 (UUID) 无效。1706 终结点格式无效。1707 网络地址无效。1708 找不到终结点。1709 超时值无效。1710 找不到对象通用唯一标识(UUID)。1711 对象通用唯一标识 (UUID)已注册。1712 类型通用唯一标识(UUID)已注册。1713 RPC 服务器已在侦听。1714 未登记任何协议序列。1715 RPC 服务器未在侦听。1716 未知的管理器类型。1717 未知的界面。1718 没有任何链接。1719 无任何协议顺序。1720 无法创建终结点。1721 资源不足，无法完成此操作。1722 RPC 服务器不可用。1723 RPC 服务器过忙以致无法完成此操作。1724 网络选项无效。1725 在此线程中，没有使用中的远程过程调用。1726 远程过程调用失败。1727 远程过程调用失败且未运行。1728 远程过程调用(RPC)协议出错。1730 RPC 服务器不支持传送语法。1732 不支持通用唯一标识(UUID)类型。1733 标记无效。1734 数组边界无效。1735 链接不包含项目名称。1736 名称语法无效。1737 不支持名称语法。1739 没有可用来创建通用唯一标识 (UUID)的网络地址。1740 终结点是一份备份。1741 未知的验证类型。1742 调用的最大个数太小。1743 字符串太长。1744 找不到 RPC 协议顺序。1745 过程号超出范围。1746 绑定不包含任何验证信息。1747 未知的验证服务。1748 未知的验证级别。1749 安全上下文无效。1750 未知的授权服务。1751 项目无效。1752 服务器终结点无法运行操作。1753 终结点映射表中无更多的可用终结点。1754 未导出任何界面。1755 项目名称不完整。1756 版本选项无效。1757 没有其他成员。1758 没有内容未导出。1759 接口没有找到。1760 项目已存在。1761 找不到项目。1762 无可用的名称服务。1763 网络地址族无效。1764 不支持请求的操作。1765 无可用的安全上下文以允许模拟。1766 远程过程调用(RPC)中发生内部错误。1767 RPC 服务器试图以零除整数。1768 RPC 服务器中发生地址错误。1769 RPC 服务器上的浮点操作导至以零做除数。1770 RPC 服务器上发生浮点下溢。1771 RPC 服务器上发生浮点上溢。1772 自动句柄绑定的可用 RPC 服务器列表已用完。1773 无法打开字符翻译表文件。1774 包含字符翻译表的文件少于512 字节。1775 在远程过程调用时，将空的上下文句柄从客户传递到主机。1777 在远程过程调用时，上下文句柄已更改。1778 传递到远程过程调用的绑定句柄不相符。1779 承接体无法获得远程过程调用句柄。1780 传递空引用指针到承接体。1781 列举值超出范围。1782 字节计数太小。1783 承接体接收到坏数据。1784 提供给请求操作的用户缓冲区无效。1785 磁盘媒体无法识别。可能未被格式化。1786 工作站没有信任机密。1787 服务器上的安全数据库没有此工作站信任关系的计算机帐户。1788 主域和受信域间的信任关系失败。1789 此工作站和主域间的信任关系失败。1790 网络登录失败。1791 此线程的远程过程调用已在进行中。1792 试图登录，但是网络登录服务没有启动。1793 用户帐户到期。1794 转发程序已被占用且无法卸载。1795 指定的打印机驱动程序已安装。1796 指定的端口未知。1797 未知的打印机驱动程序。1798 未知的打印机处理器。1799 指定的分隔页文件无效。1800 指定的优先级无效。1801 打印机名无效。1802 打印机已存在。1803 打印机命令无效。1804 指定的数据类型无效。1805 指定的环境无效。1806 没有更多的绑定。1807 所用帐户为域间信任帐户。请使用您的全局用户帐户或本地用户帐户来访问这台服务器。1808 所用帐户是一个计算机帐户。使用您的全局用户帐户或本地用户帐户来访问此服务器。1809 已使用的帐户为服务器信任帐户。使用您的全局用户帐户或本地用户帐户来访问此服务器。1810 指定域的名称或安全标识(SID)与该域的信任信息不一致。1811 服务器在使用中且无法卸载。1812 指定的映像文件不包含资源区域。1813 找不到映像文件中指定的资源类型。1814 找不到映像文件中指定的资源名。1815 找不到映像文件中指定的资源语言标识。1816 配额不足，无法处理此命令。1817 未登记任何界面。1818 远程过程调用被取消。1819 绑定句柄不包含所有需要的信息。1820 在远程过程调用过程中通讯失败。1821 不支持请求的验证级别。1822 未登记任何主名称。1823 指定的错误不是有效的 Windows RPC 错误码。1824 已配置一个只在这部计算机上有效的 UUID。1825 发生一个安全包特有的错误。1826 线程未取消。1827 无效的编码/解码句柄操作。1828 序列化包装的版本不兼容。1829 RPC 承接体的版本不兼容。1830 RPC 管道对象无效或已损坏。1831 试图在 RPC 管道物件上进行无效操作。1832 不被支持的 RPC 管道版本。1898 找不到该组成员。1899 无法创建终结点映射表数据库项。1900 对象通用唯一标识 (UUID) 为 nil UUID。1901 指定的时间无效。1902 指定的格式名称无效。1903 指定的格式大小无效。1904 指定的打印机句柄正等候在1905 已删除指定的打印机。1906 打印机的状态无效。1907 在第一次登录之前，必须更改用户密码。1908 找不到此域的域控制器。1909 引用的帐户当前已锁定，且可能无法登录。1910 没有发现指定的此对象导出者1911 没有发现指定的对象。1912 没有发现指定的对象解析器。1913 一些待发数据仍停留在请求缓冲区内。1914 无效的异步远程过程调用句柄。1915 这个操作的异步 RPC 调用句柄不正确。1916 RPC 管道对象已经关闭。1917 在 RPC 调用完成之前全部的管道都已处理完成。1918 没有其他可用的数据来自 RPC 管道。1919 这个机器没有可用的站点名。1920 系统无法访问此文件。1921 系统无法辨识文件名。1922 项目不是所要的类型。1923 无法将所有对象的 UUID 导出到指定的项。1924 无法将界面导出到指定的项。1925 无法添加指定的配置文件项。1926 无法添加指定的配置文件元素。1927 无法删除指定的配置文件元素。1928 无法添加组元素。1929 无法删除组元素。2000 无效的像素格式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[操作系统 32位和64位]]></title>
      <url>%2F2013%2F01%2F19%2Fos-32-64-bit%2F</url>
      <content type="text"><![CDATA[两者之间存在的“五大不同”。与此同时，着重说明Microsoft Windows64位（x64）操作系统，相对于32位（x86）操作系统的最大优势和劣势是什么？ 第一，设计初衷不同 64位操作系统的设计初衷是：满足机械设计和分析、三维动画、视频编辑和创作，以及科学计算和高性能计算应用程序等领域中需要大量内存和浮点性能的客户需求。换句简明的话说就是：它们是高科技人员使用本行业特殊软件的运行平台。而32位操作系统是为普通用户设计的。 第二，要求配置不同 64位操作系统只能安装在64位电脑上(CPU必须是64位的)。同时需要安装64位常用软件以发挥64位（x64）的最佳性能。32位操作系统则可以安装在32位(32位CPU)或64位(64位CPU)电脑上。当然，32位操作系统安装在64位电脑上，其硬件恰似“大马拉小车”：64位效能就会大打折扣。 第三，运算速度不同 64位CPU GPRs(General-Purpose Registers，通用寄存器)的数据宽度为64位，64位指令集可以运行64位数据指令，也就是说处理器一次可提取64位数据(只要两个指令，一次提取8个字节的数据)，比32位(需要四个指令,一次提取4个字节的数据)提高了一倍，理论上性能会相应提升1倍。 第四，寻址能力不同 64位处理器的优势还体现在系统对内存的控制上。由于地址使用的是特殊的整数，因此一个ALU（算术逻辑运算器）和寄存器可以处理更大的整数，也就是更大的地址。比如，Windows Vista x64 Edition支持多达128 GB的内存和多达16 TB的虚拟内存，而32位CPU和操作系统最大只可支持4G内存。 第五，软件普及不同 目前，64位常用软件比32位常用软件，要少得多的多。道理很简单：使用64位操作系统的用户相对较少。因此，软件开发商必须考虑“投入产出比”，将有限资金投入到更多使用群体的软件之中。这也是为什么64位软件价格相对昂贵的重要原因(将成本摊入较少的发售之中)。 总而言之，Microsoft Windows 64位操作系统，必须“上”靠64位主机硬件的支撑，“下”靠64位常用软件的协助，才能将64位的优势发挥到极致，“三位一体”缺一不可(道理很简单：操作系统只是承上启下的运行平台)。至于64位电脑可以安装32位操作系统，64位操作系统可以安装32位软件，那是设计上的“向下兼容”，不是64位设计初衷的本来含义(如上所述)。 附言 1、64位电脑虽然可以安装32位操作系统，但是32位电脑绝对不能安装64位操作系统。这点至关重要务必牢记，以避免盲目下载和安装。 2、在64位电脑运行的32位操作系统上，不能采取硬盘安装方式安装64位操作系统。如若安装，首选光盘格式化安装方式，也可采用比较繁琐的DOS安装方式。 3、使用虚拟机安装操作系统，实际上就是在目前运行的操作系统上安装软件。因此，在32位操作系统上不能虚拟安装64位操作系统。即便采取“曲线”方式勉强安装，其实已经脱离了底层设备的支持，是毫无疑义的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[VC++6.0 MFC编程心得小结]]></title>
      <url>%2F2013%2F01%2F18%2Fvc-6-mfc-develop-summary%2F</url>
      <content type="text"><![CDATA[作为一个正经的科班出身软件工程专业者，想必都知道什么是VC++6.0。这个充满神奇的工具。而作为专业教学课的首选编程IDE，它有着不可撼动的地位。博主不知道别家院系使用何种启蒙工具，反正博主就是这个工具启蒙的。对它，有着又爱又恨得情怀。 数据库一个程序的最基本功能有输入、查询、修改、删除、保存、打印，均与数据库有关。而对数据库的基本操作使用最频繁，以Access 为例： 1、用程序创建Access 数据库文件： 手工创建数据文件的方法大家并不陌生，如果用程序创建有时候也需要，下面就是其中一种方法，可以使用ADOX::CatalogPtr来创建mdb文件。用下面“配置设置文件”文件方法设置数据库的参数，配置数据文件的名称、密码、ID和路径，在有安装程序的情况下需要它。 ADOX的建库，它是在没有数据库文件的情况下，用ADOX的目录指针CatalogPtr来创建ACCESS数据库文件，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758BOOL CRecord::UseADOXCatalogPtrCreatAccessDB()&#123; CString str=DBPath + DBName; //数据库的路径和名称 CString strPassword=DBPasswd; //数据库的密码 CString strcnn=_T("Provider=Microsoft.JET.OLEDB.4.0;Data source ="+str+";\ Jet OLEDB:DatabasePassword="+strPassword); //数据库的字串 //使用ADOX::CatalogPtr来创建mdb文件： HRESULT hr = S_OK; hr=::CoInitialize(NULL); if(SUCCEEDED(hr)) &#123; HRESULT hr = S_OK; try &#123; ADOX::_CatalogPtrm_pCatalog = NULL; hr=m_pCatalog.CreateInstance(__uuidof(ADOX::Catalog)); if(FAILED(hr)) &#123; _com_issue_error(hr); &#125; else&#123; m_pCatalog-&gt;Create(_bstr_t(strcnn));//Create MDB &#125; &#125;catch(_com_error e) //异常处理 &#123;//错误显示&#125; &#125; ::CoUninitialize(); return TRUE;&#125; 2、用程序在系统中创建Access的数据源名称DSN： 手工配置ODBC的数据源名称，大家也不陌生。而通过程序动态建立ODBC的DSN，在有安装程序的情况下也需要它。它是在已有数据库文件的情况下建立数据源名称。 123456789101112131415161718192021222324252627282930313233BOOL CRecord::CreatAccessDSN()&#123; CString DBID ,lpszFile=DBPath+DBName; int mlen; char* szDesc=new char[512]; sprintf(szDesc,"DSN=%s?UID=%s?;PWD=%s?;DESCRIPTION=;?DBQ=%s?\FIL=MicrosoftAccess?DEFAULTDIR=%s??"\ ,DBName,DBID,DBPasswd,lpszFile,DBPath); mlen=strlen(szDesc); for(int i=0;i&lt;mlen;i++) &#123; if(szDesc[i]=='?') szDesc[i]='\0'; &#125; if(SQLConfigDataSource(NULL,ODBC_ADD_DSN,"MicrosoftAccess\ Driver (*.mdb)\0", (LPCSTR)szDesc)) return TRUE; ……&#125; 3、动态建数据库表 一种方法可以通过一个配置数据库表的txt文件，它包括创建数据表的SQL语句，程序读入该文件的，并分析该文件的内容，得到一SQL字串，进行创建，这种方法建表比较灵活；另一种方法也可以通过有包括创建Access数据表SQL语句的程序代码创建。两种创建方法都要注意在字段名与它的字段类型之间必需用tab键隔开。如下，采用后者： 12345678910111213141516171819try&#123; VARIANT* RecordsAffected=0; CString strSQL=\"CREATE TABLE accesstable(ID longinteger ID ENTITY(1,1) not null,"; strPSW=strPSW+"name text(10)not null,"; strPSW=strPSW+"cash DOUBLE,remark text(100));"; //SQL字串 m_pCon-&gt;Execute((_bstr_t)(LPCTSTR)strSQL,NULL,adExecuteNoRecords);&#125;catch(_com_error&amp;e) &#123; …… &#125; 用VC++程序来动态建库很多数据类型不支持，但表名、字段名可以是变量。 4、数据库的连接和关闭 12345678910111213141516171819202122232425262728293031323334353637383940414243bool CRecordSonPrg::CreatConnect() //数据库的连接&#123;CString str="Provider=MSDASQL.1;Password='"+DBPasswd+"';\ PersistSecurity Info=True;Data Source="+DBName; //连接字串 try &#123; m_pCon.CreateInstance(__uuidof(Connection)); m_strConnection = _T(str); intbCon=m_pCon-&gt;Open(_bstr_t(m_strConnection),"","",adConnectUnspecified); &#125; catch(_com_error &amp;e) &#123; …… &#125; return true;&#125;void CRecordSonPrg::CloseConnect() //数据库的关闭&#123; try &#123; m_pCon-&gt;Close(); //关闭连接 m_pCon.Release(); //释放 &#125; catch(_com_error &amp;e)&#123; …… &#125;&#125; 5、用ADO对数据库记录的增、删、改、存、查、排序、过滤、打印 1234567//打开一个数据表DBtablem_pRs.CreateInstance(__uuidof(Recordset));m_strCmdText= _T("DBtable");m_pRs-&gt;Open((LPCTSTR)m_strCmdText,(LPCTSTR)m_strConnection,adOpenStatic,adLockOptimistic,adCmdTable); ①增加记录： 123456789101112131415try&#123; if(!m_pRs-&gt;Supports(adAddNew))return false; m_pRs-&gt;AddNew();m_pRs-&gt;Fields-&gt;GetItem("user")-&gt;Value=(_variant_t)strm_newuser; …… m_pRs-&gt;Update();&#125; ②删除记录： 1234567try&#123; m_pRs-&gt;Delete(adAffectCurrent ); //删除当前记录&#125; ③改动、保存记录： 1234567891011void CRsCgDlg::SaveModifiedRecord() //记录修改后保存&#123; …… //拷贝对话框数据到ADOC++ 绑定成员 //调用ADO数据绑定更新模式的接口 HRESULT hr = m_piAdoRecordBinding-&gt;Update( (CADORecordBinding*)this );&#125; ④查找记录： 123456789CString temp ="user='"+m_FindUserName+"'"; //查找字串_bstr_ttemp1=(_bstr_t)temp; //类型转换为_bstr_tm_pRs-&gt;Find(temp1,0,adSearchForward,""); ⑤排序记录： 12345678910111213CString temp="’user,"+m_FindUserName+"'"; //排序字串_bstr_ttemp1=(_bstr_t)temp; //类型转换为_bstr_tm_pRs-&gt;Sort=(temp1);m_pRs-&gt;Sort=(""); //取消排序 ⑥过滤记录： 123456789CString strfilter = _T(&quot;name = &apos;&quot;+m_strFilter+&quot;&apos;&quot;); //过滤字串m_pRs-&gt;Filter= (_variant_t)strfilter;m_pRs-&gt;Filter= (long) adFilterNone; //取消过滤 ⑦打印记录： 打印记录可以采用CDocument类的serialize()文档类的方式，也可以借助显示控件实现。这里是用FlexGrid控件编写的打印代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071void CMyApp::PrintToText()&#123; CString cFilePath = &quot;C:\\Documents and Settings\\Administrator\\&quot;; CString cFileName = &quot;打印统计表.txt&quot;; CString cFile = cFilePath+cFileName;CStdioFile file; //CStdioFile类是CFile类的派生类,它是以流方式操作文本 file.Open(cFile,CFile::modeCreate|CFile::modeWrite|CFile::typeText)CString str; str.Format(&quot;%s\n\n&quot;,cFileName); //格式化文件主题 file.WriteString(str); //写入文件主题 int RowCount = m_MSFGrid.GetRows(); //从FlexGrid控件表取行数 int ColCount = m_MSFGrid.GetCol(); //从FlexGrid控件表取列数 for(long r=0;r&lt;RowCount;r++) //行循环 &#123; for(long c=0;c&lt;ColCount;c++) //列循环 &#123; CString Matrix =m_MSFGrid.GetTextMatrix(r,c);//得到r行c列的文本 switch(c) &#123; str.Format( …… );//产生打印格式 &#125; file.WriteString(str); &#125; &#125; file.SetLength(file.GetPosition()); //设置文件长度 file.Close(); //关闭文件 str=&quot;notepad &quot;+cFile; WinExec(str,SW_SHOW); //利用记事本打开生成的文本文件&#125; 6、配置设置文件： 为了增加程序的灵活性，对配置文件的读、写也是必要的。Windows操作系统专门为此提供了6个API函数来对配置设置文件进行读、写： 1234567891011121314151617181920212223GetPrivateProfileInt() //从私有初始化文件获取整型数值 GetPrivateProfileString() //从私有初始化文件获取字符串型值 GetProfileInt //从win.ini获取整数值 GetProfileString //从win.ini获取字符串值 WritePrivateProfileString //写字符串到私有初始化文件 WriteProfileString //写字符串到win.ini 下面采用私有初始化文件获取或写入字符串型值的函数来读写配置文件： 读文件： 123456789101112131415161718192021222324252627282930CString CMyApp::GetOneIniData(CString sFilePath)&#123; CString str; char buf[256] =NULL; int len=0; len = GetPrivateProfileString( "Custom", //节名 "UserName" //项名 "No", //没找到此项时的返回值 buf, //目标缓冲区地址 256, //目标缓冲区长度 sFilePath //配置文件的准确路径 ); str=buf; return str;&#125; 写文件： 1234567891011121314151617181920212223BOOL CKaApp::WriteIniData(CString cstr,CString strUserName)&#123; CString sFile = cstr; CFileStatus status; BOOL RetUser=WritePrivateProfileString( "Custom", //节名 "UserName", //项名 strUserName, //内容 sFile //配置文件的准确路径 ); return TRUE;&#125; 对于SQL Server的操作类似。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[毕业论文摘要的书写方法和技巧]]></title>
      <url>%2F2013%2F01%2F18%2Fcollege-thesis-summary-skill%2F</url>
      <content type="text"><![CDATA[摘要也就是内容提要，是论文中不可缺少的一部分。论文摘要是一篇具有独立性的短文，有其特别的地方。它是建立在对论文进行总结的基础之上，用简单、明确、易懂、精辟的语言对全文内容加以概括，留主干去枝叶，提取论文的主要信息。作者的观点、论文的主要内容、研究成果、独到的见解，这些都应该在摘要中体现出来。好的摘要便于索引与查找，易于收录到大型资料库中并为他人提供信息。因此摘要在资料交流方面承担着至关重要的作用。 书写摘要的基本规范和原则 （1）论文摘要分为中文摘要和外文（一般为英文）摘要。摘要在篇幅方面的限定，不同的学校和机构有不同的要求，通常中文摘要不超过300字，英文摘要不超过250个实词，中英文摘要应一致。毕业论文摘要可适当增加篇幅。 （2）多向指导教师请教，并根据提供的意见及时修改，以期达到更高水平。 （3）摘要是完整的短文，具有独立性，可以单独使用。即使不看论文全文的内容，仍然可以理解论文的主要内容、作者的新观点和想法、课题所要实现的目的、采取的方法、研究的结果与结论。 （4）叙述完整，突出逻辑性，短文结构要合理。 （5）要求文字简明扼要，不容赘言，提取重要内容，不含前言、背景等细节部分，去掉旧结论、原始数据，不加评论和注释。采用直接表述的方法，删除不必要的文学修饰。摘要中不应包括作者将来的计划以及与此课题无关的内容，做到用最少的文字提供最大的信息量。 （6）摘要中不使用特殊字符，也不使用图表和化学结构式，以及由特殊字符组成的数学表达式，不列举例证。 摘要的四要素 目的、方法、结果和结论称为摘要的四要素。 （1）目的：指出研究的范围、目的、重要性、任务和前提条件，不是主题的简单重复。 （2）方法：简述课题的工作流程，研究了哪些主要内容，在这个过程中都做了哪些工作，包括对象、原理、条件、程序、手段等。 （3）结果：陈述研究之后重要的新发现、新成果及价值，包括通过调研、实验、观察取得的数据和结果，并剖析其不理想的局限部分。 （4）结论：通过对这个课题的研究所得出的重要结论，包括从中取得证实的正确观点，进行分析研究，比较预测其在实际生活中运用的意义，理论与实际相结合的价值。 撰写步骤 摘要作为一种特殊的陈述性短文，书写的步骤也与普通类型的文章有所不同。摘要的写作时间通常在论文的完成之后，但也可以采用提早写的方式，然后再边写论文边修改摘要。首先，从摘要的四要素出发，通读论文全文，仔细将文中的重要内容一一列出，特别是每段的主题句和论文结尾的归纳总结，保留梗概与精华部分，提取用于编写摘要的关键信息。然后，看这些信息能否完全、准确的回答摘要的四要素所涉及的问题，并要求语句精炼。若不足以回答这些问题，则重新阅读论文，摘录相应的内容进行补充。最后，将这些零散信息，组成符合语法规则和逻辑规则的完整句子，再进一步组成通畅的短文，通读此短文，反复修改，达到摘要的要求。 关于英文摘要 （1）英文摘要的写作方法要依据公认的写作规范。 （2）尽量使用简单句，避免句型单调，表达要求准确完整。 （3）正确使用冠词。 （4）使用标准英语书写，避免使用口语，应使用易于理解的常用词，不用生僻词汇。 （5）作者所做工作用过去时，结论用现在时。 （6）多使用主动语态。 关键词 关键词是为了文献标引工作从报告、论文中选出来用以表示全文主题内容信息目的单词术语。每篇报告、论文选取3～8个词作为关键词，以显著的字符另起一行，排在摘要的左方。如有可能，尽量用《汉语主题词表》等词表提供的规范词。为了国际交流，应标注与中文对应的英文关键词。 关键词是主题词中的一类。主题词是一种新型检索词汇，多用于计算机网络检索。 关键词分为中文关键词和与之对应的英文关键词，分别置于中文摘要和英文摘要之下。为便于他人的检索，不能使用过于宽泛的词语。选择关键词既可以从论文的各级标题入手，也可以从论文本身的内容选取，将选出的关键词按照所涉及领域的范围从大到小顺序列出。]]></content>
    </entry>

    
  
  
</search>
