<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Chars</title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://chars.tech/</link>
    <description>Chars's Tech Blog</description>
    <pubDate>Thu, 01 Feb 2018 08:02:24 +0800</pubDate>
    
      <item>
        <title>数据链路层之 LLDP</title>
        <link>/web/2018/01/29/data-link-layer-lldp.html</link>
        <guid isPermaLink="true">/web/2018/01/29/data-link-layer-lldp.html</guid>
        <description>&lt;p&gt;随着网络技术的发展，接入网络的设备的种类越来越多，配置越来越复杂，来自不同设备厂商的设备也往往会增加自己特有的功能，这就导致在一个网络中往往会有很多具有不同特性的、来自不同厂商的设备，为了方便对这样的网络进行管理，就需要使得不同厂商的设备能够在网络中相互发现并交互各自的系统及配置信息。 &lt;/p&gt;

&lt;p&gt;LLDP（Link Layer Discovery Protocol，链路层发现协议）就是用于这个目的的协议。LLDP 定义在 802.1ab 中，它是一个二层协议，它提供了一种标准的链路层发现方式。LLDP 协议使得接入网络的一台设备可以将其主要的&lt;strong&gt;能力，管理地址，设备标识，接口标识&lt;/strong&gt;等信息发送给接入同一个局域网络的其它设备。当一个设备从网络中接收到其它设备的这些信息时，它就将这些信息以MIB的形式存储起来。&lt;/p&gt;

&lt;p&gt;这些 MIB 信息可用于发现设备的物理拓扑结构以及管理配置信息。需要注意的是 LLDP 仅仅被设计用于进行信息通告，它被用于通告一个设备的信息并可以获得其它设备的信息，进而得到相关的 MIB 信息。它不是一个配置、控制协议，无法通过该协议对远端设备进行配置，&lt;strong&gt;它只是提供了关于网络拓扑以及管理配置的信息，这些信息可以被用于管理、配置的目的，如何用取决于信息的使用者。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;结构&quot;&gt;结构&lt;/h2&gt;

&lt;p&gt;LLDP 的框架结构如图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-struct.png&quot; alt=&quot;LLDP 结构图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此图也表明 LLDP 就是一个信息发现与通告协议，LLDP 的实体主要维护了两个 MIB 库，一个 local system MIB，一个 remote system MIB。从其名字也可以看出，一个用于维护本地相关的设备 MIB 信息，一个用于维护远端设备 MIB 信息。&lt;/p&gt;

&lt;p&gt;LLDP 通过与上图中右侧的几个 MIB 库交互来初始化并维护 local system MIB，并将本地的相关信息通告出去；同时当接收到来自其它设备的信息时就将其更新到remote system MIB 中。通过这种工作方式，一个设备就可以将自己的信息通告出去并获得网络中其它设备的相关信息，最终获得反应网络拓扑以及其它配置信息的两个 MIB 库。这两个库可以被其用户用来完成各种功能。需要说明的是&lt;strong&gt;LLDP 信息的通告以及接收处理不受端口的STP状态的影响。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;

&lt;h3 id=&quot;帧格式&quot;&gt;帧格式&lt;/h3&gt;

&lt;p&gt;封装有 LLDPDU 的报文称为 LLDP 帧，其封装格式有两种：Ethernet II 和 SNAP（Subnetwork Access Protocol，子网访问协议）。&lt;/p&gt;

&lt;h4 id=&quot;ethernet-ii-格式封装的-lldp-帧&quot;&gt;Ethernet II 格式封装的 LLDP 帧&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-ethernet-ii-frame.png&quot; alt=&quot;Ethernet II 格式封装的 LLDP 帧&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是以 Ethernet II 格式封装的 LLDP 帧，其中各字段的含义如下： &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DA：目的 MAC 地址，为固定的组播 MAC 地址 0x0180-C200-000E。 &lt;/li&gt;
  &lt;li&gt;SA：源 MAC 地址，为端口 MAC 地址或设备 MAC 地址（如有端口地址则用端口 MAC 地址，否则用设备 MAC 地址）。 指与设备相邻连接设备的桥 MAC。&lt;/li&gt;
  &lt;li&gt;LLDP Ethertype：帧类型，为 0x88CC。 &lt;/li&gt;
  &lt;li&gt;LLDPDU：LLDP Data Unit，LLDP 数据单元，它是 LLDP 信息交换的主体。&lt;/li&gt;
  &lt;li&gt;FCS：帧检验序列。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;snap-格式封装的-lldp-帧&quot;&gt;SNAP 格式封装的 LLDP 帧&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-snap-frame.png&quot; alt=&quot;SNAP 格式封装的 LLDP 帧&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是以 SNAP 格式封装的 LLDP 帧，其中各字段的含义如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DA：目的 MAC 地址，为固定的组播 MAC 地址 01-80-C2-00-00-0E。 &lt;/li&gt;
  &lt;li&gt;SA：源 MAC 地址，为端口 MAC 地址或设备 MAC 地址（如有端口地址则用端口 MAC 地址，否则用设备 MAC 地址）。 &lt;/li&gt;
  &lt;li&gt;Type：帧类型，为 0xAAAA-0300-0000-88CC。 &lt;/li&gt;
  &lt;li&gt;Data：数据，为 LLDPDU。 &lt;/li&gt;
  &lt;li&gt;FCS：帧检验序列。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;目的地址&quot;&gt;目的地址&lt;/h4&gt;

&lt;p&gt;目的地址实际上包括三个，分别为 01-80-C2-00-00-0E，01-80-C2-00-00-03，01-80-C2-00-00-00。这三个地址分别用于不同的目的，它们可以跨越不同的网络。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;01-80-C2-00-00-0E，也被称为 Nearest Bridge 组地址：无论是 Two-Port MAC Relay (TPMR)组件、S-VLAN 组件、C-VLAN 组件，还是 802.1D 网桥都不能转发目的为该地址的帧。简单的说任何类型的网桥都不能转发目的为该地址的帧，目的为该地址的帧被限制在连接两个网桥接口的连接上传输。&lt;/li&gt;
  &lt;li&gt;01-80-C2-00-00-03，也被称为 Nearest non-TPMR Bridge 组地址：对于目的地址为该地址的帧，Two-Port MAC Relay (TPMR)组件将成为一个中继器，即不接收它。而 S-VLAN（Service Provider VLAN）组件，C-VLAN（Customer VLAN）组件，以及 802.1D 网桥都不能转发它，而是需要进行接收并处理。因此目的地址为该地址的帧将跨越 TPMR。&lt;/li&gt;
  &lt;li&gt;01-80-C2-00-00-00，也被称为 Nearest Customer Bridge 组地址：对于目的地址为该地址的帧，Two-Port MAC Relay (TPMR)组件以及 S-VLAN 组件将成为中继器，即不接收它。而 C-VLAN 组件，以及 802.1D 网桥都不能转发它，而是需要进行接收并处理。因此目的地址为该地址的帧将跨越 TPMR 以及 S-VLAN。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tpmr-介绍&quot;&gt;TPMR 介绍&lt;/h3&gt;

&lt;p&gt;TPMR 以及 S-VLAN，C-VLAN 都是 802.1Q 中的概念，包括这三者的网络以及各个地址的作用范围如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-mac-addr.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-group-mac-addr.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-diff-os-mac-addr.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C-VLAN：Customer VLAN，是用户网络内部使用的 VLAN；&lt;/li&gt;
  &lt;li&gt;S-VLAN：Service VLAN，服务提供商网络中使用的 VLAN，该 VLAN 标识 VPN 用户或者是用户的业务；&lt;/li&gt;
  &lt;li&gt;Customer Bridge: Customer 网络中的 Bridge，只能识别 C-VLAN；&lt;/li&gt;
  &lt;li&gt;Provider Bridge：服务提供商网络中的 Bridge，根据处理内容的不同又分为S-VLAN Bridge 和 Provider Edge Bridge。其中 S-VLAN Bridge 只能识别 S-VLAN； Provider Edge Bridge 可以同时识别 C-VLAN 和 S-VLAN；&lt;/li&gt;
  &lt;li&gt;C-VLAN Component：在 Bridge 内可识别、插入、删除 C-VLAN 的实体，每个端口一个，对 C-VLAN 的操作互相独立（两个端口上接收到相同的 C-VLAN，但由于属于不同的客户最后的处理结果会不同）；&lt;/li&gt;
  &lt;li&gt;S-VLAN Component：在 Bridge 内可识别、插入、删除 S-VLAN 的实体，由于在一个 Bridge 内不存在相同的 S-VLAN 属于不同服务提供商的情况，因此在一个桥内只有一个 S-VLAN 的实体。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;qinq-介绍&quot;&gt;QinQ 介绍&lt;/h3&gt;

&lt;p&gt;QinQ 的理论基础，是 IEEE 定义的 802.1ad。在这个规范里面，IEEE 提出了一个概念，它认为汇聚和接入层那里有这么两种设备：S-VLAN Bridge 和 Provider Edge Bridge，再往下就是 Customer System 了（注意，这里说 System 而不是 Bridge，是因为 Customer 接进来的未必是二层设备，可能也是三层设备）。VLAN 空间也被分成两个 VLAN 空间，即 S-VLAN 和 C-VLAN，S 即 Service Provider，C 即 Customer。在 S-VLAN Bridge 上，只有 S-VLAN 空间，而在 Provider Edge Bridge 上，则既有 S-VLAN 空间，又有 C-VLAN 空间。相应的，这个 Bridge 就被从逻辑上划分为两部分，支持 S-VLAN 功能的部分称之为 S-VLAN Component，支持 C-VLAN 功能的部分称之为 C-VLAN Component。S-VLAN Bridge 只包含 S-VLAN Component。&lt;/p&gt;

&lt;p&gt;除了两种 Bridge 的概念，802.1ad 还提出了三种 Service 类型和四种 Port 类型，其中一种 Port 是内部 Port，对用户不可见，其它三种 Port 分别对应了三种不同的 Service，即运营商可以通过在交换机上配置三种不同的 Port 类型，来相应的为用户提供三种不同类型的 Service。三种 Service 分别是 Port Based Service，C-Tag Based Service 和 S-Tag Based Service。四种Port 分别是 Customer Network Port （CN）， Customer Edge Port（CE），Provider Network Port（PN），Provider Edge Port（内部 Port）。&lt;/p&gt;

&lt;p&gt;所谓 Port Based Service，就是说某个 Service 是基于 Port 的，从该 Port 进来的所有报文，都被认为是属于某一个特定的 Customer 的，不管它是否带 C-Tag，带了什么样的 C-Tag，这些信息统统被忽视。所有从这个 Port 进来的报文被赋予一个 S-VLAN，该 S-VLAN 被用来标识该 Customer，或说该 Service。提供这种 Service 的 Port 就是CN Port。CN Port 的实质就是运营商为一个 Customer 提供一个专门的 Port，不跟别的 Customer 共享。注意，从这个 Port 上进来的报文不能带 S-Tag，否则会被丢弃。也就是说，对于 S-Tag 而言，这个 Port 是 Access Port，而不是 Trunk Port。这是跟后面的 S-Tag Based service 本质的不同。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-port-based-pbn.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所谓的 S-Tag Based Service，就是说从一个 Port 上进来的报文，根据 S-VLAN 来把它们划分到不同的 Customer，换句话说，是用 S-VLAN 来标记 Customer。提供这种 Service 的 Port 也是 CN Port，只不过这个时候的 CN Port，必须配置成 Trunk Port，只识别 S-VLAN，根据 S-VLAN 来标识 Customer，转发报文。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-port-based-pbn-struct.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所谓的 C-Tag Based Service，就是指报文携带 C-Tag 进入 Port，在该 Port 上基于 C-VLAN 来标识 Customer，一个 Port 上可以支持多个 Customer。用来支持 C-Tag Based Service 的 Port 就是 CE Port，CE Port 是 C-VLAN Component 的一部分，对于 C-VLAN 而言，CE Port 是 Trunk Port。它不识别 S-Tag。&lt;/p&gt;

&lt;p&gt;PN Port 是 S-VLAN Component 的一部分，它跟 CN Port 唯一的不同是 CN Port 面向 Customer Network，而它面向 Provider Network，在实际的交换机中通常被配置成 Uplink Port，而且通常都是 VLAN Trunk Mode（相对于 Access Mode）。&lt;/p&gt;

&lt;p&gt;对于一个拥有 S-VLAN Component 和 C-VLAN Component 的 Provider Edge Bridge 而言，在做 Mac Forwarding/Learning 的时候，有两种模式，一种是用 &lt;code class=&quot;highlighter-rouge&quot;&gt;S-VLAN+MAC&lt;/code&gt;，另外一种则是 &lt;code class=&quot;highlighter-rouge&quot;&gt;S-VLAN+C-VLAN+MAC&lt;/code&gt;，前者即所谓的 C-VLAN Unaware Mode，而后者则是 C-VLAN Aware Mode。&lt;/p&gt;

&lt;p&gt;C-VLAN Aware Mode 带来的好处是显而易见的，因为它将 VLAN 空间从 4K 扩展到了 16M，但是它的问题在于，当前绝大多数芯片都不支持，就算支持了，也不太可能支持到理论上的 16M。&lt;/p&gt;

&lt;h4 id=&quot;一种独创的-qinq-模式&quot;&gt;一种独创的 QinQ 模式&lt;/h4&gt;

&lt;p&gt;现实世界中用户的需求是千奇百怪，有一种需求，是市场上现存的交换机所解决不了的。在讨论这种需求之前，先看一下当前交换机的做法。无论各个厂家的实现差别有多大，但是有一点大家都是一样的，就是在接入交换机上，通过 Port 或者 C-VLAN 来识别用户，然后为每个用户分配一个 S-VLAN，然后用 S-VLAN 来做后续处理，如 ACL/QoS/Mac Learning/Mac Forwarding 等。&lt;/p&gt;

&lt;p&gt;但是运营商，特别是欧美的一些运营商可能有这样的需求，为了描述的方便，我们假设有个运营商 A，它在为它的客户提供服务的时候，有的时候需要租用别的运营商，假设是运营商 B 的网络，在租用网络的时候，A 这些 B 的客户，运营商 B 需要给 A 分配 S-VLAN，而且往往是一个 S-VLAN 多少钱，因为 VLAN 是稀缺资源，特别是网络比较大的时候。这个时候，如果运营商 A 为它自己的客户每个都分配一个 S-VLAN，那么相应的它就需要向 B 也申请很多个 S-VLAN，不划算，这个时候它就想在自己的接入设备上，不用 S-VLAN 来标识 Customer，给所有的 Customer 分配同一个 S-VLAN，用该 S-VLAN 来穿越 B 的网络，这个时候，S-VLAN 的意义不是代表 Customer，而是代表一个 Tunnel。&lt;/p&gt;

&lt;p&gt;问题关键在于，如果不用 S-VLAN 来代表 Customer，在 A 的接入设备上，如何来对不同的 Customer 来做区分处理呢？用 C-VLAN 肯定是不行的，因为不同 Port 上的 C-VLAN 代表的 Customer 可能是不同的。Centec 的交换机，在芯片内部用一个不同于 C-VLAN 和 S-VLAN 的 CustomerID 来标识 Customer，用这个值来做后续的一系列 Customer 的处理，非常强大。&lt;/p&gt;

&lt;h4 id=&quot;qinq-的不足&quot;&gt;QinQ 的不足&lt;/h4&gt;

&lt;p&gt;尽管 QinQ 貌似很好很强大，并且受到热烈追捧，但是这不能掩盖它的先天不足。&lt;/p&gt;

&lt;p&gt;QinQ 的最大不足就是它无法对运营商网络完全隐藏 Customer 信息，因为它可以让运营商 Core Network 的设备看不到 Customer VLAN，但是无法让它们看不到 Customer MAC。而这一点有两个不利的影响，一个是 Scalability 非常差，如果中间的设备都是二层设备，会导致 MAC 表非常大；第二个不利的影响则是，一旦 Customer 网络出现了环路，会导致 Provider Network 里面的设备不断进行 MAC Learning，万一有 ARP 之类报文，还可能冲击 CPU。&lt;/p&gt;

&lt;p&gt;如果 Customer VLAN 对运营商网络不可见，那么就起不到扩展 VLAN 空间的作用，运营商的 VLAN 空间就仍然只有 4K。&lt;/p&gt;

&lt;p&gt;而 PBB，即所谓的 MAC-in-MAC 则能很好的解决 QinQ 的这个不足，因为 PBB 不仅在原来的报文上新增一个 VLAN，还新增 MACSa/MACDa 以及 24 个 bit 的 Isid（用来标识 Service），它可以完全对运营商的 Core Network 设备隐藏 Customer 信息，且能利用 Isid 来支持 16M Customer/Service。&lt;/p&gt;

&lt;p&gt;当然PBB也有PBB的问题，目前看不到它有成为主流技术的趋势。&lt;/p&gt;

&lt;h2 id=&quot;lldpdu&quot;&gt;LLDPDU&lt;/h2&gt;

&lt;p&gt;LLDPDU 是 LLDP 的有效负载，用于承载要发送的消息。LLDPDU 的格式如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-du.png&quot; alt=&quot;LLDPDU&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LLDPDU 采用了 TLV 的格式，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;type+length+value&lt;/code&gt; 的格式，type 表示 TLV 的类型，length 是以字节为单位的 TLV 的长度，value 是该 TLV 的值。其中 Chassis ID TLV，Port ID TLV Time To Live TLV 以及 End Of LLDPDU TLV 是强制的，必须包含的部分，除此之外在 TLV Time To Live TLV 和 End Of LLDPDU TLV 之间可以包含 0 个到多个可选的其它 TLV。&lt;/p&gt;

&lt;h2 id=&quot;tlv&quot;&gt;TLV&lt;/h2&gt;

&lt;p&gt;TLV 是组成 LLDPDU 的单元，每个 TLV 都代表一个信息。LLDPDU 的 TLV 可以分为两大类&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;被认为是网络管理的基础的 TLV 集合，所有的 LLDP 实现都需要支持。&lt;/li&gt;
  &lt;li&gt;组织定义的 TLV 扩展集合，包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;802.1&lt;/code&gt; 组织定义 TLV、&lt;code class=&quot;highlighter-rouge&quot;&gt;802.3&lt;/code&gt; 组织定义 TLV 以及其他组织定义的 TLV。这些 TLV 用于增强对网络设备的管理，可根据实际需要选择是否在 LLDPDU 中发送。 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TLV 的基本格式如图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-tlv-format.png&quot; alt=&quot;TLV基本格式图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TLV的类型域的定义及分配如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-tlv-list.png&quot; alt=&quot;TLV类型域&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;type0-8&lt;/code&gt; 属于基本的 TLV 集合。对于其中的 Mandatory 的 TLV，它是必须包含在 LLDP 中的。 组织定义 TLV 集合的格式如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-tlv-frame.png&quot; alt=&quot;TLV集合格式&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OUI：组织机构的 ID。&lt;/li&gt;
  &lt;li&gt;organizationally defined subtype：组织自定义的类型。&lt;/li&gt;
  &lt;li&gt;organizationally defined information string：传输的信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;基础-tlv-集合&quot;&gt;基础 TLV 集合&lt;/h2&gt;

&lt;p&gt;几个强制的必须包含的 TLV 的定义如下。非强制的可以参考 IEEE802.1AB。&lt;/p&gt;

&lt;h3 id=&quot;end-of-lldpdu-tlv&quot;&gt;End Of LLDPDU TLV&lt;/h3&gt;

&lt;p&gt;该 TLV 用于标识 LLDPDU 的结束。其格式如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-tlv-end.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于 length=0，因此它不包含 value 域。&lt;/p&gt;

&lt;h3 id=&quot;chassis-id-tlv&quot;&gt;Chassis ID TLV&lt;/h3&gt;

&lt;p&gt;该 TLV 用于通告该 LLDPDU 发送者的 Chassis ID。由于有很多方式可用来标识一个 Chassis，因此在该类 TLV 中包含一个子类型域用于告诉接收者，发送者的 Chassis ID 采用的是哪一种标识方式。其格式如图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-tlv-chassis.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个 LLDPDU 必须包含且仅包含一个该类型的 TLV。由于 Chassis ID 实际上是用于标识设备的，因此在连接可用时它应该保持不变。 Chassis 子类型所可能的取值如图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-tlv-chassis-list.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;port-id-tlv&quot;&gt;Port ID TLV&lt;/h3&gt;

&lt;p&gt;它用于标识发送该 LLDPDU 的设备的端口。类似于 Chassis ID，有很多方式可以标识一个 Port，因此该 TLV 也包含一个子类型域。其格式如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-tlv-port.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个 LLDPDU 必须包含一个且只能包含一个该类型的 TLV。同时，当端口可用时，从该端口发送出去的 LLDPDU 的该 TLV 应该保持不变。 其子类型的可能取值如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-tlv-port-list.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;time-to-live-tlv&quot;&gt;Time To Live TLV&lt;/h3&gt;

&lt;p&gt;该 TLV 用于告诉接收端，它接收到的这些信息的有效期有多长。其格式如图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-tlv-ttl.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TTL 的时间单位是秒，由于只有 2 个字节长，因而最大有效时间是 65536 秒。如果在这个时间到期了还没有新的 LLDPDU 被收到，则该 TLV 所属的那个 LLDPDU 携带的信息会被从 MIB 中删除。如果收到了新的 LLDPDU，则&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果 TTL 不为 0，则会用新收到的 LLDPDU 的信息替换 MIB 库中的相应的信息（即与该 LLDPDU 的发送者相关的 MIB 信息，LLDP 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Chassis ID+Port ID&lt;/code&gt; 来判断是否来自于同一个源，这也是要求这两者保持不变的原因）。&lt;/li&gt;
  &lt;li&gt;如果 TTL 为 0，则删除相应的 MIB 库中的信息（即与该 LLDPDU 的发送者相关的 MIB 信息）。因此 TTL 为 0 的 LLDPDU 又被称为SHUTDOWN LLDPDU。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每一个 LLDPDU 必须包含且只能包含一个该类型的 TLV。&lt;/p&gt;

&lt;h2 id=&quot;工作机制&quot;&gt;工作机制&lt;/h2&gt;

&lt;p&gt;LLDP 是一个用于信息通告和获取的协议，但是需要注意的一点是，LLDP 发送的信息通告不需要确认，不能发送一个请求来请求获取某些信息，也就是说 LLDP 是一个单向的协议，只有主动通告一种工作方式，无需确认，不能查询、请求（比如像 ARP 协议那样请求某个 IP 的 MAC 地址）。&lt;/p&gt;

&lt;p&gt;LLDP 主要完成如下工作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;初始化并维护本地 MIB 库中的信息。&lt;/li&gt;
  &lt;li&gt;从本地 MIB 库中提取信息，并将信息封装到 LLDP 帧中。LLDP 帧的发送有两种触发方式，一是定时器到期触发，一是设备状态发生了变化触发。&lt;/li&gt;
  &lt;li&gt;识别并处理接收到的 LLDPDU 帧。&lt;/li&gt;
  &lt;li&gt;维护远端设备 LLDP MIB 信息库。&lt;/li&gt;
  &lt;li&gt;当本地或远端设备 MIB 信息库中有信息发生变化时，发出通告事件。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;lldpdu-发送&quot;&gt;LLDPDU 发送&lt;/h3&gt;

&lt;h4 id=&quot;发送机制&quot;&gt;发送机制&lt;/h4&gt;

&lt;p&gt;LLDPDU 的发送可以被如下事件触发：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;与本地 MIB 信息库相关联的定时器 txTTR 到期时，这将确保远端接收系统中的相关信息不会因为 TTL 到期而过期。&lt;/li&gt;
  &lt;li&gt;本地 MIB 信息库中的信息发生了改变时，会立即发送 LLDPDU，这将保证改变能及时被更新。&lt;/li&gt;
  &lt;li&gt;如果一个“新邻居”被识别，将会启用快速发送机制，在很短的时间内连续发送指定数量（txFastInit，默认值为 4）的 LLDPDU，以确保“新邻居”能被快速更新。如果远端系统 MIB 信息库因为过载（tooManyNeighbors）而不能容纳新的邻居信息，则会为了避免过多的LLDPDU 传输而抑制快速发送行为。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;LLDP 的常规发送时间是建立在系统的 Tick 之上的，间隔为 1 秒一个，为了防止在共享介质的 LAN（shared media LAN）中同时出现大量的 LLDPDU（因为接入同一个LAN的多个系统的时间是同步的，因而多个系统上的基于 Tick 的1秒定时器可能同时到期），发送定时器引入了一个随机的抖动，这就使得常规的 LLDP 帧的发送间隔时间的平均值仍是 1 秒，但是具体到某一次到期时间可能并不是准确的 1 秒。&lt;/p&gt;

&lt;p&gt;同时为了防止在有多个端口需要发送 LLDPDU 的系统中，所有的端口的定时器都在同一时间到期，因而标准建议将采用某种机制将多个发送实例的定时器到期时间给错开，以避免一个系统在同一时刻发送大量的 LLDPDU。&lt;/p&gt;

&lt;h4 id=&quot;发送状态机&quot;&gt;发送状态机&lt;/h4&gt;

&lt;p&gt;LLDPDU 的发送状态机如图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-send-state-machine.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于该状态机：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为了防止过于频繁的重新初始化发送状态机，在 LLDP 的发送状态机中引入了一个延时，该延时限制了在关闭发送状态机后，必须至少等待多长时间才能重新初始化发送状态机。&lt;/li&gt;
  &lt;li&gt;是否发送 SHUTDOWN LLDPDU 由本地的 LLDP 工作状态决定。&lt;/li&gt;
  &lt;li&gt;是否发送正常的 LLDPDU 由 txNow 和 txCredit 决定。这两个变量都由发送定时器状态机更新。txNow 决定是否发送，而 txCredit 则是一个信用量，决定了可以发送的量，如果是 0 则不允许发送，只有大于 0 的值才允许发送，每发送一个该值就减 1。更重要的是在本地信息快速改变时，txCredit 既允许连续发送多个 LLDPDU，但是又对可以连续发送的 LLDPDU 帧数做了限制，这使得本地状态的快速改变可以及时被通告出去，但是又不能无限发送导致网络出现大量 LLDPDU 帧。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;发送定时器状态机&quot;&gt;发送定时器状态机&lt;/h4&gt;

&lt;p&gt;LLDP 发送定时器状态机如图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-send-timer-state-machine.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;localChange 表示本地信息是否发生改变；txTTR 表示下一次定时器到期的时间；newNeighbor 表示是否发现了新的邻居，并由接收状态设置，由该状态机清除；txTick 表示基于系统时间的1秒定时器是否到期。&lt;/p&gt;

&lt;p&gt;对于该状态机：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SIGNAL_TX 用于触发发送，它会将 txNow 设置为允许发送，并设置本地信息发生改变为 FALSE，如果当前不是在快速发送状态（txFast = 0）就设置发送定时器下次到期时间为 msgTxInterval（msgTxInterval默认为30秒，取值范围1-3600秒），否则设置发送定时器下次到期时间为 msgFastTx（msgFastTx默认值为1秒，取值范围1-3600秒）。&lt;/li&gt;
  &lt;li&gt;如果本地信息发生了改变，就立即进入 SIGNAL_TX。&lt;/li&gt;
  &lt;li&gt;如果定时器到期，则如果 txFast 大于 0，则将其减 1 并进入 SIGNAL_TX，否则直接进入 SIGNAL_TX。&lt;/li&gt;
  &lt;li&gt;如果发现了新邻居，则首先将发现新邻居的标识更新为没有发现新邻居，然后如果当前已经处于快速发送状态就直接进入发送定时器到期状态（以触发一次立即发送），否则设置 txFast 的值为 txFastInit 的值（txFastInit 默认值为 4，取值范围 1-8）。&lt;/li&gt;
  &lt;li&gt;如果基于系统时间的 1 秒定时器到期，则给 txCredit 增加信用量，其最大值为 txCreditMax，txCreditMax 是一个取值在 1 到 10 之间的值，默认值为 5。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里有取值范围的几个变量都是可配置的变量。&lt;/p&gt;

&lt;p&gt;从上述两个状态机的工作状态可以看出，发送定时器状态机用于维护信用量以及是否允许发送 LLDPDU 帧，而发送状态机根据这两个信息来决定是否发送。另外需要注意的是 LLDP 所使用的所有定时器操作都是“基于系统时间的 1 秒定时器的”，每当这个定时器到期时它除了会将 txTick 设置为 TRUE 外，还会处理其它的定时功能。&lt;/p&gt;

&lt;h3 id=&quot;lldpdu-接收&quot;&gt;LLDPDU 接收&lt;/h3&gt;

&lt;h4 id=&quot;接收机制&quot;&gt;接收机制&lt;/h4&gt;

&lt;p&gt;LLDP 帧的接收由 3 个阶段组成：帧的识别、帧的校验、LLDP 远端 MIB 信息库更新。&lt;/p&gt;

&lt;h5 id=&quot;帧的识别&quot;&gt;帧的识别&lt;/h5&gt;

&lt;p&gt;由在 LLDP/LSAP（链路服务访问点）进行，检查的内容是帧的目的地是否是 LLDP 的组播 MAC 地址，帧的类型是否是 LLDP。&lt;/p&gt;

&lt;h5 id=&quot;帧的验证&quot;&gt;帧的验证&lt;/h5&gt;

&lt;p&gt;该过程会首先根据 TLV 的格式定义依次校验 Chassis ID TLV，Port ID TLV， Time To Live TLV，如果这三个 TLV 都存在且有效，才会进一步的解码可选的 TLV 直到遇到 End Of LLDPDU TLV，然后根据获得的信息更新远端 MIB 信息库。&lt;/p&gt;

&lt;h5 id=&quot;远端-mib-信息库更新&quot;&gt;远端 MIB 信息库更新&lt;/h5&gt;

&lt;p&gt;在前两步都通过之后，LLDPDU 的接收者就需要根据解析出来的信息更新远端 MIB 信息库。在 MIB 信息库中，LLDP 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Chassis ID+Port ID&lt;/code&gt; 来标识、存储来自不同源的信息。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果远端MIB库中已经有对应于该 &lt;code class=&quot;highlighter-rouge&quot;&gt;Chassis ID+Port ID&lt;/code&gt; 的信息，则使用收到的帧中的新的 TTL 来更新 TTL。并用对于收到的新的 LLDPPDU 中的每一种 type，如果有变化就进行更新，如果某种 type 原来不存在，则需要将其添加到 MIB 库中。&lt;/li&gt;
  &lt;li&gt;如果实现不支持某种类型的 type，则
    &lt;ol&gt;
      &lt;li&gt;如果 type 不是 127，则按照基本 TLV 的格式将其存储到远端 MIB 库，存储格式为 type，length，value。&lt;/li&gt;
      &lt;li&gt;如果 type 是 127，则按照组织定义 TLV 的格式将其存储到远端 MIB 库，存储格式为 type，length，value，OUI，组织自定义子类型，以及信息域。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更新时，如果需要添加新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Chassis ID+Port ID&lt;/code&gt; 的表项，或者为某个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Chassis ID+Port ID&lt;/code&gt; 添加新的 TLV，则可能遇到没有内存的问题，标准没有规定必须如何处理，只是给出了一些建议：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;忽略新的 LLDPDU 的信息&lt;/li&gt;
  &lt;li&gt;删除最旧的信息以释放空间给新的信息&lt;/li&gt;
  &lt;li&gt;随机删除一些旧的信息以释放空间给新的信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;LLDPDU 携带的 TTL（Time To Live）值会影响接收端的处理方式，如果它不为 0，则更新相应信息的老化时间，如果接收到的 LLDPDU 中的 TTL 等于 0，则将立刻老化掉相应的信息（即与该 LLDPDU 的发送者相关的MIB信息）。&lt;/p&gt;

&lt;p&gt;如果一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Chassis ID+Port ID&lt;/code&gt; 标识的信息的 TTL 超时，则相应的 MIB 信息会被删除。&lt;/p&gt;

&lt;h4 id=&quot;接收状态机&quot;&gt;接收状态机&lt;/h4&gt;

&lt;p&gt;LLDPDU 的接收状态机如图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-receive-state-machine.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;lldp-工作模式&quot;&gt;LLDP 工作模式&lt;/h3&gt;

&lt;p&gt;LLDP 可以工作在多种模式下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TxRx：既发送也接收 LLDP 帧。&lt;/li&gt;
  &lt;li&gt;Tx：只发送不接收 LLDP 帧。&lt;/li&gt;
  &lt;li&gt;Rx：只接收不发送 LLDP 帧。&lt;/li&gt;
  &lt;li&gt;Disable：既不发送也不接收 LLDP 帧（准确的说，这并不是一个 LLDP 的状态，这可能是 LLDP 功能被关闭了，也可能是设备就不支持）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于 LLDP 可以单独工作在发送或接收模式下，因此 LLDP 协议的实现需要支持单独初始化发送或者接收功能。当工作模式发生变化时，需要根据老的/新的工作模式来关闭/打开发送或者接收的功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-mib-block.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-state-machine-symbol.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此，LLDP 相关知识点已经介绍完，希望对大家有所帮助。&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Jan 2018 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>（译）TensorFlow 广度和深度学习的教程</title>
        <link>/ml/2017/11/30/tensorflow-wide-and-deep.html</link>
        <guid isPermaLink="true">/ml/2017/11/30/tensorflow-wide-and-deep.html</guid>
        <description>&lt;p&gt;在前文 &lt;a href=&quot;https://www.tensorflow.org/tutorials/wide&quot;&gt;《TensorFlow Liner Model Tutorial》&lt;/a&gt; 中，我们使用 &lt;a href=&quot;https://archive.ics.uci.edu/ml/datasets/Census+Income&quot;&gt;人口收入普查数据集&lt;/a&gt; 训练了一个 logistic 线性回归模型去预测个人年收入超过 5 万美元的概率。TensorFlow 在训练深度神经网络方面效果也很好，那么你可能会考虑该如何取舍它的功能了 – 可是，为什么不选择两者兼得呢？那么，是否可以将两者的优势结合在一个模型中呢？&lt;/p&gt;

&lt;p&gt;在这篇文章中，我们将会介绍如何使用 TF.Learn API 同时训练一个广度线性模型和一个深度前馈神经网络。这种方法结合了记忆和泛化的优势。它在一般的大规模回归和具有稀疏输入特性的分类问题（例如，分类特征存在一个很大的可能值域）上很有效。如果你有兴趣学习更多关于广度和深度学习如何工作的问题，请参考 &lt;a href=&quot;http://arxiv.org/abs/1606.07792&quot;&gt;研究论文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.tensorflow.org/images/wide_n_deep.svg&quot; alt=&quot;Wide &amp;amp; Deep Spectrum of Models&quot; title=&quot;Wide &amp;amp; Deep&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在，我们来看一个简单的例子。&lt;/p&gt;

&lt;p&gt;上图展示了广度模型（具有稀疏特征和转换性质的 logistic 回归模型），深度模型（具有一个嵌入层和多个隐藏层的前馈神经网络），广度和深度模型（两者的联合训练）的区别比较。在高层级里，只需要通过以下三个步骤就能使用 TF.Learn API 配置广度，深度或广度和深度模型。&lt;/p&gt;

&lt;p&gt;1.选择广度部分的特征：选择要使用的稀疏基本列和交叉列。&lt;/p&gt;

&lt;p&gt;2.选择深度部分的特征：选择连续列，每个分类列的嵌入维度和隐藏层大小。&lt;/p&gt;

&lt;p&gt;3.将它们一起放入广度和深度模型（&lt;code class=&quot;highlighter-rouge&quot;&gt;DNNLinearCombinedClassifier&lt;/code&gt;）。&lt;/p&gt;

&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;

&lt;p&gt;如果想要尝试本教程中的代码：&lt;/p&gt;

&lt;p&gt;1.安装 TensorFlow ，&lt;a href=&quot;http://chars.tech/2017/09/26/tensorflow-pycharm-mac/&quot;&gt;请前往此处&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;2.下载 &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/examples/learn/wide_n_deep_tutorial.py&quot;&gt;教程代码&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;3.安装 pandas 数据分析库。因为本教程中需要使用 pandas 数据。虽然 tf.learn 不要求 pandas，但是它支持 pandas。安装 pandas：&lt;/p&gt;

&lt;p&gt;a. 获取 pip：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Ubuntu/Linux 64-bit
$ sudo apt-get install python-pip python-dev

# Mac OS X
$ sudo easy_install pip
$ sudo easy_install --upgrade six
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;b. 使用 pip 安装 pandas&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo pip install pandas
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果你在安装过程中遇到问题，请前往 pandas 网站上的 &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/install.html&quot;&gt;说明&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;4.执行以下命令来训练教程中描述的线性模型：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python wide_n_deep_tutorial.py --model_type=wide_n_deep
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;请继续阅读，了解此代码如何构建其线性模型。&lt;/p&gt;

&lt;h2 id=&quot;定义基本特征列&quot;&gt;定义基本特征列&lt;/h2&gt;

&lt;p&gt;首先，定义我们使用的基本分类和连续特征的列。这些列将被作为模型的广度部分和深度部分的构件块。&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;tensorflow&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;gender&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categorical_column_with_vocabulary_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;gender&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Female&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Male&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;education&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categorical_column_with_vocabulary_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;education&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Bachelors&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;HS-grad&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;11th&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Masters&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;9th&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Some-college&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Assoc-acdm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Assoc-voc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;7th-8th&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Doctorate&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Prof-school&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;5th-6th&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;10th&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1st-4th&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Preschool&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;12th&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;marital_status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categorical_column_with_vocabulary_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;marital_status&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Married-civ-spouse&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Divorced&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Married-spouse-absent&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Never-married&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Separated&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Married-AF-spouse&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Widowed&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;relationship&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categorical_column_with_vocabulary_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;relationship&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Husband&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Not-in-family&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Wife&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Own-child&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Unmarried&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Other-relative&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;workclass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categorical_column_with_vocabulary_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;workclass&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Self-emp-not-inc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Private&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;State-gov&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Federal-gov&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Local-gov&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;?&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Self-emp-inc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Without-pay&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Never-worked&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 展示一个哈希的例子：&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;occupation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categorical_column_with_hash_bucket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;occupation&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash_bucket_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;native_country&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categorical_column_with_hash_bucket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;native_country&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash_bucket_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 连续基列&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numeric_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;age&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;education_num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numeric_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;education_num&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;capital_gain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numeric_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;capital_gain&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;capital_loss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numeric_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;capital_loss&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hours_per_week&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numeric_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hours_per_week&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 转换&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;age_buckets&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bucketized_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boundaries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;35&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;55&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;65&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;广度模型具有交叉特征列的线性模型&quot;&gt;广度模型：具有交叉特征列的线性模型&lt;/h2&gt;

&lt;p&gt;广度模型是一个具有稀疏和交叉特征列的线性模型：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;base_columns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;gender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;native_country&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;education&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;occupation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workclass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;relationship&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;age_buckets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;crossed_columns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;crossed_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;education&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;occupation&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash_bucket_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;crossed_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age_buckets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;education&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;occupation&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash_bucket_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;crossed_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;native_country&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;occupation&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash_bucket_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具有交叉特征列的广度模型可以有效地记忆特征之间的稀疏交互。也就是说，交叉特征列不能概括没有在训练数据中出现的特征组合。让我们采用嵌入方式来添加一个深度模型来修复这个问题。&lt;/p&gt;

&lt;h2 id=&quot;深度模型嵌入式神经网络&quot;&gt;深度模型：嵌入式神经网络&lt;/h2&gt;

&lt;p&gt;深度模型是一个前馈神经网络，如前图所示。每一个稀疏，高维度分类特征首先都会被转换成一个低维度密集的实值矢量，通常被称为嵌入式矢量。这些低维度密集的嵌入式矢量与连续特征相连，然后在正向传递中馈入神经网络的隐藏层。嵌入值随机初始化，并与其他模型参数一起训练，以最大化减少训练损失。如果你有兴趣了解更多关于嵌入的知识，请在查阅教程 &lt;a href=&quot;https://www.tensorflow.org/versions/r0.9/tutorials/word2vec/index.html&quot;&gt;Vector Representations of Words&lt;/a&gt; 或在 Wikipedia 上查阅 &lt;a href=&quot;https://en.wikipedia.org/wiki/Word_embedding&quot;&gt;Word Embedding&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我们将使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;embedding_column&lt;/code&gt; 配置分类嵌入列，并将它们与连续列连接：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;deep_columns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indicator_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;workclass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indicator_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;education&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indicator_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indicator_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;relationship&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# 展示一个嵌入例子&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;embedding_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;native_country&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dimension&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;embedding_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;occupation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dimension&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;education_num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;capital_gain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;capital_loss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;hours_per_week&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;嵌入的 &lt;code class=&quot;highlighter-rouge&quot;&gt;dimension&lt;/code&gt; 越高，自由度就越高，模型将不得不学习这些特性的表示。为了简单起见，我们设置所有特征列的维度为 8。从经验上看，关于维度的设定最好是从 \log_{2}(n) 或 k\sqrt[4]{n} 值开始，这里的 n 代表特征列中唯一特征的数量，k 是一个很小的常量（通常小于10）。&lt;/p&gt;

&lt;p&gt;通过密集嵌入，深度模型可以更好的概括，并更好对之前没有在训练数据中遇见的特征进行预测。然而，当两个特征列之间的底层交互矩阵是稀疏和高等级时，很难学习特征列的有效低维度表示。在这种情况下，大多数特征对之间的交互应该为零，除了少数几个，但密集的嵌入将导致所有特征对的非零预测，从而可能过度泛化。另一方面，具有交叉特征的线性模型可以用更少的模型参数有效地记住这些“异常规则”。&lt;/p&gt;

&lt;p&gt;现在，我们来看看如何联合训练广度和深度模型，让它们优势和劣势互补。&lt;/p&gt;

&lt;h2 id=&quot;将广度和深度模型结合为一体&quot;&gt;将广度和深度模型结合为一体&lt;/h2&gt;

&lt;p&gt;通过将其最终输出的对数几率作为预测结合起来，然后将预测提供给 logistic 损失函数，将广度模型和深度模型相结合。所有的图形定义和变量分配都已经被处理，所以你只需要创建一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;DNNLinearCombinedClassifier&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;tempfile&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;model_dir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tempfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mkdtemp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contrib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;learn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DNNLinearCombinedClassifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;model_dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;linear_feature_columns&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wide_columns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dnn_feature_columns&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deep_columns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dnn_hidden_units&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;训练和评估模型&quot;&gt;训练和评估模型&lt;/h2&gt;

&lt;p&gt;在训练模型之前，请先阅读人口普查数据集，就像在 &lt;a href=&quot;https://www.tensorflow.org/tutorials/wide&quot;&gt;《TensorFlow Liner Model Tutorial》&lt;/a&gt; 中所做的一样。 输入数据处理的代码再次为你提供方便：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pandas&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;urllib&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 为数据集定义列名&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;CSV_COLUMNS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;age&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;workclass&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;fnlwgt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;education&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;education_num&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;marital_status&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;occupation&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;relationship&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;race&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;gender&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;capital_gain&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;capital_loss&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hours_per_week&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;native_country&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;income_bracket&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;maybe_download&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;train_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;Maybe downloads training data and returns train and test file names.&quot;&quot;&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;train_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;train_file_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;train_data&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;train_file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tempfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NamedTemporaryFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;urllib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;urlretrieve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;train_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# pylint: disable=line-too-long&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;train_file_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;train_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;train_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Training data is downloaded to &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;train_file_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;test_file_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test_data&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;test_file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tempfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NamedTemporaryFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;urllib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;urlretrieve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;test_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# pylint: disable=line-too-long&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;test_file_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;test_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Test data is downloaded to &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test_file_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;train_file_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test_file_name&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;input_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_epochs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shuffle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;Input builder function.&quot;&quot;&quot;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;df_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read_csv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;names&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CSV_COLUMNS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;skipinitialspace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;python&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;skiprows&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;# 移除 NaN 元素&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;df_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df_data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dropna&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;how&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;any&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;axis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;labels&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;income_bracket&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;gt;50K&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;astype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;estimator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inputs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pandas_input_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;df_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;batch_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;num_epochs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_epochs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;shuffle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shuffle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;num_threads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;阅读数据之后，你可以训练并评估模型：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 将 num_epochs 设置为 None，以获得无限的数据流&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;train&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;input_fn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;train_file_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_epochs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shuffle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;steps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;train_steps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 在所有数据被消耗之前，为了运行评估，设置 steps 为 None&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evaluate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;input_fn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test_file_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_epochs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shuffle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;steps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;model directory = &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s: &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出的第一行应该类似 &lt;code class=&quot;highlighter-rouge&quot;&gt;accuracy: 0.84429705&lt;/code&gt;。我们可以看到使用广度和深度模型将广度线性模型精度约 83.6% 提高到了约 84.4%。如果你想看端对端的工作示例，你可以下载我们的 &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/examples/learn/wide_n_deep_tutorial.py&quot;&gt;示例代码&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;请注意，本教程只是一个小型数据基的简单示例，为了让你快速熟悉 API。如果你有大量具有稀疏特征列和大量可能特征值的数据集，广度和深度学习将会更加强大。此外，请随时关注我们的 &lt;a href=&quot;http://arxiv.org/abs/1606.07792&quot;&gt;研究论文&lt;/a&gt;，以了解更多关于在实际中广度和深度学习在大型机器学习方面如何应用的思考。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;译者：&lt;a href=&quot;https://github.com/charsdavy&quot;&gt;charsdavy&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;校对者：&lt;a href=&quot;https://github.com/MRNIU&quot;&gt;MRNIU&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 30 Nov 2017 22:00:10 +0800</pubDate>
      </item>
    
      <item>
        <title>聊聊 iOS 数据保护</title>
        <link>/pieces/2017/10/17/ios-data-protection.html</link>
        <guid isPermaLink="true">/pieces/2017/10/17/ios-data-protection.html</guid>
        <description>&lt;p&gt;文件系统中的文件、keychain中的项，都是加密存储的。当用户解锁设备后，系统通过UDID密钥和用户设定的密码生成一个用于解密的密码密钥，存放在内存中，直到设备再次被锁，开发者可以通过Data Protection API 来设定文件系统中的文件、keychain中的项应该何时被解密。这个就是数据保护的内容。&lt;/p&gt;

&lt;h2 id=&quot;钥匙串keychain&quot;&gt;钥匙串（keychain）&lt;/h2&gt;

&lt;p&gt;keychain服务提供了一种安全的保存私密信息（密码，序列号，私钥，证书等）的方式，每个iOS程序都有一个独立的keychain存储。相对于NSUserDefaults、文件保存等一般方式，keychain保存更为安全，而且keychain里保存的信息不会因APP被删除而丢失。&lt;/p&gt;

&lt;p&gt;基于钥匙串的特点，我们在使用时对于新增的数据项目，要注意数据删除的时机。还有一点需要注意的就是，保护属性的指定。如果没有指定保护属性，这将被视为严重的安全漏洞。&lt;/p&gt;

&lt;h3 id=&quot;作用&quot;&gt;作用&lt;/h3&gt;

&lt;h4 id=&quot;备份&quot;&gt;备份&lt;/h4&gt;

&lt;p&gt;当我们备份设备数据时，系统会将用户数据保存在相应的钥匙串中，并依照相应的安全策略保存。主要分成两类：&lt;strong&gt;加密&lt;/strong&gt;和&lt;strong&gt;不加密&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;两者的主要区别在于恢复数据时的范围不同。加密备份的数据可以恢复到任何设备上（ThisDeviceOnly指定的项目除外），而不加密的备份则只能恢复至同一台设备。&lt;/p&gt;

&lt;h4 id=&quot;共享&quot;&gt;共享&lt;/h4&gt;

&lt;p&gt;keychain支持在多个应用之间共享数据。但现实开发中&lt;code class=&quot;highlighter-rouge&quot;&gt;UIPasteboardNameFind&lt;/code&gt;的使用代替了keychain。不过好在Apple在iOS11中已经废弃它。看来Apple想规范开发者对于用户敏感数据的共享使用，同时提醒大家使用更加安全的方式存储用户敏感数据。&lt;/p&gt;

&lt;h3 id=&quot;使用范例&quot;&gt;使用范例&lt;/h3&gt;

&lt;h4 id=&quot;secitemadd&quot;&gt;SecItemAdd&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSMutableDictionary *dict = [NSMutableDictionary dictionary];
NSData *passwordData = [@&quot;myPassword&quot; dataUsingEncoding:NSUTF8StringEncoding];

[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];
[dict setObject:@&quot;Conglomco&quot; forKey:(__bridge id)kSecAttrLabel];
[dict setObject:@&quot;This is your password for the Conglomco service.&quot; forKey:(__bridge id)kSecAttrDescription];
[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];
[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];
[dict setObject:passwordData forKey:(__bridge id)kSecValueData];
[dict setObject:(__bridge id)kSecAttrAccessibleWhenUnlocked forKey:(__bridge id)kSecAttrAccessible];

OSStatus error = SecItemAdd((__bridge CFDictionaryRef)dict, NULL);
if (error == errSecSuccess) {
    NSLog(@&quot;Yay&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;secitemdelete&quot;&gt;SecItemDelete&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSMutableDictionary *dict = [NSMutableDictionary dictionary];

[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];
[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];
[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];

OSStatus error = SecItemDelete((__bridge CFDictionaryRef)dict);
if (error == errSecSuccess) {
	NSLog(@&quot;Yay&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;secitemupdate&quot;&gt;SecItemUpdate&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSMutableDictionary *dict = [NSMutableDictionary dictionary];
NSData *newPasswordData = [@&quot;newMyPassword&quot; dataUsingEncoding:NSUTF8StringEncoding];

[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];
[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];
[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];

NSDictionary *updatedAttribute = [NSDictionary dictionaryWithObject:newPasswordData forKey:(__bridge id)kSecValueData];

OSStatus error = SecItemUpdate((__bridge CFDictionaryRef)dict, (__bridge CFDictionaryRef)updatedAttribute);
if (error == errSecSuccess) {
	NSLog(@&quot;Yay&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;secitemcopymatching&quot;&gt;SecItemCopyMatching&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSMutableDictionary *dict = [NSMutableDictionary dictionary];

[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];
[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];
[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];
[dict setObject:(id)kCFBooleanTrue forKey:(__bridge id)kSecReturnAttributes];

NSDictionary *result = nil;
OSStatus error = SecItemCopyMatching((__bridge CFDictionaryRef)dict, (void *)&amp;amp;result);
if (error == errSecSuccess) {
	NSLog(@&quot;Yay %@&quot;, result);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;常用方法&quot;&gt;常用方法&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;SecItemAdd&lt;/td&gt;
      &lt;td&gt;添加数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SecItemDelete&lt;/td&gt;
      &lt;td&gt;删除数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SecItemUpdate&lt;/td&gt;
      &lt;td&gt;修改数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SecItemCopyMatching&lt;/td&gt;
      &lt;td&gt;查找数据&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;保护属性&quot;&gt;保护属性&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;钥匙串保护属性&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecAttrAccessibleAfterFirstUnlock&lt;/td&gt;
      &lt;td&gt;开机之后密钥不可用，直到用户首次输入密码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecAttrAccessibleAlways&lt;/td&gt;
      &lt;td&gt;密钥在设备开机后依旧可用。在iOS9中已经废弃&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecAttrAccessibleAlwaysThisDeviceOnly&lt;/td&gt;
      &lt;td&gt;密钥始终可用，但无法迁移到其他设备&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly&lt;/td&gt;
      &lt;td&gt;作用同上&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecAttrAccessibleWhenUnlocked&lt;/td&gt;
      &lt;td&gt;只要解锁过设备，则密钥保持可用状态&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecAttrAccessibleWhenUnlockedThisDeviceOnly&lt;/td&gt;
      &lt;td&gt;作用同上&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly&lt;/td&gt;
      &lt;td&gt;作用同上，只有用户设置密码密钥才可用&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kSecAttrAccessibleAlways&lt;/code&gt; 将会引入一个很明显的安全问题，因为此种保护属性，只要有人窃取了你的设备，他们就能读取钥匙串的内容。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly&lt;/code&gt; 这个属性可以完美的解决上述的安全问题。因为越狱时通常需要重启设备。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kSecAttrAccessibleWhenUnlocked&lt;/code&gt; 这个属性要求攻击者必须知道用户密码才能提取隐私数据。它很适合做默认属性值。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly&lt;/code&gt; 是iOS8新增的保护属性。这个属性要求在使用时用户设定了密码，否则使用就失败。&lt;/p&gt;

&lt;h3 id=&quot;基本用法&quot;&gt;基本用法&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;项目类&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecClassGenericPassword&lt;/td&gt;
      &lt;td&gt;普通密码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecClassInternetPassword&lt;/td&gt;
      &lt;td&gt;专门用于互联网服务的密码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecClassCertificate&lt;/td&gt;
      &lt;td&gt;加密证书&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecClassKey&lt;/td&gt;
      &lt;td&gt;加密密钥&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecClassIdentity&lt;/td&gt;
      &lt;td&gt;一个密钥对（包括公共证书和私钥）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;icloud同步&quot;&gt;iCloud同步&lt;/h3&gt;

&lt;p&gt;这是iOS7引入的一种新机制，可以把钥匙串项目同步到iCloud，允许用户在多个设备之间共享钥匙串项目。&lt;/p&gt;

&lt;p&gt;默认情况下，应用程序创建的钥匙串项目会禁用这个机制，但可以把&lt;code class=&quot;highlighter-rouge&quot;&gt;kSecAttrSynchronizable&lt;/code&gt;设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;来启用。&lt;/p&gt;

&lt;p&gt;另外请注意，使用此选项时无法指定不兼容的kSecAttrAccessible属性。例如，指定kSecAttrAccessibleWhenUnlockedThisDeviceOnly不起作用，因为ThisDeviceOnly指定的项目不会备份，也不能同步到iCloud、笔记本电脑、台式机或其他同步位置。&lt;/p&gt;

&lt;h2 id=&quot;数据保护&quot;&gt;数据保护&lt;/h2&gt;

&lt;p&gt;Apple 推出了数据保护API作为额外的保护层，它允许开发者指定文件解密密钥的生命周期。可以使用这个API控制文件的访问权限，与钥匙串项目中的kSecAttrAccessible 属性类似。&lt;/p&gt;

&lt;p&gt;数据保护API使用用户密码和层级密钥来加密保护文件的密钥，而当这些文件不能被访问时，会从内存中删除这个层级密钥。&lt;/p&gt;

&lt;h3 id=&quot;文件保护过程&quot;&gt;文件保护过程&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios_data_protection_2.png&quot; alt=&quot;文件保护过程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1.文件生成一个&lt;code class=&quot;highlighter-rouge&quot;&gt;文件密钥&lt;/code&gt;来加密文件的内容。&lt;/p&gt;

&lt;p&gt;2.生成一个额外的密钥对，用于生成&lt;code class=&quot;highlighter-rouge&quot;&gt;文件公钥&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;文件私钥&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;3.用&lt;code class=&quot;highlighter-rouge&quot;&gt;文件私钥&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Protected Unless Open等级公钥&lt;/code&gt;计算出一个&lt;code class=&quot;highlighter-rouge&quot;&gt;共享密码&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;4.用&lt;code class=&quot;highlighter-rouge&quot;&gt;共享密码&lt;/code&gt; SHA-1散列值加密文件密钥。&lt;/p&gt;

&lt;p&gt;5.加密过的&lt;code class=&quot;highlighter-rouge&quot;&gt;文件密钥&lt;/code&gt;会存储在文件的元数据中，元数据中还有文件的公钥。&lt;/p&gt;

&lt;p&gt;6.系统丢弃&lt;code class=&quot;highlighter-rouge&quot;&gt;文件私钥&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;7.关闭文件时从内存中删除未加密的文件密钥。&lt;/p&gt;

&lt;p&gt;8.需要再次打开文件时，用&lt;code class=&quot;highlighter-rouge&quot;&gt;Protected Unless Open等级私钥&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;文件公钥&lt;/code&gt;计算&lt;code class=&quot;highlighter-rouge&quot;&gt;共享密码&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;9.计算&lt;code class=&quot;highlighter-rouge&quot;&gt;共享密码&lt;/code&gt;的SHA-1散列值，把它当作解密文件的密钥。&lt;/p&gt;

&lt;h3 id=&quot;dataprotectionclass-权限&quot;&gt;DataProtectionClass 权限&lt;/h3&gt;

&lt;p&gt;如果你的应用在设备进入后台或锁定时不需要写入或读取文件，那你就可以在工程中配置一个&lt;code class=&quot;highlighter-rouge&quot;&gt;NSFileProtectionComplete&lt;/code&gt;值来添加权限。这将确保所有受保护的文件数据只能在设备解锁时访问，相当于为所有的应用文件都设置&lt;code class=&quot;highlighter-rouge&quot;&gt;kSecAttrAccessibleWhenUnlocked&lt;/code&gt;选项。&lt;/p&gt;

&lt;p&gt;从Xcode5开始，新工程会默认启用数据保护权限，但是一些旧工程并不会自动开启。&lt;/p&gt;

&lt;p&gt;开启方式如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios_data_protection_1.png?imageView2/2/w/800&quot; alt=&quot;开启DataProtectionClass权限&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用范例-1&quot;&gt;使用范例&lt;/h3&gt;

&lt;h4 id=&quot;nsdatawritingfileprotectioncomplete&quot;&gt;NSDataWritingFileProtectionComplete&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSData *data = [self generateData];
NSError *error = nil;
NSString *path = [NSString stringWithFormat:@&quot;%@_demo.pdf&quot;, NSTemporaryDirectory()];
[data writeToFile:path options:NSDataWritingFileProtectionComplete error:&amp;amp;error];
if (error) {
	NSLog(@&quot;%@&quot;, error);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;nsfileprotectioncomplete&quot;&gt;NSFileProtectionComplete&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@&quot;demo.txt&quot;];
NSError *error = nil;
NSDictionary *attr = [NSDictionary dictionaryWithObject:NSFileProtectionComplete forKey:NSFileProtectionKey];
[[NSFileManager defaultManager] setAttributes:attr ofItemAtPath:path error:&amp;amp;error];
if (error) {
	NSLog(@&quot;%@&quot;, error);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;sqlite_open_fileprotection_completeunlessopen&quot;&gt;SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@&quot;demo.sqlite&quot;];
sqlite3 *handle = NULL;
sqlite3_open_v2([path UTF8String],
                &amp;amp;handle,
                SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE | SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN,
                NULL);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;保护等级&quot;&gt;保护等级&lt;/h3&gt;

&lt;h4 id=&quot;completeuntilfirstuserauthentication&quot;&gt;CompleteUntilFirstUserAuthentication&lt;/h4&gt;

&lt;p&gt;这个保护等级是iOS5开始使用的默认值。主要用来防御一些需要重启的攻击。&lt;/p&gt;

&lt;h4 id=&quot;complete&quot;&gt;Complete&lt;/h4&gt;

&lt;p&gt;官方称这是目前最安全的文件保护等级。在这种情况下，锁屏之后系统就会删除内存中的层级密钥，并把文件改为不可读。&lt;/p&gt;

&lt;p&gt;具体使用的范例前文可见。&lt;/p&gt;

&lt;p&gt;使用Complete保护之前，考虑是否合适。如果你的应用进程需要持续写/读一个文件，那这种保护模式就不合适了。&lt;/p&gt;

&lt;h4 id=&quot;completeunlessopen&quot;&gt;CompleteUnlessOpen&lt;/h4&gt;

&lt;p&gt;如果一个文件当前被一个应用打开，那会暂时禁用该文件的保护。它会确保打开的文件在设备被锁定时依然能够写入，并且允许新建文件到磁盘。不过这个等级保护的文件在锁屏时无法打开，除非锁屏时就已经提前打开。&lt;/p&gt;

&lt;h2 id=&quot;commoncrypto加密&quot;&gt;CommonCrypto加密&lt;/h2&gt;

&lt;p&gt;CommonCrypto是Apple官方提供的一套加密框架。在使用这套方案时，主要注意以下几个问题即可。&lt;/p&gt;

&lt;h3 id=&quot;避免弱算法&quot;&gt;避免弱算法&lt;/h3&gt;

&lt;p&gt;众所周知，DES就是一种很典型的弱算法。如果你使用弱算法，那应用就很容易遭受密码攻击和暴力破解。&lt;/p&gt;

&lt;p&gt;我们在实际使用时，可以考虑使用AES算法、MD5算法或MD5加盐算法等。&lt;/p&gt;

&lt;h3 id=&quot;破碎的熵&quot;&gt;破碎的熵&lt;/h3&gt;

&lt;p&gt;我们通常会使用&lt;code class=&quot;highlighter-rouge&quot;&gt;rand&lt;/code&gt;方法来产生随机数，但是系统的这个随机函数并不是真正的随机。它产生的随机数符合正态分布，我们可以使用官方提供的方法&lt;code class=&quot;highlighter-rouge&quot;&gt;SecRandomCopyBytes&lt;/code&gt;获得。也可以自己使用算法产生随机数。&lt;/p&gt;

&lt;p&gt;这里分享一个笔者以前自己实现的随机数案例。&lt;a href=&quot;/2016/04/30/uniform-random/&quot;&gt;《均匀分布随机函数的实现》&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;弱密钥&quot;&gt;弱密钥&lt;/h3&gt;

&lt;p&gt;开发者经常将用户的密码当作加密密钥，尤其在移动设备上，这将导致一个非常脆弱、低熵加密的密钥。&lt;/p&gt;

&lt;p&gt;那么正确的姿势是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;CCKeyDerivationPBKDF&lt;/code&gt;方法来生成。&lt;/p&gt;

&lt;h2 id=&quot;touch-id&quot;&gt;Touch ID&lt;/h2&gt;

&lt;h3 id=&quot;使用范例-2&quot;&gt;使用范例&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;LocalAuthentication/LocalAuthentication.h&amp;gt;

LAContext *context = [[LAContext alloc] init];
NSError *error = nil;
NSString *reason = @&quot;We use this to verify your identify&quot;;
if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;amp;error]) {
	[context evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:reason reply:^(BOOL success, NSError * _Nullable error) {
		if (success) {
			NSLog(@&quot;Hello, that's your finger!&quot;);
		} else {
			NSLog(@&quot;Couldn't read your fingerprint. Falling back to PIN or somthing.&quot;);
		}
	}];
} else {
	NSLog(@&quot;Error : %@ %@&quot;, error, [error userInfo]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;touch-id-与普通密码相比的安全性&quot;&gt;Touch ID 与普通密码相比的安全性&lt;/h3&gt;

&lt;p&gt;一个人的指纹是世界上最好的密码之一。它独一无二，高度特异，并且无需记忆。它会伴随人终生，所以你可以一直使用同一个指纹密码。&lt;/p&gt;

&lt;p&gt;比起简单的4位数字锁屏密码一万分之一的破解可能性，能找到同样单个指纹的人的概率为五万分之一，这是非常安全的，比起前者我可以不断尝试，Touch ID 指纹的硬性破解几率几乎没有，因为不可能有五万多个人排队来一一解锁你的设备，况且 Touch ID 会拒绝第五次以后的尝试而要求输入密码。所以我们可以添加更加复杂的密码而不是简单的数字密码来进一步提高安全性。&lt;/p&gt;

&lt;h3 id=&quot;touch-id-指纹识别的原理&quot;&gt;Touch ID 指纹识别的原理&lt;/h3&gt;

&lt;p&gt;在如此快速的识别过程中，Home 按钮上的一圈金属环起到了感应手指的功能，通知 Touch ID 来读取指纹。Touch ID 置于该按钮中，传感器的厚度只有 170 微米，拥有 500 ppi 高分辨率，可读取极小的指纹细节。传感器可从皮肤皮下层指纹的一些小部分拍摄高分辨率图像，然后会分析该信息，根据三种基本指纹类型（弧形纹、箕形纹或斗形纹）将指纹分类，它会绘制比人眼不可见的纹路细节，确保指纹读取准确无误。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios_data_protection_3.png&quot; alt=&quot;touch id sensor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Touch ID 可从 360 度方向读取指纹，随后创建指纹的某种数学表达式，并将其与已注册的数据进行比较，以确定是否匹配。如果匹配，便可替代密码来解锁设备或通过某个令牌。&lt;/p&gt;

&lt;p&gt;此外，根据苹果官方的描述，Touch ID 会向以注册的指纹数据里持续的添加新的特征数据，随着时间的推移，这能不断提高匹配准确度，也能进一步的提高安全性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios_data_protection_4.png&quot; alt=&quot;touch id ontouch&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除了上述的内容，苹果还加入可以一些有效的手段来进一步确保安全，例如设备再重新启动或者保持锁定 48 小时后，就只能通过密码而不是指纹来解锁设备。&lt;/p&gt;

&lt;h3 id=&quot;secure-enclave&quot;&gt;Secure Enclave&lt;/h3&gt;

&lt;p&gt;Apple声明指纹的图案不会被保存，存储于设备中的是指纹特征的数学表达式，而且从这些表达式不可能直接反推出指纹图像。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios_data_protection_5.png&quot; alt=&quot;touch-id-structure&quot; /&gt;&lt;/p&gt;

&lt;p&gt;指纹的验证运算独立于主要处理器芯片（例如 A7、A8），芯片内有称为 “Secure Enclave” 的高级安全架构，专用于密码指纹数据，并使用 Secure Enclave 的专用密钥加密，以及每次启动以随机的 UID 进行管理。指纹数据仅能被 Secure Enclave 处理和使用，正因为此架构独立于其它设备部件，仅有 Touch ID 使用它，且不能将它用于匹配其他指纹数据库，所以存储的指纹数据不会由 iOS 或其他应用访问，也不会被存储到 Apple 服务器或备份到 iCloud 等地方。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios_data_protection_6.png&quot; alt=&quot;A7-Secure-Enclave&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从硬件上来看指纹特征数据尚不能被 “Secure Enclave” 和 Touch ID 以外的部件访问到，并且两者芯片互相隔离开来，所有软件都没有权利获得指纹数据，仅能得到指纹是否错误的回馈。因为架构的核心秘密仅仅只有苹果公司知道，所以目前几乎没有第三方软件可以访问到这部分敏感信息。&lt;/p&gt;

&lt;p&gt;到此，关于 iOS 数据保护的问题暂时告一段落。欢迎大家评论指正。&lt;/p&gt;
</description>
        <pubDate>Tue, 17 Oct 2017 23:18:19 +0800</pubDate>
      </item>
    
      <item>
        <title>MacOS 搭建 Tensorflow PyCharm 环境</title>
        <link>/ml/2017/09/26/tensorflow-pycharm-mac.html</link>
        <guid isPermaLink="true">/ml/2017/09/26/tensorflow-pycharm-mac.html</guid>
        <description>&lt;p&gt;TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。目前来说，&lt;a href=&quot;https://github.com/tensorflow/tensorflow&quot;&gt;Github&lt;/a&gt;上star最多的项目就是它了。&lt;/p&gt;

&lt;p&gt;在这之前，笔者写过一篇简单的入门文章&lt;a href=&quot;/2017/06/07/tensorflow-primer-guide/&quot;&gt;《初探 TensorFlow》&lt;/a&gt;。当时没能成功搭建环境，加上后期的工作原因，至此搁置了一段时间。今天，终于各种折腾，在自己的Mac上经过多种尝试之后，完美搭建成功。这里就把它分享出来，希望对大家有所帮助。&lt;/p&gt;

&lt;h2 id=&quot;基于-anaconda-的安装&quot;&gt;基于 Anaconda 的安装&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.anaconda.com/&quot;&gt;Anaconda&lt;/a&gt; 是一个集成许多第三方科学计算库的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Python&lt;/code&gt; 科学计算环境,&lt;code class=&quot;highlighter-rouge&quot;&gt;Anaconda&lt;/code&gt; 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;conda&lt;/code&gt; 作为自己的包管理工具,同时具有自己的计算环境,类似 &lt;code class=&quot;highlighter-rouge&quot;&gt;Virtualenv&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;和 &lt;code class=&quot;highlighter-rouge&quot;&gt;Virtualenv&lt;/code&gt; 一样,不同 &lt;code class=&quot;highlighter-rouge&quot;&gt;Python&lt;/code&gt; 工程需要的依赖包,&lt;code class=&quot;highlighter-rouge&quot;&gt;conda&lt;/code&gt; 将他们存储在不同的地方。 &lt;code class=&quot;highlighter-rouge&quot;&gt;TensorFlow&lt;/code&gt; 上安装的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Anaconda&lt;/code&gt; 不会对之前安装的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Python&lt;/code&gt; 包进行覆盖.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;安装 &lt;a href=&quot;https://www.anaconda.com/download/&quot;&gt;Anaconda&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;建立一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;conda&lt;/code&gt; 计算环境&lt;/li&gt;
  &lt;li&gt;激活环境,使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;conda&lt;/code&gt; 安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;TensorFlow&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;安装成功后,每次使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;TensorFlow&lt;/code&gt; 的时候需要激活 &lt;code class=&quot;highlighter-rouge&quot;&gt;conda&lt;/code&gt; 环境&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;安装-anaconda-&quot;&gt;安装 Anaconda :&lt;/h3&gt;

&lt;p&gt;参考 Anaconda 的下载页面的&lt;a href=&quot;https://www.anaconda.com/download/&quot;&gt;指导&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;建立环境&quot;&gt;建立环境&lt;/h3&gt;

&lt;p&gt;建立一个 conda 计算环境名字叫&lt;code class=&quot;highlighter-rouge&quot;&gt;tensorflow&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Python 2.7
$ conda create -n tensorflow python=2.7

# Python 3.4
$ conda create -n tensorflow python=3.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;激活&quot;&gt;激活&lt;/h3&gt;

&lt;p&gt;激活&lt;code class=&quot;highlighter-rouge&quot;&gt;tensorflow&lt;/code&gt;环境,然后使用其中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;pip&lt;/code&gt; 安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;TensorFlow&lt;/code&gt;. 当使用&lt;code class=&quot;highlighter-rouge&quot;&gt;easy_install&lt;/code&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;--ignore-installed&lt;/code&gt;标记防止错误的产生。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/install/install_mac#the_url_of_the_tensorflow_python_package&quot;&gt;URL of the TensorFlow Python package&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ source activate tensorflow
(tensorflow)$  # Your prompt should change

# Ubuntu/Linux 64-bit, CPU only, Python 2.7:
(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl

# Ubuntu/Linux 64-bit, GPU enabled, Python 2.7. Requires CUDA toolkit 7.5 and CuDNN v4.
# For other versions, see &quot;Install from sources&quot; below.
(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl

# Mac OS X, CPU only:
(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-0.11.0rc0-py2-none-any.whl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于 Python 3.x :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ source activate tensorflow
(tensorflow)$  # Your prompt should change

# Ubuntu/Linux 64-bit, CPU only, Python 3.4:
(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl

# Ubuntu/Linux 64-bit, GPU enabled, Python 3.4. Requires CUDA toolkit 7.5 and CuDNN v4.
# For other versions, see &quot;Install from sources&quot; below.
(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl

# Mac OS X, CPU only:
(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0rc0-py3-none-any.whl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;conda 环境激活后,你可以测试:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python
&amp;gt;&amp;gt;&amp;gt; import tensorflow as tf
&amp;gt;&amp;gt;&amp;gt; print(tf.__version__)
# 0.11.0rc0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;开启或关闭环境&quot;&gt;开启或关闭环境&lt;/h3&gt;

&lt;p&gt;当你不用 TensorFlow 的时候,关闭环境:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(tensorflow)$ source deactivate

$  # Your prompt should change back
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再次使用的时候再激活 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ source activate tensorflow
(tensorflow)$  # Your prompt should change.
# Run Python programs that use TensorFlow.
...
# When you are done using TensorFlow, deactivate the environment.
(tensorflow)$ source deactivate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;pycharm-配置&quot;&gt;PyCharm 配置&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;重点：&lt;/strong&gt;正确配置&lt;code class=&quot;highlighter-rouge&quot;&gt;Project&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Interpreter&lt;/code&gt;即可&lt;/p&gt;

&lt;h3 id=&quot;方法&quot;&gt;方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Preferences&lt;/li&gt;
  &lt;li&gt;Project Interpreter&lt;/li&gt;
  &lt;li&gt;Click More&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;附图&quot;&gt;附图&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;打开Preferences&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/tensorflow_pycharm_config_mac_1.png&quot; alt=&quot;打开Preferences&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/tensorflow_pycharm_config_mac_2.png&quot; alt=&quot;选择more&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;打开Project Interpreters&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/tensorflow_pycharm_config_mac_3.png&quot; alt=&quot;选择正确的tensorflow路径&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Demo运行结果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/tensorflow_pycharm_config_mac_4.png&quot; alt=&quot;demo运行结果&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 26 Sep 2017 23:03:16 +0800</pubDate>
      </item>
    
      <item>
        <title>iOS App 启动性能优化</title>
        <link>/pieces/2017/09/22/ios-app-launch-time-optimize.html</link>
        <guid isPermaLink="true">/pieces/2017/09/22/ios-app-launch-time-optimize.html</guid>
        <description>&lt;p&gt;应用启动时间，直接影响用户对一款应用的判断和使用体验。&lt;code class=&quot;highlighter-rouge&quot;&gt;ZAKER新闻&lt;/code&gt;本身就包含非常多并且复杂度高的业务模块（如新闻、视频等），也接入了很多第三方的插件，这势必会拖慢应用的启动时间，本着精益求精的态度和对用户体验的追求，我们希望在业务扩张的同时最大程度的优化启动时间。&lt;/p&gt;

&lt;h2 id=&quot;启动时间&quot;&gt;启动时间&lt;/h2&gt;

&lt;p&gt;总时间 = T1 + T2&lt;/p&gt;

&lt;h3 id=&quot;t1&quot;&gt;T1&lt;/h3&gt;

&lt;p&gt;加载&lt;code class=&quot;highlighter-rouge&quot;&gt;系统dylib&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;可执行文件&lt;/code&gt;的时间。&lt;/p&gt;

&lt;h3 id=&quot;t2&quot;&gt;T2&lt;/h3&gt;

&lt;p&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;applicationWillFinishLaunching&lt;/code&gt;结束的时间。&lt;/p&gt;

&lt;h2 id=&quot;app启动过程&quot;&gt;App启动过程&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-app-launch-time-optimize-1.png&quot; alt=&quot;App启动过程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1）解析&lt;code class=&quot;highlighter-rouge&quot;&gt;Info.plist&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;加载相关信息，例如如闪屏&lt;/li&gt;
  &lt;li&gt;沙箱建立、权限检查&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2）&lt;code class=&quot;highlighter-rouge&quot;&gt;Mach-O&lt;/code&gt;加载&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果是胖二进制文件，寻找合适当前CPU类别的部分&lt;/li&gt;
  &lt;li&gt;加载所有依赖的&lt;code class=&quot;highlighter-rouge&quot;&gt;Mach-O&lt;/code&gt;文件（递归调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Mach-O&lt;/code&gt;加载的方法）&lt;/li&gt;
  &lt;li&gt;定位内部、外部指针引用，例如字符串、函数等&lt;/li&gt;
  &lt;li&gt;执行声明为&lt;code class=&quot;highlighter-rouge&quot;&gt;__attribute__((constructor))&lt;/code&gt;的C函数&lt;/li&gt;
  &lt;li&gt;加载类扩展（Category）中的方法&lt;/li&gt;
  &lt;li&gt;C++静态对象加载、调用ObjC的&lt;code class=&quot;highlighter-rouge&quot;&gt; +load &lt;/code&gt;函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3）程序执行&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;UIApplicationMain()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;applicationWillFinishLaunching&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mach-o&quot;&gt;Mach-O&lt;/h3&gt;

&lt;p&gt;Mach-O 是针对不同运行时可执行文件的文件类型。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-app-launch-time-optimize-4.png&quot; alt=&quot;Mach-O&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;文件类型&quot;&gt;文件类型：&lt;/h4&gt;

&lt;p&gt;Executable： 应用的主要二进制&lt;/p&gt;

&lt;p&gt;Dylib： 动态链接库（又称 DSO 或 DLL）&lt;/p&gt;

&lt;p&gt;Bundle： 不能被链接的 Dylib，只能在运行时使用 dlopen() 加载，可当做 macOS 的插件。&lt;/p&gt;

&lt;p&gt;Image： executable，dylib 或 bundle&lt;/p&gt;

&lt;p&gt;Framework： 包含 Dylib 以及资源文件和头文件的文件夹&lt;/p&gt;

&lt;h3 id=&quot;mach-o-镜像文件&quot;&gt;Mach-O 镜像文件&lt;/h3&gt;

&lt;p&gt;Mach-O 被划分成一些 segement，每个 segement 又被划分成一些 section。&lt;/p&gt;

&lt;p&gt;segment 的名字都是大写的，且空间大小为页的整数。页的大小跟硬件有关，在 arm64 架构一页是 16KB，其余为 4KB。&lt;/p&gt;

&lt;p&gt;section 虽然没有整数倍页大小的限制，但是 section 之间不会有重叠。&lt;/p&gt;

&lt;p&gt;几乎所有 Mach-O 都包含这三个段（segment）： &lt;code class=&quot;highlighter-rouge&quot;&gt;__TEXT&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;__LINKEDIT&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__TEXT&lt;/code&gt; 包含 Mach header，被执行的代码和只读常量（如C 字符串）。只读可执行（r-x）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA&lt;/code&gt; 包含全局变量，静态变量等。可读写（rw-）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__LINKEDIT&lt;/code&gt; 包含了加载程序的『元数据』，比如函数的名称和地址。只读（r–）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mach-o-universal-文件&quot;&gt;Mach-O Universal 文件&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Fat_binary&quot;&gt;FAT 二进制&lt;/a&gt;文件，将多种架构的 Mach-O 文件合并而成。它通过 Fat Header 来记录不同架构在文件中的偏移量，Fat Header 占一页的空间。&lt;/p&gt;

&lt;p&gt;按分页来存储这些 segement 和 header 会浪费空间，但这有利于虚拟内存的实现。&lt;/p&gt;

&lt;h3 id=&quot;什么是image&quot;&gt;什么是image&lt;/h3&gt;

&lt;p&gt;1.executable可执行文件 比如.o文件。&lt;/p&gt;

&lt;p&gt;2.dylib 动态链接库 framework就是动态链接库和相应资源包含在一起的一个文件夹结构。&lt;/p&gt;

&lt;p&gt;3.bundle 资源文件 只能用dlopen加载，不推荐使用这种方式加载。&lt;/p&gt;

&lt;p&gt;除了我们App本身的可行性文件，系统中所有的framework比如UIKit、Foundation等都是以动态链接库的方式集成进App中的。&lt;/p&gt;

&lt;h3 id=&quot;什么是imageloader&quot;&gt;什么是ImageLoader&lt;/h3&gt;

&lt;p&gt;image 表示一个二进制文件(可执行文件或 so 文件)，里面是被编译过的符号、代码等，所以 ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。&lt;/p&gt;

&lt;p&gt;两步走：在程序运行时它先将动态链接的 image 递归加载 (也就是上面测试栈中一串的递归调用的时刻)。 再从可执行文件 image 递归加载所有符号。&lt;/p&gt;

&lt;h2 id=&quot;冷启动和热启动&quot;&gt;冷启动和热启动&lt;/h2&gt;

&lt;h3 id=&quot;冷启动&quot;&gt;冷启动&lt;/h3&gt;

&lt;p&gt;应用首次启动。即后台线程中未有当前打开的应用，所有的资源都需要加载并初始化。&lt;/p&gt;

&lt;h3 id=&quot;热启动&quot;&gt;热启动&lt;/h3&gt;

&lt;p&gt;应用非首次启动。即后台线程中保留有当前应用，应用的资源在内存中有保存。&lt;/p&gt;

&lt;h2 id=&quot;启动时间分析&quot;&gt;启动时间分析&lt;/h2&gt;

&lt;p&gt;1）开启时间分析功能&lt;/p&gt;

&lt;p&gt;在Xcode的菜单中选择&lt;code class=&quot;highlighter-rouge&quot;&gt;Project&lt;/code&gt;→&lt;code class=&quot;highlighter-rouge&quot;&gt;Scheme&lt;/code&gt;→&lt;code class=&quot;highlighter-rouge&quot;&gt;Edit Scheme...&lt;/code&gt;，然后找到&lt;code class=&quot;highlighter-rouge&quot;&gt; Run&lt;/code&gt; → &lt;code class=&quot;highlighter-rouge&quot;&gt;Environment Variables&lt;/code&gt; →&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;，添加&lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;DYLD_PRINT_STATISTICSvalue&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;的环境变量。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-app-launch-time-optimize-2.png&quot; alt=&quot;开启时间分析功能&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-app-launch-time-optimize-3.png&quot; alt=&quot;启动时间&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;load-dylibs-image&quot;&gt;load dylibs image&lt;/h3&gt;

&lt;p&gt;在每个动态库的加载过程中， dyld需要：&lt;/p&gt;

&lt;p&gt;1.分析所依赖的动态库&lt;/p&gt;

&lt;p&gt;2.找到动态库的mach-o文件&lt;/p&gt;

&lt;p&gt;3.打开文件&lt;/p&gt;

&lt;p&gt;4.验证文件&lt;/p&gt;

&lt;p&gt;5.在系统核心注册文件签名&lt;/p&gt;

&lt;p&gt;6.对动态库的每一个segment调用mmap()&lt;/p&gt;

&lt;p&gt;通常的，一个App需要加载100到400个dylibs， 但是其中的系统库被优化，可以很快的加载。 针对这一步骤的优化有：&lt;/p&gt;

&lt;p&gt;1.减少非系统库的依赖&lt;/p&gt;

&lt;p&gt;2.合并非系统库&lt;/p&gt;

&lt;p&gt;3.使用静态资源，比如把代码加入主程序&lt;/p&gt;

&lt;h3 id=&quot;rebasebind&quot;&gt;rebase/bind&lt;/h3&gt;

&lt;p&gt;由于ASLR(address space layout randomization)的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这2步来修复镜像中的资源指针，来指向正确的地址。 rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。&lt;/p&gt;

&lt;p&gt;rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。&lt;/p&gt;

&lt;p&gt;优化该阶段的关键在于减少__DATA segment中的指针数量。我们可以优化的点有：&lt;/p&gt;

&lt;p&gt;1.减少Objc类数量， 减少selector数量&lt;/p&gt;

&lt;p&gt;2.减少C++虚函数数量&lt;/p&gt;

&lt;p&gt;3.转而使用swift stuct（其实本质上就是为了减少符号的数量）&lt;/p&gt;

&lt;h3 id=&quot;解读&quot;&gt;解读&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数之前总共使用了506.48ms&lt;/li&gt;
  &lt;li&gt;在506.48ms中，加载动态库用了46.35ms，指针重定位使用了137.72ms，ObjC类初始化使用了95.39ms，各种初始化使用了226.92ms。&lt;/li&gt;
  &lt;li&gt;在初始化耗费的226.92ms中，用时最多的几个初始化是&lt;code class=&quot;highlighter-rouge&quot;&gt;libSystem.B.dylib&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;libBacktraceRecording.dylib&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;libglInterpose.dylib&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;libMTLInterpose.dylib&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2）使用instruments工作分析具体时间消耗点&lt;/p&gt;

&lt;h2 id=&quot;耗时的影响因素&quot;&gt;耗时的影响因素&lt;/h2&gt;

&lt;p&gt;1） &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数之前耗时的影响因素&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;动态库加载越多，启动越慢。&lt;/li&gt;
  &lt;li&gt;ObjC类越多，启动越慢&lt;/li&gt;
  &lt;li&gt;C的&lt;code class=&quot;highlighter-rouge&quot;&gt;constructor&lt;/code&gt;函数越多，启动越慢&lt;/li&gt;
  &lt;li&gt;C++静态对象越多，启动越慢&lt;/li&gt;
  &lt;li&gt;ObjC的&lt;code class=&quot;highlighter-rouge&quot;&gt;+load&lt;/code&gt;越多，启动越慢&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实验证明，在ObjC类的数目一样多的情况下，需要加载的动态库越多，App启动就越慢。同样的，在动态库一样多的情况下，ObjC的类越多，App的启动也越慢。需要加载的动态库从1个上升到10个的时候，用户几乎感知不到任何分别，但从10个上升到100个的时候就会变得十分明显。同理，100个类和1000个类，可能也很难查察觉得出，但1000个类和10000个类的分别就开始明显起来。&lt;/p&gt;

&lt;p&gt;同样的，尽量不要写&lt;code class=&quot;highlighter-rouge&quot;&gt;__attribute__((constructor))&lt;/code&gt;的C函数，也尽量不要用到C++的静态对象；至于ObjC的&lt;code class=&quot;highlighter-rouge&quot;&gt;+load&lt;/code&gt;方法，似乎大家已经习惯不用它了。任何情况下，能用&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_once()&lt;/code&gt;来完成的，就尽量不要用到以上的方法。&lt;/p&gt;

&lt;p&gt;2） &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数之后耗时的影响因素&lt;/p&gt;

&lt;p&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数开始至&lt;code class=&quot;highlighter-rouge&quot;&gt;applicationWillFinishLaunching&lt;/code&gt;结束，我们统一称为&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数之后的部分。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数的耗时&lt;/li&gt;
  &lt;li&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;applicationWillFinishLaunching&lt;/code&gt;的耗时&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rootViewController&lt;/code&gt;及其&lt;code class=&quot;highlighter-rouge&quot;&gt;childViewController&lt;/code&gt;的加载、&lt;code class=&quot;highlighter-rouge&quot;&gt;view&lt;/code&gt;及其&lt;code class=&quot;highlighter-rouge&quot;&gt;subviews&lt;/code&gt;的加载&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;实践&quot;&gt;实践&lt;/h2&gt;

&lt;h3 id=&quot;移除不需要用到的类&quot;&gt;移除不需要用到的类&lt;/h3&gt;

&lt;p&gt;为了解决这个历史问题，我使用了一个叫做&lt;a href=&quot;https://github.com/dblock/fui&quot;&gt;fui（Find Unused Imports）&lt;/a&gt;的开源项目，它能很好的分析出不再使用的类，准确率非常高，唯一的问题是它处理不了动态库和静态库里提供的类，也处理不了C++的类模板。&lt;/p&gt;

&lt;p&gt;使用方法是在&lt;code class=&quot;highlighter-rouge&quot;&gt;Terminal&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt;到项目所在的目录，然后执行&lt;code class=&quot;highlighter-rouge&quot;&gt;fui find&lt;/code&gt;，然后等上那么几分钟（是的你没有看错，真的需要好几分钟甚至需要更长的时间），就可以得到一个列表了。由于这个工具还不是100%靠谱，可根据这个列表，在Xcode中手动检查并删除不再用到的类。&lt;/p&gt;

&lt;h3 id=&quot;合并功能类似的类和扩展category&quot;&gt;合并功能类似的类和扩展（Category）&lt;/h3&gt;

&lt;h3 id=&quot;优化applicationdidfinishlaunchingwithoptions方法&quot;&gt;优化&lt;code class=&quot;highlighter-rouge&quot;&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt;方法&lt;/h3&gt;

&lt;h3 id=&quot;优化rootviewcontroller加载&quot;&gt;优化&lt;code class=&quot;highlighter-rouge&quot;&gt;rootViewController&lt;/code&gt;加载&lt;/h3&gt;

&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;

&lt;p&gt;1）&lt;code class=&quot;highlighter-rouge&quot;&gt;NSUserDefaults&lt;/code&gt;是否是瓶颈&lt;/p&gt;

&lt;p&gt;2）还有其他哪些点可以做优化&lt;/p&gt;

&lt;p&gt;参考文档：&lt;a href=&quot;http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/&quot;&gt;《优化 App 的启动时间》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 22 Sep 2017 22:02:16 +0800</pubDate>
      </item>
    
      <item>
        <title>那些设计iOS API需要知道的事</title>
        <link>/pieces/2017/07/10/ios-design-api-guide.html</link>
        <guid isPermaLink="true">/pieces/2017/07/10/ios-design-api-guide.html</guid>
        <description>&lt;p&gt;为了能够将我们项目中的代码能够在后续开发者使用（重用代码），通常使用的方法是将代码按照功能模块编写成API。那么我们就很有必要了解Objective-C语言中常见的编程范式（paradigm），同时还需了解各种可能碰到的陷阱。&lt;/p&gt;

&lt;h2 id=&quot;命名&quot;&gt;命名&lt;/h2&gt;

&lt;h3 id=&quot;命名冲突的问题&quot;&gt;命名冲突的问题&lt;/h3&gt;

&lt;p&gt;Objective-C没有其他语言的那种内置命名空间（namespace）机制。因此，我们只能自己想办法来解决命名冲突问题。最常用的解决方式就是，仿照其他语言（C++）建立自己的namespace，例如，使用前缀。&lt;/p&gt;

&lt;p&gt;所选前缀可以是与公司、应用程序或二者皆有关联之名。例如，ZAKER User Interface可以使用ZUI作为前缀。使用Cocoa创建应用程序时一定要注意，Apple宣称其保留使用所有“两字母前缀”(two-letter prefix)的权利，所以开发者选用的前缀应该是三个字母的。如果开发者使用了两个字母作前缀，那么很有可能开发者自定义的API和Apple的API冲突。&lt;/p&gt;

&lt;p&gt;不仅仅是类名，应用程序中的所有名称都应该加前缀。如果要为既有类新增“分类”(category)，那么一定要给“分类”及“分类”中的方法加上前缀。另外，类的实现文件中所用的纯C函数及全局变量也应该注意添加前缀。&lt;/p&gt;

&lt;p&gt;如果使用了第三方库编写自己的代码，并准备将其发布为程序库供他人开发应用程序所用，则尤其要注意重复符号问题。这种情况下为了避免使用者使用了与你相同的第三方库，应该为第三方库都加上你自己的前缀。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-design-api-guide-1.png?imageView/2/w/400&quot; alt=&quot;第三方库引入使用前缀&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;命名方式&quot;&gt;命名方式&lt;/h3&gt;

&lt;p&gt;类、方法和变量的命名是Objective-C编程的重要环节。如果命名方式好，可以提高代码可读性，减少不必要的注释。
初学者通常会觉得Objective-C是门很繁琐的语言，因为其语法结构使得代码读起来和句子一样。命名中一般都带有“in”、“for”、“with”等介词，特别是在命名时还要讲究英文语法。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *text = @&quot;This is a good idea.&quot;;
NSString *newText = [text stringByReplacingOccurrencesOfString:@&quot;idea&quot; withString:@&quot;think&quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码虽然用了比较啰嗦的方式描述一个看上去很简单的表达式。对于执行替换的那个方法，代码读起来就像日常语言里的那个句子：“Take text and give me a new string by replacing the occurrences of the string ‘idea’ with the string ‘think’”。
这个句子准确描述了开发者想做的事。在命名不像Objective-C这般繁琐的语言中，类似的程序可能会写成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;string text = &quot;This is a good idea.&quot;;
string new Text = text.replace(&quot;idea&quot;, &quot;think&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码这样写，看起来方法名简洁很多，但是带来的代码不可读性却是非常大的。首先，我们不知道 text.replace 方法的两个参数到底按照什么顺序解读（除非查看方法声明）；再者，这两个参数谁替换谁？&lt;/p&gt;

&lt;p&gt;另外，和大多数语言一样，Objective-C也是采用“驼峰式大小写命名法”（camel casing）——以小写字母开头，其后每个单词首字母大写。&lt;/p&gt;

&lt;h4 id=&quot;方法命名&quot;&gt;方法命名&lt;/h4&gt;

&lt;p&gt;清晰的方法名从左至右读起来好似一段文章。并不是说非得按照那些命名规则来给方法起名，不过这样做可以令代码变得更好维护，使他人更容易读懂。
虽然类似C++或Java中那种函数命名简单，但是，若想知道每个参数的用途，就得查看函数原型，这会令代码难于读懂。
NSString这个类展示了一套良好的命名习惯。下面列举几个方法及命名缘由：&lt;/p&gt;

&lt;p&gt;1）&lt;code class=&quot;highlighter-rouge&quot;&gt;+ (instancetype)string;&lt;/code&gt;
工厂方法（factory method），用于创建新的空字符串。方法名清晰地描述了返回值的类型。&lt;/p&gt;

&lt;p&gt;2）&lt;code class=&quot;highlighter-rouge&quot;&gt;+ (instancetype)stringWithString:(NSString *)string;&lt;/code&gt;
工厂方法，根据某字符串创建出与之内容相同的新字符串。与创建空字符串所用的那个工厂方法一样，方法名的第一个单词也指明了返回类型。&lt;/p&gt;

&lt;p&gt;3）&lt;code class=&quot;highlighter-rouge&quot;&gt;+ (instancetype)localizedStringWithFormat:(NSString *)format, ...;&lt;/code&gt;
工厂方法，根据特定格式创建出新的“本地化字符串”（localized string）。返回值类型是方法名的第二个单词（string），因为其前面还有个修饰语（localized）用来描述其逻辑含义。此方法的返回值依然是“字符串”（string），只不过是一种经过本地化处理的特殊字符串。&lt;/p&gt;

&lt;p&gt;4）&lt;code class=&quot;highlighter-rouge&quot;&gt;- (NSUInteger)lengthOfBytesUsingEncoding:(NSStringEncoding)enc;&lt;/code&gt;
若字符串是以给定的编码格式（ASCII、UTF8、UTF16）来编码的，则返回其字节数组长度。此方法与length相似，但该方法还需一个参数，该参数紧跟着方法名中描述其类型的那个名词（encoding）。&lt;/p&gt;

&lt;p&gt;因此，我们可以总结成几条方法命名规则：&lt;/p&gt;

&lt;p&gt;1）如果方法的返回值是新创建的，那么方法名的首个词应该是返回值的类型，除非前面还有修饰语，例如localizedString。属性的存取方法不遵循这种命名方式，因为一般认为这些方法不会创建新对象。即便有时返回内部对象的一份拷贝，我们也认为那相当于原有对象。这些存取方法应该按照其所对应的属性来命名。&lt;/p&gt;

&lt;p&gt;2）应该把表示参数类型的名词放在参数前面。&lt;/p&gt;

&lt;p&gt;3）如果方法要在当前对象上执行操作，那么就应该包含动词；若执行操作时还需要参数，则应该在动词后面加上一个或多个名词。&lt;/p&gt;

&lt;p&gt;4）不要使用str这种简称，应该使用string这样的全称。&lt;/p&gt;

&lt;p&gt;5）boolean属性应加is前缀。如果某方法返回非属性的boolean值，那么应该根据其功能，选用has或is当前缀。&lt;/p&gt;

&lt;p&gt;6）将get这个前缀留给那些借由“输出参数”来保存返回值的方法，比如说，把返回值填充到“C语言式数组”（C-style array）里的那种方法就可以使用这个词做前缀。&lt;/p&gt;

&lt;h4 id=&quot;类与协议命名&quot;&gt;类与协议命名&lt;/h4&gt;

&lt;p&gt;不仅仅是方法，类和协议也应该加上前缀，避免命名空间冲突。例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;UIView&lt;/li&gt;
  &lt;li&gt;UIViewController&lt;/li&gt;
  &lt;li&gt;UITableViewDelegate&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;错误模型&quot;&gt;错误模型&lt;/h2&gt;

&lt;p&gt;目前有很多编程语言都有“异常”(exception)机制，Objective-C也不例外。&lt;/p&gt;

&lt;p&gt;“自动引用计数”(ARC, Automatic Reference Counting)在默认情况下不是“异常安全的”。这意味着：如果抛出异常，那么本应该在作用域末尾释放的对象现在却不会自动释放了。如果想生成“异常安全”的代码，可以通过设置编译器的标志来实现，不过这将引入额外代码，在不抛出异常时，也照样要执行这部分代码。需要打开的编译器标志叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;-fobjc-arc-exception&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Objective-C现在所采用的办法是：只在极其罕见的情况下抛出异常，异常抛出之后，无须考虑恢复问题，而且应用程序此时也应该退出。这就是说，不用再编写复杂的“异常安全”代码了。&lt;/p&gt;

&lt;p&gt;异常只应该用于极其严重的错误，比如，你编写了某个抽象基类，它的正确用法是先从中继承一个子类，然后使用这个子类。在这种情况下，如果有人直接使用了这个抽象基类，那么可以考虑抛出异常。与其他语言不同，Objective-C中没办法将某个类标识为“抽象类”。要想达成类似效果，最好的办法是在那些子类必须覆写的超类方法里抛出异常。&lt;/p&gt;

&lt;p&gt;异常只用于处理严重错误(fatal error)，对于其他错误，Objective-C语言所用的编程范式为：令方法返回nil/0，或使用NSError，以表明有错误发生。&lt;/p&gt;

&lt;p&gt;NSError对象里封装了三条信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Error domain (错误范围，其类型为字符串)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;错误发生的范围，也就是产生错误的根源，通常用一个特有的全局变量来定义。例如，URL-handling-subsystem，在从URL中解析或获取数据时如果出错了，那么就使用NSURLErrorDomain来表示错误范围。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Error code (错误码，其类型为整数)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;独有的错误码，用以指明在某个范围内具体发生了何种错误。某个特定范围内可能会发生一系列相关错误，这些错误情况通常采用enum来定义。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;User info (用户信息，其类型为字典)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有关此错误的额外信息，其中或许包含一段“本地化描述”，或许还包含有导致该错误发生的另外一个错误，经由此种信息，可将相关错误串成一条“错误链”。&lt;/p&gt;

&lt;h2 id=&quot;使用不可变对象&quot;&gt;使用不可变对象&lt;/h2&gt;

&lt;p&gt;设计类的时候，应充分使用属性来封装数据。而在使用属性时，则可将其声明为&lt;code class=&quot;highlighter-rouge&quot;&gt;readonly&lt;/code&gt;。默认情况下，属性是&lt;code class=&quot;highlighter-rouge&quot;&gt;readwrite&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;因为如果把可变对象(mutable object)放入collection之后又修改其内容，那么很容易就会破坏set的内部数据结构，使其失去固有的语义。故此，我们应该尽量减少对象中的可变内容。具体到编程实践中，则应该尽量把对外公布出来的属性设为&lt;code class=&quot;highlighter-rouge&quot;&gt;readonly&lt;/code&gt;，而且只在有必要时才将属性对外公布。&lt;/p&gt;

&lt;p&gt;定义类的公共API时，需要注意，对象里表示各种collection的那些属性究竟应该设成可变的，还是不可变的。如果某个属性可以为外界所增删，那么这个属性就需要用可变的set来实现。在这种情况下，通常应该提供一个readonly属性供外界使用，该属性将返回不可变的set，而此set则是内部那个可变set的一份拷贝。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//  ZKRPointOfInterest.h

#import &amp;lt;UIKit/UIKit.h&amp;gt;

@interface ZKRPointOfInterest : NSObject

@property (nonatomic, copy, readonly) NSString *identifier;
@property (nonatomic, copy, readonly) NSString *title;
@property (nonatomic, assign, readonly) CGFloat latitude;
@property (nonatomic, assign, readonly) CGFloat longitude;
@property (nonatomic, strong, readonly) NSSet *locations;

- (instancetype)initWithIdentifier:(NSString *)identifier
                             title:(NSString *)title
                          latitude:(CGFloat)latitude
                         longitude:(CGFloat)longitude;

- (void)addLocation:(ZKRPointOfInterest *)location;
- (void)removeLocation:(ZKRPointOfInterest *)location;

@end

//  ZKRPointOfInterest.m

#import &quot;ZKRPointOfInterest.h&quot;

@implementation ZKRPointOfInterest
{
    NSMutableSet *_internalLocations;
}

- (instancetype)initWithIdentifier:(NSString *)identifier
                             title:(NSString *)title
                          latitude:(CGFloat)latitude
                         longitude:(CGFloat)longitude
{
    self = [super init];
    if (self) {
        
    }
    return self;
}

- (NSSet *)locations
{
    return [_internalLocations copy];
}

- (void)addLocation:(ZKRPointOfInterest *)location
{
    if (location) {
        [_internalLocations addObject:location];
    }
}

- (void)removeLocation:(ZKRPointOfInterest *)location
{
    [_internalLocations removeObject:location];
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;不要在返回的对象上查询类型以确定其是否可变。(即使不用&lt;code class=&quot;highlighter-rouge&quot;&gt;isKindOfClass:&lt;/code&gt;方法来判断返回值类型是否可变)&lt;/p&gt;

&lt;h2 id=&quot;description方法&quot;&gt;description方法&lt;/h2&gt;

&lt;p&gt;在调试程序时，经常需要打印并查看对象信息。一种办法是编写代码把对象的全部属性都log到日志中。&lt;code class=&quot;highlighter-rouge&quot;&gt;NSLog(@&quot;object=%@&quot;, object);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在构建需要打印到日志的字符串时，object对象会收到description消息，该方法所返回的描述信息将取代“格式字符串”(format string)里的“%@”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSArray *obj = @[@&quot;A string&quot;, @(123)];
NSLog(@&quot;object=%@&quot;, obj);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object=(
	&quot;A string&quot;,
	123
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果在自定义类上这么做，那么则输出的信息却是如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object=&amp;lt;ZKRSqure: 0x7656d8a90060&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果想要像上面NSArray那样打印出有用的信息，那么我们就应该在自己的类中覆写description方法，否则打印信息时就会调用NSObject类所实现的默认方法。此方法定义在NSObject协议里，不过NSObject类也实现了它。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (NSString *)description
{
    return [NSString stringWithFormat:@&quot;&amp;lt;%@: %p, \&quot;%f %f\&quot;&amp;gt;&quot;, [self class], self, _width, _height];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ZKRRectangle *rectangle = [[ZKRRectangle alloc] initWithWidth:5.0 height:7.0];
NSLog(@&quot;%@&quot;, rectangle);

//Output
&amp;lt;ZKRRectangle: 0x60000002fc20, &quot;5.000000 7.000000&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;NSObject协议中还有个需要注意的方法，就是&lt;code class=&quot;highlighter-rouge&quot;&gt;debugDescription&lt;/code&gt;，此方法用意与&lt;code class=&quot;highlighter-rouge&quot;&gt;description&lt;/code&gt;相似。二者区别在于，&lt;code class=&quot;highlighter-rouge&quot;&gt;debugDescription&lt;/code&gt;方法是开发者在调试器(debugger)中以控制台命令打印对象时才调用的。在NSObject类的默认实现中，它只是直接调用&lt;code class=&quot;highlighter-rouge&quot;&gt;description&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;初始化方法&quot;&gt;初始化方法&lt;/h2&gt;

&lt;p&gt;所有对象均要初始化，在初始化时，有些对象可能无须开发者向其提供额外信息，不过一般来说还是需要提供的。通常情况下，对象若不知道必要的信息，则无法完成其工作。例如，UITAbleViewCell类初始化该类对象时，需要指明其样式及标识符，标识符能够区分不同类型的单元格。由于这种对象的创建成本较高，所以绘制表格时可依照标识符来复用，以提升程序效率。这种可为对象提供必要信息以便其能完成工作的初始化方法叫做“全能初始化方法”(designated initializer)。&lt;/p&gt;

&lt;p&gt;如果创建类实例的方式不止一种，那么这个类就会有多个初始化方法。但是，我们仍然需要选定一个作为全能初始化方法，令其他初始化方法都来调用它。例如，NSDate类&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (instancetype)init NS_DESIGNATED_INITIALIZER;
- (instancetype)initWithTimeIntervalSinceReferenceDate:(NSTimeInterval)ti NS_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;
- (instancetype)initWithTimeIntervalSinceNow:(NSTimeInterval)secs;
- (instancetype)initWithTimeIntervalSince1970:(NSTimeInterval)secs;
- (instancetype)initWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上面几个初始化方法中，&lt;code class=&quot;highlighter-rouge&quot;&gt;initWithTimeIntervalSinceReferenceDate:&lt;/code&gt;是全能初始化方法。只有在全能初始化方法中，才会存储内部数据。这样的话，当底层数据存储机制改变时，只需修改此方法的代码就好，无须改动其他初始化方法。&lt;/p&gt;

&lt;p&gt;示例代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//  ZKRRectangle.h

#import &amp;lt;UIKit/UIKit.h&amp;gt;

@interface ZKRRectangle : NSObject&amp;lt;NSCopying&amp;gt;

@property (nonatomic, assign, readonly) CGFloat width;
@property (nonatomic, assign, readonly) CGFloat height;

- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;

@end

//  ZKRRectangle.m

#import &quot;ZKRRectangle.h&quot;

@implementation ZKRRectangle

- (instancetype)initWithCoder:(NSCoder *)aDecoder
{
    self = [super init];
    if (self) {
        _width = [[aDecoder decodeObjectForKey:@&quot;width&quot;] floatValue];
        _height = [[aDecoder decodeObjectForKey:@&quot;height&quot;] floatValue];
    }
    return self;
}

- (instancetype)init
{
    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithWidth:height: instad.&quot; userInfo:nil];
    
    return [self initWithWidth:0 height:0];
}

- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height
{
    self = [super init];
    if (self) {
        _width = width;
        _height = height;
    }
    return self;
}

@end

//  ZKRSquare.h

#import &quot;ZKRRectangle.h&quot;

@interface ZKRSquare : ZKRRectangle

- (instancetype)initWithDimension:(CGFloat)dimension;

@end

//  ZKRSquare.m

#import &quot;ZKRSquare.h&quot;

@implementation ZKRSquare

- (instancetype)init
{
    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithDimension: instad.&quot; userInfo:nil];
    
    return [self initWithDimension:0];
}

- (instancetype)initWithDimension:(CGFloat)dimension
{
    return [super initWithWidth:dimension height:dimension];
}

- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height
{
    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithDimension: instad.&quot; userInfo:nil];
    CGFloat dimension = MIN(width, height);
    return [self initWithDimension:dimension];
}

@end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均调用此方法。&lt;/li&gt;
  &lt;li&gt;若全能方法于超类不同，则需要覆写超类中的对应方法。&lt;/li&gt;
  &lt;li&gt;如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;nscopying协议&quot;&gt;NSCopying协议&lt;/h2&gt;

&lt;p&gt;使用对象时经常需要拷贝它。在Objective-C中，此操作通过copy方法完成。如果想令自己的类支持拷贝操作，那就要实现NSCopying协议，该协议只有一个方法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (id)copyWithZone:(nullable NSZone *)zone;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为什么会出现NSZone呢？因为以前开发程序时，会据此把内容分成不同的“区”(zone)，而对象会创建在某个区里面。现在不用了，每个程序只有一个区：“默认区”(default zone)。所以说，尽管必须实现这个方法，但是你不必担心其中的zone参数。&lt;/p&gt;

&lt;p&gt;copy方法由NSObject实现，该方法只是以“默认区”为参数来调用&lt;code class=&quot;highlighter-rouge&quot;&gt;copyWithZone:&lt;/code&gt;。我们总是想覆写copy方法，其实真正需要实现的是&lt;code class=&quot;highlighter-rouge&quot;&gt;copyWithZone:&lt;/code&gt;方法。若想使某个类支持拷贝功能，只需声明该类遵从NSCopying协议，并实现其中的那个方法即可。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (id)copyWithZone:(NSZone *)zone
{
    ZKRRectangle *copy = [[[self class] allocWithZone:zone] initWithWidth:_width height:_height];
    return copy;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;说到copy方法，除了NSString这样的不可变类型的copy，与之类似的还有NSMutableString类的&lt;code class=&quot;highlighter-rouge&quot;&gt;mutableCopy&lt;/code&gt;方法。与&lt;code class=&quot;highlighter-rouge&quot;&gt;copyWithZone:&lt;/code&gt;方法相对应的可变内容的copy方法&lt;code class=&quot;highlighter-rouge&quot;&gt;mutableCopyWithZone:&lt;/code&gt;方法来自于&lt;code class=&quot;highlighter-rouge&quot;&gt;NSMutableCopying&lt;/code&gt;协议。如果你的类分为可变版本(mutable)与不可变版本(immutable)，那么就应该实现NSMutableCopying协议。若采用此模式，则在可变类中覆写&lt;code class=&quot;highlighter-rouge&quot;&gt;copyWithZone:&lt;/code&gt;方法时，不要返回可变的拷贝，而应该返回一份不可变的版本。无论当前实例是否可变，需要获取其可变版本的拷贝，均应调用mutableCopy方法；获取不可变版本的拷贝，则总应该通过copy方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-design-api-guide-2.png?imageView/2/w/500&quot; alt=&quot;mutableCopy和copy类&quot; /&gt;&lt;/p&gt;

&lt;p&gt;深拷贝就是在拷贝对象自身时，将其底层数据也一并复制过去。
浅拷贝就是在拷贝对象时，只拷贝容器对象本身，而不复制其中数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-design-api-guide-3.png?imageView/2/w/400&quot; alt=&quot;深拷贝和浅拷贝比较&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 10 Jul 2017 06:32:33 +0800</pubDate>
      </item>
    
      <item>
        <title>从iOS的图片圆角想到渲染</title>
        <link>/pieces/2017/07/03/ios-corner-radius.html</link>
        <guid isPermaLink="true">/pieces/2017/07/03/ios-corner-radius.html</guid>
        <description>&lt;p&gt;圆角是一种很常见的视图效果，相比于直角，它更加柔和优美，易于接受。设置圆角会带来一定的性能损耗，如何提高性能是一个需要重点讨论的话题。&lt;/p&gt;

&lt;p&gt;大家常见的圆角代码&lt;code class=&quot;highlighter-rouge&quot;&gt;x.layer.cornerRadius = xx; x.clipsToBounds = YES;&lt;/code&gt;这两行确实实现了圆角视觉效果。其实使用&lt;code class=&quot;highlighter-rouge&quot;&gt;x.layer.cornerRadius = xx;&lt;/code&gt;已经实现了圆角，只不过在某些控件是不生效的，因为某些图层在被切割圆角图层之上而被显示出来了。而&lt;code class=&quot;highlighter-rouge&quot;&gt;x.clipsToBounds = YES;&lt;/code&gt;带来的后果就是产生&lt;code class=&quot;highlighter-rouge&quot;&gt;离屏渲染&lt;/code&gt;。可以使用instruments中的CoreAnimation工具，打开&lt;code class=&quot;highlighter-rouge&quot;&gt;Color Offscren-Rednered Yellow&lt;/code&gt;选项，可见黄色区域部分即是离屏渲染部分。&lt;/p&gt;

&lt;p&gt;那么离屏渲染会带来什么？当然后资源损耗，可能产生卡顿。因为在iPhone设备的硬件资源有差异，当离屏渲染不多时，并不是很明显感觉到它的缺点。&lt;/p&gt;

&lt;h2 id=&quot;什么是像素&quot;&gt;什么是像素&lt;/h2&gt;

&lt;p&gt;像素，为视频显示的基本单位，译自英文“pixel”，pix是英语单词picture的常用简写，加上英语单词“元素”element，就得到pixel，故“像素”表示“画像元素”之意，有时亦被称为pel（picture element）。每个这样的消息元素不是一个点或者一个方块，而是一个抽象的取样。像素是由红，绿，蓝三种颜色组件构成的。因此，位图数据有时也被叫做 RGB 数据。&lt;/p&gt;

&lt;h2 id=&quot;显示机制&quot;&gt;显示机制&lt;/h2&gt;

&lt;p&gt;一个像素是如何绘制到屏幕上去的？有很多种方式将一些东西映射到显示屏上，他们需要调用不同的框架、许多功能和方法的结合体。这里我们大概看一下屏幕之后发生的事情。&lt;/p&gt;

&lt;p&gt;图像想显示到屏幕上使人肉眼可见都需借助像素的力量。它们密集的排布在手机屏幕上，将任何图形通过不同的色值表现出来。计算机显示的流程大致可以描述为将图像转化为一系列像素点的排列然后打印在屏幕上，由图像转化为像素点的过程又可以称之为光栅化，就是从矢量的点线面的描述，变成像素的描述。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/display-screen.png?imageView/2/w/300&quot; alt=&quot;display screen&quot; /&gt;&lt;/p&gt;

&lt;p&gt;回溯历史，可以从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。&lt;/p&gt;

&lt;h3 id=&quot;关于卡顿的简单原理解释&quot;&gt;关于卡顿的简单原理解释&lt;/h3&gt;

&lt;p&gt;在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。&lt;/p&gt;

&lt;p&gt;CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。&lt;/p&gt;

&lt;h2 id=&quot;渲染机制&quot;&gt;渲染机制&lt;/h2&gt;

&lt;p&gt;当像素映射到屏幕上的时候，后台发生了很多事情。但一旦它们显示到屏幕上，每一个像素均由三个颜色组件构成：红，绿，蓝。三个独立的颜色单元会根据给定的颜色显示到一个像素上。在 iPhoneSE 的显示器上有1,136×640=727,040个像素，因此有2,181,120个颜色单元。在一些Retina屏幕上，这一数字将达到百万以上。所有的图形堆栈一起工作以确保每次正确的显示。当你滚动整个屏幕的时候，数以百万计的颜色单元必须以每秒60次的速度刷新，这就是一个很大的工作量。&lt;/p&gt;

&lt;p&gt;简单来说，iOS的显示机制大致如此：
&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/pixels-software-stack.png&quot; alt=&quot;pixels software stack&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Display 的上一层便是图形处理单元 GPU，GPU 是一个专门为图形高并发计算而量身定做的处理单元。这也是为什么它能同时更新所有的像素，并呈现到显示器上。它的并发本性让它能高效的将不同纹理合成起来。所以，开发中我们应该尽量让CPU负责主线程的UI调动，把图形显示相关的工作交给GPU来处理。&lt;/p&gt;

&lt;p&gt;GPU Driver 是直接和 GPU 交流的代码块。不同的GPU是不同的性能怪兽，但是驱动使它们在下一个层级上显示的更为统一，典型的下一层级有 OpenGL/OpenGL ES.&lt;/p&gt;

&lt;p&gt;OpenGL(Open Graphics Library) 是一个提供了 2D 和 3D 图形渲染的 API。GPU 是一块非常特殊的硬件，OpenGL 和 GPU 密切的工作以提高GPU的能力，并实现硬件加速渲染。&lt;/p&gt;

&lt;p&gt;OpenGL 之上扩展出很多东西。在 iOS 上，几乎所有的东西都是通过 Core Animation 绘制出来，然而在 OS X 上，绕过 Core Animation 直接使用 Core Graphics 绘制的情况并不少见。对于一些专门的应用，尤其是游戏，程序可能直接和 OpenGL/OpenGL ES 交流。&lt;/p&gt;

&lt;p&gt;需要强调的是，GPU 是一个非常强大的图形硬件，并且在显示像素方面起着核心作用。它连接到 CPU。从硬件上讲两者之间存在某种类型的总线，并且有像 OpenGL，Core Animation 和 Core Graphics 这样的框架来在 GPU 和 CPU 之间精心安排数据的传输。为了将像素显示到屏幕上，一些处理将在 CPU 上进行。然后数据将会传送到 GPU，最终像素显示到屏幕上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/pixels-hardware.png&quot; alt=&quot;pixels hardware&quot; /&gt;&lt;/p&gt;

&lt;p&gt;正如上图显示，GPU 需要将每一个 frame 的纹理(位图)合成在一起(一秒60次)。每一个纹理会占用 VRAM(video RAM)，所以需要给 GPU 同时保持纹理的数量做一个限制。GPU 在合成方面非常高效，但是某些合成任务却比其他更复杂，并且 GPU在 16.7ms(1/60s)内能做的工作也是有限的。&lt;/p&gt;

&lt;p&gt;另外一个问题就是将数据传输到 GPU 上。为了让 GPU 访问数据，需要将数据从 RAM 移动到 VRAM 上。这就是提及到的上传数据到 GPU。这些看起来貌似微不足道，但是一些大型的纹理却会非常耗时。&lt;/p&gt;

&lt;p&gt;最终，CPU 开始运行程序。你可能会让 CPU 从 bundle 加载一张 PNG 的图片并且解压它。这所有的事情都在 CPU 上进行。然后当你需要显示解压缩后的图片时，它需要以某种方式上传到 GPU。一些看似平凡的，比如显示文本，对 CPU 来说却是一件非常复杂的事情，这会促使 Core Text 和 Core Graphics 框架更紧密的集成来根据文本生成一个位图。一旦准备好，它将会被作为一个纹理上传到 GPU 并准备显示出来。当你滚动或者在屏幕上移动文本时，同样的纹理能够被复用，CPU 只需简单的告诉 GPU 新的位置就行了,所以 GPU 就可以重用存在的纹理了。CPU 并不需要重新渲染文本，并且位图也不需要重新上传到 GPU。&lt;/p&gt;

&lt;p&gt;在图形世界中，合成是一个描述不同位图如何放到一起来创建你最终在屏幕上看到图像的过程。屏幕上一切事物皆纹理。一个纹理就是一个包含 RGBA 值的长方形，比如，每一个像素里面都包含红、绿、蓝和透明度的值。在 Core Animation 世界中这就相当于一个 CALayer。&lt;/p&gt;

&lt;p&gt;每一个 layer 是一个纹理，所有的纹理都以某种方式堆叠在彼此的顶部。对于屏幕上的每一个像素，GPU 需要算出怎么混合这些纹理来得到像素 RGB 的值。这就是合成。&lt;/p&gt;

&lt;p&gt;如果我们所拥有的是一个和屏幕大小一样并且和屏幕像素对齐的单一纹理，那么屏幕上每一个像素相当于纹理中的一个像素，纹理的最后一个像素也就是屏幕的最后一个像素。&lt;/p&gt;

&lt;p&gt;如果我们有第二个纹理放在第一个纹理之上，然后GPU将会把第二个纹理合成到第一个纹理中。有很多种不同的合成方法，但是如果我们假定两个纹理的像素对齐，并且使用正常的混合模式，我们便可以用公式来计算每一个像素：&lt;code class=&quot;highlighter-rouge&quot;&gt;R = S + D * ( 1 – Sa )&lt;/code&gt;
结果的颜色是源色彩(顶端纹理)+目标颜色(低一层的纹理)*(1-源颜色的透明度)。在这个公式中所有的颜色都假定已经预先乘以了它们的透明度。&lt;/p&gt;

&lt;p&gt;接着我们进行第二个假定，两个纹理都完全不透明，比如 alpha=1。如果目标纹理(低一层的纹理)是蓝色(RGB=0,0,1)，并且源纹理(顶层的纹理)颜色是红色(RGB=1,0,0)，因为 Sa 为1，所以结果为：&lt;code class=&quot;highlighter-rouge&quot;&gt;R = S&lt;/code&gt;
结果是源颜色的红色。这正是我们所期待的(红色覆盖了蓝色)。如果源颜色层为50%的透明，比如 alpha=0.5，既然 alpha 组成部分需要预先乘进 RGB 的值中，那么 S 的 RGB 值为(0.5, 0, 0)，公式看起来便会像这样:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                       0.5   0               0.5
R = S + D * (1 - Sa) = 0   + 0 * (1 - 0.5) = 0
                       0     1               0.5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们最终得到RGB值为(0.5, 0, 0.5),是一个紫色。这正是我们所期望将透明红色合成到蓝色背景上所得到的。&lt;/p&gt;

&lt;p&gt;记住我们刚刚只是将纹理中的一个像素合成到另一个纹理的像素上。当两个纹理覆盖在一起的时候，GPU需要为所有像素做这种操作。正如你所知道的一样，许多程序都有很多层，因此所有的纹理都需要合成到一起。尽管GPU是一块高度优化的硬件来做这种事情，但这还是会让它非常忙碌。&lt;/p&gt;

&lt;h3 id=&quot;为何图片缩放会增加gpu工作量&quot;&gt;为何图片缩放会增加GPU工作量&lt;/h3&gt;

&lt;p&gt;当所有的像素是对齐的时候我们得到相对简单的计算公式。每当 GPU 需要计算出屏幕上一个像素是什么颜色的时候，它只需要考虑在这个像素之上的所有 layer 中对应的单个像素，并把这些像素合并到一起。或者，如果最顶层的纹理是不透明的(即图层树的最底层)，这时候 GPU 就可以简单的拷贝它的像素到屏幕上。&lt;/p&gt;

&lt;p&gt;当一个 layer 上所有的像素和屏幕上的像素完美的对应整齐，那这个 layer 就是像素对齐的。主要有两个原因可能会造成不对齐。第一个便是滚动，当一个纹理上下滚动的时候，纹理的像素便不会和屏幕的像素排列对齐。另一个原因便是当纹理的起点不在一个像素的边界上。&lt;/p&gt;

&lt;p&gt;在这两种情况下，GPU 需要再做额外的计算。它需要将源纹理上多个像素混合起来，生成一个用来合成的值。当所有的像素都是对齐的时候，GPU 只剩下很少的工作要做。&lt;/p&gt;

&lt;p&gt;Core Animation 工具和模拟器有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Color Misaligned Images &lt;/code&gt;选项，当这些在你的 CALayer 实例中发生的时候，这个功能便可向你展示。&lt;/p&gt;

&lt;p&gt;关于iOS设备的一些尺寸限制可以看这里：&lt;a href=&quot;http://iosres.com/&quot;&gt;iOSRes&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;离屏渲染&quot;&gt;离屏渲染&lt;/h2&gt;

&lt;p&gt;On-Screen Rendering意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。
Off-Screen Rendering意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。&lt;/p&gt;

&lt;p&gt;当图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制时，屏幕外渲染就被唤起了。屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。&lt;/p&gt;

&lt;p&gt;离屏渲染可以被 Core Animation 自动触发，或者被应用程序强制触发。屏幕外的渲染会合并/渲染图层树的一部分到一个新的缓冲区，然后该缓冲区被渲染到屏幕上。&lt;/p&gt;

&lt;h3 id=&quot;特殊的离屏渲染cpu渲染&quot;&gt;特殊的“离屏渲染”：CPU渲染&lt;/h3&gt;

&lt;p&gt;如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。
整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。&lt;/p&gt;

&lt;h3 id=&quot;离屏渲染的体现&quot;&gt;离屏渲染的体现&lt;/h3&gt;

&lt;p&gt;相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 创建新缓冲区
要想进行离屏渲染，首先要创建一个新的缓冲区。&lt;/li&gt;
  &lt;li&gt;2 上下文切换
离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;触发离屏渲染&quot;&gt;触发离屏渲染&lt;/h3&gt;

&lt;p&gt;1、drawRect
2、layer.shouldRasterize = true;
3、有mask或者是阴影(layer.masksToBounds, layer.shadow*)；
 3.1) shouldRasterize（光栅化）
 3.2) masks（遮罩）
 3.3) shadows（阴影）
 3.4) edge antialiasing（抗锯齿）
 3.5) group opacity（不透明）
4、Text（UILabel, CATextLayer, Core Text, etc）…
注：layer.cornerRadius，layer.borderWidth，layer.borderColor并不会Offscreen Render，因为这些不需要加入Mask。&lt;/p&gt;

&lt;h2 id=&quot;圆角优化&quot;&gt;圆角优化&lt;/h2&gt;

&lt;p&gt;前面说了那么多，这里就给上实际可行方案。圆角的优化目前考虑两方面：一是，从图片入手，将图片切割成指定圆角样式。二是，使用贝塞尔曲线，利用CALayer层绘制指定圆角样式的mask遮盖View。&lt;/p&gt;

&lt;p&gt;UIImage切割：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);
CGContextRef context = UIGraphicsGetCurrentContext();
CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);
CGContextScaleCTM(context, 1, -1);
CGContextTranslateCTM(context, 0, -rect.size.height);

CGFloat minSize = MIN(self.size.width, self.size.height);
if (borderWidth &amp;lt; minSize / 2.0) {
    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectInset(rect, borderWidth, borderWidth) byRoundingCorners:corners cornerRadii:CGSizeMake(radius, borderWidth)];
    CGContextSaveGState(context);
    [path addClip];
    CGContextDrawImage(context, rect, self.CGImage);
    CGContextRestoreGState(context);
}

UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
image = [image dd_imageByCornerRadius:radius borderedColor:borderColor borderWidth:borderWidth corners:corners];
UIGraphicsEndImageContext();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;图片绘制：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);
[self drawAtPoint:CGPointZero];
CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);
CGFloat strokeInset = borderWidth / 2.0;
CGRect strokeRect = CGRectInset(rect, strokeInset, strokeInset);
UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:strokeRect byRoundingCorners:corners cornerRadii:CGSizeMake(radius, borderWidth)];
path.lineWidth = borderWidth;
[borderColor setStroke];
[path stroke];
UIImage *result = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体源码可以转至github进行star &lt;a href=&quot;https://github.com/charsdavy/DDCornerRadius&quot;&gt;DDCornerRadius&lt;/a&gt; 欢迎issue。&lt;/p&gt;
</description>
        <pubDate>Mon, 03 Jul 2017 22:40:56 +0800</pubDate>
      </item>
    
      <item>
        <title>二叉树的那些使用</title>
        <link>/algorithm/2017/06/14/binary-tree-guide.html</link>
        <guid isPermaLink="true">/algorithm/2017/06/14/binary-tree-guide.html</guid>
        <description>&lt;p&gt;在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支(不存在分支度大于2的节点)的树结构。通常分支被称作“左子树”和“右子树”。二叉树的分支具有左右次序，不能颠倒。&lt;/p&gt;

&lt;p&gt;二叉树的第i层至多拥有 2^(i-1) 个节点数；深度为k的二叉树至多总共有 2^(k+1) - 1 个节点数，而总计拥有节点数匹配的，称为“满二叉树”；深度为k有n个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度k的满二叉树，序号为1到n的节点一对一对应时，称为“完全二叉树”。对任何一棵非空的二叉树T，如果其叶片(终端节点)数为n0，分支度为2的节点数为n2，则n0 = n2 + 1。&lt;/p&gt;

&lt;p&gt;与普通树不同，普通树的节点个数至少为1，而二叉树的节点个数可以为0；普通树节点的最大分支度没有限制，而二叉树节点的最大分支度为2；普通树的节点无左、右次序之分，而二叉树的节点有左、右次序之分。&lt;/p&gt;

&lt;p&gt;二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉查找树和二元堆积，并应用于高效率的搜索和排序。&lt;/p&gt;

&lt;p&gt;相对于普通二叉树，还有一些特殊二叉树，它们诞生于特殊的场景需求。例如，二叉搜索树就是因搜索需求而诞生的一种特殊的树。&lt;/p&gt;

&lt;p&gt;具体可以参见
&lt;a href=&quot;/2017/06/10/binary-search-tree/&quot;&gt;《聊聊「二叉搜索树」的那些事儿》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文初衷是因为Homebrew 的作者&lt;a href=&quot;https://twitter.com/mxcl/status/608682016205344768&quot;&gt;@Max Howell&lt;/a&gt;的一条twitter&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;类型&quot;&gt;类型&lt;/h2&gt;

&lt;h3 id=&quot;1完全二叉树&quot;&gt;(1)完全二叉树&lt;/h3&gt;
&lt;p&gt;若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的节点数都达到最大个数，第h层有叶子节点，并且叶子节点都是从左到右依次排布，这就是完全二叉树。&lt;/p&gt;
&lt;h3 id=&quot;2满二叉树&quot;&gt;(2)满二叉树&lt;/h3&gt;
&lt;p&gt;除了叶节点外每一个节点都有左右子叶且叶子节点都处在最底层的二叉树。&lt;/p&gt;
&lt;h3 id=&quot;3平衡二叉树&quot;&gt;(3)平衡二叉树&lt;/h3&gt;
&lt;p&gt;平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。&lt;/p&gt;

&lt;h2 id=&quot;相关术语&quot;&gt;相关术语&lt;/h2&gt;
&lt;p&gt;树的节点：包含一个数据元素及若干指向子树的分支。&lt;/p&gt;

&lt;p&gt;孩子节点：节点的子树的根称为该节点的孩子。&lt;/p&gt;

&lt;p&gt;双亲节点：B 节点是A 节点的孩子，则A节点是B 节点的双亲。&lt;/p&gt;

&lt;p&gt;兄弟节点：同一双亲的孩子节点；&lt;/p&gt;

&lt;p&gt;堂兄节点：同一层上节点。&lt;/p&gt;

&lt;p&gt;祖先节点: 从根到该节点的所经分支上的所有节点。&lt;/p&gt;

&lt;p&gt;子孙节点：以某节点为根的子树中任一节点都称为该节点的子孙。&lt;/p&gt;

&lt;p&gt;节点层：根节点的层定义为1；根的孩子为第二层节点，依此类推。&lt;/p&gt;

&lt;p&gt;树的深度：树中最大的节点层。&lt;/p&gt;

&lt;p&gt;节点的度：节点子树的个数。&lt;/p&gt;

&lt;p&gt;树的度： 树中最大的节点度。&lt;/p&gt;

&lt;p&gt;叶子节点：也叫终端节点，是度为 0 的节点。&lt;/p&gt;

&lt;p&gt;分支节点：度不为0的节点。&lt;/p&gt;

&lt;p&gt;有序树：子树有序的树，如：家族树。&lt;/p&gt;

&lt;p&gt;无序树：不考虑子树的顺序。&lt;/p&gt;

&lt;h2 id=&quot;树的结构&quot;&gt;树的结构&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;

/** 二叉树节点 */
@interface DDBinaryTreeNode : NSObject

/** 值 */
@property (nonatomic, assign) NSInteger value;
/** 左节点 */
@property (nonatomic, strong) DDBinaryTreeNode *leftNode;
/** 右节点 */
@property (nonatomic, strong) DDBinaryTreeNode *rightNode;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;树的遍历&quot;&gt;树的遍历&lt;/h2&gt;

&lt;p&gt;遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有节点，使每一个节点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个节点转换成为一个线性序列来表示。&lt;/p&gt;

&lt;p&gt;设L、D、R分别表示遍历左子树、访问根节点和遍历右子树， 则对一棵二叉树的遍历有三种情况：DLR（称为先序遍历），LDR（称为中序遍历），LRD （称为后序遍历）。&lt;/p&gt;

&lt;h3 id=&quot;先序遍历&quot;&gt;先序遍历&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)preOrderTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler {
    if (!rootNode) {
        return;
    }
    
    if (handler) {
        handler(rootNode);
    }
    [self preOrderTraverseTree:rootNode.leftNode handler:handler];
    [self preOrderTraverseTree:rootNode.rightNode handler:handler];
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;中序遍历&quot;&gt;中序遍历&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)inOrderTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void (^)(DDBinaryTreeNode *treeNode))handler
{
    if (!rootNode) {
        return;
    }
    [self inOrderTraverseTree:rootNode.leftNode handler:handler];
    if (handler) {
        handler(rootNode);
    }
    [self inOrderTraverseTree:rootNode.rightNode handler:handler];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;后序遍历&quot;&gt;后序遍历&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)postOrderTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler {
    if (!rootNode) {
        return;
    }
    [self postOrderTraverseTree:rootNode.leftNode handler:handler];
    [self postOrderTraverseTree:rootNode.rightNode handler:handler];
    if (handler) {
        handler(rootNode);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;广度优先遍历breadth-first-search&quot;&gt;广度优先遍历(Breadth First Search)&lt;/h3&gt;

&lt;p&gt;从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。
按照从上到下、从左到右的次序进行遍历。先遍历完一层，再遍历下一层。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)levelTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler {
    if (!rootNode) {
        return;
    }
    NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列
    [queueArray addObject:rootNode]; //压入根节点
    while (queueArray.count &amp;gt; 0) {
        DDBinaryTreeNode *node = [queueArray firstObject];
        if (handler) {
            handler(node);
        }
        [queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先出原则
        if (node.leftNode) {
            [queueArray addObject:node.leftNode]; //压入左节点
        }
        if (node.rightNode) {
            [queueArray addObject:node.rightNode]; //压入右节点
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;深度优先遍历depth-first-search&quot;&gt;深度优先遍历(Depth First Search)&lt;/h3&gt;

&lt;p&gt;DFS是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。
当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。
如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)depthTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler
{
    if (!rootNode) {
        return;
    }
    
    if (handler) {
        handler(rootNode);
    }
    
    [self depthTraverseTree:rootNode.leftNode handler:handler];
    [self depthTraverseTree:rootNode.rightNode handler:handler];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;树的翻转&quot;&gt;树的翻转&lt;/h2&gt;

&lt;p&gt;翻转二叉树，又叫求二叉树的镜像，就是把二叉树的左右子树对调。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (DDBinaryTreeNode *)invertBinaryTree:(DDBinaryTreeNode *)rootNode {
    if (!rootNode) {
        return nil;
    }
    if (!rootNode.leftNode &amp;amp;&amp;amp; !rootNode.rightNode) {
        return rootNode;
    }
    [self invertBinaryTree:rootNode.leftNode];
    [self invertBinaryTree:rootNode.rightNode];
    DDBinaryTreeNode *tempNode = rootNode.leftNode;
    rootNode.leftNode = rootNode.rightNode;
    rootNode.rightNode = tempNode;
    return rootNode;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;树的查找&quot;&gt;树的查找&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (DDBinaryTreeNode *)searchTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode
{
    if (!rootNode) {
        return nil;
    }
    
    if (rootNode.value == value) {
        return rootNode;
    }
    
    if (value &amp;lt; rootNode.value) {
        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.leftNode];
    } else {
        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.rightNode];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;相关链接：
&lt;a href=&quot;http://www.cocoachina.com/programmer/20151015/13687.html&quot;&gt;《百度的校园招聘面试经历》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.devtang.com/2015/06/16/talk-about-tech-interview/&quot;&gt;《你会翻转二叉树吗》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 14 Jun 2017 07:30:22 +0800</pubDate>
      </item>
    
      <item>
        <title>聊聊「二叉搜索树」的那些事儿</title>
        <link>/algorithm/2017/06/10/binary-search-tree.html</link>
        <guid isPermaLink="true">/algorithm/2017/06/10/binary-search-tree.html</guid>
        <description>&lt;p&gt;二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 它的左、右子树也分别为二叉排序树。“中序遍历”可以让节点有序。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/binary-search-tree.png&quot; alt=&quot;binary search tree&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;二叉排序树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉排序树的存储结构。中序遍历二叉排序树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉排序树变成一个有序序列，构造树的过程即为对无序序列进行排序的过程。每次插入的新的节点都是二叉排序树上新的叶子节点，在进行插入操作时，不必移动其它节点，只需改动某个节点的指针，由空变为非空即可。搜索，插入，删除的复杂度等于树高，O(log(n))。&lt;/p&gt;

&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;

&lt;h3 id=&quot;树节点&quot;&gt;树节点&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;

/** 二叉树节点 */
@interface DDBinaryTreeNode : NSObject

/** 值 */
@property (nonatomic, assign) NSInteger value;
/** 左节点 */
@property (nonatomic, strong) DDBinaryTreeNode *leftNode;
/** 右节点 */
@property (nonatomic, strong) DDBinaryTreeNode *rightNode;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;创建&quot;&gt;创建&lt;/h3&gt;
&lt;p&gt;二叉排序树的创建无非就是不断查找和插入的过程，当我们查找某个值没有找到时，我们就会将该值插入到二叉排序树中。因为在查找的过程中可以确定该结点要插入的合适位置，所以插入就显得比较简单了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;

@class DDBinaryTreeNode;

@interface DDBinarySearchTreeHandler : NSObject

/**
 *  创建二叉排序树
 *  二叉排序树：左节点值全部小于根节点值，右节点值全部大于根节点值
 *
 *  @param values 数组
 *
 *  @return 二叉树根节点
 */
+ (DDBinaryTreeNode *)createTreeWithValues:(NSArray *)values;

/**
 *  向二叉排序树节点添加一个节点
 *
 *  @param treeNode 根节点
 *  @param value	值
 *
 *  @return 根节点
 */
+ (DDBinaryTreeNode *)addTreeNode:(DDBinaryTreeNode *)treeNode value:(NSInteger)value;

/**
 *  二叉搜索树中某个值的节点
 *
 *  @param value	值
 *  @param rootNode 树根节点
 *
 *  @return 节点
 */
+ (DDBinaryTreeNode *)searchTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (DDBinaryTreeNode *)createTreeWithValues:(NSArray *)values
{
    DDBinaryTreeNode *root = nil;
    for (NSInteger i = 0; i &amp;lt; values.count; i++) {
        NSInteger value = [(NSNumber *)[values objectAtIndex:i] integerValue];
        root = [DDBinarySearchTreeHandler addTreeNode:root value:value];
    }
    return root;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;添加节点&quot;&gt;添加节点&lt;/h3&gt;

&lt;p&gt;根据查找树的性质我们可以很简单的写出添加的代码，一个一个的比较，注意每插入的一个总是叶子节点。再进行调整。最终形成的效果图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/binary-search-tree-01.png&quot; alt=&quot;添加节点&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (DDBinaryTreeNode *)addTreeNode:(DDBinaryTreeNode *)treeNode value:(NSInteger)value
{
    if (!treeNode) {
        treeNode = [[DDBinaryTreeNode alloc] init];
        treeNode.value = value;
        NSLog(@&quot;node:%td&quot;, value);
    } else if (value &amp;lt;= treeNode.value) {
        NSLog(@&quot;to left&quot;);
        //值小于根节点，则插入到左子树
        treeNode.leftNode = [DDBinarySearchTreeHandler addTreeNode:treeNode.leftNode value:value];
    } else {
        NSLog(@&quot;to right&quot;);
        //值大于根节点，则插入到右子树
        treeNode.rightNode = [DDBinarySearchTreeHandler addTreeNode:treeNode.rightNode value:value];
    }
    return treeNode;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;查找节点&quot;&gt;查找节点&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (DDBinaryTreeNode *)searchTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode
{
    if (!rootNode) {
        return nil;
    }
    
    if (rootNode.value == value) {
        return rootNode;
    }
    
    if (value &amp;lt; rootNode.value) {
        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.leftNode];
    } else {
        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.rightNode];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;删除节点&quot;&gt;删除节点&lt;/h3&gt;

&lt;p&gt;对于树来说，删除是最复杂的，主要需要考虑4种情况：叶子节点，只有左子树，只有右子树和左右子树都有。&lt;/p&gt;

&lt;h4 id=&quot;叶子节点&quot;&gt;叶子节点&lt;/h4&gt;

&lt;p&gt;删除的节点没有左子树也没有右子树，也就是删除的节点为叶子节点。这种情况下我们有可以细分为两类，一种是该叶子节点就是二叉排序树的根节点，也就是二叉排序树中只有一个节点的情况。只需要将root指针置为空即可。再一种情况是删除的叶子节点有父节点，直接将父节点连接该删除节点的指针置空即可。&lt;/p&gt;

&lt;h4 id=&quot;只有一个子节点&quot;&gt;只有一个子节点&lt;/h4&gt;

&lt;p&gt;如果删除的节点有左子树那就把左子树顶上去，如果有右子树就把右子树顶上去即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/binary-search-tree-03.png?v=20170612&quot; alt=&quot;左子树节点&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;左右子树都有&quot;&gt;左右子树都有&lt;/h4&gt;

&lt;p&gt;首先可以这么想象，如果我们要删除一个数组的元素，那么我们在删除后会将其后面的一个元素顶到被删除的位置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/binary-search-tree-04.png?v=20170612&quot; alt=&quot;双孩子节点1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那么二叉树操作同样也是一样，我们根据”中序遍历“找到要删除节点的后一个节点，然后顶上去就行了，原理跟”数组”一样一样的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/binary-search-tree-05.png?v=20170612.png&quot; alt=&quot;双孩子节点2&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)deleteTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode
{
    DDBinaryTreeNode *parent = rootNode;
    DDBinaryTreeNode *current = rootNode;
    // 记录被找到的节点是父节点的左子节点还是右子节点
    BOOL isLeftChild = false;
    // 循环直到找到目标节点的位置,否则返回
    while (current.value != value) {
        parent = current;
        if (current.value &amp;gt; value) {
            isLeftChild = true;
            current = current.leftNode;
        } else {
            isLeftChild = false;
            current = current.rightNode;
        }
        if (current == nil) {
            return;
        }
    }
    // 如果待删除的节点没有任何子节点
    // 直接将该节点的原本指向该节点的指针设置为nil
    if (current.leftNode == nil &amp;amp;&amp;amp; current.rightNode == nil) {
        if (current == rootNode) {
            rootNode = nil;
        }
        if (isLeftChild == true) {
            parent.leftNode = nil;
        } else {
            parent.rightNode = nil;
        }
    }
    // 如果待删除的节点有一个子节点,且其为左子节点
    else if (current.rightNode == nil) {
        // 判断当前节点是否为根节点
        if (current == rootNode) {
            rootNode = current.leftNode;
        } else if (isLeftChild) {
            // 挂载到父节点的左子树
            parent.leftNode = current.leftNode;
        } else {
            // 挂载到父节点的右子树
            parent.rightNode = current.leftNode;
        }
    } else if (current.leftNode == nil) {
        if (current == rootNode) {
            rootNode = current.rightNode;
        } else if (isLeftChild) {
            parent.leftNode = current.rightNode;
        } else {
            parent.rightNode = current.rightNode;
        }
    }
    // 如果待删除的节点有两个子节点
    else if (current.leftNode != nil &amp;amp;&amp;amp; current.rightNode != nil) {
        // 寻找右子树中的最小值
        DDBinaryTreeNode *successor = [DDBinarySearchTreeHandler successor:current];
        if (current == rootNode) {
            rootNode = successor;
        } else if (isLeftChild) {
            parent.leftNode = successor;
        } else {
            parent.rightNode = successor;
        }
        successor.leftNode = current.leftNode;
    }
}

/**
 在树中查找最合适的节点
 */
+ (DDBinaryTreeNode *)successor:(DDBinaryTreeNode *)node {
    DDBinaryTreeNode *successsor = nil;
    DDBinaryTreeNode *successsorParent = nil;
    DDBinaryTreeNode *current = node.rightNode;
    while (current != nil) {
        successsorParent = successsor;
        successsor = current;
        current = current.leftNode;
    }
    if (successsor != node.rightNode) {
        successsorParent.leftNode = successsor.rightNode;
        successsor.rightNode = node.rightNode;
    }
    return successsor;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 10 Jun 2017 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>初探 TensorFlow</title>
        <link>/ml/2017/06/08/tensorflow-primer-guide.html</link>
        <guid isPermaLink="true">/ml/2017/06/08/tensorflow-primer-guide.html</guid>
        <description>&lt;p&gt;TensorFlow 是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/tensors_flowing.gif&quot; alt=&quot;tensors_flowing&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;什么是数据流图data-flow-graph&quot;&gt;什么是数据流图（Data Flow Graph）&lt;/h2&gt;
&lt;p&gt;数据流图用“结点”(nodes)和“线”(edges)的有向图来描述数学计算。“节点” 一般用来表示施加的数学操作，但也可以表示数据输入(feed in)的起点/输出(push out)的终点，或者是读取/写入持久变量(persistent variable)的终点。“线”表示“节点”之间的输入/输出关系。这些数据“线”可以输运“size可动态调整”的多维数据数组，即“张量”(tensor)。张量从图中流过的直观图像是这个工具取名为“Tensorflow”的原因。一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。&lt;/p&gt;

&lt;h2 id=&quot;tensorflow的特征&quot;&gt;TensorFlow的特征&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;高度的灵活性&lt;/li&gt;
  &lt;li&gt;真正的可移植性（Portability）&lt;/li&gt;
  &lt;li&gt;将科研和产品联系在一起&lt;/li&gt;
  &lt;li&gt;自动求微分&lt;/li&gt;
  &lt;li&gt;多语言支持&lt;/li&gt;
  &lt;li&gt;性能最优化&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;下载与安装&quot;&gt;下载与安装&lt;/h2&gt;

&lt;h3 id=&quot;源码安装&quot;&gt;源码安装&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# --recurse-submodules 参数是必须的, 用于获取 TesorFlow 依赖的 protobuf 库
$ git clone --recurse-submodules https://github.com/tensorflow/tensorflow
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;linux-安装&quot;&gt;Linux 安装&lt;/h4&gt;

&lt;h5 id=&quot;安装-bazel&quot;&gt;安装 Bazel&lt;/h5&gt;

&lt;p&gt;首先依照 &lt;a href=&quot;https://bazel.build/versions/master/docs/install.html&quot;&gt;教程&lt;/a&gt; 安装 Bazel 的依赖. 然后使用下列命令下载和编译 Bazel 的源码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/bazelbuild/bazel.git
$ cd bazel
$ git checkout tags/0.1.0
$ ./compile.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面命令中拉取的代码标签为 0.1.0, 兼容 Tensorflow 目前版本. bazel 的HEAD 版本 (即最新版本) 在这里可能不稳定.&lt;/p&gt;

&lt;p&gt;将执行路径 &lt;code class=&quot;highlighter-rouge&quot;&gt;output/bazel&lt;/code&gt; 添加到 &lt;code class=&quot;highlighter-rouge&quot;&gt;$PATH&lt;/code&gt; 环境变量中.&lt;/p&gt;

&lt;h5 id=&quot;安装其他依赖&quot;&gt;安装其他依赖&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install python-numpy swig python-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;mac-os-x-安装&quot;&gt;Mac OS X 安装&lt;/h4&gt;

&lt;p&gt;Mac 和 Linux 需要的软件依赖完全一样, 但是安装过程区别很大. 以下链接用于帮助你 在 Mac OS X 上安装这些依赖:&lt;/p&gt;

&lt;h5 id=&quot;bazel&quot;&gt;Bazel&lt;/h5&gt;

&lt;p&gt;参见&lt;a href=&quot;https://bazel.build/versions/master/docs/install.html&quot;&gt;网页&lt;/a&gt;的 Mac OS X 安装指南.&lt;/p&gt;

&lt;h5 id=&quot;swig&quot;&gt;SWIG&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;http://www.swig.org/Doc3.0/Preface.html#Preface_osx_installation&quot;&gt;Mac OS X 安装教程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意: 你需要安装&lt;a href=&quot;ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/&quot;&gt;PCRE&lt;/a&gt;, 而不是 PCRE2.&lt;/p&gt;

&lt;h5 id=&quot;numpy&quot;&gt;Numpy&lt;/h5&gt;

&lt;p&gt;参见&lt;a href=&quot;https://docs.scipy.org/doc/numpy/user/install.html&quot;&gt;安装教程&lt;/a&gt;.&lt;/p&gt;

&lt;h5 id=&quot;创建-pip-包并安装&quot;&gt;创建 pip 包并安装&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ bazel build -c opt //tensorflow/tools/pip_package:build_pip_package

$ bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg

# .whl 文件的实际名字与你所使用的平台有关
$ pip install /tmp/tensorflow_pkg/tensorflow-0.5.0-cp27-none-linux_x86_64.whl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;二进制安装&quot;&gt;二进制安装&lt;/h3&gt;

&lt;p&gt;TensorFlow Python API 依赖 Python 2.7 版本.&lt;/p&gt;

&lt;p&gt;在 Linux 和 Mac 下最简单的安装方式, 是使用 &lt;a href=&quot;https://pypi.python.org/pypi/pip&quot;&gt;pip&lt;/a&gt; 安装.&lt;/p&gt;

&lt;p&gt;为了简化安装步骤, 建议使用 virtualenv, 具体安装方法在后文具体说明.&lt;/p&gt;

&lt;h4 id=&quot;ubuntulinux&quot;&gt;Ubuntu/Linux&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 仅使用 CPU 的版本
$ pip install https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.5.0-cp27-none-linux_x86_64.whl

# 开启 GPU 支持的版本 (安装该版本的前提是已经安装了 CUDA sdk)
$ pip install https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.5.0-cp27-none-linux_x86_64.whl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;mac-os-x&quot;&gt;Mac OS X&lt;/h4&gt;

&lt;p&gt;在 OS X 系统上, 推荐先安装 &lt;a href=&quot;https://brew.sh/&quot;&gt;homebrew&lt;/a&gt;, 然后执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;brew install python&lt;/code&gt;, 以便能够使用 homebrew 中的 Python 安装 TensorFlow. 另外一种推荐的方式是在 virtualenv 中安装 TensorFlow.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 当前版本只支持 CPU
$ pip install https://storage.googleapis.com/tensorflow/mac/tensorflow-0.5.0-py2-none-any.whl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;基于-virtualenv-的安装&quot;&gt;基于 VirtualEnv 的安装&lt;/h4&gt;

&lt;p&gt;推荐使用 &lt;a href=&quot;https://pypi.python.org/pypi/virtualenv&quot;&gt;virtualenv&lt;/a&gt; 创建一个隔离的容器, 来安装 TensorFlow. 这是可选的, 但是这样做能使排查安装问题变得更容易.&lt;/p&gt;

&lt;p&gt;首先, 安装所有必备工具:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 在 Linux 上:
$ sudo apt-get install python-pip python-dev python-virtualenv

# 在 Mac 上:
$ sudo easy_install pip  # 如果还没有安装 pip
$ sudo pip install --upgrade virtualenv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来, 建立一个全新的 virtualenv 环境. 为了将环境建在 ~/tensorflow 目录下, 执行:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ virtualenv --system-site-packages ~/tensorflow
$ cd ~/tensorflow
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然后, 激活 virtualenv:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ source bin/activate  # 如果使用 bash
$ source bin/activate.csh  # 如果使用 csh
(tensorflow)$  # 终端提示符应该发生变化
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在 virtualenv 内, 安装 TensorFlow:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(tensorflow)$ pip install --upgrade &amp;lt;$url_to_binary.whl&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;接下来, 使用类似命令运行 TensorFlow 程序:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(tensorflow)$ cd tensorflow/models/image/mnist
(tensorflow)$ python convolutional.py

# 当使用完 TensorFlow
(tensorflow)$ deactivate  # 停用 virtualenv

$  # 你的命令提示符会恢复原样
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;运行-tensorflow&quot;&gt;运行 TensorFlow&lt;/h2&gt;

&lt;p&gt;打开一个 python 终端:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python

&amp;gt;&amp;gt;&amp;gt; import tensorflow as tf
&amp;gt;&amp;gt;&amp;gt; hello = tf.constant('Hello, TensorFlow!')
&amp;gt;&amp;gt;&amp;gt; sess = tf.Session()
&amp;gt;&amp;gt;&amp;gt; print sess.run(hello)
Hello, TensorFlow!
&amp;gt;&amp;gt;&amp;gt; a = tf.constant(10)
&amp;gt;&amp;gt;&amp;gt; b = tf.constant(32)
&amp;gt;&amp;gt;&amp;gt; print sess.run(a+b)
42
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 08 Jun 2017 07:45:11 +0800</pubDate>
      </item>
    
      <item>
        <title>拆解 MySQL 的高阶使用与概念</title>
        <link>/web/2017/05/29/mysql-advanced-study.html</link>
        <guid isPermaLink="true">/web/2017/05/29/mysql-advanced-study.html</guid>
        <description>&lt;p&gt;前面我们主要分享了MySQL中的常见知识与使用。这里我们主要分享一下MySQL中的高阶使用，主要包括：函数、存储过程和存储引擎。&lt;/p&gt;

&lt;p&gt;对于MySQL中的基础知识，可以参见&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/2017/05/16/mysql-study/&quot;&gt;《与 MySQL 的零距离接触》&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;1-函数&quot;&gt;1 函数&lt;/h1&gt;

&lt;p&gt;函数可以返回任意类型的值，也可以接收这些类型的参数。&lt;/p&gt;

&lt;h2 id=&quot;字符函数&quot;&gt;字符函数&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;函数名称&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;CONCAT()&lt;/td&gt;
      &lt;td&gt;字符连接&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CONCAT_WS()&lt;/td&gt;
      &lt;td&gt;使用指定的分隔符进行字符连接&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FORMAT()&lt;/td&gt;
      &lt;td&gt;数字格式化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LOWER()&lt;/td&gt;
      &lt;td&gt;转换成小写字母&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;UPPER()&lt;/td&gt;
      &lt;td&gt;转换成大写字母&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LEFT()&lt;/td&gt;
      &lt;td&gt;获取左侧字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RIGHT()&lt;/td&gt;
      &lt;td&gt;获取右侧字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LENGTH()&lt;/td&gt;
      &lt;td&gt;获取字符串长度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LTRIM()&lt;/td&gt;
      &lt;td&gt;删除前导空格&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RTRIM()&lt;/td&gt;
      &lt;td&gt;删除后续空格&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TRIM()&lt;/td&gt;
      &lt;td&gt;删除前导和后续空格&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SUBSTRING()&lt;/td&gt;
      &lt;td&gt;字符串截取&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[NOT] LIKE&lt;/td&gt;
      &lt;td&gt;模式匹配&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;REPLACE()&lt;/td&gt;
      &lt;td&gt;字符串替换&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;函数可以嵌套使用。
&lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;（百分号）：代表任意个字符。
&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;（下划线）：代表任意一个字符。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 删除前导'?'符号
SELECT TRIM(LEADING '?' FROM '??MySQL???');
# 删除后续'?'符号
SELECT TRIM(TRAILING '?' FROM '??MySQL???');
# 删除前后'?'符号
SELECT TRIM(BOTH '?' FROM '??My??SQL???');
# 将'?'符号替换成'!'符号
SELECT REPLACE('??My??SQL???', '?', '!');
# 从中'MySQL'第1个开始，截取2个字符
SELECT SUBSTRING('MySQL', 1, 2);
# 从中'MySQL'截取最后1个字符
SELECT SUBSTRING('MySQL', -1);
# 从中'MySQL'第2个开始，截取至结尾
SELECT SUBSTRING('MySQL', 2);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;数值运算符函数&quot;&gt;数值运算符函数&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;函数名称&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;CEIL()&lt;/td&gt;
      &lt;td&gt;进一取整&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DIV&lt;/td&gt;
      &lt;td&gt;整数除法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FLOOR()&lt;/td&gt;
      &lt;td&gt;舍一取整&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MOD&lt;/td&gt;
      &lt;td&gt;取余数（取模）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POWER()&lt;/td&gt;
      &lt;td&gt;幂运算&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ROUND()&lt;/td&gt;
      &lt;td&gt;四舍五入&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TRUNCATE()&lt;/td&gt;
      &lt;td&gt;数字截取&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;比较运算符函数&quot;&gt;比较运算符函数&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;函数名称&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[NOT]BETWEEN…AND..&lt;/td&gt;
      &lt;td&gt;[不]在范围之内&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[NOT]IN()&lt;/td&gt;
      &lt;td&gt;[不]在列出值范围内&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IS[NOT]NULL&lt;/td&gt;
      &lt;td&gt;[不]为空&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;日期时间函数&quot;&gt;日期时间函数&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;函数名称&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;NOW()&lt;/td&gt;
      &lt;td&gt;当前日期和时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CURDATE()&lt;/td&gt;
      &lt;td&gt;当前日期&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CURTIME()&lt;/td&gt;
      &lt;td&gt;当前时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DATE_ADD()&lt;/td&gt;
      &lt;td&gt;日期变化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DATEDIFF()&lt;/td&gt;
      &lt;td&gt;日期差值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DATE_FORMAT()&lt;/td&gt;
      &lt;td&gt;日期格式化&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 时间增加1年
SELECT DATE_ADD('2016-05-28', INTERVAL 365 DAY);
# 时间减少1年
SELECT DATE_ADD('2016-05-28', INTERVAL -365 DAY);
# 时间增加3周
SELECT DATE_ADD('2016-05-28', INTERVAL 3 WEEK);
# 日期格式化
SELECT DATE_FORMAT('2016-05-28', '%m/%d/%Y');
# 更多时间格式可以前往MySQL官网查看手册
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;信息函数&quot;&gt;信息函数&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;函数名称&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;CONNECTION_ID()&lt;/td&gt;
      &lt;td&gt;连接ID&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DATEBASE()&lt;/td&gt;
      &lt;td&gt;当前数据库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LAST_INSERT_ID()&lt;/td&gt;
      &lt;td&gt;最后插入记录的ID号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;USER()&lt;/td&gt;
      &lt;td&gt;当前用户&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VERSION()&lt;/td&gt;
      &lt;td&gt;版本信息&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;聚合函数&quot;&gt;聚合函数&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;函数名称&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;AVG()&lt;/td&gt;
      &lt;td&gt;平均值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;COUNT()&lt;/td&gt;
      &lt;td&gt;计数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MAX()&lt;/td&gt;
      &lt;td&gt;最大值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MIN()&lt;/td&gt;
      &lt;td&gt;最小值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SUM()&lt;/td&gt;
      &lt;td&gt;求和&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;加密函数&quot;&gt;加密函数&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;函数名称&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;MD5()&lt;/td&gt;
      &lt;td&gt;信息摘要算法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PASSWORD()&lt;/td&gt;
      &lt;td&gt;密码算法&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;自定义函数&quot;&gt;自定义函数&lt;/h2&gt;

&lt;p&gt;用户自定义函数（user-defined function，UDF）是一种对MySQL扩展的途径，其用法与内置函数相同。UDF是对MySQL扩展的一种途径。&lt;/p&gt;

&lt;h3 id=&quot;必要条件&quot;&gt;必要条件&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;参数：可以有零个或多个&lt;/li&gt;
  &lt;li&gt;返回值：只能有一个&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数和返回值没有必然的联系。&lt;/p&gt;

&lt;h3 id=&quot;创建自定义函数&quot;&gt;创建自定义函数&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CREATE FUNCTION function_name RETURNS {STRING|INTEGER|REAL|DECIMAL} routine_body&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;函数体routine_body&quot;&gt;函数体（routine_body）&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;函数体由合法的SQL语句构成；&lt;/li&gt;
  &lt;li&gt;函数体可以是简单的SELECT或INSERT语句；&lt;/li&gt;
  &lt;li&gt;函数体如果为复合结构则使用BEGIN…END语句；&lt;/li&gt;
  &lt;li&gt;复合结构可以包含声明，循环，控制结构。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 不带参数
CREATE FUNCTION f1() RETURNS VARCHAR(30) RETURN DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');

# 带参数
CREATE FUNCTION f2(num1 SMALLINT UNSIGNED, num2 SMALLINT UNSIGNED) RETURNS FLOAT(10, 2) UNSIGNED RETURN (num1 + num2) / 2;

# 具有复合结构函数体
# 可能需要使用DELIMITER命令修改分隔符
CREATE FUNCTION f3(username VARCHAR(20)) RETURNS INT UNSIGNED 
BEGIN 
INSERT test(username) VALUES(username);
RETURN LAST_INSERT_ID();
END
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;2-存储过程&quot;&gt;2 存储过程&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-22.png&quot; alt=&quot;命令执行流程&quot; /&gt;
存储过程是SQL语句和控制语句的预编译集合，以一个名称存储作为一个单元处理。可以由用户调用执行，允许用户声明变量以及进行流程控制。存储过程可以接收输入类型的参数，也可以接收输出类型的参数，并可以存在多个返回值。执行效率比单一的SQL语句高。&lt;/p&gt;

&lt;h2 id=&quot;优点&quot;&gt;优点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;增强SQL语句的功能和灵活性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在存储过程中可以写控制语句具有很强的灵活性，可以完成复杂的判断及较复杂的运算。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实现较快的执行速度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果某一操作包含了大量的SQL语句，那么这些SQL语句都将被MySQL引擎执行语法分析、编译、执行，所以效率相对过低。而存储过程是预编译的，当客户端第一次调用存储过程时，MySQL的引擎将对它进行语法分析、编译等操作，然后把这个编译的结果存储到内存中，所以说第一次使用的时候效率和以前是相同的。但是以后客户端再次调用这个存储过程时，直接从内存中执行，所以说效率比较高，速度比较快。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;减少网络流量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果通过客户端每一个单独发送SQL语句让服务器来执行，那么通过http协议来提交的数据量相对来说较大。&lt;/p&gt;

&lt;h2 id=&quot;创建&quot;&gt;创建&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE [DEFINER = {user|CURRENT_USER}] PROCEDURE sp_name ([proc_parameter[, ...]]) [characteristic ...] routine_body
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proc_parameter &lt;/code&gt;:
&lt;code class=&quot;highlighter-rouge&quot;&gt;[IN | OUT | INOUT] param_name type&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;参数：
&lt;code class=&quot;highlighter-rouge&quot;&gt;IN&lt;/code&gt;，表示该参数的值必须在调用存储过程时指定。
&lt;code class=&quot;highlighter-rouge&quot;&gt;OUT&lt;/code&gt;，表示该参数值可以被存储过程改变，并且可以返回。
&lt;code class=&quot;highlighter-rouge&quot;&gt;INOUT&lt;/code&gt;，表示该参数的调用时指定，并且可以被改变和返回。&lt;/p&gt;

&lt;p&gt;特性：
&lt;code class=&quot;highlighter-rouge&quot;&gt;COMMENT&lt;/code&gt;注释
&lt;code class=&quot;highlighter-rouge&quot;&gt;CONTAINS SQL&lt;/code&gt;包含SQL语句，但不包含读或写数据的语句。
&lt;code class=&quot;highlighter-rouge&quot;&gt;NO SQL&lt;/code&gt;不包含SQL语句。
&lt;code class=&quot;highlighter-rouge&quot;&gt;READS SQL DATA&lt;/code&gt;包含读写数据的语句。
&lt;code class=&quot;highlighter-rouge&quot;&gt;MODIFIES SQL DATA&lt;/code&gt;包含写数据的语句。
&lt;code class=&quot;highlighter-rouge&quot;&gt;SQL SECURITY {DEFINER | INVOKER}&lt;/code&gt;指明谁有权限来执行。&lt;/p&gt;

&lt;h2 id=&quot;过程体&quot;&gt;过程体&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;过程体由合法的SQL语句构成；&lt;/li&gt;
  &lt;li&gt;过程体可以是任意SQL语句；
不能通过存储过程来创建数据表、数据库。可以通过存储过程对数据进行增、删、改、查和多表连接操作。&lt;/li&gt;
  &lt;li&gt;过程体如果为复合结构则使用BEGIN…END语句；&lt;/li&gt;
  &lt;li&gt;复合结构中可以包含声明、循环、控制结构。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;调用&quot;&gt;调用&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CALL sp_name ([parameter[, ...]])
CALL sp_name[()]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;删除&quot;&gt;删除&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DROP PROCEDURE [IF EXISTS] sp_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;修改&quot;&gt;修改&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER PROCEDURE sp_name [characteristic ...] COMMENT 'string'
| {CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}
| SQL SECURITY {DEFINER | INVOKER}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;存储过程与自定义函数的区别&quot;&gt;存储过程与自定义函数的区别&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;存储过程实现的功能要复杂一些，而函数的针对性更强。&lt;/li&gt;
  &lt;li&gt;存储过程可以返回多个值，函数只能有一个返回值。&lt;/li&gt;
  &lt;li&gt;存储过程一般独立执行，函数可以作为其他SQL语句的组成部分来实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 创建不带参数的存储过程
CREATE PROCEDURE sp1() SELECT VERSION();

# 创建带有IN类型参数的存储过程(users为数据表名)
# 参数的名字不能和数据表中的记录名字一样
CREATE PROCEDURE removeUserById(IN p_id INT UNSIGNED)
BEGIN
DELETE FROM users WHERE id = p_id;
END

# 创建带有IN和OUT类型参数的存储过程(users为数据表名)
CREATE PROCEDURE removeUserAndReturnUserNumsById(IN p_id INT UNSIGNED, OUT userNums INT UNSIGNED)
BEGIN
DELETE FROM users WHERE id = p_id;
SELECT COUNT(id) FROM users INTO userNums;
END

# 创建带有多个OUT类型参数的存储过程(users为数据表名)
CREATE PROCEDURE removeUserAndReturnInfosByAge(IN p_age SMALLINT UNSIGNED, OUT delUser SMALLINT UNSIGNED,  OUT userNums SMALLINT UNSIGNED)
BEGIN
DELETE FROM users WHERE age = p_age;
SELECT ROW_COUNT INTO delUser;
SELECT COUNT(id) FROM users INTO userNums;
END
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;3-存储引擎&quot;&gt;3 存储引擎&lt;/h1&gt;

&lt;p&gt;MySQL可以将数据以不同的技术存储在文件（内存）中，这种技术就称为存储引擎。
每一种存储引擎使用不同的存储机制、索引技巧、锁定水平，最终提供广泛且不同的功能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;锁
共享锁（读锁）：在同一时间段内，多个用户可以读取同一个资源，读取过程中数据不会发生任何变化。
排他锁（写锁）：在任何时候只能有一个用户写入资源，当进行写锁时会阻塞其他的读锁或者写锁操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;锁颗粒
表锁：是一种开销最小的锁策略。
行锁：是一种开销最大的锁策略。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;并发控制
当多个连接记录进行修改时保证数据的一致性和完整性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;事务
事务用于保证数据库的完整性。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举例：用户银行转账
&lt;code class=&quot;highlighter-rouge&quot;&gt;用户A&lt;/code&gt; 转账200元 &lt;code class=&quot;highlighter-rouge&quot;&gt;用户B&lt;/code&gt;
实现步骤：
1）从当前账户减掉200元（账户余额大于等于200元）。
2）在对方账户增加200元。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事务特性：&lt;/strong&gt;
1）原子性（atomicity）
2）一致性（consistency）
3）隔离性（isolation）
4）持久性（durability）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;外键
是保证数据一致性的策略。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;索引
是对数据表中一列或多列的值进行排序的一种结构。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;类型&quot;&gt;类型&lt;/h2&gt;

&lt;p&gt;MySQL主要支持以下几种引擎类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MyISAM&lt;/li&gt;
  &lt;li&gt;InnoDB&lt;/li&gt;
  &lt;li&gt;Memory&lt;/li&gt;
  &lt;li&gt;CSV&lt;/li&gt;
  &lt;li&gt;Archive&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;各类存储引擎特点&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;特点&lt;/th&gt;
      &lt;th&gt;MyISAM&lt;/th&gt;
      &lt;th&gt;InnoDB&lt;/th&gt;
      &lt;th&gt;Memory&lt;/th&gt;
      &lt;th&gt;Archive&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;存储限制&lt;/td&gt;
      &lt;td&gt;256TB&lt;/td&gt;
      &lt;td&gt;64TB&lt;/td&gt;
      &lt;td&gt;有&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;事务安全&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持索引&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;锁颗粒&lt;/td&gt;
      &lt;td&gt;表锁&lt;/td&gt;
      &lt;td&gt;行锁&lt;/td&gt;
      &lt;td&gt;表锁&lt;/td&gt;
      &lt;td&gt;行锁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;数据压缩&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持外键&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;CSV:实际上是由逗号分隔的数据引擎，在数据库子目录为每一个表创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;.csv&lt;/code&gt;的文件，这是一种普通的文本文件，每一个数据行占用一个文本行。不支持索引。&lt;/p&gt;

&lt;p&gt;BlackHole：黑洞引擎，写入的数据都会消失，一般用于做数据复制的中继。&lt;/p&gt;

&lt;p&gt;MyISAM：适用于事务的处理不多的情况。&lt;/p&gt;

&lt;p&gt;InnoDB：适用于事务处理比较多，需要有外键支持的情况。&lt;/p&gt;

&lt;p&gt;索引分类：普通索引、唯一索引、全文索引、btree索引、hash索引…&lt;/p&gt;

&lt;h2 id=&quot;修改存储引擎&quot;&gt;修改存储引擎&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;通过修改MySQL配置文件
&lt;code class=&quot;highlighter-rouge&quot;&gt;default-storage-engine=engine_name&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;通过创建数据表命令实现
&lt;code class=&quot;highlighter-rouge&quot;&gt;CREATE TABLE table_name(...)ENGINE=engine_name&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;通过修改数据表命令实现
&lt;code class=&quot;highlighter-rouge&quot;&gt;ALTER TABLE table_name ENGINE[=]engine_name&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;4-管理工具&quot;&gt;4 管理工具&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;phpMyAdmin
需要有PHP环境&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Navicat&lt;/li&gt;
  &lt;li&gt;MySQL Workbench&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 29 May 2017 23:31:40 +0800</pubDate>
      </item>
    
      <item>
        <title>MySQL 中的SQL</title>
        <link>/web/2017/05/19/mysql-sql-study.html</link>
        <guid isPermaLink="true">/web/2017/05/19/mysql-sql-study.html</guid>
        <description>&lt;p&gt;结构化查询语言（英语：Structured Query Language，缩写：SQL），是一种特殊目的之编程语言，用于数据库中的标准数据查询语言，IBM公司最早使用在其开发的数据库系统中。&lt;/p&gt;

&lt;p&gt;不过各种通行的数据库系统在其实践过程中都对SQL规范作了某些编改和扩充。所以，实际上不同数据库系统之间的SQL不能完全相互通用。&lt;/p&gt;

&lt;p&gt;文章以MySQL数据库为演示环境，主要分享MySQL中的SQL使用。&lt;/p&gt;

&lt;h2 id=&quot;数据库操作&quot;&gt;数据库操作&lt;/h2&gt;

&lt;h3 id=&quot;创建数据库&quot;&gt;创建数据库&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] character_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{}&lt;/code&gt;表示为必选项，即必填参数。&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;表示选项，即其中选取一项即可。&lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt;表示为可选项。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;character_name &lt;/code&gt;参数为指定数据库的编码方式，不填则使用MySQL配置的字符集编码。&lt;/p&gt;

&lt;h3 id=&quot;查看当前服务器下的数据表列表&quot;&gt;查看当前服务器下的数据表列表&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SHOW {DATABASES | SCHEMAS} [LIKE 'pattern' | WHERE expr]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;删除数据库&quot;&gt;删除数据库&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DROP {DATABASE | SCHEMA} [IF NOT EXISTS] db_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;auto_increment&quot;&gt;AUTO_INCREMENT&lt;/h2&gt;

&lt;p&gt;自动编号，且必须与主键组合使用。&lt;/p&gt;

&lt;p&gt;数值型数据。&lt;/p&gt;

&lt;p&gt;默认情况下，起始值为1，每次的增量为1。&lt;/p&gt;

&lt;h2 id=&quot;约束&quot;&gt;约束&lt;/h2&gt;

&lt;p&gt;1.保证数据的完整性和一致性。&lt;/p&gt;

&lt;p&gt;2.分为表级约束（针对两个或两个以上的字段进行约束）和列级约束（针对某一个字段进行约束）。&lt;/p&gt;

&lt;p&gt;3.类型包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NOT NULL 非空约束&lt;/li&gt;
  &lt;li&gt;PRIMARY KEY 主键约束&lt;/li&gt;
  &lt;li&gt;UNIQUE KEY 唯一约束&lt;/li&gt;
  &lt;li&gt;DEFAULT 默认约束&lt;/li&gt;
  &lt;li&gt;FOREIGN KEY 外键约束&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE t6(id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY, username VARCHAR(20) NOT NULL UNIQUE KEY, sex ENUM('1', '2', '3') DEFAULT '3');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-05.png&quot; alt=&quot;t6表结构&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSERT t6 (username) VALUES ('Chars');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-06.png&quot; alt=&quot;t6表插入值&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;空值与非空值&quot;&gt;空值与非空值&lt;/h3&gt;

&lt;p&gt;NULL，字段值可以为空。&lt;/p&gt;

&lt;p&gt;NOT NULL，字段值禁止为空。不存在表级约束。&lt;/p&gt;

&lt;h3 id=&quot;primary-key&quot;&gt;PRIMARY KEY&lt;/h3&gt;

&lt;p&gt;主键约束。&lt;/p&gt;

&lt;p&gt;每张数据表只能存在一个主键。&lt;/p&gt;

&lt;p&gt;主键保证记录的唯一性。&lt;/p&gt;

&lt;p&gt;主键自动为NOT NULL。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AUTO_INCREMENT&lt;/code&gt;必须与&lt;code class=&quot;highlighter-rouge&quot;&gt;PRIMARY KEY&lt;/code&gt;一起使用。但是，&lt;code class=&quot;highlighter-rouge&quot;&gt;PRIMARY KEY&lt;/code&gt;不一定与&lt;code class=&quot;highlighter-rouge&quot;&gt;AUTO_INCREMENT&lt;/code&gt;一起使用。&lt;/p&gt;

&lt;h3 id=&quot;unique-key&quot;&gt;UNIQUE KEY&lt;/h3&gt;

&lt;p&gt;唯一约束。&lt;/p&gt;

&lt;p&gt;唯一约束可以保证记录的唯一性。&lt;/p&gt;

&lt;p&gt;唯一约束的字段可以为空值（NULL）。&lt;/p&gt;

&lt;p&gt;每张数据表可以存在多个唯一约束。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：UNIQUE KEY与PRIMARY KEY区别&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PRIMARY KEY每张数据表只能有一个，且不能为空。&lt;/p&gt;

&lt;p&gt;UNIQUE KEY每张数据表可以有多个，且可以为空。&lt;/p&gt;

&lt;h3 id=&quot;default&quot;&gt;DEFAULT&lt;/h3&gt;

&lt;p&gt;默认值。&lt;/p&gt;

&lt;p&gt;当插入记录时，如果没有明确为字段赋值，则自动赋予默认值。&lt;/p&gt;

&lt;p&gt;不存在表级约束。&lt;/p&gt;

&lt;h3 id=&quot;foreign-key&quot;&gt;FOREIGN KEY&lt;/h3&gt;

&lt;p&gt;保持数据一致性，完整性。&lt;/p&gt;

&lt;p&gt;实现一对一或一对多关系。&lt;/p&gt;

&lt;p&gt;关系型数据库名称的来源。&lt;/p&gt;

&lt;h4 id=&quot;外键约束的要求&quot;&gt;外键约束的要求&lt;/h4&gt;

&lt;p&gt;1.父表和子表必须使用相同的存储引擎，而且禁止使用临时表。&lt;/p&gt;

&lt;p&gt;2.数据表的存储引擎只能为InnoDB。&lt;/p&gt;

&lt;p&gt;3.外键列和参照列必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度则可以不同。&lt;/p&gt;

&lt;p&gt;4.外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL将自动创建索引。&lt;/p&gt;

&lt;h4 id=&quot;外键约束的参照操作&quot;&gt;外键约束的参照操作&lt;/h4&gt;

&lt;p&gt;1.CASCADE：从父表删除或更新且自动删除或更新子表中匹配的行。&lt;/p&gt;

&lt;p&gt;2.SET NULL：从父表删除或更新行，并设置子表中的外键列为NULL。如果使用该选项，必须保证子表列没有指定NOT NULL。&lt;/p&gt;

&lt;p&gt;3.RESTRICT：拒绝对父表的删除或更新操作。&lt;/p&gt;

&lt;p&gt;4.NO ACTION：标准SQL的关键字，在MySQL中与RESTRICT相同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;物理外键即使用FOREIGN KEY关键字定义表。逻辑外键即定义表的时候按照某种联系，但是不使用FOREIGN KEY关键字修饰。&lt;/p&gt;

&lt;h4 id=&quot;编辑数据表的默认存储引擎&quot;&gt;编辑数据表的默认存储引擎&lt;/h4&gt;

&lt;p&gt;MySQL配置文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;default-storage-engine=INNODB&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;create table provinces(id smallint unsigned primary key auto_increment, pname varchar(20) not null);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;create table users(id smallint unsigned primary key auto_increment, username varchar(10) not null, pid bigint, foreign key(pid) references provinces(id));

# 报错
# ERROR 1215 (HY000): Cannot add foreign key constraint
# 因为类型不匹配

# 正确命令应该是：
create table users(id smallint unsigned primary key auto_increment, username varchar(10) not null, pid smallint unsigned, foreign key(pid) references provinces(id));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-07.png&quot; alt=&quot;provinces表索引结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-08.png&quot; alt=&quot;users表索引结构&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;表级约束和列级约束&quot;&gt;表级约束和列级约束&lt;/h3&gt;

&lt;p&gt;对一个数据列建立的约束，称为列级约束。&lt;/p&gt;

&lt;p&gt;对多个数据列建立的约束，称为表级约束。&lt;/p&gt;

&lt;p&gt;列级约束既可以在列定义时声明，也可以在列定义后声明。&lt;/p&gt;

&lt;p&gt;表级约束只能在列定义后声明。&lt;/p&gt;

&lt;h2 id=&quot;数据表操作&quot;&gt;数据表操作&lt;/h2&gt;

&lt;p&gt;数据表（或称表）是数据库最重要的组成部分之一，是其它对象的基础。数据表即二维表，行称为记录，列称为字段。&lt;/p&gt;

&lt;h3 id=&quot;use&quot;&gt;USE&lt;/h3&gt;

&lt;p&gt;打开数据库&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;USE 数据库名称;&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;创建数据表&quot;&gt;创建数据表&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE [IF NOT EXISTS] table_name (column_name data_type, ...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;查看数据表列表&quot;&gt;查看数据表列表&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SHOW TABLES [FROM db_name] [LIKE 'pattern' | WHERE expr]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;查看数据表结构&quot;&gt;查看数据表结构&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SHOW COLUMNS FROM tbl_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;插入表记录&quot;&gt;插入表记录&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSERT [INTO] tbl_name [(col_name,...)] VALUES(val,...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果省略col_name就需要写全数据表所有的值。&lt;/p&gt;

&lt;h3 id=&quot;记录查找&quot;&gt;记录查找&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT expr,... FROM tbl_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;添加单列数据表字段&quot;&gt;添加单列（数据表字段）&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name ADD [COLUMN] col_name column_definition [FIRST|AFTER col_name]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;省略[FIRST&lt;/td&gt;
      &lt;td&gt;AFTER col_name]参数将位于所有列的最后面。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;添加多列数据表字段&quot;&gt;添加多列（数据表字段）&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name ADD [COLUMN] (col_name column_definition, ...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;删除列数据表字段&quot;&gt;删除列（数据表字段）&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name DROP [COLUMN] col_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;添加主键约束&quot;&gt;添加主键约束&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_col_name, ...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;添加唯一约束&quot;&gt;添加唯一约束&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] UNIQUE [INDEX|KEY] [index_name] [index_type] (index_col_name, ...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;添加外键约束&quot;&gt;添加外键约束&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] FOREIGN KEY [index_name] (index_col_name, ...) reference_definition
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;添加删除默认约束&quot;&gt;添加／删除默认约束&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name ALTER [COLUMN] col_name {SET DEFAULT literal | DROP DEFAULT}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;删除主键约束&quot;&gt;删除主键约束&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name DROP PRIMARY KEY
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;删除唯一约束&quot;&gt;删除唯一约束&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name DROP {INDEX | KEY} index_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;删除外键约束&quot;&gt;删除外键约束&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;修改列定义&quot;&gt;修改列定义&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name MODIFY [COLUMN] col_name column_definition [FIRST | AFTER col_name]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;修改列名称&quot;&gt;修改列名称&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name CHANGE [COLUMN] old_col_name new_col_name column_definition [FIRST | AFTER col_name]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;数据表更名&quot;&gt;数据表更名&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 方法1
ALTER TABLE tbl_name RENAME [TO|AS] new_tbl_name

# 方法2
RENAME TABLE tbl_name TO new_tbl_name [, tbl_name2 TO new_tbl_name2] ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;数据表数据操作&quot;&gt;数据表数据操作&lt;/h2&gt;

&lt;h3 id=&quot;insert&quot;&gt;INSERT&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 插入记录（可以插入多条记录）
INSERT [INTO] tbl_name [(col_name, ...)] {VALUES|VALUE} ({expr|DEFAULT}, ...), (...), ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 插入记录（不可以插入多条记录）
INSERT [INTO] tbl_name SET col_name = {expr|DEFAULT}, ...

# 说明：与前一种方式的区别在于，此方法可以使用子查询（SubQuery）。由比较运算引发子查询（SubQuery）。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 插入记录
INSERT [INTO] tbl_name [(col_name, ...)] SELECT ...

# 说明：此方法可以将查询结果插入到指定数据表。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.创建“商品分类”表
CREATE TABLE IF NOT EXISTS tdb_goods_cates(cate_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,cate_name VARCHAR(40));

2.查询tdb_goods表的所有记录，并且按&quot;类别&quot;分组
SELECT goods_cate FROM tdb_goods GROUP BY goods_cate;

3.将分组结果写入到tdb_goods_cates数据表
INSERT tdb_goods_cates (cate_name) SELECT goods_cate FROM tdb_goods GROUP BY goods_cate;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;update&quot;&gt;UPDATE&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 更新记录（单表更新）
UPDATE [LOW_PRIORITY] [IGNORE] table_reference SET col_name1 = {expr|DEFAULT} [, col_name2 = {expr|DEFAULT}] ... [WHERE where_condition]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;delete&quot;&gt;DELETE&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 删除记录（单表删除）
DELETE FROM tbl_name [WHERE where_condition]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;select&quot;&gt;SELECT&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 查找记录
SELECT select_expr [, select_expr ...] 
[
	FROM table_references
	[WHERE where_condition]
	[GROUP BY {col_name|position} [ASC|DESC], ... ]
	[HAVING where_condition]
	[ORDER BY {col_name|expr|position} [ASC|DESC], ...]
	[LIMIT {[offset,] row_count | row_count OFFSET offset}]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;select_expr-查询表达式&quot;&gt;select_expr 查询表达式&lt;/h4&gt;

&lt;p&gt;每一个表达式表示想要的一列，必须至少有一个。&lt;/p&gt;

&lt;p&gt;多个列之间以英文逗号分隔。&lt;/p&gt;

&lt;p&gt;星号（&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;）表示多有列。&lt;code class=&quot;highlighter-rouge&quot;&gt;tbl_name.*&lt;/code&gt;可以表示命名表的所有列。&lt;/p&gt;

&lt;p&gt;查询表达式可以使用[AS] alias_name为其赋予别名。&lt;/p&gt;

&lt;p&gt;别名可用于GROUP BY，ORDER BY或HAVING子句。&lt;/p&gt;

&lt;h4 id=&quot;where-条件表达式&quot;&gt;WHERE 条件表达式&lt;/h4&gt;

&lt;p&gt;对记录进行过滤，如果没有指定WHERE子句，则显示所有记录。&lt;/p&gt;

&lt;p&gt;在WHERE表达式中，可以使用MySQL支持的函数或运算符。&lt;/p&gt;

&lt;h4 id=&quot;group-by-查询结果分组&quot;&gt;GROUP BY 查询结果分组&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[GROUP BY {col_name|position} [ASC|DESC], ... ]&lt;/code&gt;
ASC：生序，默认值。
DESC：降序。&lt;/p&gt;

&lt;h4 id=&quot;having-分组条件&quot;&gt;HAVING 分组条件&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[HAVING where_condition]&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;where_condition&lt;/code&gt;中要么使用聚合函数，要么出现的字段一定要在SELECT中出现。&lt;/p&gt;

&lt;p&gt;聚合函数：count() …&lt;/p&gt;

&lt;h4 id=&quot;order-by-对查询结果进行排序&quot;&gt;ORDER BY 对查询结果进行排序&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[ORDER BY {col_name|expr|position} [ASC|DESC], ...]&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;limit-限制查询返回的数量&quot;&gt;LIMIT 限制查询返回的数量&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[LIMIT {[offset,] row_count | row_count OFFSET offset}]&lt;/code&gt;
offset是从0开始的。&lt;/p&gt;

&lt;h3 id=&quot;create--select&quot;&gt;CREATE … SELECT&lt;/h3&gt;

&lt;p&gt;创建数据表同时将查询结果写入到数据表
&lt;code class=&quot;highlighter-rouge&quot;&gt;CREATE TABLE [IF NOT EXISTS] tbl_name [(create_definition, ...)] select_statement&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过CREATE…SELECT来创建数据表并且同时写入记录
&lt;code class=&quot;highlighter-rouge&quot;&gt;CREATE TABLE tdb_goods_brands (brand_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,brand_name VARCHAR(40) NOT NULL) SELECT brand_name FROM tdb_goods GROUP BY brand_name;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;子查询&quot;&gt;子查询&lt;/h2&gt;

&lt;p&gt;子查询（Subquery）是指出现在其他SQL语句内的SELECT子句。例如：
&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT * FROM t1 WHERE col1=(SELECT col2 FROM t2);&lt;/code&gt;
其中&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT * FROM t1&lt;/code&gt;称为Outer Query/Outer Statement。&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT col2 FROM t2&lt;/code&gt;称为SubQuery。&lt;/p&gt;

&lt;p&gt;子查询指嵌套在查询内部，且必须始终出现在圆括号内。子查询可以包含多个关键字或条件，如DISTINCT、GROUP BY、ORDER BY、LIMIT函数等。子查询外层的查询可以是：SELECT、INSERT、UPDATE、SET或DO。&lt;/p&gt;

&lt;p&gt;子查询可以返回标量、一行、一列或子查询。&lt;/p&gt;

&lt;h3 id=&quot;数据准备&quot;&gt;数据准备&lt;/h3&gt;

&lt;p&gt;1.创建表&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;create table tdb_goods (
	goods_id smallint unsigned primary key auto_increment,
	goods_name varchar(150) not null, 
	goods_cate varchar(40) not null, 
	brand_name varchar(40) not null,
	goods_price decimal(15,3) unsigned default 0 not null, 
	is_show boolean default 1 not null, 
	is_saleoff boolean default 0 not null);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.添加数据&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES('Mac Pro MD878CH/A 专业级台式电脑','服务器/工作站','苹果','28888',DEFAULT,DEFAULT);
 
INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES(' HMZ-T3W 头戴显示设备','笔记本配件','索尼','6999',DEFAULT,DEFAULT);

INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES('商务双肩背包','笔记本配件','索尼','99',DEFAULT,DEFAULT);

INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES('X3250 M4机架式服务器 2583i14','服务器/工作站','IBM','6888',DEFAULT,DEFAULT);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;分类&quot;&gt;分类&lt;/h3&gt;

&lt;h4 id=&quot;使用比较运算符的子查询&quot;&gt;使用比较运算符的子查询&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;=、&amp;gt;、&amp;lt;、&amp;gt;=、&amp;lt;=、&amp;lt;&amp;gt;、!=、&amp;lt;=&amp;gt; ...&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;语法结构
&lt;code class=&quot;highlighter-rouge&quot;&gt;operand comparison_operator subquery&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;求所有电脑产品的平均价格,并且保留两位小数，AVG,MAX,MIN、COUNT、SUM为聚合函数
&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT ROUND(AVG(goods_price),2) AS avg_price FROM tdb_goods;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询所有价格大于平均价格的商品，并且按价格降序排序
&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price &amp;gt; 5845.10 ORDER BY goods_price DESC;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用子查询来实现
&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price &amp;gt; (SELECT ROUND(AVG(goods_price),2) AS avg_price FROM tdb_goods) ORDER BY goods_price DESC;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;用anysome或all修饰的比较运算符&quot;&gt;用ANY、SOME或ALL修饰的比较运算符&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;operand comparison_operator ANY(subquery)&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;operand comparison_operator SOME(subquery)&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;operand comparison_operator ALL(subquery)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ANY、SOME、ALL关键字&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;查询价格大于或等于”超级本”价格的商品，并且按价格降序排列
&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price = ANY(SELECT goods_price FROM tdb_goods WHERE goods_cate = '超级本') ORDER BY goods_price DESC;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;使用notin的子查询&quot;&gt;使用[NOT]IN的子查询&lt;/h4&gt;

&lt;p&gt;语法结构
&lt;code class=&quot;highlighter-rouge&quot;&gt;operand comparison_operator [NOT]IN(subquery)&lt;/code&gt;
=ANY运算符与IN等效。
!=ALL或&amp;lt;&amp;gt;ALL运算符与NOT IN等效。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;= ANY 或 = SOME 等价于 IN
&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price IN (SELECT goods_price FROM tdb_goods WHERE goods_cate = '超级本') ORDER BY goods_price DESC;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;使用notexists的子查询&quot;&gt;使用[NOT]EXISTS的子查询&lt;/h4&gt;

&lt;p&gt;如果子查询返回任何行，EXISTS将返回TRUE；否则为FALSE。&lt;/p&gt;

&lt;h2 id=&quot;连接&quot;&gt;连接&lt;/h2&gt;

&lt;p&gt;MySQL在SELECT语句、多表更新、多表删除语句中支持JOIN操作。&lt;/p&gt;

&lt;h3 id=&quot;多表更新&quot;&gt;多表更新&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UPDATE table_references SET col_name1 = {expr1|DEFAULT} [, col_name2 = {expr2|DEFAULT}] ... [WHERE where_condition]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;table_references &lt;/code&gt;的语法结构：
&lt;code class=&quot;highlighter-rouge&quot;&gt;{[INNER|CROSS] JOIN | {LEFT|RIGHT} [OUTER] JOIN} table_reference ON conditional_expr&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;数据表参照&quot;&gt;数据表参照&lt;/h4&gt;

&lt;p&gt;table_references
&lt;code class=&quot;highlighter-rouge&quot;&gt;tbl_name [[AS] alias]|table_subquery [AS] alias&lt;/code&gt;
数据表可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;tbl_name AS alias_name&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;tbl_name alias_name&lt;/code&gt;赋予别名。
&lt;code class=&quot;highlighter-rouge&quot;&gt;table_subquery&lt;/code&gt;可以作为子查询使用在FROM子句中，这样的子查询必须为其赋予别名。&lt;/p&gt;

&lt;h4 id=&quot;连接类型&quot;&gt;连接类型&lt;/h4&gt;

&lt;p&gt;INNER JOIN，内连接。在MySQL中，JOIN，CROSS JOIN和INNER JOIN是等价的。
LEFT [OUTER] JOIN，左外连接。
RIGHT [OUTER] JOIN，右外连接。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过tdb_goods_cates数据表来更新tdb_goods表
&lt;code class=&quot;highlighter-rouge&quot;&gt;UPDATE tdb_goods INNER JOIN tdb_goods_cates ON goods_cate = cate_name SET goods_cate = cate_id ;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;多表删除&quot;&gt;多表删除&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DELETE tbl_name [.*] [, tbl_name [.*]] ... FROM table_references [WHERE where_condition]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;内连接&quot;&gt;内连接&lt;/h3&gt;

&lt;p&gt;显示左表及右表符合连接条件的记录。即仅显示符合连接条件的内容。
&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-11.png?imageView/2/w/150&quot; alt=&quot;内连接&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;外连接&quot;&gt;外连接&lt;/h3&gt;

&lt;p&gt;A LEFT JOIN B join_condition.
数据表B的结果集依赖数据表A。
数据表A的结果集根据左连接条件依赖所有数据表（B表除外）。
左外连接条件决定如何检索数据表B（在没有指定WHERE条件的情况下）。
如果数据表A的某条记录符合WHERE条件，但是在数据表B不存在符合连接条件的记录，将生成一个所有列为空的额外的B行。
如果使用内连接查找的记录在连接数据表中不存在，并且在WHERE子句中尝试以下操作：col_name IS NULL时，如果col_name被定义为NOT NULL，MySQL将在找到符合连接条件的记录后停止搜索更多的行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;左外连接
显示左表的全部记录及右表符合连接条件的记录。
&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-12.png?imageView/2/w/150&quot; alt=&quot;左外连接&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;右外连接
显示右表的全部记录及左表符合连接条件的记录。
&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-13.png?imageView/2/w/150&quot; alt=&quot;右外连接&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;连接条件&quot;&gt;连接条件&lt;/h3&gt;

&lt;p&gt;使用ON关键字来设定连接条件，也可以使用WHERE来代替。
通常使用ON关键字来设定连接条件，使用WHERE关键字进行结果集记录的过滤。&lt;/p&gt;

&lt;h3 id=&quot;无限级分类表设计&quot;&gt;无限级分类表设计&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;无限分类的数据表设计
&lt;code class=&quot;highlighter-rouge&quot;&gt;CREATE TABLE tdb_goods_types(
   type_id   SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
   type_name VARCHAR(20) NOT NULL,
   parent_id SMALLINT UNSIGNED NOT NULL DEFAULT 0
);&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;插入数据&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSERT tdb_goods_types(type_name,parent_id) VALUES('家用电器',DEFAULT);
INSERT tdb_goods_types(type_name,parent_id) VALUES('电脑、办公',DEFAULT);
INSERT tdb_goods_types(type_name,parent_id) VALUES('大家电',1);
INSERT tdb_goods_types(type_name,parent_id) VALUES('生活电器',1);
INSERT tdb_goods_types(type_name,parent_id) VALUES('平板电视',3);
INSERT tdb_goods_types(type_name,parent_id) VALUES('空调',3);
INSERT tdb_goods_types(type_name,parent_id) VALUES('电风扇',4);
INSERT tdb_goods_types(type_name,parent_id) VALUES('饮水机',4);
INSERT tdb_goods_types(type_name,parent_id) VALUES('电脑整机',2);
INSERT tdb_goods_types(type_name,parent_id) VALUES('电脑配件',2);
INSERT tdb_goods_types(type_name,parent_id) VALUES('笔记本',9);
INSERT tdb_goods_types(type_name,parent_id) VALUES('超级本',9);
INSERT tdb_goods_types(type_name,parent_id) VALUES('游戏本',9);
INSERT tdb_goods_types(type_name,parent_id) VALUES('CPU',10);
INSERT tdb_goods_types(type_name,parent_id) VALUES('主机',10);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;自身连接&quot;&gt;自身连接&lt;/h3&gt;

&lt;p&gt;同一个数据表对其自身进行连接。&lt;/p&gt;
</description>
        <pubDate>Fri, 19 May 2017 23:43:18 +0800</pubDate>
      </item>
    
      <item>
        <title>与 MySQL 的零距离接触</title>
        <link>/web/2017/05/17/mysql-study.html</link>
        <guid isPermaLink="true">/web/2017/05/17/mysql-study.html</guid>
        <description>&lt;p&gt;&lt;a href=&quot;https://www.mysql.com/&quot;&gt;MySQL&lt;/a&gt;是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。&lt;/p&gt;

&lt;p&gt;MySQL是一个开源的关系型数据库管理系统，分为社区版和企业版。&lt;/p&gt;

&lt;h1 id=&quot;1-安装&quot;&gt;1 安装&lt;/h1&gt;

&lt;p&gt;直接前往官网 https://www.mysql.com/ ，进入download页面下载所需对应安装版本。默认配置安装即可。&lt;/p&gt;

&lt;h1 id=&quot;2-配置&quot;&gt;2 配置&lt;/h1&gt;

&lt;p&gt;安装成功之后，需要修改密码。详看&lt;a href=&quot;/2017/03/22/mysql-install-config/&quot;&gt;《MySQL 安装配置》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;修改编码方式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[mysql]
default-character-set=utf8

[mysql]
character-set-server=utf8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;3-目录结构&quot;&gt;3 目录结构&lt;/h1&gt;

&lt;p&gt;bin目录，存储可执行文件。&lt;/p&gt;

&lt;p&gt;data目录，存储数据文件。&lt;/p&gt;

&lt;p&gt;docs，文档。&lt;/p&gt;

&lt;p&gt;include目录，存储包含的头文件。&lt;/p&gt;

&lt;p&gt;lib目录，存储库文件。&lt;/p&gt;

&lt;p&gt;share，错误消息和字符集文件。&lt;/p&gt;

&lt;h1 id=&quot;4-命令参数说明&quot;&gt;4 命令参数说明&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-D,–database=name&lt;/td&gt;
      &lt;td&gt;打开指定数据库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–delimiter=name&lt;/td&gt;
      &lt;td&gt;指定分隔符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-h,–host=name&lt;/td&gt;
      &lt;td&gt;服务器名称&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-p,–password[=name]&lt;/td&gt;
      &lt;td&gt;密码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-P,–port=#&lt;/td&gt;
      &lt;td&gt;端口号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–prompt=name&lt;/td&gt;
      &lt;td&gt;设置提示符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-u,–user=name&lt;/td&gt;
      &lt;td&gt;用户名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-V,–version&lt;/td&gt;
      &lt;td&gt;输出版本信息并退出&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;mysql提示符&quot;&gt;MySQL提示符&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;\D&lt;/td&gt;
      &lt;td&gt;完整的日期&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\d&lt;/td&gt;
      &lt;td&gt;当前数据库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\h&lt;/td&gt;
      &lt;td&gt;服务器名称&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\u&lt;/td&gt;
      &lt;td&gt;当前用户&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;命令使用&quot;&gt;命令使用&lt;/h2&gt;

&lt;h3 id=&quot;修改mysql提示符&quot;&gt;修改MySQL提示符&lt;/h3&gt;

&lt;p&gt;1.连接客户端时通过参数指定&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql -uroot -proot --prompt 提示符
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.连接上客户端后，通过prompt命令修改&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt;prompt 提示符
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;mysql常用命令&quot;&gt;MySQL常用命令&lt;/h3&gt;

&lt;p&gt;1.显示当前服务器版本&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT VERSION();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.显示当前日期时间&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT NOW();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.显示当前用户&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT USER();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;mysql语句规范&quot;&gt;MySQL语句规范&lt;/h3&gt;

&lt;p&gt;1.关键字与函数名称全部大写。&lt;/p&gt;

&lt;p&gt;2.数据库名称、表名称、字段名称全部小写。&lt;/p&gt;

&lt;p&gt;3.SQL语句必须以”;”符号结尾。&lt;/p&gt;

&lt;h1 id=&quot;5-sql&quot;&gt;5 SQL&lt;/h1&gt;

&lt;p&gt;结构化查询语言（英语：Structured Query Language，缩写：SQL），是一种特殊目的之编程语言，用于数据库中的标准数据查询语言。
不过各种通行的数据库系统在其实践过程中都对SQL规范作了某些编改和扩充。所以，实际上不同数据库系统之间的SQL不能完全相互通用。&lt;/p&gt;

&lt;p&gt;具体参看文章
&lt;a href=&quot;/2017/05/19/mysql-sql-study/&quot;&gt;《MySQL 中的SQL》&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;6-数据类型&quot;&gt;6 数据类型&lt;/h1&gt;

&lt;p&gt;数据类型是指列、存储过程参数、表达式和局部变量的数据特征，它决定了数据的存储格式，代表了不同信息的类型。&lt;/p&gt;

&lt;h2 id=&quot;整型&quot;&gt;整型&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-01.png&quot; alt=&quot;整型表&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;浮点型&quot;&gt;浮点型&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;数据类型&lt;/th&gt;
      &lt;th&gt;存储范围&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;FLOAT[(M,D)]&lt;/td&gt;
      &lt;td&gt;-3.402823466E+38到-1.175494351E-38、0和1.175494351E-38到3.402823466E+38。M是数字总位数，D是小数点后面的位数。如果M和D被省略，根据硬件允许的限制来保存值。单精度浮点数精确到大约7位小数点。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DOUBLE[(M,D)]&lt;/td&gt;
      &lt;td&gt;-1.7976931348623157E+308到-2.2250738585072014E-308、0和2.2250738585072014E-308到1.7976931348623157E+308。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;日期和时间型&quot;&gt;日期和时间型&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;列类型&lt;/th&gt;
      &lt;th&gt;存储需求&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;YEAR&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TIME&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DATE&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DATETIME&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TIMESTAMP&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;字符型&quot;&gt;字符型&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;列类型&lt;/th&gt;
      &lt;th&gt;存储需求&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;CHAR(M)&lt;/td&gt;
      &lt;td&gt;M个字节，0&amp;lt;=M&amp;lt;=255&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VARCHAR(M)&lt;/td&gt;
      &lt;td&gt;L+1个字节，其中L&amp;lt;=M且0&amp;lt;=M&amp;lt;=65535&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TINYTEXT&lt;/td&gt;
      &lt;td&gt;L+1个字节，其中L&amp;lt;2^8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TEXT&lt;/td&gt;
      &lt;td&gt;L+2个字节，其中L&amp;lt;2^16&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MEDIUMTEXT&lt;/td&gt;
      &lt;td&gt;L+3个字节，其中L&amp;lt;2^24&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LONGTEXT&lt;/td&gt;
      &lt;td&gt;L+4个字节，其中L&amp;lt;2^32&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ENUM(‘VALUE1’,’VALUE2’,…)&lt;/td&gt;
      &lt;td&gt;1或2个字节，取决于枚举值的个数（最多65,535个值）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SET(‘VALUE1’,’VALUE2’,…)&lt;/td&gt;
      &lt;td&gt;1、2、3、4或者8个字节，取决于set成员的数目（最多64个成员）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;更多其他MySQL使用与知识可以参见&lt;a href=&quot;/2017/05/29/mysql-advanced-study/&quot;&gt;《拆解 MySQL 的高阶使用与概念》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 17 May 2017 07:05:12 +0800</pubDate>
      </item>
    
      <item>
        <title>聊聊Objective-C的Runtime</title>
        <link>/pieces/2017/05/09/objc-runtime.html</link>
        <guid isPermaLink="true">/pieces/2017/05/09/objc-runtime.html</guid>
        <description>&lt;p&gt;Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。&lt;/p&gt;

&lt;p&gt;对于Objective-C来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。Runtime基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。&lt;/p&gt;

&lt;p&gt;在Runtime中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。这些结构体和函数被runtime函数封装后，让Objective-C的面向对象编程变为可能。&lt;/p&gt;

&lt;p&gt;找出方法的最终执行代码：当程序执行&lt;code class=&quot;highlighter-rouge&quot;&gt;[object doSomething]&lt;/code&gt;时，会向消息接收者(object)发送一条消息(doSomething)，runtime会根据消息接收者是否能响应该消息而做出不同的反应。&lt;/p&gt;

&lt;h1 id=&quot;1-消息机制&quot;&gt;1 消息机制&lt;/h1&gt;

&lt;p&gt;与古老的C语言不同，Objective-C虽然源自C语言，但是它却是面向对象的，在这之中，消息机制发挥着重大作用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C语言和Objective-C编译时的区别：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C语言在编译的时候，已经知道调用哪一个函数。&lt;/p&gt;

&lt;p&gt;Objective-C不一样，只有在运行时才知道需要调用的方法和函数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;OBJC_EXPORT void objc_msgSend(void /* id self, SEL op, ... */ )
    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用这个方法要&lt;code class=&quot;highlighter-rouge&quot;&gt;#import &amp;lt;objc/message.h&amp;gt;&lt;/code&gt;，另外，Apple在Xcode5开始，不建议使用底层方法，而恰巧以上方法就是底层方法。此时，Xcode就会报错，那么，如何解决呢？&lt;/p&gt;

&lt;p&gt;解决方案如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1）打开Project的&lt;code class=&quot;highlighter-rouge&quot;&gt;Build Settings&lt;/code&gt;，搜索“msg”。&lt;/li&gt;
  &lt;li&gt;2）将&lt;code class=&quot;highlighter-rouge&quot;&gt;Enable Strict Checking of objc_msgSend Calls&lt;/code&gt;的值设置为NO。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;发送无参消息&quot;&gt;发送无参消息&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface Sample : NSObject
+ (void)run;
- (void)run;
- (void)eatWithFood:(NSString *)food;
@end

@implementation Sample
+ (void)run
{
    NSLog(@&quot;类方法 run&quot;);
}

- (void)run
{
    NSLog(@&quot;实例方法 run&quot;);
}

- (void)eatWithFood:(NSString *)food
{
    NSLog(@&quot;实例方法 eat：%@&quot;, food);
}
@end

- (void)test {
	Sample *t = [[Sample alloc] init];
	objc_msgSend(t, @selector(run));

	objc_msgSend([Sample class], @selector(run));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;发送带参消息&quot;&gt;发送带参消息&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)test {
	Sample *t = [[Sample alloc] init];
	objc_msgSend(t, @selector(eatWithFood:), @&quot;apple&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;附加：将Objective-C转换出Runtime代码方法&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clang -rewrite-objc xxxx.m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;交换方法的实现&quot;&gt;交换方法的实现&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;class_getInstanceMethod(__unsafe_unretained Class cls, SEL name)&lt;/code&gt;获取对象方法。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;class_getClassMethod(__unsafe_unretained Class cls, SEL name)&lt;/code&gt;获取类方法。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;method_exchangeImplementations(Method m1, Method m2)&lt;/code&gt;交换方法的实现方式。&lt;/p&gt;

&lt;p&gt;常见示例代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSURL *url = [NSURL URLWithString:@&quot;https://charsdavy.github.io&quot;];
[NSURLRequest requestWithURL:url];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但&lt;code class=&quot;highlighter-rouge&quot;&gt;url&lt;/code&gt;可能返回nil，而此段代码未能对返回值&lt;code class=&quot;highlighter-rouge&quot;&gt;url&lt;/code&gt;进行合法判断。但每次使用以上类似代码都需要进行合法性判断，那么有什么更好的方法使&lt;code class=&quot;highlighter-rouge&quot;&gt;URLWithString:&lt;/code&gt;能够做合法性判断呢？这个时候就需要使用Runtime的特有方法了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface NSURL (DD)
+ (instancetype)dd_URLWithString:(NSString *)URLString;
@end

@implementation NSURL (DD)
// 加载此分类时调用
+ (void)load
{
    //获取方法名称
    Method urlMethod = class_getClassMethod([NSURL class], @selector(URLWithString:));
    Method ddUrlMethod = class_getClassMethod([NSURL class], @selector(dd_URLWithString:));
    //交换方法的实现
    method_exchangeImplementations(urlMethod, ddUrlMethod);
}
//此方法与URLWithString:交换了实现方式
+ (instancetype)dd_URLWithString:(NSString *)URLString
{
//    NSURL *url = [NSURL URLWithString:URLString]; 此处不能再调用此方法，否则会死循环
    NSURL *url = [NSURL dd_URLWithString:URLString];
    if (!url) {
        NSLog(@&quot;url is nil&quot;);
    }
    return url;
}
@end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;归档和解档&quot;&gt;归档和解档&lt;/h2&gt;

&lt;p&gt;先来理解几个Objective-C中的概念：&lt;/p&gt;

&lt;p&gt;序列化：将自定义的Objective-C的对象转化成二进制文件数据。&lt;/p&gt;

&lt;p&gt;反序列化：将二进制文件数据转化成自定义的Objective-C的对象。&lt;/p&gt;

&lt;p&gt;归档：将自定义的Objective-C的对象存储到本地磁盘。&lt;/p&gt;

&lt;p&gt;解档：将存储在本地磁盘的数据转换成自定义的Objective-C的对象。&lt;/p&gt;

&lt;p&gt;Ivar类型：成员属性。&lt;/p&gt;

&lt;p&gt;Method类型：成员方法。&lt;/p&gt;

&lt;p&gt;通常我们使用归档和解档的方式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface Sample : NSObject&amp;lt;NSCoding&amp;gt;
@property (nonatomic) NSString *name;
@property (nonatomic) NSString *age;
@end

@implementation Sample
- (void)encodeWithCoder:(NSCoder *)aCoder
{
    [aCoder encodeObject:self.name forKey:@&quot;name&quot;];
    [aCoder encodeObject:self.age forKey:@&quot;age&quot;];
}
- (instancetype)initWithCoder:(NSCoder *)aDecoder
{
    self = [super init];
    if (self) {
        self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;];
        self.age = [aDecoder decodeObjectForKey:@&quot;age&quot;];
    }
    return self;
}
@end

- (void)saveObject
{
    Sample *p = [[Sample alloc] init];
    p.name = @&quot;Chars&quot;;
    p.age = @&quot;18&quot;;
    
    NSString *path = [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;chars.dat&quot;];
    
    BOOL flag = [NSKeyedArchiver archiveRootObject:p toFile:path];
    if (flag) {
        NSLog(@&quot;success&quot;);
    } else {
        NSLog(@&quot;falied&quot;);
    }
    NSLog(@&quot;%@&quot;, path);
}

- (void)readObject
{
    NSString *path = [NSTemporaryDirectory() stringByAppendingPathComponent:@&quot;chars.dat&quot;];
    
    Sample *p = [NSKeyedUnarchiver unarchiveObjectWithFile:path];
    if (p) {
        NSLog(@&quot;name:%@,age:%@&quot;, p.name, p.age);
    } else {
        NSLog(@&quot;falied&quot;);
    }
    NSLog(@&quot;%@&quot;, path);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Objective-C中归档底层实现方式：将对象拆分为字典（键值对），然后变成二进制存入磁盘。&lt;/p&gt;

&lt;p&gt;但是，当model中成员属性数量很多的时候，就沦为了体力劳动。那么，此时我们又能使用Runtime来简化工作。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;class_copyIvarList(__unsafe_unretained Class cls, unsigned int *outCount)&lt;/code&gt;获取Class中成员变量的个数。&lt;/p&gt;

&lt;p&gt;以下就是使用Runtime消息机制编写的归档与解档方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)encodeWithCoder:(NSCoder *)aCoder
{   
    unsigned int count = 0;
    Ivar *ivars = class_copyIvarList([Sample class], &amp;amp;count);
    for (int i = 0; i &amp;lt; count; i++) {
        Ivar ivar = ivars[i];
        const char *name = ivar_getName(ivar);
        NSString *key = [NSString stringWithUTF8String:name];
        [aCoder encodeObject:[self valueForKey:key] forKey:key];
    }
    free(ivars);
}

- (instancetype)initWithCoder:(NSCoder *)aDecoder
{
    self = [super init];
    if (self) {
        unsigned int count = 0;
        Ivar *ivars = class_copyIvarList([Sample class], &amp;amp;count);
        for (int i = 0; i &amp;lt; count; i++) {
            Ivar ivar = ivars[i];
            const char *name = ivar_getName(ivar);
            NSString *key = [NSString stringWithUTF8String:name];
            id value = [aDecoder decodeObjectForKey:key];
            [self setValue:value forKey:key];
        }
        free(ivars);
    }
    return self;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;2-kvo&quot;&gt;2 KVO&lt;/h1&gt;

&lt;p&gt;利用Runtime，在运行时动态创建一个对象。&lt;/p&gt;

&lt;p&gt;实现原理：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建&lt;code class=&quot;highlighter-rouge&quot;&gt;NSKVONotifying_XXX:XXX&lt;/code&gt;类(XXX为被监听者)。&lt;/li&gt;
  &lt;li&gt;重写属性set方法，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;willChangeValueForKey:&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;didChangeValueForKey:&lt;/code&gt;方法，进而触发调用观察者的&lt;code class=&quot;highlighter-rouge&quot;&gt;observeValueForKeyPath:ofObject:change:context:&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;示例代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface Viewer : NSObject
@property (nonatomic) NSString *name;
@property (nonatomic) NSString *age;
@end

@interface Observer : NSObject
@property (nonatomic) NSString *name;
@property (nonatomic) NSString *age;
@end

@implementation Observer
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&amp;lt;NSKeyValueChangeKey,id&amp;gt; *)change context:(void *)context
{
    NSLog(@&quot;object:%@, keyPath:%@, change:%@&quot;, object, keyPath, change);
}
@end

Observer *observer = [[Observer alloc] init];
Viewr *viewer = [[Viewer alloc] init];
//注册监听,viewer为被监听者，observer为观察者
[viewr addObserver:observer forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew context:nil];
//触发KVO
viewer.age = @&quot;99&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;3-动态添加方法&quot;&gt;3 动态添加方法&lt;/h1&gt;

&lt;p&gt;当方法被调用时，才被加载。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ (BOOL)resolveClassMethod:(SEL)sel;&lt;/code&gt;当一个类被调用了一个没有实现的方法时，则会调用此方法。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+ (BOOL)resolveInstanceMethod:(SEL)sel&lt;/code&gt;当一个类被调用了一个没有实现的实例方法时，则会调用此方法。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;class_addMethod(__unsafe_unretained Class cls, SEL name, IMP imp, const char *types)&lt;/code&gt;动态添加方法。&lt;/p&gt;

&lt;p&gt;参数&lt;code class=&quot;highlighter-rouge&quot;&gt;cls &lt;/code&gt;：类类型。参数&lt;code class=&quot;highlighter-rouge&quot;&gt;name &lt;/code&gt;：方法编号。参数&lt;code class=&quot;highlighter-rouge&quot;&gt;imp &lt;/code&gt;：方法实现，就是一个函数的指针。参数&lt;code class=&quot;highlighter-rouge&quot;&gt;* types &lt;/code&gt;：方法类型&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@implementation Sample
//一个类被调用了一个没有实现的实例方法时，则会调用此方法。
+ (BOOL)resolveInstanceMethod:(SEL)sel
{
    if (sel == @selector(eat)) {
        //添加一个实例方法
        class_addMethod([Sample class], sel, (IMP)eat, &quot;v@:&quot;);
    }
    return [super resolveInstanceMethod:sel];
}

//隐式参数,self和_cmd是系统传过来的参数
void eat(id self, SEL _cmd) {
    NSLog(@&quot;调用了%@的%@方法&quot;, self, NSStringFromSelector(_cmd));
}
@end

[[[Sample alloc] init] performSelector:@selector(eat)];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 09 May 2017 16:36:49 +0800</pubDate>
      </item>
    
      <item>
        <title>Python 学习 基础篇</title>
        <link>/web/2017/04/22/python-basic-knowledge.html</link>
        <guid isPermaLink="true">/web/2017/04/22/python-basic-knowledge.html</guid>
        <description>&lt;p&gt;全世界大概有几百种编程语言，而其中著名的只有十几种。Python就是著名编程语言之一。它起源于“龟叔”（Guido van Rossum，荷兰人）在1989年圣诞节间的无聊，而为了打发时间所创造。&lt;/p&gt;

&lt;p&gt;可见业余时间比工作时间创造出来的东西更容易出名哈，当然，这是开玩笑的。“龟叔”赋予Python“优雅、明确、简单”的特点。&lt;/p&gt;

&lt;p&gt;那么，Python适合做什么呢？它主要适用领域：Web网站和各种网络服务（YouTube、Instagram、douban、openstack）；系统工具和脚本；作为“胶水”语言把其它语言开发的模块包装起来方便使用。&lt;/p&gt;

&lt;p&gt;优点是显著的，但是也少不了缺点。Python不适用的领域：贴近硬件的代码（首选C）；移动开发（iOS／Android都有各自的开发语言）；因为不能做到告诉渲染，所以不适合游戏开发（首选C／C++）。&lt;/p&gt;

&lt;h2 id=&quot;python和其它语言对比&quot;&gt;Python和其它语言对比&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;语言&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;运行速度&lt;/th&gt;
      &lt;th&gt;代码量&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;C&lt;/td&gt;
      &lt;td&gt;编译为机器码&lt;/td&gt;
      &lt;td&gt;非常快&lt;/td&gt;
      &lt;td&gt;非常多&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Java&lt;/td&gt;
      &lt;td&gt;编译为字节码&lt;/td&gt;
      &lt;td&gt;快&lt;/td&gt;
      &lt;td&gt;多&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Python&lt;/td&gt;
      &lt;td&gt;解释执行&lt;/td&gt;
      &lt;td&gt;慢&lt;/td&gt;
      &lt;td&gt;少&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;CPU越来越快，程序的运行速度瓶颈往往不在Python的执行，更多受到网络速度和硬盘速度的制约。&lt;/p&gt;

&lt;p&gt;另外，Python发布程序即发布源代码。&lt;/p&gt;

&lt;h2 id=&quot;安装python&quot;&gt;安装Python&lt;/h2&gt;

&lt;p&gt;前往&lt;a href=&quot;http://www.python.org&quot;&gt;官网下载&lt;/a&gt;对应平台对应工具。另外Python2.7版本和3.3版本并不兼容，所以开发时请注意使用Python的版本。&lt;/p&gt;

&lt;p&gt;作为Mac OS X使用者，其实更推荐&lt;a href=&quot;https://www.jetbrains.com/pycharm/&quot;&gt;PyCharm IDE&lt;/a&gt;。安装之后直接使用即可。&lt;/p&gt;

&lt;h2 id=&quot;数据类型&quot;&gt;数据类型&lt;/h2&gt;

&lt;p&gt;计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：&lt;/p&gt;

&lt;h3 id=&quot;整数&quot;&gt;整数&lt;/h3&gt;

&lt;p&gt;Python可以处理任意大小的整数，当然包括负整数，在Python程序中，整数的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。&lt;/p&gt;

&lt;p&gt;计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。&lt;/p&gt;

&lt;h3 id=&quot;浮点数&quot;&gt;浮点数&lt;/h3&gt;

&lt;p&gt;浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10^9 和 12.3x10^8 是相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9 就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。&lt;/p&gt;

&lt;p&gt;整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。&lt;/p&gt;

&lt;h3 id=&quot;字符串&quot;&gt;字符串&lt;/h3&gt;

&lt;p&gt;字符串是以’‘或”“括起来的任意文本，比如’abc’，”xyz”等等。请注意，’‘或”“本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。&lt;/p&gt;

&lt;h3 id=&quot;布尔值&quot;&gt;布尔值&lt;/h3&gt;

&lt;p&gt;布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来。&lt;/p&gt;

&lt;p&gt;布尔值可以用and、or和not运算。&lt;/p&gt;

&lt;p&gt;and运算是与运算，只有所有都为 True，and运算结果才是 True。&lt;/p&gt;

&lt;p&gt;or运算是或运算，只要其中有一个为 True，or 运算结果就是 True。&lt;/p&gt;

&lt;p&gt;not运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。&lt;/p&gt;

&lt;h3 id=&quot;空值&quot;&gt;空值&lt;/h3&gt;

&lt;p&gt;空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。&lt;/p&gt;

&lt;p&gt;此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型。&lt;/p&gt;

&lt;h2 id=&quot;print-语句&quot;&gt;print 语句&lt;/h2&gt;

&lt;p&gt;print语句可以向屏幕上输出指定的文字。比如输出’hello, world’，用代码实现如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print 'hello, world'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;p&gt;1.当我们在Python交互式环境下编写代码时，»&amp;gt;是Python解释器的提示符，不是代码的一部分。&lt;/p&gt;

&lt;p&gt;2.当我们在文本编辑器中编写代码时，千万不要自己添加 »&amp;gt;。&lt;/p&gt;

&lt;p&gt;print语句也可以跟上多个字符串，用逗号“,”隔开，就可以连成一串输出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print 'The quick brown fox', 'jumps over', 'the lazy dog'
The quick brown fox jumps over the lazy dog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;print会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/python-basic-knowledge-1.jpg&quot; alt=&quot;print解释图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;print也可以打印整数，或者计算结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print 300
300    #运行结果
&amp;gt;&amp;gt;&amp;gt; print 100 + 200
300    #运行结果
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因此，我们可以把计算100 + 200的结果打印得更漂亮一点：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print '100 + 200 =', 100 + 200
100 + 200 = 300     #运行结果
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意: 对于100 + 200，Python解释器自动计算出结果300，但是，’100 + 200 =’是字符串而非数学公式，Python把它视为字符串，请自行解释上述打印结果。&lt;/p&gt;

&lt;h2 id=&quot;python的注释&quot;&gt;Python的注释&lt;/h2&gt;
&lt;p&gt;任何时候，我们都可以给程序加上注释。注释是用来说明代码的，给自己或别人看，而程序运行的时候，Python解释器会直接忽略掉注释，所以，有没有注释不影响程序的执行结果，但是影响到别人能不能看懂你的代码。&lt;/p&gt;

&lt;p&gt;Python的注释以&lt;code class=&quot;highlighter-rouge&quot;&gt; # &lt;/code&gt;开头，后面的文字直到行尾都算注释&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 这一行全部都是注释...
print 'hello' # 这也是注释
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注释还有一个巧妙的用途，就是一些代码我们不想运行，但又不想删除，就可以用注释暂时屏蔽掉：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 暂时不想运行下面一行代码:
# print 'hello, python.'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;变量&quot;&gt;变量&lt;/h2&gt;

&lt;p&gt;在Python中，变量的概念基本上和初中代数的方程变量是一致的。&lt;/p&gt;

&lt;p&gt;例如，对于方程式&lt;code class=&quot;highlighter-rouge&quot;&gt; y=x*x &lt;/code&gt;，x就是变量。当&lt;code class=&quot;highlighter-rouge&quot;&gt;x=2&lt;/code&gt;时，计算结果是4，当&lt;code class=&quot;highlighter-rouge&quot;&gt;x=5&lt;/code&gt;时，计算结果是25。&lt;/p&gt;

&lt;p&gt;只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。&lt;/p&gt;

&lt;p&gt;在Python程序中，变量是用一个变量名表示，变量名必须是&lt;strong&gt;大小写英文、数字和下划线（_）的组合，且不能用数字开头&lt;/strong&gt;，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a = 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;变量&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;是一个整数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;t_007 = 'T007'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;变量&lt;code class=&quot;highlighter-rouge&quot;&gt;t_007&lt;/code&gt;是一个字符串。&lt;/p&gt;

&lt;p&gt;在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a = 123    # a是整数
print a
a = 'Chars'   # a变为字符串
print a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。&lt;/p&gt;

&lt;p&gt;静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int a = 123; // a是整数类型变量
a = &quot;Chars&quot;; // 错误：不能把字符串赋给整型变量
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;和静态语言相比，动态语言更灵活，就是这个原因。&lt;/p&gt;

&lt;p&gt;请不要把赋值语句的等号等同于数学的等号。比如下面的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x = 10
x = x + 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果从数学上理解&lt;code class=&quot;highlighter-rouge&quot;&gt;x = x + 2&lt;/code&gt;那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式&lt;code class=&quot;highlighter-rouge&quot;&gt;x + 2&lt;/code&gt;，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。&lt;/p&gt;

&lt;p&gt;最后，理解变量在计算机内存中的表示也非常重要。当我们写：&lt;code class=&quot;highlighter-rouge&quot;&gt;a = 'ABC'&lt;/code&gt;时，Python解释器干了两件事情：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在内存中创建了一个’ABC’的字符串；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在内存中创建了一个名为a的变量，并把它指向’ABC’。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a = 'ABC'
b = a
a = 'XYZ'
print b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后一行打印出变量b的内容到底是&lt;code class=&quot;highlighter-rouge&quot;&gt;'ABC'&lt;/code&gt;呢还是&lt;code class=&quot;highlighter-rouge&quot;&gt;'XYZ'&lt;/code&gt;？如果从数学意义上理解，就会错误地得出b和a相同，也应该是&lt;code class=&quot;highlighter-rouge&quot;&gt;'XYZ'&lt;/code&gt;，但实际上b的值是&lt;code class=&quot;highlighter-rouge&quot;&gt;'ABC'&lt;/code&gt;，让我们一行一行地执行代码，就可以看到到底发生了什么事：&lt;/p&gt;

&lt;p&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;a = 'ABC'&lt;/code&gt;，解释器创建了字符串&lt;code class=&quot;highlighter-rouge&quot;&gt; 'ABC'&lt;/code&gt;和变量&lt;code class=&quot;highlighter-rouge&quot;&gt; a&lt;/code&gt;，并把a指向&lt;code class=&quot;highlighter-rouge&quot;&gt; 'ABC'&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/python-basic-knowledge-2.jpg&quot; alt=&quot;变量图1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;b = a&lt;/code&gt;，解释器创建了变量 b，并把b指向 a 指向的字符串&lt;code class=&quot;highlighter-rouge&quot;&gt;'ABC'&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/python-basic-knowledge-3.jpg&quot; alt=&quot;变量图2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;a = 'XYZ'&lt;/code&gt;，解释器创建了字符串&lt;code class=&quot;highlighter-rouge&quot;&gt;'XYZ'&lt;/code&gt;，并把a的指向改为&lt;code class=&quot;highlighter-rouge&quot;&gt;'XYZ'&lt;/code&gt;，但b并没有更改：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/python-basic-knowledge-4.jpg&quot; alt=&quot;变量图3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以，最后打印变量b的结果自然是&lt;code class=&quot;highlighter-rouge&quot;&gt;'ABC'&lt;/code&gt;了。&lt;/p&gt;

&lt;h2 id=&quot;字符串-1&quot;&gt;字符串&lt;/h2&gt;

&lt;h3 id=&quot;定义字符串&quot;&gt;定义字符串&lt;/h3&gt;

&lt;p&gt;前面我们讲解了什么是字符串。字符串可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;''&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&quot;&lt;/code&gt;括起来表示。&lt;/p&gt;

&lt;p&gt;如果字符串本身包含’怎么办？比如我们要表示字符串 &lt;code class=&quot;highlighter-rouge&quot;&gt;I'm OK &lt;/code&gt;，这时，可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot; &quot;&lt;/code&gt;括起来表示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;I'm OK&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;类似的，如果字符串包含”，我们就可以用’ ‘括起来表示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'Learn &quot;Python&quot; in Chars's Blog'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果字符串既包含’又包含”怎么办？&lt;/p&gt;

&lt;p&gt;这个时候，就需要对字符串的某些特殊字符进行“转义”，Python字符串用&lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt;进行转义。&lt;/p&gt;

&lt;p&gt;要表示字符串 &lt;code class=&quot;highlighter-rouge&quot;&gt;Bob said &quot;I'm OK&quot;&lt;/code&gt;.
由于 ‘ 和 “ 会引起歧义，因此，我们在它前面插入一个&lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt;表示这是一个普通字符，不代表字符串的起始，因此，这个字符串又可以表示为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'Bob said \&quot;I\'m OK\&quot;.'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意：转义字符 \ 不计入字符串的内容中。&lt;/p&gt;

&lt;p&gt;常用的转义字符还有：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\n 表示换行
\t 表示一个制表符
\\ 表示 \ 字符本身
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;raw字符串与多行字符串&quot;&gt;raw字符串与多行字符串&lt;/h3&gt;

&lt;p&gt;如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀&lt;code class=&quot;highlighter-rouge&quot;&gt; r &lt;/code&gt;，表示这是一个 raw 字符串，里面的字符就不需要转义了。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;r'\(~_~)/ \(~_~)/'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是&lt;code class=&quot;highlighter-rouge&quot;&gt;r'...'&lt;/code&gt;表示法不能表示多行字符串，也不能表示包含&lt;code class=&quot;highlighter-rouge&quot;&gt;'&lt;/code&gt;和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&lt;/code&gt;的字符串（为什么？）&lt;/p&gt;

&lt;p&gt;如果要表示多行字符串，可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;'''...'''&lt;/code&gt;表示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'''Line 1
Line 2
Line 3'''
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面这个字符串的表示方法和下面的是完全一样的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'Line 1\nLine 2\nLine 3'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;还可以在多行字符串前面添加&lt;code class=&quot;highlighter-rouge&quot;&gt; r &lt;/code&gt;，把这个多行字符串也变成一个raw字符串：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;r'''Python is created by &quot;Guido&quot;.
It is free and easy to learn.
Let's start learn Python in Chars's Blog!'''
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;unicode字符串&quot;&gt;Unicode字符串&lt;/h3&gt;

&lt;p&gt;字符串还有一个编码问题。&lt;/p&gt;

&lt;p&gt;因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），0 - 255被用来表示大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母 A 的编码是65，小写字母 z 的编码是122。&lt;/p&gt;

&lt;p&gt;如果要表示中文，显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。&lt;/p&gt;

&lt;p&gt;类似的，日文和韩文等其他语言也有这个问题。为了统一所有文字的编码，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。&lt;/p&gt;

&lt;p&gt;Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。&lt;/p&gt;

&lt;p&gt;因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码，普通的字符串’ABC’在Python内部都是ASCII编码的。&lt;/p&gt;

&lt;p&gt;Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u’…‘表示，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print u'中文'
中文
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意: 不加 u ，中文就不能正常显示。&lt;/p&gt;

&lt;p&gt;Unicode字符串除了多了一个 u 之外，与普通字符串没啥区别，转义字符和多行表示法仍然有效：&lt;/p&gt;

&lt;p&gt;转义：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;u'中文\n日文\n韩文'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;多行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;u'''第一行
第二行'''
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;raw+多行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ur'''Python的Unicode字符串支持&quot;中文&quot;,
&quot;日文&quot;,
&quot;韩文&quot;等多种语言'''
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果中文字符串在Python环境下遇到&lt;code class=&quot;highlighter-rouge&quot;&gt; UnicodeDecodeError&lt;/code&gt;，这是因为.py文件保存的格式有问题。可以在第一行添加注释&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# -*- coding: utf-8 -*-
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;目的是告诉Python解释器，用UTF-8编码读取源代码。然后用Notepad++ 另存为… 并选择UTF-8格式保存。&lt;/p&gt;

&lt;h2 id=&quot;list&quot;&gt;List&lt;/h2&gt;

&lt;h3 id=&quot;创建list&quot;&gt;创建list&lt;/h3&gt;

&lt;p&gt;Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。&lt;/p&gt;

&lt;p&gt;比如，列出班里所有同学的名字，就可以用一个list表示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; ['Michael', 'Bob', 'Tracy']
['Michael', 'Bob', 'Tracy']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;list是数学意义上的有序集合，也就是说，list中的元素是按照顺序排列的。&lt;/p&gt;

&lt;p&gt;构造list非常简单，按照上面的代码，直接用 [ ] 把list的所有元素都括起来，就是一个list对象。通常，我们会把list赋值给一个变量，这样，就可以通过变量来引用list：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; classmates = ['Michael', 'Bob', 'Tracy']
&amp;gt;&amp;gt;&amp;gt; classmates # 打印classmates变量的内容
['Michael', 'Bob', 'Tracy']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于Python是动态语言，所以list中包含的元素并不要求都必须是同一种数据类型，我们完全可以在list中包含各种数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L = ['Michael', 100, True]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一个元素也没有的list，就是空list：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; empty_list = []
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;按照索引访问list&quot;&gt;按照索引访问list&lt;/h3&gt;

&lt;p&gt;由于list是一个有序集合，所以，我们可以用一个list按分数从高到低表示出班里的3个同学：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L = ['Adam', 'Lisa', 'Bart']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那我们如何从list中获取指定第 N 名的同学呢？方法是通过索引来获取list中的指定元素。&lt;/p&gt;

&lt;p&gt;需要特别注意的是，索引从 0 开始，也就是说，第一个元素的索引是0，第二个元素的索引是1，以此类推。&lt;/p&gt;

&lt;p&gt;因此，要打印第一名同学的名字，用 L[0]:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print L[0]
Adam
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要打印第二名同学的名字，用 L[1]:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print L[1]
Lisa
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要打印第三名同学的名字，用 L[2]:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print L[2]
Bart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要打印第四名同学的名字，用 L[3]:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print L[3]
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
IndexError: list index out of range
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;报错了！IndexError意思就是索引超出了范围，因为上面的list只有3个元素，有效的索引是 0，1，2。&lt;/p&gt;

&lt;p&gt;所以，使用索引时，&lt;strong&gt;千万注意不要越界&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;倒序访问list&quot;&gt;倒序访问list&lt;/h3&gt;

&lt;p&gt;我们还是用一个list按分数从高到低表示出班里的3个同学：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L = ['Adam', 'Lisa', 'Bart']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这时，老师说，请分数最低的同学站出来。&lt;/p&gt;

&lt;p&gt;要写代码完成这个任务，我们可以先数一数这个 list，发现它包含3个元素，因此，最后一个元素的索引是2：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print L[2]
Bart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有没有更简单的方法？有！&lt;/p&gt;

&lt;p&gt;Bart同学是最后一名，俗称倒数第一，所以，我们可以用 -1 这个索引来表示最后一个元素：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print L[-1]
Bart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Bart同学表示躺枪。&lt;/p&gt;

&lt;p&gt;类似的，倒数第二用 -2 表示，倒数第三用 -3 表示，倒数第四用 -4 表示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print L[-2]
Lisa
&amp;gt;&amp;gt;&amp;gt; print L[-3]
Adam
&amp;gt;&amp;gt;&amp;gt; print L[-4]
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
IndexError: list index out of range
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;L[-4] 报错了，因为倒数第四不存在，一共只有3个元素。&lt;/p&gt;

&lt;p&gt;使用倒序索引时，也要&lt;strong&gt;注意不要越界&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;添加新元素&quot;&gt;添加新元素&lt;/h3&gt;

&lt;p&gt;现在，班里有3名同学：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L = ['Adam', 'Lisa', 'Bart']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;今天，班里转来一名新同学 Paul，如何把新同学添加到现有的 list 中呢？&lt;/p&gt;

&lt;p&gt;第一个办法是用 list 的 append() 方法，把新同学追加到 list 的末尾：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L = ['Adam', 'Lisa', 'Bart']
&amp;gt;&amp;gt;&amp;gt; L.append('Paul')
&amp;gt;&amp;gt;&amp;gt; print L
['Adam', 'Lisa', 'Bart', 'Paul']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;append()总是把新的元素添加到 list 的尾部。&lt;/p&gt;

&lt;p&gt;如果 Paul 同学表示自己总是考满分，要求添加到第一的位置，怎么办？&lt;/p&gt;

&lt;p&gt;方法是用list的 insert()方法，它接受两个参数，第一个参数是索引号，第二个参数是待添加的新元素：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L = ['Adam', 'Lisa', 'Bart']
&amp;gt;&amp;gt;&amp;gt; L.insert(0, 'Paul')
&amp;gt;&amp;gt;&amp;gt; print L
['Paul', 'Adam', 'Lisa', 'Bart']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;L.insert(0, ‘Paul’) 的意思是，’Paul’将被添加到索引为 0 的位置上（也就是第一个），而原来索引为 0 的Adam同学，以及后面的所有同学，都自动向后移动一位。&lt;/p&gt;

&lt;h3 id=&quot;删除元素&quot;&gt;删除元素&lt;/h3&gt;

&lt;p&gt;Paul同学刚来几天又要转走了，那么我们怎么把Paul 从现有的list中删除呢？&lt;/p&gt;

&lt;p&gt;如果Paul同学排在最后一个，我们可以用list的pop()方法删除：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L = ['Adam', 'Lisa', 'Bart', 'Paul']
&amp;gt;&amp;gt;&amp;gt; L.pop()
'Paul'
&amp;gt;&amp;gt;&amp;gt; print L
['Adam', 'Lisa', 'Bart']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;pop()方法总是删掉list的最后一个元素，并且它还返回这个元素，所以我们执行 L.pop() 后，会打印出 ‘Paul’。&lt;/p&gt;

&lt;p&gt;如果Paul同学不是排在最后一个怎么办？比如Paul同学排在第三：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L = ['Adam', 'Lisa', 'Paul', 'Bart']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要把Paul踢出list，我们就必须先定位Paul的位置。由于Paul的索引是2，因此，用 pop(2)把Paul删掉：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L.pop(2)
'Paul'
&amp;gt;&amp;gt;&amp;gt; print L
['Adam', 'Lisa', 'Bart']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;替换元素&quot;&gt;替换元素&lt;/h3&gt;

&lt;p&gt;假设现在班里仍然是3名同学：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L = ['Adam', 'Lisa', 'Bart']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在，Bart同学要转学走了，碰巧来了一个Paul同学，要更新班级成员名单，我们可以先把Bart删掉，再把Paul添加进来。&lt;/p&gt;

&lt;p&gt;另一个办法是直接用Paul把Bart给替换掉：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L[2] = 'Paul'
&amp;gt;&amp;gt;&amp;gt; print L
L = ['Adam', 'Lisa', 'Paul']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对list中的某一个索引赋值，就可以直接用新的元素替换掉原来的元素，list包含的元素个数保持不变。&lt;/p&gt;

&lt;p&gt;由于Bart还可以用 -1 做索引，因此，下面的代码也可以完成同样的替换工作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L[-1] = 'Paul'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tuple&quot;&gt;Tuple&lt;/h2&gt;

&lt;h3 id=&quot;创建tuple&quot;&gt;创建tuple&lt;/h3&gt;

&lt;p&gt;tuple是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，但是，tuple一旦创建完毕，就不能修改了。&lt;/p&gt;

&lt;p&gt;同样是表示班里同学的名称，用tuple表示如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; t = ('Adam', 'Lisa', 'Bart')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;创建tuple和创建list唯一不同之处是用( )替代了[ ]。&lt;/p&gt;

&lt;p&gt;现在，这个 t 就不能改变了，tuple没有 append()方法，也没有insert()和pop()方法。所以，新同学没法直接往 tuple 中添加，老同学想退出 tuple 也不行。&lt;/p&gt;

&lt;p&gt;获取 tuple 元素的方式和 list 是一模一样的，我们可以正常使用 t[0]，t[-1]等索引方式访问元素，但是不能赋值成别的元素，不信可以试试：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; t[0] = 'Paul'
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: 'tuple' object does not support item assignment
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;创建单元素tuple&quot;&gt;创建单元素tuple&lt;/h3&gt;

&lt;p&gt;tuple和list一样，可以包含 0 个、1个和任意多个元素。&lt;/p&gt;

&lt;p&gt;包含多个元素的 tuple，前面我们已经创建过了。&lt;/p&gt;

&lt;p&gt;包含 0 个元素的 tuple，也就是空tuple，直接用 ()表示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; t = ()
&amp;gt;&amp;gt;&amp;gt; print t
()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;创建包含1个元素的 tuple 呢？来试试：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; t = (1)
&amp;gt;&amp;gt;&amp;gt; print t
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;好像哪里不对！t 不是 tuple ，而是整数1。为什么呢？&lt;/p&gt;

&lt;p&gt;因为()既可以表示tuple，又可以作为括号表示运算时的优先级，结果 (1) 被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。&lt;/p&gt;

&lt;p&gt;正是因为用()定义单元素的tuple有歧义，所以 Python 规定，单元素 tuple 要多加一个逗号“,”，这样就避免了歧义：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; t = (1,)
&amp;gt;&amp;gt;&amp;gt; print t
(1,)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;可变的tuple&quot;&gt;可变的tuple&lt;/h3&gt;

&lt;p&gt;前面我们看到了tuple一旦创建就不能修改。现在，我们来看一个“可变”的tuple：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; t = ('a', 'b', ['A', 'B'])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意到 t 有 3 个元素：’a’，’b’和一个list：[‘A’, ‘B’]。list作为一个整体是tuple的第3个元素。list对象可以通过 t[2] 拿到：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L = t[2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后，我们把list的两个元素改一改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L[0] = 'X'
&amp;gt;&amp;gt;&amp;gt; L[1] = 'Y'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再看看tuple的内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print t
('a', 'b', ['X', 'Y'])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不是说tuple一旦定义后就不可变了吗？怎么现在又变了？&lt;/p&gt;

&lt;p&gt;别急，我们先看看定义的时候tuple包含的3个元素：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/python-basic-knowledge-5.jpg&quot; alt=&quot;tuple图1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当我们把list的元素’A’和’B’修改为’X’和’Y’后，tuple变为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/python-basic-knowledge-6.jpg&quot; alt=&quot;tuple图2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;表面上看，tuple的元素确实变了，但其实变的不是 tuple 的元素，而是list的元素。&lt;/p&gt;

&lt;p&gt;tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！&lt;/p&gt;

&lt;p&gt;理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。&lt;/p&gt;

&lt;h2 id=&quot;条件判断和循环&quot;&gt;条件判断和循环&lt;/h2&gt;

&lt;h3 id=&quot;条件判断&quot;&gt;条件判断&lt;/h3&gt;

&lt;p&gt;计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。&lt;/p&gt;

&lt;h4 id=&quot;if语句&quot;&gt;if语句&lt;/h4&gt;

&lt;p&gt;比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，可以用if语句实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;age = 20
if age &amp;gt;= 18:
    print 'your age is', age
    print 'adult'
print 'END'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意: Python代码的缩进规则。具有相同缩进的代码被视为代码块，上面的3，4行 print 语句就构成一个代码块（但不包括第5行的print）。如果 if 语句判断为 True，就会执行这个代码块。&lt;/p&gt;

&lt;p&gt;缩进请严格按照Python的习惯写法：4个空格，不要使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。&lt;/p&gt;

&lt;p&gt;注意: if 语句后接表达式，然后用:表示代码块开始。&lt;/p&gt;

&lt;p&gt;如果你在Python交互环境下敲代码，还要特别留意缩进，并且退出缩进需要多敲一行回车：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; age = 20
&amp;gt;&amp;gt;&amp;gt; if age &amp;gt;= 18:
...     print 'your age is', age
...     print 'adult'
...
your age is 20
adult
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;if-else语句&quot;&gt;if-else语句&lt;/h4&gt;

&lt;p&gt;当 if 语句判断表达式的结果为 True 时，就会执行 if 包含的代码块：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if age &amp;gt;= 18:
    print 'adult'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果我们想判断年龄在18岁以下时，打印出 ‘teenager’，怎么办？&lt;/p&gt;

&lt;p&gt;方法是再写一个 if:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if age &amp;lt; 18:
    print 'teenager'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;或者用 not 运算：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if not age &amp;gt;= 18:
    print 'teenager'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;细心的读者可以发现，这两种条件判断是“非此即彼”的，要么符合条件1，要么符合条件2，因此，完全可以用一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;if ... else ... &lt;/code&gt;语句把它们统一起来：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if age &amp;gt;= 18:
    print 'adult'
else:
    print 'teenager'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;利用&lt;code class=&quot;highlighter-rouge&quot;&gt; if ... else ... &lt;/code&gt;语句，我们可以根据条件表达式的值为 True 或者 False ，分别执行 if 代码块或者 else 代码块。&lt;/p&gt;

&lt;p&gt;注意: else 后面有个“:”。&lt;/p&gt;

&lt;h4 id=&quot;if-elif-else语句&quot;&gt;if-elif-else语句&lt;/h4&gt;

&lt;p&gt;有的时候，一个&lt;code class=&quot;highlighter-rouge&quot;&gt; if ... else ... &lt;/code&gt;还不够用。比如，根据年龄的划分：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;条件1：18岁或以上：adult
条件2：6岁或以上：teenager
条件3：6岁以下：kid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以用一个 if age &amp;gt;= 18 判断是否符合条件1，如果不符合，再通过一个 if 判断 age &amp;gt;= 6 来判断是否符合条件2，否则，执行条件3：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if age &amp;gt;= 18:
    print 'adult'
else:
    if age &amp;gt;= 6:
        print 'teenager'
    else:
        print 'kid'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样写出来，我们就得到了一个两层嵌套的&lt;code class=&quot;highlighter-rouge&quot;&gt; if ... else ... &lt;/code&gt;语句。这个逻辑没有问题，但是，如果继续增加条件，比如3岁以下是 baby：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if age &amp;gt;= 18:
    print 'adult'
else:
    if age &amp;gt;= 6:
        print 'teenager'
    else:
        if age &amp;gt;= 3:
            print 'kid'
        else:
            print 'baby'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这种缩进只会越来越多，代码也会越来越难看。&lt;/p&gt;

&lt;p&gt;要避免嵌套结构的&lt;code class=&quot;highlighter-rouge&quot;&gt; if ... else ...&lt;/code&gt;，我们可以用&lt;code class=&quot;highlighter-rouge&quot;&gt; if ... &lt;/code&gt;多个&lt;code class=&quot;highlighter-rouge&quot;&gt;elif ... else ... &lt;/code&gt;的结构，一次写完所有的规则：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if age &amp;gt;= 18:
    print 'adult'
elif age &amp;gt;= 6:
    print 'teenager'
elif age &amp;gt;= 3:
    print 'kid'
else:
    print 'baby'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;elif 意思就是 else if。这样一来，我们就写出了结构非常清晰的一系列条件判断。&lt;/p&gt;

&lt;p&gt;特别注意: 这一系列条件判断会从上到下依次判断，如果某个判断为 True，执行完对应的代码块，后面的条件判断就直接忽略，不再执行了。&lt;/p&gt;

&lt;h3 id=&quot;循环&quot;&gt;循环&lt;/h3&gt;

&lt;h4 id=&quot;for循环&quot;&gt;for循环&lt;/h4&gt;

&lt;p&gt;list或tuple可以表示一个有序集合。如果我们想依次访问一个list中的每一个元素呢？比如 list：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;L = ['Adam', 'Lisa', 'Bart']
print L[0]
print L[1]
print L[2]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果list只包含几个元素，这样写还行，如果list包含1万个元素，我们就不可能写1万行print。&lt;/p&gt;

&lt;p&gt;这时，循环就派上用场了。&lt;/p&gt;

&lt;p&gt;Python的 for 循环就可以依次把list或tuple的每个元素迭代出来：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;L = ['Adam', 'Lisa', 'Bart']
for name in L:
    print name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意:  name 这个变量是在 for 循环中定义的，意思是，依次取出list中的每一个元素，并把元素赋值给 name，然后执行for循环体（就是缩进的代码块）。&lt;/p&gt;

&lt;p&gt;这样一来，遍历一个list或tuple就非常容易了。&lt;/p&gt;

&lt;h4 id=&quot;while循环&quot;&gt;while循环&lt;/h4&gt;

&lt;p&gt;和 for 循环不同的另一种循环是 while 循环，while 循环不会迭代 list 或 tuple 的元素，而是根据表达式判断循环是否结束。&lt;/p&gt;

&lt;p&gt;比如要从 0 开始打印不大于 N 的整数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;N = 10
x = 0
while x &amp;lt; N:
    print x
    x = x + 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;while循环每次先判断 x &amp;lt; N，如果为True，则执行循环体的代码块，否则，退出循环。&lt;/p&gt;

&lt;p&gt;在循环体内，x = x + 1 会让 x 不断增加，最终因为 x &amp;lt; N 不成立而退出循环。&lt;/p&gt;

&lt;p&gt;如果没有这一个语句，while循环在判断 x &amp;lt; N 时总是为True，就会无限循环下去，变成死循环，所以要特别留意while循环的退出条件。&lt;/p&gt;

&lt;h4 id=&quot;break退出循环&quot;&gt;break退出循环&lt;/h4&gt;

&lt;p&gt;用 for 循环或者 while 循环时，如果要在循环体内直接退出循环，可以使用 break 语句。&lt;/p&gt;

&lt;p&gt;比如计算1至100的整数和，我们用while来实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sum = 0
x = 1
while True:
    sum = sum + x
    x = x + 1
    if x &amp;gt; 100:
        break
print sum
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;咋一看， while True 就是一个死循环，但是在循环体内，我们还判断了 x &amp;gt; 100 条件成立时，用break语句退出循环，这样也可以实现循环的结束。&lt;/p&gt;

&lt;h4 id=&quot;continue继续循环&quot;&gt;continue继续循环&lt;/h4&gt;

&lt;p&gt;在循环过程中，可以用break退出当前循环，还可以用continue跳过后续循环代码，继续下一次循环。&lt;/p&gt;

&lt;p&gt;假设我们已经写好了利用for循环计算平均分的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;L = [75, 98, 59, 81, 66, 43, 69, 85]
sum = 0.0
n = 0
for x in L:
    sum = sum + x
    n = n + 1
print sum / n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在老师只想统计及格分数的平均分，就要把 x &amp;lt; 60 的分数剔除掉，这时，利用 continue，可以做到当 x &amp;lt; 60的时候，不继续执行循环体的后续代码，直接进入下一次循环：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for x in L:
    if x &amp;lt; 60:
        continue
    sum = sum + x
    n = n + 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;多重循环&quot;&gt;多重循环&lt;/h4&gt;

&lt;p&gt;在循环内部，还可以嵌套循环，我们来看一个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for x in ['A', 'B', 'C']:
    for y in ['1', '2', '3']:
        print x + y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;x 每循环一次，y 就会循环 3 次。&lt;/p&gt;

&lt;h2 id=&quot;dict类型&quot;&gt;Dict类型&lt;/h2&gt;

&lt;p&gt;我们已经知道，list 和 tuple 可以用来表示顺序集合，例如，班里同学的名字：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;['Adam', 'Lisa', 'Bart']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;或者考试的成绩列表：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[95, 85, 59]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是，要根据名字找到对应的成绩，用两个 list 表示就不方便。&lt;/p&gt;

&lt;p&gt;如果把名字和分数关联起来，组成类似的查找表：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'Adam' ==&amp;gt; 95
'Lisa' ==&amp;gt; 85
'Bart' ==&amp;gt; 59
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;给定一个名字，就可以直接查到分数。&lt;/p&gt;

&lt;p&gt;Python的 dict 就是专门干这件事的。用 dict 表示“名字”-“成绩”的查找表如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;d = {
    'Adam': 95,
    'Lisa': 85,
    'Bart': 59
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们把名字称为key，对应的成绩称为value，dict就是通过 key 来查找 value。&lt;/p&gt;

&lt;p&gt;花括号 {} 表示这是一个dict，然后按照 key: value, 写出来即可。最后一个 key: value 的逗号可以省略。&lt;/p&gt;

&lt;p&gt;由于dict也是集合，len() 函数可以计算任意集合的大小：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; len(d)
3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意: 一个 key-value 算一个，因此，dict大小为3。&lt;/p&gt;

&lt;h3 id=&quot;访问dict&quot;&gt;访问Dict&lt;/h3&gt;

&lt;p&gt;我们已经能创建一个dict，用于表示名字和成绩的对应关系：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;d = {
    'Adam': 95,
    'Lisa': 85,
    'Bart': 59
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么，如何根据名字来查找对应的成绩呢？&lt;/p&gt;

&lt;p&gt;可以简单地使用 d[key] 的形式来查找对应的 value，这和 list 很像，不同之处是，list 必须使用索引返回对应的元素，而dict使用key：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print d['Adam']
95
&amp;gt;&amp;gt;&amp;gt; print d['Paul']
Traceback (most recent call last):
  File &quot;index.py&quot;, line 11, in &amp;lt;module&amp;gt;
    print d['Paul']
KeyError: 'Paul'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意: 通过 key 访问 dict 的value，只要 key 存在，dict就返回对应的value。如果key不存在，会直接报错：KeyError。&lt;/p&gt;

&lt;p&gt;要避免 KeyError 发生，有两个办法：&lt;/p&gt;

&lt;p&gt;一是先判断一下 key 是否存在，用 in 操作符：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if 'Paul' in d:
    print d['Paul']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果 ‘Paul’ 不存在，if语句判断为False，自然不会执行 print d[‘Paul’] ，从而避免了错误。&lt;/p&gt;

&lt;p&gt;二是使用dict本身提供的一个 get 方法，在Key不存在的时候，返回None：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print d.get('Bart')
59
&amp;gt;&amp;gt;&amp;gt; print d.get('Paul')
None
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;dict特点&quot;&gt;Dict特点&lt;/h3&gt;

&lt;p&gt;dict的第一个特点是查找速度快，无论dict有10个元素还是10万个元素，查找速度都一样。而list的查找速度随着元素增加而逐渐下降。&lt;/p&gt;

&lt;p&gt;不过dict的查找速度快不是没有代价的，dict的缺点是占用内存大，还会浪费很多内容，list正好相反，占用内存小，但是查找速度慢。&lt;/p&gt;

&lt;p&gt;由于dict是按 key 查找，所以，在一个dict中，key不能重复。&lt;/p&gt;

&lt;p&gt;dict的第二个特点就是存储的key-value序对是没有顺序的！这和list不一样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;d = {
    'Adam': 95,
    'Lisa': 85,
    'Bart': 59
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当我们试图打印这个dict时：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print d
{'Lisa': 85, 'Adam': 95, 'Bart': 59}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同，这说明dict内部是无序的，不能用dict存储有序的集合。&lt;/p&gt;

&lt;p&gt;dict的第三个特点是作为 key 的元素必须不可变，Python的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。但是list是可变的，就不能作为 key。&lt;/p&gt;

&lt;p&gt;可以试试用list作为key时会报什么样的错误。&lt;/p&gt;

&lt;p&gt;不可变这个限制仅作用于key，value是否可变无所谓：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    '123': [1, 2, 3],  # key 是 str，value是list
    123: '123',  # key 是 int，value 是 str
    ('a', 'b'): True  # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最常用的key还是字符串，因为用起来最方便。&lt;/p&gt;

&lt;h3 id=&quot;更新dict&quot;&gt;更新Dict&lt;/h3&gt;

&lt;p&gt;dict是可变的，也就是说，我们可以随时往dict中添加新的 key-value。比如已有dict：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;d = {
    'Adam': 95,
    'Lisa': 85,
    'Bart': 59
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;要把新同学’Paul’的成绩 72 加进去，用赋值语句：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d['Paul'] = 72
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再看看dict的内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print d
{'Lisa': 85, 'Paul': 72, 'Adam': 95, 'Bart': 59}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果 key 已经存在，则赋值会用新的 value 替换掉原来的 value：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d['Bart'] = 60
&amp;gt;&amp;gt;&amp;gt; print d
{'Lisa': 85, 'Paul': 72, 'Adam': 95, 'Bart': 60}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;遍历dict&quot;&gt;遍历Dict&lt;/h3&gt;

&lt;p&gt;由于dict也是一个集合，所以，遍历dict和遍历list类似，都可以通过 for 循环实现。&lt;/p&gt;

&lt;p&gt;直接使用for循环可以遍历 dict 的 key：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }
&amp;gt;&amp;gt;&amp;gt; for key in d:
...     print key
... 
Lisa
Adam
Bart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于通过 key 可以获取对应的 value，因此，在循环体内，可以获取到value的值。&lt;/p&gt;

&lt;h2 id=&quot;set类型&quot;&gt;Set类型&lt;/h2&gt;

&lt;p&gt;dict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。&lt;/p&gt;

&lt;p&gt;有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set就派上用场了。&lt;/p&gt;

&lt;p&gt;set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。&lt;/p&gt;

&lt;p&gt;创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s = set(['A', 'B', 'C'])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以查看 set 的内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print s
set(['A', 'C', 'B'])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;请注意，上述打印的形式类似 list， 但它不是 list，仔细看还可以发现，打印的顺序和原始 list 的顺序有可能是不同的，因为set内部存储的元素是无序的。&lt;/p&gt;

&lt;p&gt;因为set不能包含重复的元素，所以，当我们传入包含重复元素的 list 会怎么样呢？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s = set(['A', 'B', 'C', 'C'])
&amp;gt;&amp;gt;&amp;gt; print s
set(['A', 'C', 'B'])
&amp;gt;&amp;gt;&amp;gt; len(s)
3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结果显示，set会自动去掉重复的元素，原来的list有4个元素，但set只有3个元素。&lt;/p&gt;

&lt;h3 id=&quot;访问set&quot;&gt;访问Set&lt;/h3&gt;

&lt;p&gt;由于set存储的是无序集合，所以我们没法通过索引来访问。&lt;/p&gt;

&lt;p&gt;访问 set中的某个元素实际上就是判断一个元素是否在set中。&lt;/p&gt;

&lt;p&gt;例如，存储了班里同学名字的set：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s = set(['Adam', 'Lisa', 'Bart', 'Paul'])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以用 in 操作符判断：&lt;/p&gt;

&lt;p&gt;Bart是该班的同学吗？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 'Bart' in s
True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Bill是该班的同学吗？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 'Bill' in s
False
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;bart是该班的同学吗？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 'bart' in s
False
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;看来大小写很重要，’Bart’ 和 ‘bart’被认为是两个不同的元素。&lt;/p&gt;

&lt;h3 id=&quot;set的特点&quot;&gt;Set的特点&lt;/h3&gt;

&lt;p&gt;set的内部结构和dict很像，唯一区别是不存储value，因此，判断一个元素是否在set中速度很快。&lt;/p&gt;

&lt;p&gt;set存储的元素和dict的key类似，必须是不变对象，因此，任何可变对象是不能放入set中的。&lt;/p&gt;

&lt;p&gt;最后，set存储的元素也是没有顺序的。&lt;/p&gt;

&lt;p&gt;set的这些特点，可以应用在哪些地方呢？&lt;/p&gt;

&lt;p&gt;星期一到星期日可以用字符串’MON’, ‘TUE’, … ‘SUN’表示。&lt;/p&gt;

&lt;p&gt;假设我们让用户输入星期一至星期日的某天，如何判断用户的输入是否是一个有效的星期呢？&lt;/p&gt;

&lt;p&gt;可以用 if 语句判断，但这样做非常繁琐：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x = '???' # 用户输入的字符串
if x!= 'MON' and x!= 'TUE' and x!= 'WED' ... and x!= 'SUN':
    print 'input error'
else:
    print 'input ok'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意：if 语句中的…表示没有列出的其它星期名称，测试时，请输入完整。&lt;/p&gt;

&lt;p&gt;如果事先创建好一个set，包含’MON’ ~ ‘SUN’：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;weekdays = set(['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN'])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再判断输入是否有效，只需要判断该字符串是否在set中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x = '???' # 用户输入的字符串
if x in weekdays:
    print 'input ok'
else:
    print 'input error'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样一来，代码就简单多了。&lt;/p&gt;

&lt;h3 id=&quot;遍历set&quot;&gt;遍历Set&lt;/h3&gt;

&lt;p&gt;由于 set 也是一个集合，所以，遍历 set 和遍历 list 类似，都可以通过 for 循环实现。&lt;/p&gt;

&lt;p&gt;直接使用 for 循环可以遍历 set 的元素：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s = set(['Adam', 'Lisa', 'Bart'])
&amp;gt;&amp;gt;&amp;gt; for name in s:
...     print name
... 
Lisa
Adam
Bart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意: 观察 for 循环在遍历set时，元素的顺序和list的顺序很可能是不同的，而且不同的机器上运行的结果也可能不同。&lt;/p&gt;

&lt;h3 id=&quot;更新set&quot;&gt;更新Set&lt;/h3&gt;

&lt;p&gt;由于set存储的是一组不重复的无序元素，因此，更新set主要做两件事：&lt;/p&gt;

&lt;p&gt;一是把新的元素添加到set中，二是把已有元素从set中删除。&lt;/p&gt;

&lt;p&gt;添加元素时，用set的add()方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s = set([1, 2, 3])
&amp;gt;&amp;gt;&amp;gt; s.add(4)
&amp;gt;&amp;gt;&amp;gt; print s
set([1, 2, 3, 4])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果添加的元素已经存在于set中，add()不会报错，但是不会加进去了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s = set([1, 2, 3])
&amp;gt;&amp;gt;&amp;gt; s.add(3)
&amp;gt;&amp;gt;&amp;gt; print s
set([1, 2, 3])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;删除set中的元素时，用set的remove()方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s = set([1, 2, 3, 4])
&amp;gt;&amp;gt;&amp;gt; s.remove(4)
&amp;gt;&amp;gt;&amp;gt; print s
set([1, 2, 3])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果删除的元素不存在set中，remove()会报错：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s = set([1, 2, 3])
&amp;gt;&amp;gt;&amp;gt; s.remove(4)
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
KeyError: 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所以用add()可以直接添加，而remove()前需要判断。&lt;/p&gt;

&lt;h2 id=&quot;函数&quot;&gt;函数&lt;/h2&gt;

&lt;p&gt;我们知道圆的面积计算公式为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;S = πr²
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;r1 = 12.34
r2 = 9.08
r3 = 73.1
s1 = 3.14 * r1 * r1
s2 = 3.14 * r2 * r2
s3 = 3.14 * r3 * r3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 * x * x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。&lt;/p&gt;

&lt;p&gt;有了函数，我们就不再每次写s = 3.14 * x * x，而是写成更有意义的函数调用 s = area_of_circle(x)，而函数 area_of_circle 本身只需要写一次，就可以多次调用。&lt;/p&gt;

&lt;p&gt;抽象是数学中非常常见的概念。举个例子：&lt;/p&gt;

&lt;p&gt;计算数列的和，比如：1 + 2 + 3 + … + 100，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + … + 100记作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;100
∑n
n=1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这种抽象记法非常强大，因为我们看到∑就可以理解成求和，而不是还原成低级的加法运算。&lt;/p&gt;

&lt;p&gt;而且，这种抽象记法是可扩展的，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;100
∑(n²+1)
n=1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;还原成加法运算就变成了：&lt;/p&gt;

&lt;p&gt;(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + … + (100 x 100 + 1)
可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。&lt;/p&gt;

&lt;p&gt;写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。&lt;/p&gt;

&lt;p&gt;Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。&lt;/p&gt;

&lt;h3 id=&quot;调用函数&quot;&gt;调用函数&lt;/h3&gt;

&lt;p&gt;Python内置了很多有用的函数，我们可以直接调用。&lt;/p&gt;

&lt;p&gt;要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数 abs，它接收一个参数。&lt;/p&gt;

&lt;p&gt;可以直接从Python的官方网站查看文档：
http://docs.python.org/2/library/functions.html#abs
也可以在交互式命令行通过 help(abs) 查看abs函数的帮助信息。&lt;/p&gt;

&lt;p&gt;调用 abs 函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; abs(100)
100
&amp;gt;&amp;gt;&amp;gt; abs(-20)
20
&amp;gt;&amp;gt;&amp;gt; abs(12.34)
12.34
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; abs(1, 2)
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: abs() takes exactly one argument (2 given)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; abs('a')
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: bad operand type for abs(): 'str'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而比较函数 cmp(x, y) 就需要两个参数，如果 x&amp;lt;y，返回 -1，如果 x==y，返回 0，如果 x&amp;gt;y，返回 1：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; cmp(1, 2)
-1
&amp;gt;&amp;gt;&amp;gt; cmp(2, 1)
1
&amp;gt;&amp;gt;&amp;gt; cmp(3, 3)
0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Python内置的常用函数还包括数据类型转换函数，比如   int()函数可以把其他数据类型转换为整数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; int('123')
123
&amp;gt;&amp;gt;&amp;gt; int(12.34)
12
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;str()函数把其他类型转换成 str：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; str(123)
'123'
&amp;gt;&amp;gt;&amp;gt; str(1.23)
'1.23'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;编写函数&quot;&gt;编写函数&lt;/h3&gt;

&lt;p&gt;在Python中，定义一个函数要使用 def 语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用 return 语句返回。&lt;/p&gt;

&lt;p&gt;我们以自定义一个求绝对值的 my_abs 函数为例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def my_abs(x):
    if x &amp;gt;= 0:
        return x
    else:
        return -x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。&lt;/p&gt;

&lt;p&gt;如果没有return语句，函数执行完毕后也会返回结果，只是结果为 None。&lt;/p&gt;

&lt;p&gt;return None可以简写为return。&lt;/p&gt;

&lt;h3 id=&quot;返回多值&quot;&gt;返回多值&lt;/h3&gt;

&lt;p&gt;函数可以返回多个值吗？答案是肯定的。&lt;/p&gt;

&lt;p&gt;比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;# math&lt;/code&gt;包提供了sin()和 cos()函数，我们先用&lt;code class=&quot;highlighter-rouge&quot;&gt;import&lt;/code&gt;引用它：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import math
def move(x, y, step, angle):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样我们就可以同时获得返回值：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; x, y = move(100, 100, 60, math.pi / 6)
&amp;gt;&amp;gt;&amp;gt; print x, y
151.961524227 70.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但其实这只是一种假象，Python函数返回的仍然是单一值：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; r = move(100, 100, 60, math.pi / 6)
&amp;gt;&amp;gt;&amp;gt; print r
(151.96152422706632, 70.0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;用print打印返回结果，原来返回值是一个tuple！&lt;/p&gt;

&lt;p&gt;但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。&lt;/p&gt;

&lt;h3 id=&quot;递归函数&quot;&gt;递归函数&lt;/h3&gt;

&lt;p&gt;在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。&lt;/p&gt;

&lt;p&gt;举个例子，我们来计算阶乘 n! = 1 * 2 * 3 * … * n，用函数 fact(n)表示，可以看出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fact(n) = n! = 1 * 2 * 3 * ... * (n-1) * n = (n-1)! * n = fact(n-1) * n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所以，fact(n)可以表示为 n * fact(n-1)，只有n=1时需要特殊处理。&lt;/p&gt;

&lt;p&gt;于是，fact(n)用递归的方式写出来就是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面就是一个递归函数。可以试试：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; fact(1)
1
&amp;gt;&amp;gt;&amp;gt; fact(5)
120
&amp;gt;&amp;gt;&amp;gt; fact(100)
93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000L
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果我们计算fact(5)，可以根据函数定义看到计算过程如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;===&amp;gt; fact(5)
===&amp;gt; 5 * fact(4)
===&amp;gt; 5 * (4 * fact(3))
===&amp;gt; 5 * (4 * (3 * fact(2)))
===&amp;gt; 5 * (4 * (3 * (2 * fact(1))))
===&amp;gt; 5 * (4 * (3 * (2 * 1)))
===&amp;gt; 5 * (4 * (3 * 2))
===&amp;gt; 5 * (4 * 6)
===&amp;gt; 5 * 24
===&amp;gt; 120
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用递归函数需要注意防止栈溢出。&lt;/strong&gt;在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试计算 fact(10000)。&lt;/p&gt;

&lt;h3 id=&quot;定义默认参数&quot;&gt;定义默认参数&lt;/h3&gt;

&lt;p&gt;定义函数的时候，还可以有默认参数。&lt;/p&gt;

&lt;p&gt;例如Python自带的 int() 函数，其实就有两个参数，我们既可以传一个参数，又可以传两个参数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; int('123')
123
&amp;gt;&amp;gt;&amp;gt; int('123', 8)
83
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;int()函数的第二个参数是转换进制，如果不传，默认是十进制 (base=10)，如果传了，就用传入的参数。&lt;/p&gt;

&lt;p&gt;可见，函数的默认参数的作用是简化调用，你只需要把必须的参数传进去。但是在需要的时候，又可以传入额外的参数来覆盖默认参数值。&lt;/p&gt;

&lt;p&gt;我们来定义一个计算 x 的N次方的函数:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def power(x, n):
    s = 1
    while n &amp;gt; 0:
        n = n - 1
        s = s * x
    return s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;假设计算平方的次数最多，我们就可以把 n 的默认值设定为 2：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def power(x, n=2):
    s = 1
    while n &amp;gt; 0:
        n = n - 1
        s = s * x
    return s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样一来，计算平方就不需要传入两个参数了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; power(5)
25
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于函数的参数按从左到右的顺序匹配，所以默认参数只能定义在必需参数的后面：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# OK:
def fn1(a, b=1, c=2):
    pass
# Error:
def fn2(a=1, b):
    pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;定义可变参数&quot;&gt;定义可变参数&lt;/h3&gt;

&lt;p&gt;如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def fn(*args):
    print args
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可变参数的名字前面有个 * 号，我们可以传入0个、1个或多个参数给可变参数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; fn()
()
&amp;gt;&amp;gt;&amp;gt; fn('a')
('a',)
&amp;gt;&amp;gt;&amp;gt; fn('a', 'b')
('a', 'b')
&amp;gt;&amp;gt;&amp;gt; fn('a', 'b', 'c')
('a', 'b', 'c')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可变参数也不是很神秘，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。&lt;/p&gt;

&lt;p&gt;定义可变参数的目的也是为了简化调用。假设我们要计算任意个数的平均值，就可以定义一个可变参数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def average(*args):
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样，在调用的时候，可以这样写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; average()
0
&amp;gt;&amp;gt;&amp;gt; average(1, 2)
1.5
&amp;gt;&amp;gt;&amp;gt; average(1, 2, 2, 3, 4)
2.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;切片&quot;&gt;切片&lt;/h2&gt;

&lt;h3 id=&quot;对list进行切片&quot;&gt;对list进行切片&lt;/h3&gt;

&lt;p&gt;取一个list的部分元素是非常常见的操作。比如，一个list如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L = ['Adam', 'Lisa', 'Bart', 'Paul']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;取前3个元素，应该怎么做？&lt;/p&gt;

&lt;p&gt;笨办法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; [L[0], L[1], L[2]]
['Adam', 'Lisa', 'Bart']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;之所以是笨办法是因为扩展一下，取前N个元素就没辙了。&lt;/p&gt;

&lt;p&gt;取前N个元素，也就是索引为0-(N-1)的元素，可以用循环：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; r = []
&amp;gt;&amp;gt;&amp;gt; n = 3
&amp;gt;&amp;gt;&amp;gt; for i in range(n):
...     r.append(L[i])
... 
&amp;gt;&amp;gt;&amp;gt; r
['Adam', 'Lisa', 'Bart']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。&lt;/p&gt;

&lt;p&gt;对应上面的问题，取前3个元素，用一行代码就可以完成切片：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L[0:3]
['Adam', 'Lisa', 'Bart']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。&lt;/p&gt;

&lt;p&gt;如果第一个索引是0，还可以省略：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L[:3]
['Adam', 'Lisa', 'Bart']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;也可以从索引1开始，取出2个元素出来：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L[1:3]
['Lisa', 'Bart']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;只用一个 : ，表示从头到尾：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L[:]
['Adam', 'Lisa', 'Bart', 'Paul']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因此，L[:]实际上复制出了一个新list。&lt;/p&gt;

&lt;p&gt;切片操作还可以指定第三个参数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L[::2]
['Adam', 'Bart']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第三个参数表示每N个取一个，上面的 L[::2] 会每两个元素取出一个来，也就是隔一个取一个。&lt;/p&gt;

&lt;p&gt;把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。&lt;/p&gt;

&lt;h3 id=&quot;倒序切片&quot;&gt;倒序切片&lt;/h3&gt;

&lt;p&gt;对于list，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L = ['Adam', 'Lisa', 'Bart', 'Paul']

&amp;gt;&amp;gt;&amp;gt; L[-2:]
['Bart', 'Paul']

&amp;gt;&amp;gt;&amp;gt; L[:-2]
['Adam', 'Lisa']

&amp;gt;&amp;gt;&amp;gt; L[-3:-1]
['Lisa', 'Bart']

&amp;gt;&amp;gt;&amp;gt; L[-4:-1:2]
['Adam', 'Bart']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;记住倒数第一个元素的索引是-1。倒序切片包含起始索引，不包含结束索引。&lt;/p&gt;

&lt;h3 id=&quot;对字符串切片&quot;&gt;对字符串切片&lt;/h3&gt;

&lt;p&gt;字符串 ‘xxx’和 Unicode字符串 u’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 'ABCDEFG'[:3]
'ABC'
&amp;gt;&amp;gt;&amp;gt; 'ABCDEFG'[-3:]
'EFG'
&amp;gt;&amp;gt;&amp;gt; 'ABCDEFG'[::2]
'ACEG'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。&lt;/p&gt;

&lt;h2 id=&quot;迭代&quot;&gt;迭代&lt;/h2&gt;

&lt;p&gt;在Python中，如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们成为迭代（Iteration）。&lt;/p&gt;

&lt;p&gt;在Python中，迭代是通过 for … in 来完成的，而很多语言比如C或者Java，迭代list是通过下标完成的，比如Java代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (i=0; i&amp;lt;list.length; i++) {
    n = list[i];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看出，Python的for循环抽象程度要高于Java的for循环。&lt;/p&gt;

&lt;p&gt;因为 Python 的 for循环不仅可以用在list或tuple上，还可以作用在其他任何可迭代对象上。&lt;/p&gt;

&lt;p&gt;因此，迭代操作就是对于一个集合，无论该集合是有序还是无序，我们用 for 循环总是可以依次取出集合的每一个元素。&lt;/p&gt;

&lt;p&gt;注意: 集合是指包含一组元素的数据结构，我们已经介绍的包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;有序集合：list，tuple，str和unicode；&lt;/li&gt;
  &lt;li&gt;无序集合：set&lt;/li&gt;
  &lt;li&gt;无序集合并且具有 key-value 对：dict
而迭代是一个动词，它指的是一种操作，在Python中，就是 for 循环。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;迭代与按下标访问数组最大的不同是，后者是一种具体的迭代实现方式，而前者只关心迭代结果，根本不关心迭代内部是如何实现的。&lt;/p&gt;

&lt;h3 id=&quot;索引迭代&quot;&gt;索引迭代&lt;/h3&gt;

&lt;p&gt;Python中，迭代永远是取出元素本身，而非元素的索引。&lt;/p&gt;

&lt;p&gt;对于有序集合，元素确实是有索引的。有的时候，我们确实想在 for 循环中拿到索引，怎么办？&lt;/p&gt;

&lt;p&gt;方法是使用 enumerate() 函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L = ['Adam', 'Lisa', 'Bart', 'Paul']
&amp;gt;&amp;gt;&amp;gt; for index, name in enumerate(L):
...     print index, '-', name
... 
0 - Adam
1 - Lisa
2 - Bart
3 - Paul
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 enumerate() 函数，我们可以在for循环中同时绑定索引index和元素name。但是，这不是 enumerate() 的特殊语法。实际上，enumerate() 函数把：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;['Adam', 'Lisa', 'Bart', 'Paul']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;变成了类似：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[(0, 'Adam'), (1, 'Lisa'), (2, 'Bart'), (3, 'Paul')]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因此，迭代的每一个元素实际上是一个tuple：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for t in enumerate(L):
    index = t[0]
    name = t[1]
    print index, '-', name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for index, name in enumerate(L):
    print index, '-', name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样不但代码更简单，而且还少了两条赋值语句。&lt;/p&gt;

&lt;p&gt;可见，索引迭代也不是真的按索引访问，而是由 enumerate() 函数自动把每个元素变成 (index, element) 这样的tuple，再迭代，就同时获得了索引和元素本身。&lt;/p&gt;

&lt;h3 id=&quot;迭代dict的value&quot;&gt;迭代Dict的value&lt;/h3&gt;

&lt;p&gt;我们已经了解了dict对象本身就是可迭代对象，用 for 循环直接迭代 dict，可以每次拿到dict的一个key。&lt;/p&gt;

&lt;p&gt;如果我们希望迭代 dict 对象的value，应该怎么做？&lt;/p&gt;

&lt;p&gt;dict 对象有一个 values() 方法，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }
print d.values()
# [85, 95, 59]
for v in d.values():
    print v
# 85
# 95
# 59
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果仔细阅读Python的文档，还可以发现，dict除了values()方法外，还有一个 itervalues() 方法，用 itervalues() 方法替代 values() 方法，迭代效果完全一样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }
print d.itervalues()
# &amp;lt;dictionary-valueiterator object at 0x106adbb50&amp;gt;
for v in d.itervalues():
    print v
# 85
# 95
# 59
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那这两个方法有何不同之处呢？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;values() 方法实际上把一个 dict 转换成了包含 value 的list。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;但是 itervalues() 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;打印 itervalues() 发现它返回一个 &lt;dictionary-valueiterator&gt; 对象，这说明在Python中，for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。&lt;/dictionary-valueiterator&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。&lt;/p&gt;

&lt;h3 id=&quot;迭代dict的key和value&quot;&gt;迭代Dict的key和value&lt;/h3&gt;

&lt;p&gt;我们了解了如何迭代 dict 的key和value，那么，在一个 for 循环中，能否同时迭代 key和value？答案是肯定的。&lt;/p&gt;

&lt;p&gt;首先，我们看看 dict 对象的 items() 方法返回的值：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }
&amp;gt;&amp;gt;&amp;gt; print d.items()
[('Lisa', 85), ('Adam', 95), ('Bart', 59)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到，items() 方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; for key, value in d.items():
...     print key, ':', value
... 
Lisa : 85
Adam : 95
Bart : 59
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;和 values() 有一个 itervalues() 类似， items() 也有一个对应的 iteritems()，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。&lt;/p&gt;

&lt;h2 id=&quot;列表&quot;&gt;列表&lt;/h2&gt;

&lt;h3 id=&quot;列表生成&quot;&gt;列表生成&lt;/h3&gt;

&lt;p&gt;要生成&lt;code class=&quot;highlighter-rouge&quot;&gt;list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&lt;/code&gt;，我们可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;range(1, 11)&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; range(1, 11)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; L = []
&amp;gt;&amp;gt;&amp;gt; for x in range(1, 11):
...    L.append(x * x)
... 
&amp;gt;&amp;gt;&amp;gt; L
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。&lt;/p&gt;

&lt;p&gt;写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。&lt;/p&gt;

&lt;h3 id=&quot;复杂表达式&quot;&gt;复杂表达式&lt;/h3&gt;

&lt;p&gt;使用for循环的迭代不仅可以迭代普通的list，还可以迭代dict。&lt;/p&gt;

&lt;p&gt;假设有如下的dict：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;完全可以通过一个复杂的列表生成式把它变成一个 HTML 表格：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tds = ['&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;%s&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;%s&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;' % (name, score) for name, score in d.iteritems()]
print '&amp;lt;table&amp;gt;'
print '&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Score&amp;lt;/th&amp;gt;&amp;lt;tr&amp;gt;'
print '\n'.join(tds)
print '&amp;lt;/table&amp;gt;'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注：字符串可以通过 % 进行格式化，用指定的参数替代 %s。字符串的join()方法可以把一个 list 拼接成一个字符串。&lt;/p&gt;

&lt;p&gt;把打印出来的结果保存为一个html文件，就可以在浏览器中看到效果了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;table border=&quot;1&quot;&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Score&amp;lt;/th&amp;gt;&amp;lt;tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Lisa&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;85&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Adam&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;95&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Bart&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;59&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;Score&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Lisa&lt;/td&gt;
      &lt;td&gt;85&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Adam&lt;/td&gt;
      &lt;td&gt;95&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Bart&lt;/td&gt;
      &lt;td&gt;59&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;条件过滤&quot;&gt;条件过滤&lt;/h3&gt;

&lt;p&gt;列表生成式的 for 循环后面还可以加上 if 判断。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果我们只想要偶数的平方，不改动 range()的情况下，可以加上 if 来筛选：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。&lt;/p&gt;

&lt;h3 id=&quot;多层表达式&quot;&gt;多层表达式&lt;/h3&gt;

&lt;p&gt;for循环可以嵌套，因此，在列表生成式中，也可以用多层 for 循环来生成列表。&lt;/p&gt;

&lt;p&gt;对于字符串 ‘ABC’ 和 ‘123’，可以使用两层循环，生成全排列：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; [m + n for m in 'ABC' for n in '123']
['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;翻译成循环代码就像下面这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;L = []
for m in 'ABC':
    for n in '123':
        L.append(m + n)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 22 Apr 2017 21:48:41 +0800</pubDate>
      </item>
    
  </channel>
</rss>