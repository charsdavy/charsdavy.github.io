<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <!-- JQuery (used for bootstrap and jekyll search) -->
    <script src="/assets/js/jquery-3.2.1.min.js" ></script>
    
    <!-- Main JS (navbar.js and katex_init.js)-->
    <script defer=true src="/assets/js/main.min.js"></script>
    
    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css">

    <!--Favicon-->
    <link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

    <!-- Canonical -->
    <link rel="canonical" href="http://chars.tech/code/2016/02/17/YYModel-reading.html">

    <!-- RSS -->
    <link rel="alternate" type="application/atom+xml" title="Chars" href="http://chars.tech///feed.xml"/>

    <!-- Font Awesome -->
    <!-- <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"> -->
    <link rel="stylesheet" type="text/css" href="/assets/css/font-awesome.min.css">

    <!-- Google Fonts -->
    
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css"> 
    

    <!-- KaTeX 0.8.3 -->
    
    <!--<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js"></script> -->
    <link rel="stylesheet" type="text/css" href="/assets/css/katex.min.css">
    <script src="/assets/js/katex.min.js">
    </script>
    

    <!-- Google Analytics -->
    
    <script>
        (function(i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r;
            i[r] = i[r] || function() {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o),
                m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m)
        })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

        ga('create', 'UA-80507808-1', 'auto');
        ga('send', 'pageview');

    </script>
    
    
    <!-- seo tags -->
    <!-- Begin Jekyll SEO tag v2.4.0 -->
<title>YYModel源代码阅读 - 基础知识</title>
<meta name="generator" content="Jekyll v3.7.2" />
<meta property="og:title" content="YYModel源代码阅读 - 基础知识" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="YYModel堪称神级大作，虽然不免一些小bug，但是完全不影响膝盖碎一地。文章主要分享在阅读YYModel源代码时，所引发的知识点的补充与思考。 前言 这段时间因为工作需要，阅读了YYModel这个开源框架，至于它能做什么，最直白的讲述就是JSON与Model之间的相互转化。 源代码在Github，大家可以自行git clone或者download。 接下来，笔者主要分析阅读源代码而引出的各种问题与知识点，不足之处请大家指正。 NS_ASSUME_NONNULL_BEGIN &amp; NS_ASSUME_NONNULL_END 这组宏是成对使用的，不得不说我们自己写代码的时候使用的很少，以至于遗漏这个知识点，现在我们就来看看这两个宏会引出什么问题。 这组宏会引出几个关于Objective-C新特性的知识点： Nullability Annotations Lightweight Generics __kindof Nullability Annotations 我们都知道在swift中，可以使用!和?来表示一个对象是optional的还是non-optional，如view?和view!。而在 Objective-C中则没有这一区分，view既可表示这个对象是optional，也可表示是non-optioanl。这样就会造成一个问题：在 Swift与Objective-C混编时，Swift编译器并不知道一个Objective-C对象到底是optional还是non-optional，因此这种情况下编译器会隐式地将Objective-C的对象当成是non-optional。 为了解决这个问题，苹果在Xcode 6.3引入了一个Objective-C的新特性：nullability annotations。这一新特性的核心是两个新的类型注释：** __nullable** 和 __nonnull 。从字面上我们可以猜到，__nullable表示对象可以是NULL或nil，而__nonnull表示对象不应该为空。当我们不遵循这一规则时，编译器就会给出警告。 我们来看看以下的实例， @interface TestNullabilityClass () @property (nonatomic, copy) NSArray * items; - (id)itemWithName:(NSString * __nonnull)name; @end @implementation TestNullabilityClass ... - (void)testNullability { [self itemWithName:nil]; // 编译器警告：Null passed to a callee that requires a non-null argument } - (id)itemWithName:(NSString * __nonnull)name { return nil; } @end 不过这只是一个警告，程序还是能编译通过并运行。 事实上，在任何可以使用const关键字的地方都可以使用__nullable和__nonnull，不过这两个关键字仅限于使用在指针类型上。而在方法的声明中，我们还可以使用不带下划线的nullable和nonnull，如下所示： - (nullable id)itemWithName:(NSString * nonnull)name 在属性声明中，也增加了两个相应的特性，因此上例中的items属性可以如下声明： @property (nonatomic, copy, nonnull) NSArray * items; 当然也可以用以下这种方式： @property (nonatomic, copy) NSArray * __nonnull items; 推荐使用nonnull这种方式，这样可以让属性声明看起来更清晰。 Nonnull区域设置(Audited Regions) 如果需要每个属性或每个方法都去指定nonnull和nullable，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END。在这两个宏之间的代码，所有简单指针对象都被假定为 nonnull，因此我们只需要去指定那些nullable的指针。如下代码所示： NS_ASSUME_NONNULL_BEGIN @interface TestNullabilityClass () @property (nonatomic, copy) NSArray * items; - (id)itemWithName:(nullable NSString *)name; @end NS_ASSUME_NONNULL_END 在上面的代码中，items属性默认是nonnull的，itemWithName:方法的返回值也是nonnull，而参数是指定为nullable的。 不过，为了安全起见，苹果还制定了几条规则： typedef定义的类型的nullability特性通常依赖于上下文，即使是在Audited Regions中，也不能假定它为nonnull。 复杂的指针类型(如id *)必须显示去指定是nonnull还是nullable。例如，指定一个指向nullable对象的nonnull指针，可以使用”__nullable id * __nonnull”。 我们经常使用的NSError **通常是被假定为一个指向nullable NSError对象的nullable指针。 兼容性 因为Nullability Annotations是Xcode 6.3新加入的，所以我们需要考虑之前的老代码。实际上，苹果已以帮我们处理好了这种兼容问题，我们可以安全地使用它们： 老代码仍然能正常工作，即使对nonnull对象使用了nil也没有问题。 老代码在需要和swift混编时，在新的swift编译器下会给出一个警告。 nonnull不会影响性能。事实上，我们仍然可以在运行时去判断我们的对象是否为nil。 事实上，我们可以将nonnull/nullable与我们的断言和异常一起看待，其需要处理的问题都是同一个：违反约定是一个程序员的错误。特别是，返回值是我们可控的东西，如果返回值是nonnull的，则我们不应该返回nil，除非是为了向后兼容。 Lightweight Generics Lightweight Generics 轻量级泛型，轻量是因为这是个纯编译器的语法支持（LLVM 7.0），和 Nullability 一样，没有借助任何 objc runtime 的升级，也就是说，这个新语法在 Xcode 7 上可以使用且完全向下兼容（更低的 iOS 版本） 带泛型的容器 这无疑是本次最重大的改进，有了泛型后终于可以指定容器类中对象的类型了： NSArray&lt;NSString *&gt; *strings = @[@&quot;sun&quot;, @&quot;yuan&quot;]; NSDictionary&lt;NSString *, NSNumber *&gt; *mapping = @{@&quot;a&quot;: @1, @&quot;b&quot;: @2}; 返回值的 id 被替换成具体的类型后，令人感动的代码提示也出来了。 假如向泛型容器中加入错误的对象，编译器会不开心的。 系统中常用的一系列容器类型都增加了泛型支持，甚至连 NSEnumerator 都支持了，这是非常 Nice 的改进。和 Nullability 一样，我认为最大的意义还是丰富了接口描述信息，对比下面两种写法： @property (readonly) NSArray *imageURLs; @property (readonly) NSArray&lt;NSURL *&gt; *imageURLs; 不用多想就清楚下面的数组中存的是什么，避免了 NSString 和 NSURL 的混乱。 自定义泛型类 比起使用系统的泛型容器，更好玩的是自定义一个泛型类，目前这里还没什么文档，但拦不住我们写测试代码，假设我们要自定义一个 Stack 容器类： @interface Stack&lt;ObjectType&gt; : NSObject - (void)pushObject:(ObjectType)object; - (ObjectType)popObject; @property (nonatomic, readonly) NSArray&lt;ObjectType&gt; *allObjects; @end 这个 ObjectType 是传入类型的 placeholder，它只能在 @interface 上定义（类声明、类扩展、Category），如果你喜欢用 T 表示也 OK，这个类型在 @interface 和 @end 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型，应该说一切都是符合预期的。我们还可以给 ObjectType 增加类型限制，比如： // 只接受 NSNumber * 的泛型 @interface Stack&lt;ObjectType: NSNumber *&gt; : NSObject // 只接受满足 NSCopying 协议的泛型 @interface Stack&lt;ObjectType: id&lt;NSCopying&gt;&gt; : NSObject 若什么都不加，表示接受任意类型 ( id )；当类型不满足时编译器将产生 error。 实例化一个 Stack，一切工作正常： 对于多参数的泛型，用逗号隔开，其他都一样，可以参考 NSDictionary 的头文件。 协变性和逆变性 当类支持泛型后，它们的 Type 发生了变化，比如下面三个对象看上去都是 Stack，但实际上属于三个 Type： Stack *stack; // Stack * Stack&lt;NSString *&gt; *stringStack; // Stack&lt;NSString *&gt; Stack&lt;NSMutableString *&gt; *mutableStringStack; // Stack&lt;NSMutableString *&gt; 当其中两种类型做类型转化时，编译器需要知道哪些转化是允许的，哪些是禁止的，比如，默认情况下： Stack *stack; Stack&lt;NSString *&gt; *stringStack; Stack&lt;NSMutableString *&gt; *mutableStringStack; stack = stringStack; stack = mutableStringStack; stringStack = stack; stringStack = mutableStringStack; mutableStringStack = stack; mutableStringStack = stringStack 在Xcode中我们可以看到，不指定泛型类型的 Stack 可以和任意泛型类型转化，但指定了泛型类型后，两个不同类型间是不可以强转的，假如你希望主动控制转化关系，就需要使用泛型的协变性和逆变性修饰符了： __covariant - 协变性，子类型可以强转到父类型（里氏替换原则） __contravariant - 逆变性，父类型可以强转到子类型（WTF） 协变 @interface Stack&lt;__covariant ObjectType&gt; : NSObject 逆变 @interface Stack&lt;__contravariant ObjectType&gt; : NSObject 协变是非常好理解的，像 NSArray 的泛型就用了协变的修饰符。 __kindof __kindof 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 UITableView 的这个方法来说： - (id)dequeueReusableCellWithIdentifier:(NSString *)identifier; 使用时前面基本会使用 UITableViewCell 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 UITableViewCell 或 UITableViewCell 子类的实例，于是新的 __kindof 关键字解决了这个问题： - (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier; 既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView 的 subviews 属性被修改成了： @property (nonatomic, readonly, copy) NSArray&lt;__kindof UIView *&gt; *subviews; 这样，写下面的代码时就没有任何警告了： UIButton *button = view.subviews.lastObject; NS_ENUM &amp; NS_OPTIONS 枚举是指将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。 枚举本质上是一个整数，枚举的作用是把值限定在指定的范围内，并且增加代码的可读性。 枚举的成员如果没有显示指定值，那么第一个成员的值总是0，后面成员的值依次递增。枚举可以直接用于比较。 一般我们声明枚举： #import &lt;Foundation/Foundation.h&gt; // 声明枚举类型 enum Direction {up, down, left = 10, right}; int main(int argc, const char * argv[]){ ... } 其中up = 0, down = 1, left = 10, right = 11。 我们会发现枚举中一些不可自定义的部分，例如，枚举名。 NS_ENUM 和 NS_OPTIONS 都不算太古老的宏，在iOS 6 / OS X Mountain Lion才开始有，它们都是代替 enum 的更好的办法。 NS_ENUM 如果要在早期的iOS或OS X系统中使用这两个宏，简单定义一下就好 #ifndef NS_ENUM #define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type #endif 在OS X 10.4 中的原始定义如下： #define NS_ENUM(_type, _name) CF_ENUM(_type, _name) #define NS_OPTIONS(_type, _name) CF_OPTIONS(_type, _name) 在之前枚举可以这么定义： typedef enum { UITableViewCellStyleDefault, UITableViewCellStyleValue1, UITableViewCellStyleValue2, UITableViewCellStyleSubtitle }; 或者 typedef NSInteger UITableViewCellStyle; 现在，有了统一的风格 typedef NS_ENUM(NSInteger, UITableViewCellSelectionStyle) { UITableViewCellSelectionStyleNone, UITableViewCellSelectionStyleBlue, UITableViewCellSelectionStyleGray, UITableViewCellSelectionStyleDefault }; NS_ENUM 的第一个参数是用于存储的新类型的类型。在64位环境下，UITableViewCellStyle 和 NSInteger 一样有8 bytes长。你要保证你给出的所有值能被该类型容纳，否则就会产生错误。第二个参数是新类型的名字。大括号里面和以前一样，是你要定义的各种值。 NS_OPTIONS 语法和 NS_ENUM 完全相同，但这个宏提示编译器值是如何通过位掩码 组合在一起的。 typedef NS_OPTIONS(NSUInteger, AMGResizing) { AMGResizingNone = 0, AMGResizingFlexibleWidth = 1 &lt;&lt; 0, AMGResizingFlexibleHeight = 1 &lt;&lt; 1, AMGResizingFlexibleUnicorn = 1 &lt;&lt; 2 }; attribute((always_inline)) 我们知道一般的函数调用都会通过call的方式来调用，这样让攻击很容易对一个函数做手脚，如果是以inline的方式编译的会，会把该函数的code拷贝到每次调用该函数的地方。而static会让生成的二进制文件中没有清晰的符号表，让逆向的人很难弄清楚逻辑。 __attribute__((always_inline)) 的意思是强制内联，所有加了__attribute__((always_inline)) 的函数再被调用时不会被编译成函数调用而是直接扩展到调用函数体内，比如定义了函数 __attribute__((always_inline)) void a() 和 void b()｛ a(); ｝ b 调用 a 函数的汇编代码不会是跳转到a执行，而是 a 函数的代码直接在 b 内成为 b 的一部分。 #define __inline __attribute__((always_inline)) 的意思就是用 __inline 代替__attribute__((always_inline)) 内声明a的时候可以直接写成__inline void a() 这样比较方便因为__attribute__((always_inline)) 字多。 undef 这是预编译指令，和#define搭配使用，意思是取消之前的宏定义。 #define PROC_ADD void main(void) { #ifdef PROC_ADD // Do this code here then undefined it to run the code in the else // processing work #undef PROC_ADD #else // now that PROC_ADD has been undefined run this code // processing work #endif } __unsafe_unretained __unsafe_unretained是对对象的非zeroing的weak reference，意思是当对象所指向的内存被销毁了，对象还存在，称为“野指针”。 在iOS引入了Automatic Reference Count（ARC）之后，编译器可以在编译时对obj-c对象进行内存管理。大致规则如下： alloc的要release; retain/copy的要release; NSAutoreleasePool在ARC中被禁止使用,替换成@autoreleasepool 函数体; 使用@ autoreleasepool,在函数入口的时候,autorelease pool入栈,正常退出时,autorelease pool出栈,从而释放变量. 注意:@ autoreleasepool在非ARC模式下,也能使用,并据说使用@autoreleasepool比使用NSAutoreleasePool速度能快6倍, 明显提升程序性能. @package 为了强制一个对象隐藏其数据，编译器限制实例变量范围以限制其在程序中的可见性，但是为了提供灵活性，苹果也让开发者显式设置范围。 以下是这些关键字的使用范围： @private The instance variable is accessible only within the class that declares it. 实例变量只能被声明它的类访问. @protected The instance variable is accessible within the class that declares it and within classes that inherit it. All instance variables without an explicit scope directive have @protected scope. 实例变量能被声明它的类和子类访问，所有没有显式制定范围的实例变量都是. @public The instance variable is accessible everywhere. 实例变量可以被在任何地方访问. @package Using the modern runtime, an @package instance variable has @public scope inside the executable image that implements the class, but acts like @private outside.使用modern运行时，一个@package实例变量在实现这个类的可执行文件镜像中实际上是@public的，但是在外面就是@private【runtime需要再看一下苹果文档Runtime Programming Guide】 The @package scope for Objective-C instance variables is analogous to private_extern for C variables and functions. Any code outside the class implementation’s image that tries to use the instance variable gets a link error. Objective-C中的@package与C语言中变量和函数的private_extern类似。任何在实现类的镜像之外的代码想使用这个实例变量都会引发link error This scope is most useful for instance variables in framework classes, where @private may be too restrictive but @protected or @public too permissive. 这个类型最常用于框架类的实例变量，使用@private太限制，使用@protected或者@public又太开放." />
<meta property="og:description" content="YYModel堪称神级大作，虽然不免一些小bug，但是完全不影响膝盖碎一地。文章主要分享在阅读YYModel源代码时，所引发的知识点的补充与思考。 前言 这段时间因为工作需要，阅读了YYModel这个开源框架，至于它能做什么，最直白的讲述就是JSON与Model之间的相互转化。 源代码在Github，大家可以自行git clone或者download。 接下来，笔者主要分析阅读源代码而引出的各种问题与知识点，不足之处请大家指正。 NS_ASSUME_NONNULL_BEGIN &amp; NS_ASSUME_NONNULL_END 这组宏是成对使用的，不得不说我们自己写代码的时候使用的很少，以至于遗漏这个知识点，现在我们就来看看这两个宏会引出什么问题。 这组宏会引出几个关于Objective-C新特性的知识点： Nullability Annotations Lightweight Generics __kindof Nullability Annotations 我们都知道在swift中，可以使用!和?来表示一个对象是optional的还是non-optional，如view?和view!。而在 Objective-C中则没有这一区分，view既可表示这个对象是optional，也可表示是non-optioanl。这样就会造成一个问题：在 Swift与Objective-C混编时，Swift编译器并不知道一个Objective-C对象到底是optional还是non-optional，因此这种情况下编译器会隐式地将Objective-C的对象当成是non-optional。 为了解决这个问题，苹果在Xcode 6.3引入了一个Objective-C的新特性：nullability annotations。这一新特性的核心是两个新的类型注释：** __nullable** 和 __nonnull 。从字面上我们可以猜到，__nullable表示对象可以是NULL或nil，而__nonnull表示对象不应该为空。当我们不遵循这一规则时，编译器就会给出警告。 我们来看看以下的实例， @interface TestNullabilityClass () @property (nonatomic, copy) NSArray * items; - (id)itemWithName:(NSString * __nonnull)name; @end @implementation TestNullabilityClass ... - (void)testNullability { [self itemWithName:nil]; // 编译器警告：Null passed to a callee that requires a non-null argument } - (id)itemWithName:(NSString * __nonnull)name { return nil; } @end 不过这只是一个警告，程序还是能编译通过并运行。 事实上，在任何可以使用const关键字的地方都可以使用__nullable和__nonnull，不过这两个关键字仅限于使用在指针类型上。而在方法的声明中，我们还可以使用不带下划线的nullable和nonnull，如下所示： - (nullable id)itemWithName:(NSString * nonnull)name 在属性声明中，也增加了两个相应的特性，因此上例中的items属性可以如下声明： @property (nonatomic, copy, nonnull) NSArray * items; 当然也可以用以下这种方式： @property (nonatomic, copy) NSArray * __nonnull items; 推荐使用nonnull这种方式，这样可以让属性声明看起来更清晰。 Nonnull区域设置(Audited Regions) 如果需要每个属性或每个方法都去指定nonnull和nullable，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END。在这两个宏之间的代码，所有简单指针对象都被假定为 nonnull，因此我们只需要去指定那些nullable的指针。如下代码所示： NS_ASSUME_NONNULL_BEGIN @interface TestNullabilityClass () @property (nonatomic, copy) NSArray * items; - (id)itemWithName:(nullable NSString *)name; @end NS_ASSUME_NONNULL_END 在上面的代码中，items属性默认是nonnull的，itemWithName:方法的返回值也是nonnull，而参数是指定为nullable的。 不过，为了安全起见，苹果还制定了几条规则： typedef定义的类型的nullability特性通常依赖于上下文，即使是在Audited Regions中，也不能假定它为nonnull。 复杂的指针类型(如id *)必须显示去指定是nonnull还是nullable。例如，指定一个指向nullable对象的nonnull指针，可以使用”__nullable id * __nonnull”。 我们经常使用的NSError **通常是被假定为一个指向nullable NSError对象的nullable指针。 兼容性 因为Nullability Annotations是Xcode 6.3新加入的，所以我们需要考虑之前的老代码。实际上，苹果已以帮我们处理好了这种兼容问题，我们可以安全地使用它们： 老代码仍然能正常工作，即使对nonnull对象使用了nil也没有问题。 老代码在需要和swift混编时，在新的swift编译器下会给出一个警告。 nonnull不会影响性能。事实上，我们仍然可以在运行时去判断我们的对象是否为nil。 事实上，我们可以将nonnull/nullable与我们的断言和异常一起看待，其需要处理的问题都是同一个：违反约定是一个程序员的错误。特别是，返回值是我们可控的东西，如果返回值是nonnull的，则我们不应该返回nil，除非是为了向后兼容。 Lightweight Generics Lightweight Generics 轻量级泛型，轻量是因为这是个纯编译器的语法支持（LLVM 7.0），和 Nullability 一样，没有借助任何 objc runtime 的升级，也就是说，这个新语法在 Xcode 7 上可以使用且完全向下兼容（更低的 iOS 版本） 带泛型的容器 这无疑是本次最重大的改进，有了泛型后终于可以指定容器类中对象的类型了： NSArray&lt;NSString *&gt; *strings = @[@&quot;sun&quot;, @&quot;yuan&quot;]; NSDictionary&lt;NSString *, NSNumber *&gt; *mapping = @{@&quot;a&quot;: @1, @&quot;b&quot;: @2}; 返回值的 id 被替换成具体的类型后，令人感动的代码提示也出来了。 假如向泛型容器中加入错误的对象，编译器会不开心的。 系统中常用的一系列容器类型都增加了泛型支持，甚至连 NSEnumerator 都支持了，这是非常 Nice 的改进。和 Nullability 一样，我认为最大的意义还是丰富了接口描述信息，对比下面两种写法： @property (readonly) NSArray *imageURLs; @property (readonly) NSArray&lt;NSURL *&gt; *imageURLs; 不用多想就清楚下面的数组中存的是什么，避免了 NSString 和 NSURL 的混乱。 自定义泛型类 比起使用系统的泛型容器，更好玩的是自定义一个泛型类，目前这里还没什么文档，但拦不住我们写测试代码，假设我们要自定义一个 Stack 容器类： @interface Stack&lt;ObjectType&gt; : NSObject - (void)pushObject:(ObjectType)object; - (ObjectType)popObject; @property (nonatomic, readonly) NSArray&lt;ObjectType&gt; *allObjects; @end 这个 ObjectType 是传入类型的 placeholder，它只能在 @interface 上定义（类声明、类扩展、Category），如果你喜欢用 T 表示也 OK，这个类型在 @interface 和 @end 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型，应该说一切都是符合预期的。我们还可以给 ObjectType 增加类型限制，比如： // 只接受 NSNumber * 的泛型 @interface Stack&lt;ObjectType: NSNumber *&gt; : NSObject // 只接受满足 NSCopying 协议的泛型 @interface Stack&lt;ObjectType: id&lt;NSCopying&gt;&gt; : NSObject 若什么都不加，表示接受任意类型 ( id )；当类型不满足时编译器将产生 error。 实例化一个 Stack，一切工作正常： 对于多参数的泛型，用逗号隔开，其他都一样，可以参考 NSDictionary 的头文件。 协变性和逆变性 当类支持泛型后，它们的 Type 发生了变化，比如下面三个对象看上去都是 Stack，但实际上属于三个 Type： Stack *stack; // Stack * Stack&lt;NSString *&gt; *stringStack; // Stack&lt;NSString *&gt; Stack&lt;NSMutableString *&gt; *mutableStringStack; // Stack&lt;NSMutableString *&gt; 当其中两种类型做类型转化时，编译器需要知道哪些转化是允许的，哪些是禁止的，比如，默认情况下： Stack *stack; Stack&lt;NSString *&gt; *stringStack; Stack&lt;NSMutableString *&gt; *mutableStringStack; stack = stringStack; stack = mutableStringStack; stringStack = stack; stringStack = mutableStringStack; mutableStringStack = stack; mutableStringStack = stringStack 在Xcode中我们可以看到，不指定泛型类型的 Stack 可以和任意泛型类型转化，但指定了泛型类型后，两个不同类型间是不可以强转的，假如你希望主动控制转化关系，就需要使用泛型的协变性和逆变性修饰符了： __covariant - 协变性，子类型可以强转到父类型（里氏替换原则） __contravariant - 逆变性，父类型可以强转到子类型（WTF） 协变 @interface Stack&lt;__covariant ObjectType&gt; : NSObject 逆变 @interface Stack&lt;__contravariant ObjectType&gt; : NSObject 协变是非常好理解的，像 NSArray 的泛型就用了协变的修饰符。 __kindof __kindof 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 UITableView 的这个方法来说： - (id)dequeueReusableCellWithIdentifier:(NSString *)identifier; 使用时前面基本会使用 UITableViewCell 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 UITableViewCell 或 UITableViewCell 子类的实例，于是新的 __kindof 关键字解决了这个问题： - (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier; 既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView 的 subviews 属性被修改成了： @property (nonatomic, readonly, copy) NSArray&lt;__kindof UIView *&gt; *subviews; 这样，写下面的代码时就没有任何警告了： UIButton *button = view.subviews.lastObject; NS_ENUM &amp; NS_OPTIONS 枚举是指将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。 枚举本质上是一个整数，枚举的作用是把值限定在指定的范围内，并且增加代码的可读性。 枚举的成员如果没有显示指定值，那么第一个成员的值总是0，后面成员的值依次递增。枚举可以直接用于比较。 一般我们声明枚举： #import &lt;Foundation/Foundation.h&gt; // 声明枚举类型 enum Direction {up, down, left = 10, right}; int main(int argc, const char * argv[]){ ... } 其中up = 0, down = 1, left = 10, right = 11。 我们会发现枚举中一些不可自定义的部分，例如，枚举名。 NS_ENUM 和 NS_OPTIONS 都不算太古老的宏，在iOS 6 / OS X Mountain Lion才开始有，它们都是代替 enum 的更好的办法。 NS_ENUM 如果要在早期的iOS或OS X系统中使用这两个宏，简单定义一下就好 #ifndef NS_ENUM #define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type #endif 在OS X 10.4 中的原始定义如下： #define NS_ENUM(_type, _name) CF_ENUM(_type, _name) #define NS_OPTIONS(_type, _name) CF_OPTIONS(_type, _name) 在之前枚举可以这么定义： typedef enum { UITableViewCellStyleDefault, UITableViewCellStyleValue1, UITableViewCellStyleValue2, UITableViewCellStyleSubtitle }; 或者 typedef NSInteger UITableViewCellStyle; 现在，有了统一的风格 typedef NS_ENUM(NSInteger, UITableViewCellSelectionStyle) { UITableViewCellSelectionStyleNone, UITableViewCellSelectionStyleBlue, UITableViewCellSelectionStyleGray, UITableViewCellSelectionStyleDefault }; NS_ENUM 的第一个参数是用于存储的新类型的类型。在64位环境下，UITableViewCellStyle 和 NSInteger 一样有8 bytes长。你要保证你给出的所有值能被该类型容纳，否则就会产生错误。第二个参数是新类型的名字。大括号里面和以前一样，是你要定义的各种值。 NS_OPTIONS 语法和 NS_ENUM 完全相同，但这个宏提示编译器值是如何通过位掩码 组合在一起的。 typedef NS_OPTIONS(NSUInteger, AMGResizing) { AMGResizingNone = 0, AMGResizingFlexibleWidth = 1 &lt;&lt; 0, AMGResizingFlexibleHeight = 1 &lt;&lt; 1, AMGResizingFlexibleUnicorn = 1 &lt;&lt; 2 }; attribute((always_inline)) 我们知道一般的函数调用都会通过call的方式来调用，这样让攻击很容易对一个函数做手脚，如果是以inline的方式编译的会，会把该函数的code拷贝到每次调用该函数的地方。而static会让生成的二进制文件中没有清晰的符号表，让逆向的人很难弄清楚逻辑。 __attribute__((always_inline)) 的意思是强制内联，所有加了__attribute__((always_inline)) 的函数再被调用时不会被编译成函数调用而是直接扩展到调用函数体内，比如定义了函数 __attribute__((always_inline)) void a() 和 void b()｛ a(); ｝ b 调用 a 函数的汇编代码不会是跳转到a执行，而是 a 函数的代码直接在 b 内成为 b 的一部分。 #define __inline __attribute__((always_inline)) 的意思就是用 __inline 代替__attribute__((always_inline)) 内声明a的时候可以直接写成__inline void a() 这样比较方便因为__attribute__((always_inline)) 字多。 undef 这是预编译指令，和#define搭配使用，意思是取消之前的宏定义。 #define PROC_ADD void main(void) { #ifdef PROC_ADD // Do this code here then undefined it to run the code in the else // processing work #undef PROC_ADD #else // now that PROC_ADD has been undefined run this code // processing work #endif } __unsafe_unretained __unsafe_unretained是对对象的非zeroing的weak reference，意思是当对象所指向的内存被销毁了，对象还存在，称为“野指针”。 在iOS引入了Automatic Reference Count（ARC）之后，编译器可以在编译时对obj-c对象进行内存管理。大致规则如下： alloc的要release; retain/copy的要release; NSAutoreleasePool在ARC中被禁止使用,替换成@autoreleasepool 函数体; 使用@ autoreleasepool,在函数入口的时候,autorelease pool入栈,正常退出时,autorelease pool出栈,从而释放变量. 注意:@ autoreleasepool在非ARC模式下,也能使用,并据说使用@autoreleasepool比使用NSAutoreleasePool速度能快6倍, 明显提升程序性能. @package 为了强制一个对象隐藏其数据，编译器限制实例变量范围以限制其在程序中的可见性，但是为了提供灵活性，苹果也让开发者显式设置范围。 以下是这些关键字的使用范围： @private The instance variable is accessible only within the class that declares it. 实例变量只能被声明它的类访问. @protected The instance variable is accessible within the class that declares it and within classes that inherit it. All instance variables without an explicit scope directive have @protected scope. 实例变量能被声明它的类和子类访问，所有没有显式制定范围的实例变量都是. @public The instance variable is accessible everywhere. 实例变量可以被在任何地方访问. @package Using the modern runtime, an @package instance variable has @public scope inside the executable image that implements the class, but acts like @private outside.使用modern运行时，一个@package实例变量在实现这个类的可执行文件镜像中实际上是@public的，但是在外面就是@private【runtime需要再看一下苹果文档Runtime Programming Guide】 The @package scope for Objective-C instance variables is analogous to private_extern for C variables and functions. Any code outside the class implementation’s image that tries to use the instance variable gets a link error. Objective-C中的@package与C语言中变量和函数的private_extern类似。任何在实现类的镜像之外的代码想使用这个实例变量都会引发link error This scope is most useful for instance variables in framework classes, where @private may be too restrictive but @protected or @public too permissive. 这个类型最常用于框架类的实例变量，使用@private太限制，使用@protected或者@public又太开放." />
<link rel="canonical" href="http://chars.tech/code/2016/02/17/YYModel-reading.html" />
<meta property="og:url" content="http://chars.tech/code/2016/02/17/YYModel-reading.html" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-02-17T04:51:21+08:00" />
<script type="application/ld+json">
{"description":"YYModel堪称神级大作，虽然不免一些小bug，但是完全不影响膝盖碎一地。文章主要分享在阅读YYModel源代码时，所引发的知识点的补充与思考。 前言 这段时间因为工作需要，阅读了YYModel这个开源框架，至于它能做什么，最直白的讲述就是JSON与Model之间的相互转化。 源代码在Github，大家可以自行git clone或者download。 接下来，笔者主要分析阅读源代码而引出的各种问题与知识点，不足之处请大家指正。 NS_ASSUME_NONNULL_BEGIN &amp; NS_ASSUME_NONNULL_END 这组宏是成对使用的，不得不说我们自己写代码的时候使用的很少，以至于遗漏这个知识点，现在我们就来看看这两个宏会引出什么问题。 这组宏会引出几个关于Objective-C新特性的知识点： Nullability Annotations Lightweight Generics __kindof Nullability Annotations 我们都知道在swift中，可以使用!和?来表示一个对象是optional的还是non-optional，如view?和view!。而在 Objective-C中则没有这一区分，view既可表示这个对象是optional，也可表示是non-optioanl。这样就会造成一个问题：在 Swift与Objective-C混编时，Swift编译器并不知道一个Objective-C对象到底是optional还是non-optional，因此这种情况下编译器会隐式地将Objective-C的对象当成是non-optional。 为了解决这个问题，苹果在Xcode 6.3引入了一个Objective-C的新特性：nullability annotations。这一新特性的核心是两个新的类型注释：** __nullable** 和 __nonnull 。从字面上我们可以猜到，__nullable表示对象可以是NULL或nil，而__nonnull表示对象不应该为空。当我们不遵循这一规则时，编译器就会给出警告。 我们来看看以下的实例， @interface TestNullabilityClass () @property (nonatomic, copy) NSArray * items; - (id)itemWithName:(NSString * __nonnull)name; @end @implementation TestNullabilityClass ... - (void)testNullability { [self itemWithName:nil]; // 编译器警告：Null passed to a callee that requires a non-null argument } - (id)itemWithName:(NSString * __nonnull)name { return nil; } @end 不过这只是一个警告，程序还是能编译通过并运行。 事实上，在任何可以使用const关键字的地方都可以使用__nullable和__nonnull，不过这两个关键字仅限于使用在指针类型上。而在方法的声明中，我们还可以使用不带下划线的nullable和nonnull，如下所示： - (nullable id)itemWithName:(NSString * nonnull)name 在属性声明中，也增加了两个相应的特性，因此上例中的items属性可以如下声明： @property (nonatomic, copy, nonnull) NSArray * items; 当然也可以用以下这种方式： @property (nonatomic, copy) NSArray * __nonnull items; 推荐使用nonnull这种方式，这样可以让属性声明看起来更清晰。 Nonnull区域设置(Audited Regions) 如果需要每个属性或每个方法都去指定nonnull和nullable，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END。在这两个宏之间的代码，所有简单指针对象都被假定为 nonnull，因此我们只需要去指定那些nullable的指针。如下代码所示： NS_ASSUME_NONNULL_BEGIN @interface TestNullabilityClass () @property (nonatomic, copy) NSArray * items; - (id)itemWithName:(nullable NSString *)name; @end NS_ASSUME_NONNULL_END 在上面的代码中，items属性默认是nonnull的，itemWithName:方法的返回值也是nonnull，而参数是指定为nullable的。 不过，为了安全起见，苹果还制定了几条规则： typedef定义的类型的nullability特性通常依赖于上下文，即使是在Audited Regions中，也不能假定它为nonnull。 复杂的指针类型(如id *)必须显示去指定是nonnull还是nullable。例如，指定一个指向nullable对象的nonnull指针，可以使用”__nullable id * __nonnull”。 我们经常使用的NSError **通常是被假定为一个指向nullable NSError对象的nullable指针。 兼容性 因为Nullability Annotations是Xcode 6.3新加入的，所以我们需要考虑之前的老代码。实际上，苹果已以帮我们处理好了这种兼容问题，我们可以安全地使用它们： 老代码仍然能正常工作，即使对nonnull对象使用了nil也没有问题。 老代码在需要和swift混编时，在新的swift编译器下会给出一个警告。 nonnull不会影响性能。事实上，我们仍然可以在运行时去判断我们的对象是否为nil。 事实上，我们可以将nonnull/nullable与我们的断言和异常一起看待，其需要处理的问题都是同一个：违反约定是一个程序员的错误。特别是，返回值是我们可控的东西，如果返回值是nonnull的，则我们不应该返回nil，除非是为了向后兼容。 Lightweight Generics Lightweight Generics 轻量级泛型，轻量是因为这是个纯编译器的语法支持（LLVM 7.0），和 Nullability 一样，没有借助任何 objc runtime 的升级，也就是说，这个新语法在 Xcode 7 上可以使用且完全向下兼容（更低的 iOS 版本） 带泛型的容器 这无疑是本次最重大的改进，有了泛型后终于可以指定容器类中对象的类型了： NSArray&lt;NSString *&gt; *strings = @[@&quot;sun&quot;, @&quot;yuan&quot;]; NSDictionary&lt;NSString *, NSNumber *&gt; *mapping = @{@&quot;a&quot;: @1, @&quot;b&quot;: @2}; 返回值的 id 被替换成具体的类型后，令人感动的代码提示也出来了。 假如向泛型容器中加入错误的对象，编译器会不开心的。 系统中常用的一系列容器类型都增加了泛型支持，甚至连 NSEnumerator 都支持了，这是非常 Nice 的改进。和 Nullability 一样，我认为最大的意义还是丰富了接口描述信息，对比下面两种写法： @property (readonly) NSArray *imageURLs; @property (readonly) NSArray&lt;NSURL *&gt; *imageURLs; 不用多想就清楚下面的数组中存的是什么，避免了 NSString 和 NSURL 的混乱。 自定义泛型类 比起使用系统的泛型容器，更好玩的是自定义一个泛型类，目前这里还没什么文档，但拦不住我们写测试代码，假设我们要自定义一个 Stack 容器类： @interface Stack&lt;ObjectType&gt; : NSObject - (void)pushObject:(ObjectType)object; - (ObjectType)popObject; @property (nonatomic, readonly) NSArray&lt;ObjectType&gt; *allObjects; @end 这个 ObjectType 是传入类型的 placeholder，它只能在 @interface 上定义（类声明、类扩展、Category），如果你喜欢用 T 表示也 OK，这个类型在 @interface 和 @end 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型，应该说一切都是符合预期的。我们还可以给 ObjectType 增加类型限制，比如： // 只接受 NSNumber * 的泛型 @interface Stack&lt;ObjectType: NSNumber *&gt; : NSObject // 只接受满足 NSCopying 协议的泛型 @interface Stack&lt;ObjectType: id&lt;NSCopying&gt;&gt; : NSObject 若什么都不加，表示接受任意类型 ( id )；当类型不满足时编译器将产生 error。 实例化一个 Stack，一切工作正常： 对于多参数的泛型，用逗号隔开，其他都一样，可以参考 NSDictionary 的头文件。 协变性和逆变性 当类支持泛型后，它们的 Type 发生了变化，比如下面三个对象看上去都是 Stack，但实际上属于三个 Type： Stack *stack; // Stack * Stack&lt;NSString *&gt; *stringStack; // Stack&lt;NSString *&gt; Stack&lt;NSMutableString *&gt; *mutableStringStack; // Stack&lt;NSMutableString *&gt; 当其中两种类型做类型转化时，编译器需要知道哪些转化是允许的，哪些是禁止的，比如，默认情况下： Stack *stack; Stack&lt;NSString *&gt; *stringStack; Stack&lt;NSMutableString *&gt; *mutableStringStack; stack = stringStack; stack = mutableStringStack; stringStack = stack; stringStack = mutableStringStack; mutableStringStack = stack; mutableStringStack = stringStack 在Xcode中我们可以看到，不指定泛型类型的 Stack 可以和任意泛型类型转化，但指定了泛型类型后，两个不同类型间是不可以强转的，假如你希望主动控制转化关系，就需要使用泛型的协变性和逆变性修饰符了： __covariant - 协变性，子类型可以强转到父类型（里氏替换原则） __contravariant - 逆变性，父类型可以强转到子类型（WTF） 协变 @interface Stack&lt;__covariant ObjectType&gt; : NSObject 逆变 @interface Stack&lt;__contravariant ObjectType&gt; : NSObject 协变是非常好理解的，像 NSArray 的泛型就用了协变的修饰符。 __kindof __kindof 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 UITableView 的这个方法来说： - (id)dequeueReusableCellWithIdentifier:(NSString *)identifier; 使用时前面基本会使用 UITableViewCell 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 UITableViewCell 或 UITableViewCell 子类的实例，于是新的 __kindof 关键字解决了这个问题： - (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier; 既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView 的 subviews 属性被修改成了： @property (nonatomic, readonly, copy) NSArray&lt;__kindof UIView *&gt; *subviews; 这样，写下面的代码时就没有任何警告了： UIButton *button = view.subviews.lastObject; NS_ENUM &amp; NS_OPTIONS 枚举是指将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。 枚举本质上是一个整数，枚举的作用是把值限定在指定的范围内，并且增加代码的可读性。 枚举的成员如果没有显示指定值，那么第一个成员的值总是0，后面成员的值依次递增。枚举可以直接用于比较。 一般我们声明枚举： #import &lt;Foundation/Foundation.h&gt; // 声明枚举类型 enum Direction {up, down, left = 10, right}; int main(int argc, const char * argv[]){ ... } 其中up = 0, down = 1, left = 10, right = 11。 我们会发现枚举中一些不可自定义的部分，例如，枚举名。 NS_ENUM 和 NS_OPTIONS 都不算太古老的宏，在iOS 6 / OS X Mountain Lion才开始有，它们都是代替 enum 的更好的办法。 NS_ENUM 如果要在早期的iOS或OS X系统中使用这两个宏，简单定义一下就好 #ifndef NS_ENUM #define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type #endif 在OS X 10.4 中的原始定义如下： #define NS_ENUM(_type, _name) CF_ENUM(_type, _name) #define NS_OPTIONS(_type, _name) CF_OPTIONS(_type, _name) 在之前枚举可以这么定义： typedef enum { UITableViewCellStyleDefault, UITableViewCellStyleValue1, UITableViewCellStyleValue2, UITableViewCellStyleSubtitle }; 或者 typedef NSInteger UITableViewCellStyle; 现在，有了统一的风格 typedef NS_ENUM(NSInteger, UITableViewCellSelectionStyle) { UITableViewCellSelectionStyleNone, UITableViewCellSelectionStyleBlue, UITableViewCellSelectionStyleGray, UITableViewCellSelectionStyleDefault }; NS_ENUM 的第一个参数是用于存储的新类型的类型。在64位环境下，UITableViewCellStyle 和 NSInteger 一样有8 bytes长。你要保证你给出的所有值能被该类型容纳，否则就会产生错误。第二个参数是新类型的名字。大括号里面和以前一样，是你要定义的各种值。 NS_OPTIONS 语法和 NS_ENUM 完全相同，但这个宏提示编译器值是如何通过位掩码 组合在一起的。 typedef NS_OPTIONS(NSUInteger, AMGResizing) { AMGResizingNone = 0, AMGResizingFlexibleWidth = 1 &lt;&lt; 0, AMGResizingFlexibleHeight = 1 &lt;&lt; 1, AMGResizingFlexibleUnicorn = 1 &lt;&lt; 2 }; attribute((always_inline)) 我们知道一般的函数调用都会通过call的方式来调用，这样让攻击很容易对一个函数做手脚，如果是以inline的方式编译的会，会把该函数的code拷贝到每次调用该函数的地方。而static会让生成的二进制文件中没有清晰的符号表，让逆向的人很难弄清楚逻辑。 __attribute__((always_inline)) 的意思是强制内联，所有加了__attribute__((always_inline)) 的函数再被调用时不会被编译成函数调用而是直接扩展到调用函数体内，比如定义了函数 __attribute__((always_inline)) void a() 和 void b()｛ a(); ｝ b 调用 a 函数的汇编代码不会是跳转到a执行，而是 a 函数的代码直接在 b 内成为 b 的一部分。 #define __inline __attribute__((always_inline)) 的意思就是用 __inline 代替__attribute__((always_inline)) 内声明a的时候可以直接写成__inline void a() 这样比较方便因为__attribute__((always_inline)) 字多。 undef 这是预编译指令，和#define搭配使用，意思是取消之前的宏定义。 #define PROC_ADD void main(void) { #ifdef PROC_ADD // Do this code here then undefined it to run the code in the else // processing work #undef PROC_ADD #else // now that PROC_ADD has been undefined run this code // processing work #endif } __unsafe_unretained __unsafe_unretained是对对象的非zeroing的weak reference，意思是当对象所指向的内存被销毁了，对象还存在，称为“野指针”。 在iOS引入了Automatic Reference Count（ARC）之后，编译器可以在编译时对obj-c对象进行内存管理。大致规则如下： alloc的要release; retain/copy的要release; NSAutoreleasePool在ARC中被禁止使用,替换成@autoreleasepool 函数体; 使用@ autoreleasepool,在函数入口的时候,autorelease pool入栈,正常退出时,autorelease pool出栈,从而释放变量. 注意:@ autoreleasepool在非ARC模式下,也能使用,并据说使用@autoreleasepool比使用NSAutoreleasePool速度能快6倍, 明显提升程序性能. @package 为了强制一个对象隐藏其数据，编译器限制实例变量范围以限制其在程序中的可见性，但是为了提供灵活性，苹果也让开发者显式设置范围。 以下是这些关键字的使用范围： @private The instance variable is accessible only within the class that declares it. 实例变量只能被声明它的类访问. @protected The instance variable is accessible within the class that declares it and within classes that inherit it. All instance variables without an explicit scope directive have @protected scope. 实例变量能被声明它的类和子类访问，所有没有显式制定范围的实例变量都是. @public The instance variable is accessible everywhere. 实例变量可以被在任何地方访问. @package Using the modern runtime, an @package instance variable has @public scope inside the executable image that implements the class, but acts like @private outside.使用modern运行时，一个@package实例变量在实现这个类的可执行文件镜像中实际上是@public的，但是在外面就是@private【runtime需要再看一下苹果文档Runtime Programming Guide】 The @package scope for Objective-C instance variables is analogous to private_extern for C variables and functions. Any code outside the class implementation’s image that tries to use the instance variable gets a link error. Objective-C中的@package与C语言中变量和函数的private_extern类似。任何在实现类的镜像之外的代码想使用这个实例变量都会引发link error This scope is most useful for instance variables in framework classes, where @private may be too restrictive but @protected or @public too permissive. 这个类型最常用于框架类的实例变量，使用@private太限制，使用@protected或者@public又太开放.","@type":"BlogPosting","url":"http://chars.tech/code/2016/02/17/YYModel-reading.html","headline":"YYModel源代码阅读 - 基础知识","dateModified":"2016-02-17T04:51:21+08:00","datePublished":"2016-02-17T04:51:21+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://chars.tech/code/2016/02/17/YYModel-reading.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <!-- Manual seo tags -->
    <!--
    <title>YYModel源代码阅读 - 基础知识 | Chars</title>
    <meta name="description" content="YYModel堪称神级大作，虽然不免一些小bug，但是完全不影响膝盖碎一地。文章主要分享在阅读YYModel源代码时，所引发的知识点的补充与思考。前言这段时间因为工作需要，阅读了YYModel这个开源框架，至于它能做什么，最直白的讲述就是JSON与Model之间的相互转化。源代码在Github，大家可以自行git...">
    -->
</head>

  <body>
    <header class="site-header">
    
    <!-- Logo and title -->
	<div class="branding">
		<a href="/">
			<img class="avatar" src="/assets/img/avatar.png" alt=""/>
		</a>

		<h1 class="site-title">
			<a href="/">Chars</a>
		</h1>
	</div>
    
    <!-- Toggle menu -->
    <nav class="clear">
    <a id="pull" class="toggle" href="#">
    <i class="fa fa-bars fa-lg"></i>
    </a>
    
    <!-- Menu -->
    <ul>
        
        
        
        
        <li>
            <a class="clear" href="/about/">
                About
            </a>
        </li>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
         
        
        
        <li>
            <a class="clear" href="http://chars.tech/hobby">
                Hobby
            </a>
        </li>
        
        
        <li>
            <a class="clear" href="http://chars.tech/search">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
        </li>
        
        
        <li>
            <a class="clear" href="http://chars.tech/tags">
                <i class="fa fa-tags" aria-hidden="true"></i>
            </a>
        </li>
        
        
    </ul>
        
	</nav>
</header>

    <div class="content">
      <article >
  <header id="main" style="background-image: url('/')">
    <h1 id="YYModel%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB+-+%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" class="title">YYModel源代码阅读 - 基础知识</h1>
    <p class="meta">
    February 17, 2016
    
    </p>
  </header>
  <section class="post-content"><p>YYModel堪称神级大作，虽然不免一些小bug，但是完全不影响膝盖碎一地。文章主要分享在阅读YYModel源代码时，所引发的知识点的补充与思考。</p>

<h1 id="前言">前言</h1>
<p>这段时间因为工作需要，阅读了YYModel这个开源框架，至于它能做什么，最直白的讲述就是JSON与Model之间的相互转化。</p>

<p>源代码在<a href="https://github.com/ibireme/YYModel">Github</a>，大家可以自行<code class="highlighter-rouge">git clone</code>或者download。</p>

<p>接下来，笔者主要分析阅读源代码而引出的各种问题与知识点，不足之处请大家指正。</p>

<h1 id="ns_assume_nonnull_begin--ns_assume_nonnull_end">NS_ASSUME_NONNULL_BEGIN &amp; NS_ASSUME_NONNULL_END</h1>

<p>这组宏是成对使用的，不得不说我们自己写代码的时候使用的很少，以至于遗漏这个知识点，现在我们就来看看这两个宏会引出什么问题。</p>

<p>这组宏会引出几个关于Objective-C新特性的知识点：</p>

<ul>
  <li>
    <p>Nullability Annotations</p>
  </li>
  <li>
    <p>Lightweight Generics</p>
  </li>
  <li>
    <p>__kindof</p>
  </li>
</ul>

<h2 id="nullability-annotations">Nullability Annotations</h2>

<p>我们都知道在swift中，可以使用!和?来表示一个对象是optional的还是non-optional，如view?和view!。而在 Objective-C中则没有这一区分，view既可表示这个对象是optional，也可表示是non-optioanl。这样就会造成一个问题：在 Swift与Objective-C混编时，Swift编译器并不知道一个Objective-C对象到底是optional还是non-optional，因此这种情况下编译器会隐式地将Objective-C的对象当成是non-optional。</p>

<p>为了解决这个问题，苹果在Xcode 6.3引入了一个Objective-C的新特性：<strong>nullability annotations</strong>。这一新特性的核心是两个新的类型注释：** __nullable** 和 <strong>__nonnull</strong> 。从字面上我们可以猜到，<code class="highlighter-rouge">__nullable</code>表示对象可以是NULL或nil，而<code class="highlighter-rouge">__nonnull</code>表示对象不应该为空。当我们不遵循这一规则时，编译器就会给出警告。</p>

<p>我们来看看以下的实例，</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@interface TestNullabilityClass ()
@property (nonatomic, copy) NSArray * items;
- (id)itemWithName:(NSString * __nonnull)name;
@end
@implementation TestNullabilityClass
...
- (void)testNullability {
    [self itemWithName:nil];    // 编译器警告：Null passed to a callee that requires a non-null argument
}
- (id)itemWithName:(NSString * __nonnull)name {
    return nil;
}
@end
</code></pre></div></div>

<p>不过这只是一个警告，程序还是能编译通过并运行。</p>

<p>事实上，在任何可以使用const关键字的地方都可以使用<code class="highlighter-rouge">__nullable</code>和<code class="highlighter-rouge">__nonnull</code>，不过这两个关键字仅限于使用在指针类型上。而在方法的声明中，我们还可以使用不带下划线的<code class="highlighter-rouge">nullable</code>和<code class="highlighter-rouge">nonnull</code>，如下所示：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (nullable id)itemWithName:(NSString * nonnull)name
在属性声明中，也增加了两个相应的特性，因此上例中的items属性可以如下声明：

@property (nonatomic, copy, nonnull) NSArray * items;
当然也可以用以下这种方式：

@property (nonatomic, copy) NSArray * __nonnull items;
推荐使用nonnull这种方式，这样可以让属性声明看起来更清晰。
</code></pre></div></div>

<h3 id="nonnull区域设置audited-regions">Nonnull区域设置(Audited Regions)</h3>

<p>如果需要每个属性或每个方法都去指定<code class="highlighter-rouge">nonnull</code>和<code class="highlighter-rouge">nullable</code>，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：<strong>NS_ASSUME_NONNULL_BEGIN</strong>和<strong>NS_ASSUME_NONNULL_END</strong>。在这两个宏之间的代码，所有简单指针对象都被假定为 <code class="highlighter-rouge">nonnull</code>，因此我们只需要去指定那些<code class="highlighter-rouge">nullable</code>的指针。如下代码所示：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NS_ASSUME_NONNULL_BEGIN
@interface TestNullabilityClass ()
@property (nonatomic, copy) NSArray * items;
- (id)itemWithName:(nullable NSString *)name;
@end
NS_ASSUME_NONNULL_END
</code></pre></div></div>

<p>在上面的代码中，items属性默认是nonnull的，itemWithName:方法的返回值也是nonnull，而参数是指定为nullable的。</p>

<p>不过，为了安全起见，苹果还制定了几条规则：</p>

<ul>
  <li>
    <p>typedef定义的类型的nullability特性通常依赖于上下文，即使是在Audited Regions中，也不能假定它为nonnull。</p>
  </li>
  <li>
    <p>复杂的指针类型(如id *)必须显示去指定是nonnull还是nullable。例如，指定一个指向nullable对象的nonnull指针，可以使用”__nullable id * __nonnull”。</p>
  </li>
  <li>
    <p>我们经常使用的NSError **通常是被假定为一个指向nullable NSError对象的nullable指针。</p>
  </li>
</ul>

<h3 id="兼容性">兼容性</h3>

<p>因为Nullability Annotations是Xcode 6.3新加入的，所以我们需要考虑之前的老代码。实际上，苹果已以帮我们处理好了这种兼容问题，我们可以安全地使用它们：</p>

<ul>
  <li>
    <p>老代码仍然能正常工作，即使对nonnull对象使用了nil也没有问题。</p>
  </li>
  <li>
    <p>老代码在需要和swift混编时，在新的swift编译器下会给出一个警告。</p>
  </li>
  <li>
    <p>nonnull不会影响性能。事实上，我们仍然可以在运行时去判断我们的对象是否为nil。</p>
  </li>
</ul>

<p>事实上，我们可以将nonnull/nullable与我们的断言和异常一起看待，其需要处理的问题都是同一个：违反约定是一个程序员的错误。特别是，返回值是我们可控的东西，如果返回值是nonnull的，则我们不应该返回nil，除非是为了向后兼容。</p>

<h2 id="lightweight-generics">Lightweight Generics</h2>

<p>Lightweight Generics 轻量级泛型，轻量是因为这是个纯编译器的语法支持（LLVM 7.0），和 Nullability 一样，没有借助任何 objc runtime 的升级，也就是说，这个新语法在 Xcode 7 上可以使用且完全向下兼容（更低的 iOS 版本）</p>

<h3 id="带泛型的容器">带泛型的容器</h3>

<p>这无疑是本次最重大的改进，有了泛型后终于可以指定容器类中对象的类型了：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NSArray&lt;NSString *&gt; *strings = @[@"sun", @"yuan"];
NSDictionary&lt;NSString *, NSNumber *&gt; *mapping = @{@"a": @1, @"b": @2};
</code></pre></div></div>
<p>返回值的 id 被替换成具体的类型后，令人感动的代码提示也出来了。</p>

<p>假如向泛型容器中加入错误的对象，编译器会不开心的。</p>

<p>系统中常用的一系列容器类型都增加了泛型支持，甚至连 <code class="highlighter-rouge">NSEnumerator</code> 都支持了，这是非常 Nice 的改进。和 <code class="highlighter-rouge">Nullability</code> 一样，我认为最大的意义还是丰富了接口描述信息，对比下面两种写法：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@property (readonly) NSArray *imageURLs;
@property (readonly) NSArray&lt;NSURL *&gt; *imageURLs;
</code></pre></div></div>
<p>不用多想就清楚下面的数组中存的是什么，避免了 <code class="highlighter-rouge">NSString</code> 和 <code class="highlighter-rouge">NSURL</code> 的混乱。</p>

<h3 id="自定义泛型类">自定义泛型类</h3>

<p>比起使用系统的泛型容器，更好玩的是自定义一个泛型类，目前这里还没什么文档，但拦不住我们写测试代码，假设我们要自定义一个 Stack 容器类：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@interface Stack&lt;ObjectType&gt; : NSObject
- (void)pushObject:(ObjectType)object;
- (ObjectType)popObject;
@property (nonatomic, readonly) NSArray&lt;ObjectType&gt; *allObjects;
@end
</code></pre></div></div>
<p>这个 <code class="highlighter-rouge">ObjectType</code> 是传入类型的 <code class="highlighter-rouge">placeholder</code>，它只能在 <code class="highlighter-rouge">@interface</code> 上定义（类声明、类扩展、Category），如果你喜欢用 T 表示也 OK，这个类型在 <code class="highlighter-rouge">@interface</code> 和 <code class="highlighter-rouge">@end</code> 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型，应该说一切都是符合预期的。我们还可以给 ObjectType 增加类型限制，比如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 只接受 NSNumber * 的泛型
@interface Stack&lt;ObjectType: NSNumber *&gt; : NSObject
// 只接受满足 NSCopying 协议的泛型
@interface Stack&lt;ObjectType: id&lt;NSCopying&gt;&gt; : NSObject
</code></pre></div></div>
<p>若什么都不加，表示接受任意类型 ( id )；当类型不满足时编译器将产生 error。
实例化一个 Stack，一切工作正常：</p>

<p>对于多参数的泛型，用逗号隔开，其他都一样，可以参考 NSDictionary 的头文件。</p>

<h3 id="协变性和逆变性">协变性和逆变性</h3>

<p>当类支持泛型后，它们的 Type 发生了变化，比如下面三个对象看上去都是 Stack，但实际上属于三个 Type：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Stack *stack; // Stack *
Stack&lt;NSString *&gt; *stringStack; // Stack&lt;NSString *&gt;
Stack&lt;NSMutableString *&gt; *mutableStringStack; // Stack&lt;NSMutableString *&gt;
</code></pre></div></div>
<p>当其中两种类型做类型转化时，编译器需要知道哪些转化是允许的，哪些是禁止的，比如，默认情况下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Stack *stack;
Stack&lt;NSString *&gt; *stringStack;
Stack&lt;NSMutableString *&gt; *mutableStringStack; 

stack = stringStack;
stack = mutableStringStack;
stringStack = stack;
stringStack = mutableStringStack;
mutableStringStack = stack;
mutableStringStack = stringStack
</code></pre></div></div>
<p>在Xcode中我们可以看到，不指定泛型类型的 Stack 可以和任意泛型类型转化，但指定了泛型类型后，两个不同类型间是不可以强转的，假如你希望主动控制转化关系，就需要使用泛型的协变性和逆变性修饰符了：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>__covariant - 协变性，子类型可以强转到父类型（里氏替换原则）
__contravariant - 逆变性，父类型可以强转到子类型（WTF）
</code></pre></div></div>

<h4 id="协变">协变</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@interface Stack&lt;__covariant ObjectType&gt; : NSObject
</code></pre></div></div>

<h4 id="逆变">逆变</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@interface Stack&lt;__contravariant ObjectType&gt; : NSObject
</code></pre></div></div>

<p>协变是非常好理解的，像 <code class="highlighter-rouge">NSArray</code> 的泛型就用了协变的修饰符。</p>

<h2 id="__kindof">__kindof</h2>

<p><code class="highlighter-rouge">__kindof</code> 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 <code class="highlighter-rouge">UITableView</code> 的这个方法来说：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;
</code></pre></div></div>
<p>使用时前面基本会使用 <code class="highlighter-rouge">UITableViewCell</code> 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 <code class="highlighter-rouge">UITableViewCell</code> 或 <code class="highlighter-rouge">UITableViewCell</code> 子类的实例，于是新的 <code class="highlighter-rouge">__kindof</code> 关键字解决了这个问题：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;
</code></pre></div></div>

<p>既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView 的 subviews 属性被修改成了：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@property (nonatomic, readonly, copy) NSArray&lt;__kindof UIView *&gt; *subviews;
</code></pre></div></div>

<p>这样，写下面的代码时就没有任何警告了：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>UIButton *button = view.subviews.lastObject;
</code></pre></div></div>

<h1 id="ns_enum--ns_options">NS_ENUM &amp; NS_OPTIONS</h1>

<p>枚举是指将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。</p>

<p>枚举本质上是一个整数，枚举的作用是把值限定在指定的范围内，并且增加代码的可读性。 枚举的成员如果没有显示指定值，那么第一个成员的值总是0，后面成员的值依次递增。枚举可以直接用于比较。</p>

<p>一般我们声明枚举：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#import &lt;Foundation/Foundation.h&gt;

// 声明枚举类型
enum Direction {up, down, left = 10, right};

int main(int argc, const char * argv[]){
  ...
}
其中up = 0, down = 1, left = 10, right = 11。
</code></pre></div></div>

<p>我们会发现枚举中一些不可自定义的部分，例如，枚举名。</p>

<p>NS_ENUM 和 NS_OPTIONS 都不算太古老的宏，在iOS 6 / OS X Mountain Lion才开始有，它们都是代替 enum 的更好的办法。</p>

<h2 id="ns_enum">NS_ENUM</h2>

<p>如果要在早期的iOS或OS X系统中使用这两个宏，简单定义一下就好</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#ifndef NS_ENUM
#define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type
#endif
</code></pre></div></div>
<p>在OS X 10.4 中的原始定义如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define NS_ENUM(_type, _name) CF_ENUM(_type, _name)
#define NS_OPTIONS(_type, _name) CF_OPTIONS(_type, _name)
</code></pre></div></div>
<p>在之前枚举可以这么定义：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef enum {
    UITableViewCellStyleDefault,
    UITableViewCellStyleValue1,
    UITableViewCellStyleValue2,
    UITableViewCellStyleSubtitle
};
</code></pre></div></div>

<p>或者</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef NSInteger UITableViewCellStyle;
</code></pre></div></div>

<p>现在，有了统一的风格</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef NS_ENUM(NSInteger, UITableViewCellSelectionStyle) {
    UITableViewCellSelectionStyleNone,
    UITableViewCellSelectionStyleBlue,
    UITableViewCellSelectionStyleGray,
    UITableViewCellSelectionStyleDefault
};
</code></pre></div></div>

<p><code class="highlighter-rouge">NS_ENUM</code> 的第一个参数是用于存储的新类型的类型。在64位环境下，<code class="highlighter-rouge">UITableViewCellStyle</code> 和 <code class="highlighter-rouge">NSInteger</code> 一样有8 bytes长。你要保证你给出的所有值能被该类型容纳，否则就会产生错误。第二个参数是新类型的名字。大括号里面和以前一样，是你要定义的各种值。</p>

<h2 id="ns_options">NS_OPTIONS</h2>

<table>
  <tbody>
    <tr>
      <td>语法和 <code class="highlighter-rouge">NS_ENUM</code> 完全相同，但这个宏提示编译器值是如何通过位掩码</td>
      <td>组合在一起的。</td>
    </tr>
  </tbody>
</table>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef NS_OPTIONS(NSUInteger, AMGResizing) {
    AMGResizingNone            = 0,
    AMGResizingFlexibleWidth   = 1 &lt;&lt; 0,
    AMGResizingFlexibleHeight  = 1 &lt;&lt; 1,
    AMGResizingFlexibleUnicorn = 1 &lt;&lt; 2
};
</code></pre></div></div>

<h1 id="attributealways_inline"><strong>attribute</strong>((always_inline))</h1>

<p>我们知道一般的函数调用都会通过call的方式来调用，这样让攻击很容易对一个函数做手脚，如果是以<code class="highlighter-rouge">inline</code>的方式编译的会，会把该函数的code拷贝到每次调用该函数的地方。而<code class="highlighter-rouge">static</code>会让生成的二进制文件中没有清晰的符号表，让逆向的人很难弄清楚逻辑。</p>

<p><code class="highlighter-rouge">__attribute__((always_inline))</code> 的意思是强制内联，所有加了<code class="highlighter-rouge">__attribute__((always_inline))</code> 的函数再被调用时不会被编译成函数调用而是直接扩展到调用函数体内，比如定义了函数
<code class="highlighter-rouge">__attribute__((always_inline)) void a()</code>
和</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void b()｛  
    a();
｝
</code></pre></div></div>

<p>b 调用 a 函数的汇编代码不会是跳转到a执行，而是 a 函数的代码直接在 b 内成为 b 的一部分。
<code class="highlighter-rouge">#define __inline __attribute__((always_inline))</code> 的意思就是用
<code class="highlighter-rouge">__inline</code> 代替<code class="highlighter-rouge">__attribute__((always_inline))</code>
内声明a的时候可以直接写成<code class="highlighter-rouge">__inline void a()</code> 这样比较方便因为<code class="highlighter-rouge">__attribute__((always_inline))</code> 字多。</p>

<h1 id="undef">undef</h1>

<p>这是预编译指令，和<code class="highlighter-rouge">#define</code>搭配使用，意思是取消之前的宏定义。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define PROC_ADD 
void main(void) 
{
#ifdef PROC_ADD 
// Do this code here then undefined it to run the code in the else 
// processing work 
#undef PROC_ADD 
#else 
// now that PROC_ADD has been undefined run this code 
// processing work 
#endif 
}
</code></pre></div></div>

<h1 id="__unsafe_unretained">__unsafe_unretained</h1>

<p><code class="highlighter-rouge">__unsafe_unretained</code>是对对象的非zeroing的weak reference，意思是当对象所指向的内存被销毁了，对象还存在，称为“野指针”。</p>

<p>在iOS引入了Automatic Reference Count（ARC）之后，编译器可以在编译时对obj-c对象进行内存管理。大致规则如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alloc的要release;
retain/copy的要release;
NSAutoreleasePool在ARC中被禁止使用,替换成@autoreleasepool 函数体;
使用@ autoreleasepool,在函数入口的时候,autorelease pool入栈,正常退出时,autorelease pool出栈,从而释放变量.
注意:@ autoreleasepool在非ARC模式下,也能使用,并据说使用@autoreleasepool比使用NSAutoreleasePool速度能快6倍, 明显提升程序性能.
</code></pre></div></div>

<h1 id="package">@package</h1>

<p>为了强制一个对象隐藏其数据，编译器限制实例变量范围以限制其在程序中的可见性，但是为了提供灵活性，苹果也让开发者显式设置范围。</p>

<p>以下是这些关键字的使用范围：</p>

<ul>
  <li>@private</li>
</ul>

<p>The instance variable is accessible only within the class that declares it.</p>

<p>实例变量只能被声明它的类访问.</p>

<ul>
  <li>@protected</li>
</ul>

<p>The instance variable is accessible within the class that declares it and within classes that inherit it. All instance variables without an explicit scope directive have @protected scope.</p>

<p>实例变量能被声明它的类和子类访问，所有没有显式制定范围的实例变量都是.</p>

<ul>
  <li>@public</li>
</ul>

<p>The instance variable is accessible everywhere.</p>

<p>实例变量可以被在任何地方访问.</p>

<ul>
  <li>@package</li>
</ul>

<p>Using the modern runtime, an <code class="highlighter-rouge">@package</code> instance variable has <code class="highlighter-rouge">@public</code> scope inside the executable image that implements the class, but acts like <code class="highlighter-rouge">@private</code> outside.使用modern运行时，一个<code class="highlighter-rouge">@package</code>实例变量在实现这个类的可执行文件镜像中实际上是<code class="highlighter-rouge">@public</code>的，但是在外面就是<code class="highlighter-rouge">@private</code>【runtime需要再看一下苹果文档Runtime Programming Guide】</p>

<p>The <code class="highlighter-rouge">@package</code> scope for Objective-C instance variables is analogous to private_extern for C variables and functions. Any code outside the class implementation’s image that tries to use the instance variable gets a link error.</p>

<p>Objective-C中的<code class="highlighter-rouge">@package</code>与C语言中变量和函数的private_extern类似。任何在实现类的镜像之外的代码想使用这个实例变量都会引发link error</p>

<p>This scope is most useful for instance variables in framework classes, where <code class="highlighter-rouge">@private</code> may be too restrictive but <code class="highlighter-rouge">@protected</code> or <code class="highlighter-rouge">@public</code> too permissive.</p>

<table>
  <tbody>
    <tr>
      <td>这个类型最常用于框架类的实例变量，使用<code class="highlighter-rouge">@private</code>太限制，使用<code class="highlighter-rouge">@protected</code>或者<code class="highlighter-rouge">@public</code>又太开放.</td>
    </tr>
  </tbody>
</table>

</section>
   
   <!-- Tag list -->
  
  


    <footer>
        <div class="tag-list">
        
          <div class="meta">Tags</div>
        
            
        
          <a class="button" href="/tags#ios">
            <p><i class="fa fa-tag fa-fw"></i> ios</p>
          </a>
        
          <a class="button" href="/tags#框架">
            <p><i class="fa fa-tag fa-fw"></i> 框架</p>
          </a>
        
        </div>
    </footer>
  

    
</article>

<!-- comment -->

<div class="comments">
  <!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid=MTAyMC8zMzY4My8xMDIzOA==>
<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
</script>
<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
</div>


<!-- Post navigation -->

  <div id="post-nav">
  
  <div id="previous-post" class="post-nav-post">
      <p>Previous</p>
      <a href="/pieces/2016/02/11/memory-alignment.html">
        内存对齐详解
      </a>
  </div>
  
  
  <div id="next-post" class="post-nav-post">
      <p>Next</p>
      <a href="/code/2016/02/17/objc-new-alloc-init.html">
        Objective-C 中 new、alloc和init的区别
      </a>
  </div>
  
</div>

    </div>
    
<footer class="site-footer">
    <p class="text"></p>
    <p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a>. Theme by <a href="https://github.com/charsdavy/Type-on-Strap">Type-on-Strap</a>. &copy; 2016 - 2018 </p>
            <div class="footer-icons">
                <ul>
                <!-- Social icons from Font Awesome, if enabled -->
                
<li>
	<a href="http://chars.tech////feed.xml" title="Follow RSS feed">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>



<li>
	<a href="mailto:chars.davy@gmail.com" title="Email">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>









<li>
	<a href="https://www.facebook.com/wei.deng.1460" title="Follow on Facebook">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>





<li>
	<a href="https://github.com/charsdavy" title="Follow on GitHub">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-github fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>

























<li>
	<a href="https://twitter.com/charsdavy" title="Follow on Twitter" class="type">
        <span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>



<li>
    <a href="https://weibo.com/u/3875245858" title="Follow on Weibo" class="type">
        <span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
        </span>
    </a>
</li>








                </ul>
            </div>
</footer>




  </body>
</html>
